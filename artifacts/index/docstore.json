{"ISLP_website::c000000": {"text": "(BSFUI\u0001+BNFT\u0001t\u0001%BOJFMB\u00018JUUFO\u0001t\u00015SFWPS\u0001)BTUJF3PCFSU\u00015JCTIJSBOJ\u0001t\u0001+POBUIBO\u00015BZMPS\"O\u0001*OUSPEVDUJPOUP\u00014UBUJTUJDBM\u0001-FBSOJOHXJUI\u0001\"QQMJDBUJPOT\u0001JO\u00011ZUIPO To our parents:Alison and Michael JamesChiara Nappi and Edward WittenValerie and Patrick HastieVera and Sami TibshiraniJohn and Brenda Taylorand to our families:Michael, Daniel, and CatherineTessa, Theo, Otto, and AriSamantha, Timothy, and LyndaCharlie, Ryan, Julie, and CherylLee-Ann and Isobel Preface Statistical learning refers to a set of tools for making sense of complex datasets. In recent years, we have seen a staggering increase in the scale and scope of data collection across virtually all areas of science and industry. As a result, statistical learning has become a critical toolkit for anyone who wishes to understand data — and as more and more of today’s jobs involve data, this means that statistical learning is fast becoming a critical toolkit foreveryone . One of the first books on statistical learning — The Elements of Statisti- cal Learning (ESL, by Hastie, Tibshirani, and Friedman) — was published in 2001, with a second edition in 2009. ESL has become a popular text not only in statistics but also in related fields. One of the reasons for ESL’s popularity is its relatively accessible style. But ESL is best-suited for indi- viduals with advanced training in the mathematical sciences. An Introduction to Statistical Learning, With Applications in R (ISLR) — first published in 2013, with a second edition in 2021 — arose from the clear need for a broader and less technical treatment of the key topics in statistical learning. In addition to a review of linear regression, ISLR covers many of today’s most important statistical and machine learning approaches, including resampling, sparse methods for classification and re- gression, generalized additive models, tree-based methods, support vector machines, deep learning, survival analysis, clustering, and multiple testing. Since it was published in 2013, ISLR has become a mainstay of un- dergraduate and graduate classrooms worldwide, as well as an important reference book for data scientists. One of the keys to its success has been that, beginning with Chapter 2, each chapter contains an Rlab illustrating how to implement the statistical learning methods seen in that chapter, providing the reader with valuable hands-on experience. However, in recent years Pythonhas become an increasingly popular lan- guage for data science, and there has been increasing demand for a Python- vii viiibased alternative to ISLR. Hence, this book,An Introduction to StatisticalLearning, With Applications in Python(ISLP), covers the same materialsas ISLR but with labs implemented inPython— a feat accomplished by theaddition of a", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 0, "start_word": 0, "end_word": 400, "chunk_words": 400}}, "ISLP_website::c000001": {"text": "2, each chapter contains an Rlab illustrating how to implement the statistical learning methods seen in that chapter, providing the reader with valuable hands-on experience. However, in recent years Pythonhas become an increasingly popular lan- guage for data science, and there has been increasing demand for a Python- vii viiibased alternative to ISLR. Hence, this book,An Introduction to StatisticalLearning, With Applications in Python(ISLP), covers the same materialsas ISLR but with labs implemented inPython— a feat accomplished by theaddition of a new co-author, Jonathan Taylor. Several of the labs make useof theISLP Pythonpackage, which we have written to facilitate carrying outthe statistical learning methods covered in each chapter inPython. Theselabs will be useful both forPythonnovices, as well as experienced users.The intention behind ISLP (and ISLR) is to concentrate more on theapplications of the methods and less on the mathematical details, so it isappropriate for advanced undergraduates or master’s students in statisticsor related quantitative fields, or for individuals in other disciplines whowish to use statistical learning tools to analyze their data. It can be usedas a textbook for a course spanning two semesters.We are grateful to these readers for providing valuable comments on thefirst edition of ISLR: Pallavi Basu, Alexandra Chouldechova, Patrick Dana-her, Will Fithian, Luella Fu, Sam Gross, Max Grazier G’Sell, CourtneyPaulson, Xinghao Qiao, Elisa Sheng, Noah Simon, Kean Ming Tan, Xin LuTan.WethankthesereadersforhelpfulinputonthesecondeditionofISLR:Alan Agresti, Iain Carmichael, Yiqun Chen, Erin Craig, Daisy Ding, LucyGao, Ismael Lemhadri, Bryan Martin, Anna Neufeld, Geoff Tims, CarstenVoelkmann, Steve Yadlowsky, and James Zou. We are immensely gratefulto Balasubramanian “Naras” Narasimhan for his assistance on both ISLRand ISLP.It has been an honor and a privilege for us to see the considerable impactthatISLRhashadonthewayinwhichstatisticallearningispracticed,bothin and out of the academic setting. We hope that this newPythoneditionwill continue to give today’s and tomorrow’s applied statisticians and datascientists the tools they need for success in a data-driven world.It’s tough to make predictions, especially about the future.-Yogi BerraPreface Contents Preface vii 1 Introduction 1 2 Statistical Learning 15 2.1 What Is Statistical Learning? . . . . . . . . . . . . . . . . . 15 2.1.1 Why Estimate f? . . . . . . . . . . . . . . . . . . . 17 2.1.2 How Do We Estimate f? . . . . . . . . . . . . . . . 20 2.1.3 The Trade-Off Between Prediction Accuracy and", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 1, "start_word": 320, "end_word": 720, "chunk_words": 400}}, "ISLP_website::c000002": {"text": "2 Statistical Learning 15 2.1 What Is Statistical Learning? . . . . . . . . . . . . . . . . . 15 2.1.1 Why Estimate f? . . . . . . . . . . . . . . . . . . . 17 2.1.2 How Do We Estimate f? . . . . . . . . . . . . . . . 20 2.1.3 The Trade-Off Between Prediction Accuracy and Model Interpretability . . . . . . . . . . . . . . 23 2.1.4 Supervised Versus Unsupervised Learning . . . . . 25 2.1.5 Regression Versus Classification Problems . . . . . 27 2.2 Assessing Model Accuracy . . . . . . . . . . . . . . . . . . 27 2.2.1 Measuring the Quality of Fit . . . . . . . . . . . . 28 2.2.2 The Bias-Variance Trade-Off . . . . . . . . . . . . . 31 2.2.3 The Classification Setting . . . . . . . . . . . . . . 34 2.3 Lab: Introduction to Python . . . . . . . . . . . . . . . . . 40 2.3.1 Getting Started . . . . . . . . . . . . . . . . . . . . 40 2.3.2 Basic Commands . . . . . . . . . . . . . . . . . . . 40 2.3.3 Introduction to Numerical Python . . . . . . . . . 42 2.3.4 Graphics . . . . . . . . . . . . . . . . . . . . . . . . 48 2.3.5 Sequences and Slice Notation . . . . . . . . . . . . 51 2.3.6 Indexing Data . . . . . . . . . . . . . . . . . . . . . 51 2.3.7 Loading Data . . . . . . . . . . . . . . . . . . . . . 55 2.3.8 For Loops . . . . . . . . . . . . . . . . . . .", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 2, "start_word": 640, "end_word": 1040, "chunk_words": 400}}, "ISLP_website::c000003": {"text": ". . . . . . . 51 2.3.6 Indexing Data . . . . . . . . . . . . . . . . . . . . . 51 2.3.7 Loading Data . . . . . . . . . . . . . . . . . . . . . 55 2.3.8 For Loops . . . . . . . . . . . . . . . . . . . . . . . 59 2.3.9 Additional Graphical and Numerical Summaries . . 61 2.4 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63 3 Linear Regression 69 3.1 Simple Linear Regression . . . . . . . . . . . . . . . . . . . 70 3.1.1 Estimating the Coefficients . . . . . . . . . . . . . 71 3.1.2 Assessing the Accuracy of the Coefficient Estimates . . . . . . . . . . . . . . . . . . . . . . . 72 3.1.3 Assessing the Accuracy of the Model . . . . . . . . 77 3.2 Multiple Linear Regression . . . . . . . . . . . . . . . . . . 80 3.2.1 Estimating the Regression Coefficients . . . . . . . 81 ix x Contents 3.2.2 Some Important Questions . . . . . . . . . . . . . . 83 3.3 Other Considerations in the Regression Model . . . . . . . 91 3.3.1 Qualitative Predictors . . . . . . . . . . . . . . . . 91 3.3.2 Extensions of the Linear Model . . . . . . . . . . . 94 3.3.3 Potential Problems . . . . . . . . . . . . . . . . . . 100 3.4 The Marketing Plan . . . . . . . . . . . . . . . . . . . . . . 109 3.5 Comparison of Linear Regression with K-Nearest Neighbors . . . . . . . . . . . . .", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 3, "start_word": 960, "end_word": 1360, "chunk_words": 400}}, "ISLP_website::c000004": {"text": ". . . . . . . . . 94 3.3.3 Potential Problems . . . . . . . . . . . . . . . . . . 100 3.4 The Marketing Plan . . . . . . . . . . . . . . . . . . . . . . 109 3.5 Comparison of Linear Regression with K-Nearest Neighbors . . . . . . . . . . . . . . . . . . . . . . . . . . . . 111 3.6 Lab: Linear Regression . . . . . . . . . . . . . . . . . . . . 116 3.6.1 Importing packages . . . . . . . . . . . . . . . . . . 116 3.6.2 Simple Linear Regression . . . . . . . . . . . . . . . 117 3.6.3 Multiple Linear Regression . . . . . . . . . . . . . . 122 3.6.4 Multivariate Goodness of Fit . . . . . . . . . . . . 123 3.6.5 Interaction Terms . . . . . . . . . . . . . . . . . . . 124 3.6.6 Non-linear Transformations of the Predictors . . . 125 3.6.7 Qualitative Predictors . . . . . . . . . . . . . . . . 126 3.7 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . 127 4 Classification 135 4.1 An Overview of Classification . . . . . . . . . . . . . . . . . 135 4.2 Why Not Linear Regression? . . . . . . . . . . . . . . . . . 136 4.3 Logistic Regression . . . . . . . . . . . . . . . . . . . . . . 138 4.3.1 The Logistic Model . . . . . . . . . . . . . . . . . . 139 4.3.2 Estimating the Regression Coefficients . . . . . . . 140 4.3.3 Making Predictions . .", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 4, "start_word": 1280, "end_word": 1680, "chunk_words": 400}}, "ISLP_website::c000005": {"text": ". . . . . . . . . . . . 136 4.3 Logistic Regression . . . . . . . . . . . . . . . . . . . . . . 138 4.3.1 The Logistic Model . . . . . . . . . . . . . . . . . . 139 4.3.2 Estimating the Regression Coefficients . . . . . . . 140 4.3.3 Making Predictions . . . . . . . . . . . . . . . . . . 141 4.3.4 Multiple Logistic Regression . . . . . . . . . . . . . 142 4.3.5 Multinomial Logistic Regression . . . . . . . . . . . 144 4.4 Generative Models for Classification . . . . . . . . . . . . . 146 4.4.1 Linear Discriminant Analysis for p=1 . . . . . . . 147 4.4.2 Linear Discriminant Analysis for p>1 . . . . . . . 150 4.4.3 Quadratic Discriminant Analysis . . . . . . . . . . 156 4.4.4 Naive Bayes . . . . . . . . . . . . . . . . . . . . . . 158 4.5 A Comparison of Classification Methods . . . . . . . . . . 161 4.5.1 An Analytical Comparison . . . . . . . . . . . . . . 161 4.5.2 An Empirical Comparison . . . . . . . . . . . . . . 164 4.6 Generalized Linear Models . . . . . . . . . . . . . . . . . . 167 4.6.1 Linear Regression on the Bikeshare Data . . . . . . 167 4.6.2 Poisson Regression on the Bikeshare Data . . . . . 169 4.6.3 Generalized Linear Models in Greater Generality . 172 4.7 Lab: Logistic Regression, LDA, QDA, and KNN . . . . . . 173 4.7.1 The Stock Market Data . . . . . . . . . . . . . . . 173 4.7.2 Logistic Regression . . . . . . . . . . . . . . . . . . 174 4.7.3 Linear Discriminant Analysis . . . . .", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 5, "start_word": 1600, "end_word": 2000, "chunk_words": 400}}, "ISLP_website::c000006": {"text": ". . . 169 4.6.3 Generalized Linear Models in Greater Generality . 172 4.7 Lab: Logistic Regression, LDA, QDA, and KNN . . . . . . 173 4.7.1 The Stock Market Data . . . . . . . . . . . . . . . 173 4.7.2 Logistic Regression . . . . . . . . . . . . . . . . . . 174 4.7.3 Linear Discriminant Analysis . . . . . . . . . . . . 179 4.7.4 Quadratic Discriminant Analysis . . . . . . . . . . 181 4.7.5 Naive Bayes . . . . . . . . . . . . . . . . . . . . . . 182 4.7.6 K-Nearest Neighbors . . . . . . . . . . . . . . . . . 183 4.7.7 Linear and Poisson Regression on the Bikeshare Data188 4.8 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . 193 Contents xi 5 Resampling Methods 201 5.1 Cross-Validation . . . . . . . . . . . . . . . . . . . . . . . . 202 5.1.1 The Validation Set Approach . . . . . . . . . . . . 202 5.1.2 Leave-One-Out Cross-Validation . . . . . . . . . . 204 5.1.3k-Fold Cross-Validation . . . . . . . . . . . . . . . 206 5.1.4 Bias-Variance Trade-Off for k-Fold Cross-Validation . . . . . . . . . . . . . . . . . . . 208 5.1.5 Cross-Validation on Classification Problems . . . . 209 5.2 The Bootstrap . . . . . . . . . . . . . . . . . . . . . . . . . 212 5.3 Lab: Cross-Validation and the Bootstrap . . . . . . . . . . 215 5.3.1 The Validation Set Approach . . . . . . . . . . . . 216 5.3.2 Cross-Validation . . . . . . . . . . . . . . . . . . . 217 5.3.3 The Bootstrap . .", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 6, "start_word": 1920, "end_word": 2320, "chunk_words": 400}}, "ISLP_website::c000007": {"text": ". . . . . . . . . . . . . . . . . 212 5.3 Lab: Cross-Validation and the Bootstrap . . . . . . . . . . 215 5.3.1 The Validation Set Approach . . . . . . . . . . . . 216 5.3.2 Cross-Validation . . . . . . . . . . . . . . . . . . . 217 5.3.3 The Bootstrap . . . . . . . . . . . . . . . . . . . . 220 5.4 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . 224 6 Linear Model Selection and Regularization 229 6.1 Subset Selection . . . . . . . . . . . . . . . . . . . . . . . . 231 6.1.1 Best Subset Selection . . . . . . . . . . . . . . . . . 231 6.1.2 Stepwise Selection . . . . . . . . . . . . . . . . . . 233 6.1.3 Choosing the Optimal Model . . . . . . . . . . . . 235 6.2 Shrinkage Methods . . . . . . . . . . . . . . . . . . . . . . 240 6.2.1 Ridge Regression . . . . . . . . . . . . . . . . . . . 240 6.2.2 The Lasso . . . . . . . . . . . . . . . . . . . . . . . 244 6.2.3 Selecting the Tuning Parameter . . . . . . . . . . . 252 6.3 Dimension Reduction Methods . . . . . . . . . . . . . . . . 253 6.3.1 Principal Components Regression . . . . . . . . . . 254 6.3.2 Partial Least Squares . . . . . . . . . . . . . . . . . 260 6.4 Considerations in High Dimensions . . . . . . . . . . . . . 262 6.4.1 High-Dimensional Data", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 7, "start_word": 2240, "end_word": 2640, "chunk_words": 400}}, "ISLP_website::c000008": {"text": "6.3 Dimension Reduction Methods . . . . . . . . . . . . . . . . 253 6.3.1 Principal Components Regression . . . . . . . . . . 254 6.3.2 Partial Least Squares . . . . . . . . . . . . . . . . . 260 6.4 Considerations in High Dimensions . . . . . . . . . . . . . 262 6.4.1 High-Dimensional Data . . . . . . . . . . . . . . . . 262 6.4.2 What Goes Wrong in High Dimensions? . . . . . . 263 6.4.3 Regression in High Dimensions . . . . . . . . . . . 265 6.4.4 Interpreting Results in High Dimensions . . . . . . 266 6.5 Lab: Linear Models and Regularization Methods . . . . . . 267 6.5.1 Subset Selection Methods . . . . . . . . . . . . . . 268 6.5.2 Ridge Regression and the Lasso . . . . . . . . . . . 273 6.5.3 PCR and PLS Regression . . . . . . . . . . . . . . 280 6.6 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . 283 7 Moving Beyond Linearity 289 7.1 Polynomial Regression . . . . . . . . . . . . . . . . . . . . . 290 7.2 Step Functions . . . . . . . . . . . . . . . . . . . . . . . . . 292 7.3 Basis Functions . . . . . . . . . . . . . . . . . . . . . . . . 293 7.4 Regression Splines . . . . . . . . . . . . . . . . . . . . . . . 294 7.4.1 Piecewise Polynomials . . . . . . . . . . . . . . . . 294 7.4.2 Constraints and Splines . . . . . . . . . . . . . . . 296 7.4.3 The Spline", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 8, "start_word": 2560, "end_word": 2960, "chunk_words": 400}}, "ISLP_website::c000009": {"text": ". . . . . . . . . 293 7.4 Regression Splines . . . . . . . . . . . . . . . . . . . . . . . 294 7.4.1 Piecewise Polynomials . . . . . . . . . . . . . . . . 294 7.4.2 Constraints and Splines . . . . . . . . . . . . . . . 296 7.4.3 The Spline Basis Representation . . . . . . . . . . 296 7.4.4 Choosing the Number and Locations of the Knots . . . . . . . . . . . . . . . . . . . . . . 297 7.4.5 Comparison to Polynomial Regression . . . . . . . 299 xii Contents 7.5 Smoothing Splines . . . . . . . . . . . . . . . . . . . . . . . 300 7.5.1 An Overview of Smoothing Splines . . . . . . . . . 300 7.5.2 Choosing the Smoothing Parameter λ. . . . . . . 301 7.6 Local Regression . . . . . . . . . . . . . . . . . . . . . . . . 303 7.7 Generalized Additive Models . . . . . . . . . . . . . . . . . 305 7.7.1 GAMs for Regression Problems . . . . . . . . . . . 306 7.7.2 GAMs for Classification Problems . . . . . . . . . . 308 7.8 Lab: Non-Linear Modeling . . . . . . . . . . . . . . . . . . 309 7.8.1 Polynomial Regression and Step Functions . . . . . 310 7.8.2 Splines . . . . . . . . . . . . . . . . . . . . . . . . . 315 7.8.3 Smoothing Splines and GAMs . . . . . . . . . . . . 317 7.8.4 Local Regression . . . . . . . . . . . . . . . . . . . 324 7.9 Exercises . . . . . . . . . . . . . . .", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 9, "start_word": 2880, "end_word": 3280, "chunk_words": 400}}, "ISLP_website::c000010": {"text": ". . . . . . . . . . . . . . . . . . . . . 315 7.8.3 Smoothing Splines and GAMs . . . . . . . . . . . . 317 7.8.4 Local Regression . . . . . . . . . . . . . . . . . . . 324 7.9 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . 325 8 Tree-Based Methods 331 8.1 The Basics of Decision Trees . . . . . . . . . . . . . . . . . 331 8.1.1 Regression Trees . . . . . . . . . . . . . . . . . . . 331 8.1.2 Classification Trees . . . . . . . . . . . . . . . . . . 337 8.1.3 Trees Versus Linear Models . . . . . . . . . . . . . 341 8.1.4 Advantages and Disadvantages of Trees . . . . . . . 341 8.2 Bagging, Random Forests, Boosting, and Bayesian Additive Regression Trees . . . . . . . . . . . . . . . . . . . . . . . . 343 8.2.1 Bagging . . . . . . . . . . . . . . . . . . . . . . . . 343 8.2.2 Random Forests . . . . . . . . . . . . . . . . . . . . 346 8.2.3 Boosting . . . . . . . . . . . . . . . . . . . . . . . . 347 8.2.4 Bayesian Additive Regression Trees . . . . . . . . . 350 8.2.5 Summary of Tree Ensemble Methods . . . . . . . . 353 8.3 Lab: Tree-Based Methods . . . . . . . . . . . . . . . . . . . 354 8.3.1 Fitting Classification Trees . . . . . . . . . . . . . . 355 8.3.2 Fitting Regression Trees . . . . . . . . . .", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 10, "start_word": 3200, "end_word": 3600, "chunk_words": 400}}, "ISLP_website::c000011": {"text": ". . . . . . . 350 8.2.5 Summary of Tree Ensemble Methods . . . . . . . . 353 8.3 Lab: Tree-Based Methods . . . . . . . . . . . . . . . . . . . 354 8.3.1 Fitting Classification Trees . . . . . . . . . . . . . . 355 8.3.2 Fitting Regression Trees . . . . . . . . . . . . . . . 358 8.3.3 Bagging and Random Forests . . . . . . . . . . . . 360 8.3.4 Boosting . . . . . . . . . . . . . . . . . . . . . . . . 361 8.3.5 Bayesian Additive Regression Trees . . . . . . . . . 362 8.4 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . 363 9 Support Vector Machines 367 9.1 Maximal Margin Classifier . . . . . . . . . . . . . . . . . . 367 9.1.1 What Is a Hyperplane? . . . . . . . . . . . . . . . . 368 9.1.2 Classification Using a Separating Hyperplane . . . 368 9.1.3 The Maximal Margin Classifier . . . . . . . . . . . 370 9.1.4 Construction of the Maximal Margin Classifier . . 372 9.1.5 The Non-separable Case . . . . . . . . . . . . . . . 372 9.2 Support Vector Classifiers . . . . . . . . . . . . . . . . . . . 373 9.2.1 Overview of the Support Vector Classifier . . . . . 373 9.2.2 Details of the Support Vector Classifier . . . . . . . 374 9.3 Support Vector Machines . . . . . . . . . . . . . . . . . . . 377 9.3.1 Classification with Non-Linear Decision Boundaries . . . . . . . . . . . . . . . . . . . . . . 378 9.3.2 The Support Vector Machine . . . . . .", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 11, "start_word": 3520, "end_word": 3920, "chunk_words": 400}}, "ISLP_website::c000012": {"text": "373 9.2.2 Details of the Support Vector Classifier . . . . . . . 374 9.3 Support Vector Machines . . . . . . . . . . . . . . . . . . . 377 9.3.1 Classification with Non-Linear Decision Boundaries . . . . . . . . . . . . . . . . . . . . . . 378 9.3.2 The Support Vector Machine . . . . . . . . . . . . 379 Contents xiii 9.3.3 An Application to the Heart Disease Data . . . . . 382 9.4 SVMs with More than Two Classes . . . . . . . . . . . . . 383 9.4.1 One-Versus-One Classification . . . . . . . . . . . . 384 9.4.2 One-Versus-All Classification . . . . . . . . . . . . 384 9.5 Relationship to Logistic Regression . . . . . . . . . . . . . 384 9.6 Lab: Support Vector Machines . . . . . . . . . . . . . . . . 387 9.6.1 Support Vector Classifier . . . . . . . . . . . . . . . 387 9.6.2 Support Vector Machine . . . . . . . . . . . . . . . 390 9.6.3 ROC Curves . . . . . . . . . . . . . . . . . . . . . . 392 9.6.4 SVM with Multiple Classes . . . . . . . . . . . . . 393 9.6.5 Application to Gene Expression Data . . . . . . . . 394 9.7 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . 395 10 Deep Learning 399 10.1 Single Layer Neural Networks . . . . . . . . . . . . . . . . 400 10.2 Multilayer Neural Networks . . . . . . . . . . . . . . . . . . 402 10.3 Convolutional Neural Networks . . . . . . . . . . . . . . . . 406 10.3.1 Convolution", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 12, "start_word": 3840, "end_word": 4240, "chunk_words": 400}}, "ISLP_website::c000013": {"text": ". . . . . . . 395 10 Deep Learning 399 10.1 Single Layer Neural Networks . . . . . . . . . . . . . . . . 400 10.2 Multilayer Neural Networks . . . . . . . . . . . . . . . . . . 402 10.3 Convolutional Neural Networks . . . . . . . . . . . . . . . . 406 10.3.1 Convolution Layers . . . . . . . . . . . . . . . . . . 407 10.3.2 Pooling Layers . . . . . . . . . . . . . . . . . . . . 410 10.3.3 Architecture of a Convolutional Neural Network . . 410 10.3.4 Data Augmentation . . . . . . . . . . . . . . . . . . 411 10.3.5 Results Using a Pretrained Classifier . . . . . . . . 412 10.4 Document Classification . . . . . . . . . . . . . . . . . . . . 413 10.5 Recurrent Neural Networks . . . . . . . . . . . . . . . . . . 416 10.5.1 Sequential Models for Document Classification . . 418 10.5.2 Time Series Forecasting . . . . . . . . . . . . . . . 420 10.5.3 Summary of RNNs . . . . . . . . . . . . . . . . . . 424 10.6 When to Use Deep Learning . . . . . . . . . . . . . . . . . 425 10.7 Fitting a Neural Network . . . . . . . . . . . . . . . . . . . 427 10.7.1 Backpropagation . . . . . . . . . . . . . . . . . . . 428 10.7.2 Regularization and Stochastic Gradient Descent . . 429 10.7.3 Dropout Learning . . . . . . . . . . . . . . . . . . . 431 10.7.4 Network Tuning . . . . . . . . . . . . . . . . . . . . 431 10.8 Interpolation and", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 13, "start_word": 4160, "end_word": 4560, "chunk_words": 400}}, "ISLP_website::c000014": {"text": "Backpropagation . . . . . . . . . . . . . . . . . . . 428 10.7.2 Regularization and Stochastic Gradient Descent . . 429 10.7.3 Dropout Learning . . . . . . . . . . . . . . . . . . . 431 10.7.4 Network Tuning . . . . . . . . . . . . . . . . . . . . 431 10.8 Interpolation and Double Descent . . . . . . . . . . . . . . 432 10.9 Lab: Deep Learning . . . . . . . . . . . . . . . . . . . . . . 435 10.9.1 Single Layer Network on Hitters Data . . . . . . . 437 10.9.2 Multilayer Network on the MNIST Digit Data . . . 444 10.9.3 Convolutional Neural Networks . . . . . . . . . . . 448 10.9.4 Using Pretrained CNN Models . . . . . . . . . . . 452 10.9.5 IMDB Document Classification . . . . . . . . . . . 454 10.9.6 Recurrent Neural Networks . . . . . . . . . . . . . 458 10.10 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . 465 11 Survival Analysis and Censored Data 469 11.1 Survival and Censoring Times . . . . . . . . . . . . . . . . 470 11.2 A Closer Look at Censoring . . . . . . . . . . . . . . . . . . 470 11.3 The Kaplan–Meier Survival Curve . . . . . . . . . . . . . . 472 11.4 The Log-Rank Test . . . . . . . . . . . . . . . . . . . . . . 474 11.5 Regression Models With a Survival Response . . . . . . . . 476 xiv Contents 11.5.1 The Hazard Function . . . . . . . . . . . . . . . . . 476 11.5.2 Proportional Hazards . . . . . . .", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 14, "start_word": 4480, "end_word": 4880, "chunk_words": 400}}, "ISLP_website::c000015": {"text": ". . 472 11.4 The Log-Rank Test . . . . . . . . . . . . . . . . . . . . . . 474 11.5 Regression Models With a Survival Response . . . . . . . . 476 xiv Contents 11.5.1 The Hazard Function . . . . . . . . . . . . . . . . . 476 11.5.2 Proportional Hazards . . . . . . . . . . . . . . . . . 478 11.5.3 Example: Brain Cancer Data . . . . . . . . . . . . 482 11.5.4 Example: Publication Data . . . . . . . . . . . . . 482 11.6 Shrinkage for the Cox Model . . . . . . . . . . . . . . . . . 484 11.7 Additional Topics . . . . . . . . . . . . . . . . . . . . . . . 486 11.7.1 Area Under the Curve for Survival Analysis . . . . 486 11.7.2 Choice of Time Scale . . . . . . . . . . . . . . . . . 487 11.7.3 Time-Dependent Covariates . . . . . . . . . . . . . 488 11.7.4 Checking the Proportional Hazards Assumption . . 488 11.7.5 Survival Trees . . . . . . . . . . . . . . . . . . . . . 488 11.8 Lab: Survival Analysis . . . . . . . . . . . . . . . . . . . . . 489 11.8.1 Brain Cancer Data . . . . . . . . . . . . . . . . . . 489 11.8.2 Publication Data . . . . . . . . . . . . . . . . . . . 493 11.8.3 Call Center Data . . . . . . . . . . . . . . . . . . . 494 11.9 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . 498 12 Unsupervised Learning 503 12.1 The Challenge of", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 15, "start_word": 4800, "end_word": 5200, "chunk_words": 400}}, "ISLP_website::c000016": {"text": ". . . . . . . . . . . . . . . . 493 11.8.3 Call Center Data . . . . . . . . . . . . . . . . . . . 494 11.9 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . 498 12 Unsupervised Learning 503 12.1 The Challenge of Unsupervised Learning . . . . . . . . . . 503 12.2 Principal Components Analysis . . . . . . . . . . . . . . . . 504 12.2.1 What Are Principal Components? . . . . . . . . . . 505 12.2.2 Another Interpretation of Principal Components . 508 12.2.3 The Proportion of Variance Explained . . . . . . . 510 12.2.4 More on PCA . . . . . . . . . . . . . . . . . . . . . 512 12.2.5 Other Uses for Principal Components . . . . . . . . 515 12.3 Missing Values and Matrix Completion . . . . . . . . . . . 515 12.4 Clustering Methods . . . . . . . . . . . . . . . . . . . . . . 520 12.4.1K-Means Clustering . . . . . . . . . . . . . . . . . 521 12.4.2 Hierarchical Clustering . . . . . . . . . . . . . . . . 525 12.4.3 Practical Issues in Clustering . . . . . . . . . . . . 532 12.5 Lab: Unsupervised Learning . . . . . . . . . . . . . . . . . 535 12.5.1 Principal Components Analysis . . . . . . . . . . . 535 12.5.2 Matrix Completion . . . . . . . . . . . . . . . . . . 539 12.5.3 Clustering . . . . . . . . . . . . . . . . . . . . . . . 542 12.5.4 NCI60 Data Example . . . . . . . . . . . . . . .", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 16, "start_word": 5120, "end_word": 5520, "chunk_words": 400}}, "ISLP_website::c000017": {"text": "Analysis . . . . . . . . . . . 535 12.5.2 Matrix Completion . . . . . . . . . . . . . . . . . . 539 12.5.3 Clustering . . . . . . . . . . . . . . . . . . . . . . . 542 12.5.4 NCI60 Data Example . . . . . . . . . . . . . . . . . 546 12.6 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . 552 13 Multiple Testing 557 13.1 A Quick Review of Hypothesis Testing . . . . . . . . . . . 558 13.1.1 Testing a Hypothesis . . . . . . . . . . . . . . . . . 558 13.1.2 Type I and Type II Errors . . . . . . . . . . . . . . 562 13.2 The Challenge of Multiple Testing . . . . . . . . . . . . . . 563 13.3 The Family-Wise Error Rate . . . . . . . . . . . . . . . . . 565 13.3.1 What is the Family-Wise Error Rate? . . . . . . . 565 13.3.2 Approaches to Control the Family-Wise Error Rate 567 13.3.3 Trade-Off Between the FWER and Power . . . . . 572 13.4 The False Discovery Rate . . . . . . . . . . . . . . . . . . . 573 13.4.1 Intuition for the False Discovery Rate . . . . . . . 573 13.4.2 The Benjamini–Hochberg Procedure . . . . . . . . 575 Contents xv 13.5 A Re-Sampling Approach to p-Values and False Discovery Rates . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 577 13.5.1 A Re-Sampling Approach to the p-Value . . . . . . 578 13.5.2 A Re-Sampling Approach to the False Discovery Rate579 13.5.3 When Are Re-Sampling Approaches Useful? . . . . 581 13.6 Lab: Multiple Testing . . . .", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 17, "start_word": 5440, "end_word": 5840, "chunk_words": 400}}, "ISLP_website::c000018": {"text": "Approach to p-Values and False Discovery Rates . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 577 13.5.1 A Re-Sampling Approach to the p-Value . . . . . . 578 13.5.2 A Re-Sampling Approach to the False Discovery Rate579 13.5.3 When Are Re-Sampling Approaches Useful? . . . . 581 13.6 Lab: Multiple Testing . . . . . . . . . . . . . . . . . . . . . 583 13.6.1 Review of Hypothesis Tests . . . . . . . . . . . . . 583 13.6.2 Family-Wise Error Rate . . . . . . . . . . . . . . . 585 13.6.3 False Discovery Rate . . . . . . . . . . . . . . . . . 588 13.6.4 A Re-Sampling Approach . . . . . . . . . . . . . . 590 13.7 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . 593 Index 597 1 Introduction An Overview of Statistical Learning Statistical learning referstoavastsetoftoolsfor understanding data .These tools can be classified as supervised orunsupervised . Broadly speaking, supervised statistical learning involves building a statistical model for pre- dicting, or estimating, an outputbased on one or more inputs. Problems of thisnatureoccurinfieldsasdiverseasbusiness,medicine,astrophysics,and public policy. With unsupervised statistical learning, there are inputs but no supervising output; nevertheless we can learn relationships and struc- ture from such data. To provide an illustration of some applications of statistical learning, we briefly discuss three real-world data sets that are considered in this book. Wage Data In this application (which we refer to as the Wagedata set throughout this book), we examine a number of factors that relate to wages for a group of men from the Atlantic region of the United States. In particular, we wish to understand the association between an employee’s ageandeducation , as well as the calendar year, on his wage. Consider, for example, the left-hand panel of Figure 1.1, which displays wageversusagefor each of the individu- als in the data set. There is evidence that wageincreases with agebut then decreases again after approximately age 60.", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 18, "start_word": 5760, "end_word": 6160, "chunk_words": 400}}, "ISLP_website::c000019": {"text": "we examine a number of factors that relate to wages for a group of men from the Atlantic region of the United States. In particular, we wish to understand the association between an employee’s ageandeducation , as well as the calendar year, on his wage. Consider, for example, the left-hand panel of Figure 1.1, which displays wageversusagefor each of the individu- als in the data set. There is evidence that wageincreases with agebut then decreases again after approximately age 60. The blue line, which provides an estimate of the average wagefor a given age, makes this trend clearer. Given an employee’s age, we can use this curve to predicthiswage. However, it is also clear from Figure 1.1that there is a significant amount of vari- ability associated with this average value, and so agealone is unlikely to provide an accurate prediction of a particular man’s wage. © Springer Nature Switzerland AG 2023 G. James et al., An Introduction to Statistical Learning , Springer Texts in Statistics, https://doi.org/10.1007/978-3-031-38747-0_1 1 2 1. Introduction 20 40 60 8050 100 200 300AgeWage2003 2006 200950 100 200 300YearWage1234550 100 200 300Education LevelWage FIGURE 1.1. Wagedata, which contains income survey information for men from the central Atlantic region of the United States. Left:wageas a function of age. On average, wageincreases with ageuntil about 60years of age, at which point it begins to decline. Center:wageas a function of year. There is a slow but steady increase of approximately $10,000in the average wagebetween 2003 and2009.Right:Boxplots displaying wageas a function of education , with1 indicating the lowest level (no high school diploma) and 5the highest level (an advanced graduate degree). On average, wageincreases with the level of education. We also have information regarding each employee’s education level and theyearin which the wagewas earned. The center and right-hand panels of Figure 1.1, which display wageas a function of both yearandeducation , indicate that both of these factors are associated with wage. Wages increase by approximately $10,000, in a roughly linear (or straight-line) fashion, between 2003 and2009 , though this rise is very slight relative to the vari- ability in the data. Wages are also typically greater for individuals with higher education levels: men with the lowest education level (1) tend to have substantially lower wages than those with the highest education level (5). Clearly, the most accurate prediction of a given man’s wagewill be obtained by combining his age, hiseducation ,", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 19, "start_word": 6080, "end_word": 6480, "chunk_words": 400}}, "ISLP_website::c000020": {"text": "Wages increase by approximately $10,000, in a roughly linear (or straight-line) fashion, between 2003 and2009 , though this rise is very slight relative to the vari- ability in the data. Wages are also typically greater for individuals with higher education levels: men with the lowest education level (1) tend to have substantially lower wages than those with the highest education level (5). Clearly, the most accurate prediction of a given man’s wagewill be obtained by combining his age, hiseducation , and the year. In Chapter 3, we discuss linear regression, which can be used to predict wagefrom this data set. Ideally, we should predict wagein a way that accounts for the non-linear relationship between wageandage. In Chapter 7, we discuss a class of approaches for addressing this problem. Stock Market Data TheWagedatainvolvespredictinga continuous orquantitative outputvalue. This is often referred to as a regression problem. However, in certain cases wemayinsteadwishtopredictanon-numericalvalue—thatis,a categorical orqualitative output. For example, in Chapter 4we examine a stock market data set that contains the daily movements in the Standard & Poor’s 500 (S&P) stock index over a 5-year period between 2001 and2005 . We refer to this as the Smarketdata. The goal is to predict whether the index will increase ordecrease on a given day, using the past 5 days’ percentage changes in the index. Here the statistical learning problem does not involve predicting a numerical value. Instead it involves predicting whether a given 1. Introduction 3 Down Up−4 −2 0 2 4 6Yesterday Today’s DirectionPercentage change in S&PDown Up−4 −2 0 2 4 6Two Days Previous Today’s DirectionPercentage change in S&PDown Up−4 −2 0 2 4 6Three Days Previous Today’s DirectionPercentage change in S&P FIGURE 1.2. Left:Boxplots of the previous day’s percentage change in the S&P index for the days for which the market increased or decreased, obtained from the Smarket data.Center and Right: Same as left panel, but the percentage changes for 2 and 3 days previous are shown. day’s stock market performance will fall into the Upbucket or the Down bucket. This is known as a classification problem. A model that could accurately predict the direction in which the market will move would be very useful! The left-hand panel of Figure 1.2displays two boxplots of the previous day’s percentage changes in the stock index: one for the 648days for which the market increased on the subsequent day, and one for the 602days for which the", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 20, "start_word": 6400, "end_word": 6800, "chunk_words": 400}}, "ISLP_website::c000021": {"text": "previous are shown. day’s stock market performance will fall into the Upbucket or the Down bucket. This is known as a classification problem. A model that could accurately predict the direction in which the market will move would be very useful! The left-hand panel of Figure 1.2displays two boxplots of the previous day’s percentage changes in the stock index: one for the 648days for which the market increased on the subsequent day, and one for the 602days for which the market decreased. The two plots look almost identical, suggest- ing that there is no simple strategy for using yesterday’s movement in the S&P to predict today’s returns. The remaining panels, which display box- plots for the percentage changes 2 and 3 days previous to today, similarly indicate little association between past and present returns. Of course, this lack of pattern is to be expected: in the presence of strong correlations be- tween successive days’ returns, one could adopt a simple trading strategy to generate profits from the market. Nevertheless, in Chapter 4, we explore thesedatausingseveraldifferentstatisticallearningmethods.Interestingly, there are hints of some weak trends in the data that suggest that, at least for this 5-year period, it is possible to correctly predict the direction of movement in the market approximately 60% of the time (Figure 1.3). Gene Expression Data The previous two applications illustrate data sets with both input and output variables. However, another important class of problems involves situations in which we only observe input variables, with no corresponding output. For example, in a marketing setting, we might have demographic informationforanumberofcurrentorpotentialcustomers.Wemaywishto understand which types of customers are similar to each other by grouping individuals according to their observed characteristics. This is known as a 4 1. Introduction DownUp0.46 0.48 0.50 0.52Today’s DirectionPredicted ProbabilityFIGURE 1.3. We fit a quadratic discriminant analysis model to the subset of theSmarket data corresponding to the 2001–2004 time period, and predicted the probability of a stock market decrease using the 2005 data. On average, the predicted probability of decrease is higher for the days in which the market does decrease. Based on these results, we are able to correctly predict the direction of movement in the market 60% of the time. clustering problem. Unlike in the previous examples, here we are not trying to predict an output variable. We devote Chapter 12to a discussion of statistical learning methods for problems in which no natural output variable is", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 21, "start_word": 6720, "end_word": 7120, "chunk_words": 400}}, "ISLP_website::c000022": {"text": "decrease using the 2005 data. On average, the predicted probability of decrease is higher for the days in which the market does decrease. Based on these results, we are able to correctly predict the direction of movement in the market 60% of the time. clustering problem. Unlike in the previous examples, here we are not trying to predict an output variable. We devote Chapter 12to a discussion of statistical learning methods for problems in which no natural output variable is available. We consider theNCI60data set, which consists of 6,830gene expression measurements for each of 64cancer cell lines. Instead of predicting a particular output variable, we are interested in determining whether there are groups, or clusters, among the cell lines based on their gene expression measurements. This is a difficult question to address, in part because there are thousands of gene expression measurements per cell line, making it hard to visualize the data. The left-hand panel of Figure 1.4addresses this problem by represent- ing each of the 64cell lines using just two numbers, Z1andZ2. These are the first two principal components of the data, which summarize the 6,830expression measurements for each cell line down to two numbers or dimensions . While it is likely that this dimension reduction has resulted in some loss of information, it is now possible to visually examine the data for evidence of clustering. Deciding on the number of clusters is often a difficult problem. But the left-hand panel of Figure 1.4suggests at least four groups of cell lines, which we have represented using separate colors. In this particular data set, it turns out that the cell lines correspond to14different types of cancer. (However, this information was not used to create the left-hand panel of Figure 1.4.) The right-hand panel of Fig- ure1.4is identical to the left-hand panel, except that the 14 cancer types are shown using distinct colored symbols. There is clear evidence that cell lines with the same cancer type tend to be located near each other in this two-dimensional representation. In addition, even though the cancer infor- mationwasnotusedtoproducetheleft-handpanel,theclusteringobtained does bear some resemblance to some of the actual cancer types observed in the right-hand panel. This provides some independent verification of the accuracy of our clustering analysis. 1. Introduction 5 −40 −20 0 20 40 60−60 −40 −20 0 20−40 −20 0 20 40 60−60 −40 −20 0 20Z1Z1 Z2Z2 FIGURE 1.4.Left:Representation of theNCI60gene expression", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 22, "start_word": 7040, "end_word": 7440, "chunk_words": 400}}, "ISLP_website::c000023": {"text": "with the same cancer type tend to be located near each other in this two-dimensional representation. In addition, even though the cancer infor- mationwasnotusedtoproducetheleft-handpanel,theclusteringobtained does bear some resemblance to some of the actual cancer types observed in the right-hand panel. This provides some independent verification of the accuracy of our clustering analysis. 1. Introduction 5 −40 −20 0 20 40 60−60 −40 −20 0 20−40 −20 0 20 40 60−60 −40 −20 0 20Z1Z1 Z2Z2 FIGURE 1.4.Left:Representation of theNCI60gene expression data set ina two-dimensional space,Z1andZ2. Each point corresponds to one of the64cell lines. There appear to be four groups of cell lines, which we have representedusing different colors.Right:Same as left panel except that we have representedeach of the14different types of cancer using a different colored symbol. Cell linescorresponding to the same cancer type tend to be nearby in the two-dimensionalspace.A Brief History of Statistical LearningThoughthetermstatistical learningisfairlynew,manyoftheconceptsthatunderlie the field were developed long ago. At the beginning of the nine-teenth century, the method ofleast squareswas developed, implementingthe earliest form of what is now known aslinear regression. The approachwas first successfully applied to problems in astronomy. Linear regressionis used for predicting quantitative values, such as an individual’s salary.In order to predict qualitative values, such as whether a patient survivesor dies, or whether the stock market increases or decreases,linear discrim-inant analysiswas proposed in 1936. In the 1940s, various authors putforth an alternative approach,logistic regression. In the early 1970s, thetermgeneralized linear modelwas developed to describe an entire class ofstatistical learning methods that include both linear and logistic regressionas special cases.By the end of the 1970s, many more techniques for learning from datawere available. However, they were almost exclusivelylinearmethods be-cause fittingnon-linearrelationships was computationally difficult at thetime. By the 1980s, computing technology had finally improved sufficientlythat non-linear methods were no longer computationally prohibitive. Inthe mid 1980s,classification and regression treeswere developed, followedshortly bygeneralized additive models.Neural networksgained popularityin the 1980s, andsupport vector machinesarose in the 1990s.Since that time, statistical learning has emerged as a new subfield instatistics,focusedonsupervisedandunsupervisedmodelingandprediction.In recent years, progress in statistical learning has been marked by theincreasingavailabilityofpowerfulandrelativelyuser-friendlysoftware,suchas the popular and freely availablePythonsystem. This has the potential tocontinue the transformation of the field from a set of techniques used and 6 1. Introductiondeveloped by statisticians and computer scientists to an essential toolkitfor a much broader community.This BookThe Elements of Statistical Learning(ESL) by Hastie, Tibshirani, andFriedman was first published in 2001. Since that time, it has become animportant reference on", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 23, "start_word": 7360, "end_word": 7760, "chunk_words": 400}}, "ISLP_website::c000024": {"text": "learning has emerged as a new subfield instatistics,focusedonsupervisedandunsupervisedmodelingandprediction.In recent years, progress in statistical learning has been marked by theincreasingavailabilityofpowerfulandrelativelyuser-friendlysoftware,suchas the popular and freely availablePythonsystem. This has the potential tocontinue the transformation of the field from a set of techniques used and 6 1. Introductiondeveloped by statisticians and computer scientists to an essential toolkitfor a much broader community.This BookThe Elements of Statistical Learning(ESL) by Hastie, Tibshirani, andFriedman was first published in 2001. Since that time, it has become animportant reference on the fundamentals of statistical machine learning.Its success derives from its comprehensive and detailed treatment of manyimportant topics in statistical learning, as well as the fact that (relative tomany upper-level statistics textbooks) it is accessible to a wide audience.However, the greatest factor behind the success of ESL has been its topicalnature. At the time of its publication, interest in the field of statisticallearning was starting to explode. ESL provided one of the first accessibleand comprehensive introductions to the topic.Since ESL was first published, the field of statistical learning has con-tinued to flourish. The field’s expansion has taken two forms. The mostobvious growth has involved the development of new and improved statis-tical learning approaches aimed at answering a range of scientific questionsacross a number of fields. However, the field of statistical learning hasalso expanded its audience. In the 1990s, increases in computational powergenerated a surge of interest in the field from non-statisticians who wereeager to use cutting-edge statistical tools to analyze their data. Unfortu-nately, the highly technical nature of these approaches meant that the usercommunity remained primarily restricted to experts in statistics, computerscience, and related fields with the training (and time) to understand andimplement them.In recent years, new and improved software packages have significantlyeased the implementation burden for many statistical learning methods.At the same time, there has been growing recognition across a number offields, from business to health care to genetics to the social sciences andbeyond, that statistical learning is a powerful tool with important practicalapplications.Asaresult,thefieldhasmovedfromoneofprimarilyacademicinterest to a mainstream discipline, with an enormous potential audience.This trend will surely continue with the increasing availability of enormousquantities of data and the software to analyze it.The purpose ofAn Introduction to Statistical Learning(ISL) is to facili-tate the transition of statistical learning from an academic to a mainstreamfield. ISL is not intended to replace ESL, which is a far more comprehen-sive text both in terms of the number of approaches considered and thedepth to which they are", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 24, "start_word": 7680, "end_word": 8080, "chunk_words": 400}}, "ISLP_website::c000025": {"text": "tool with important practicalapplications.Asaresult,thefieldhasmovedfromoneofprimarilyacademicinterest to a mainstream discipline, with an enormous potential audience.This trend will surely continue with the increasing availability of enormousquantities of data and the software to analyze it.The purpose ofAn Introduction to Statistical Learning(ISL) is to facili-tate the transition of statistical learning from an academic to a mainstreamfield. ISL is not intended to replace ESL, which is a far more comprehen-sive text both in terms of the number of approaches considered and thedepth to which they are explored. We consider ESL to be an importantcompanion for professionals (with graduate degrees in statistics, machinelearning, or related fields) who need to understand the technical detailsbehind statistical learning approaches. However, the community of users ofstatistical learning techniques has expanded to include individuals with awider range of interests and backgrounds. Therefore, there is a place for aless technical and more accessible version of ESL. 1. Introduction 7In teaching these topics over the years, we have discovered that they areof interest to master’s and PhD students in fields as disparate as businessadministration, biology, and computer science, as well as to quantitatively-oriented upper-division undergraduates. It is important for this diversegroup to be able to understand the models, intuitions, and strengths andweaknesses of the various approaches. But for this audience, many of thetechnical details behind statistical learning methods, such as optimiza-tion algorithms and theoretical properties, are not of primary interest.We believe that these students do not need a deep understanding of theseaspectsinordertobecomeinformedusersofthevariousmethodologies,andin order to contribute to their chosen fields through the use of statisticallearning tools.ISL is based on the following four premises.1.Many statistical learning methods are relevant and useful in a widerange of academic and non-academic disciplines, beyond just the sta-tistical sciences.Webelievethatmanycontemporarystatisticallearn-ing procedures should, and will, become as widely available and usedas is currently the case for classical methods such as linear regres-sion. As a result, rather than attempting to consider every possibleapproach (an impossible task), we have concentrated on presentingthe methods that we believe are most widely applicable.2.Statistical learning should not be viewed as a series of black boxes.Nosingle approach will perform well in all possible applications. With-out understanding all of the cogs inside the box, or the interactionbetween those cogs, it is impossible to select the best box. Hence, wehave attempted to carefully describe the model, intuition, assump-tions, and trade-offs behind each of the methods that we consider.3.While it is important to know what job is performed by each cog, it isnot", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 25, "start_word": 8000, "end_word": 8400, "chunk_words": 400}}, "ISLP_website::c000026": {"text": "believe are most widely applicable.2.Statistical learning should not be viewed as a series of black boxes.Nosingle approach will perform well in all possible applications. With-out understanding all of the cogs inside the box, or the interactionbetween those cogs, it is impossible to select the best box. Hence, wehave attempted to carefully describe the model, intuition, assump-tions, and trade-offs behind each of the methods that we consider.3.While it is important to know what job is performed by each cog, it isnot necessary to have the skills to construct the machine inside thebox!Thus, we have minimized discussion of technical details relatedto fitting procedures and theoretical properties. We assume that thereader is comfortable with basic mathematical concepts, but we donot assume a graduate degree in the mathematical sciences. For in-stance, we have almost completely avoided the use of matrix algebra,and it is possible to understand the entire book without a detailedknowledge of matrices and vectors.4.We presume that the reader is interested in applying statistical learn-ing methods to real-world problems.In order to facilitate this, as wellas to motivate the techniques discussed, we have devoted a sectionwithin each chapter to computer labs. In each lab, we walk the readerthrougharealisticapplicationofthemethodsconsideredinthatchap-ter. When we have taught this material in our courses, we have al-located roughly one-third of classroom time to working through thelabs, and we have found them to be extremely useful. Many of theless computationally-oriented students who were initially intimidatedby the labs got the hang of things over the course of the quarter orsemester. This book originally appeared (2013, second edition 2021) 8 1. Introduction with computer labs written in the Rlanguage. Since then, there has been increasing demand for Pythonimplementations of the impor- tant techniques in statistical learning. Consequently, this version has labs inPython. There are a rapidly growing number of Pythonpack- ages available, and by examination of the imports at the beginning of each lab, readers will see that we have carefully selected and used the most appropriate. We have also supplied some additional code and functionality in our package ISLP. However, the labs in ISL are self- contained, and can be skipped if the reader wishes to use a different software package or does not wish to apply the methods discussed to real-world problems. Who Should Read This Book? This book is intended for anyone who is interested in using modern statis- tical methods for modeling and prediction from data. This group includes scientists,", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 26, "start_word": 8320, "end_word": 8720, "chunk_words": 400}}, "ISLP_website::c000027": {"text": "the most appropriate. We have also supplied some additional code and functionality in our package ISLP. However, the labs in ISL are self- contained, and can be skipped if the reader wishes to use a different software package or does not wish to apply the methods discussed to real-world problems. Who Should Read This Book? This book is intended for anyone who is interested in using modern statis- tical methods for modeling and prediction from data. This group includes scientists, engineers, data analysts, data scientists, and quants, but also less technical individuals with degrees in non-quantitative fields such as the so- cial sciences or business. We expect that the reader will have had at least one elementary course in statistics. Background in linear regression is also useful, though not required, since we review the key concepts behind linear regression in Chapter 3. The mathematical level of this book is modest, and a detailed knowledge of matrix operations is not required. This book provides an introduction to Python. Previous exposure to a programming language, such as MATLABorR, is useful but not required. The first edition of this textbook has been used to teach master’s and PhD students in business, economics, computer science, biology, earth sci- ences, psychology, and many other areas of the physical and social sciences. It has also been used to teach advanced undergraduates who have already taken a course on linear regression. In the context of a more mathemat- ically rigorous course in which ESL serves as the primary textbook, ISL could be used as a supplementary text for teaching computational aspects of the various approaches. Notation and Simple Matrix Algebra Choosing notation for a textbook is always a difficult task. For the most part we adopt the same notational conventions as ESL. We will use nto represent the number of distinct data points, or observa- tions, in our sample. We will let pdenote the number of variables that are available for use in making predictions. For example, the Wagedata set con- sists of 11 variables for 3,000people, so we have n=3,000observations and p= 11 variables (such as year,age,race, and more). Note that throughout this book, we indicate variable names using colored font: Variable Name . In some examples, pmight be quite large, such as on the order of thou- sands or even millions; this situation arises quite often, for example, in the analysis of modern biological data", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 27, "start_word": 8640, "end_word": 9040, "chunk_words": 400}}, "ISLP_website::c000028": {"text": "that are available for use in making predictions. For example, the Wagedata set con- sists of 11 variables for 3,000people, so we have n=3,000observations and p= 11 variables (such as year,age,race, and more). Note that throughout this book, we indicate variable names using colored font: Variable Name . In some examples, pmight be quite large, such as on the order of thou- sands or even millions; this situation arises quite often, for example, in the analysis of modern biological data or web-based advertising data. 1. Introduction 9In general, we will letxijrepresent the value of thejth variable for theith observation, wherei=1,2,...,nandj=1,2,...,p. Throughout thisbook,iwill be used to index the samples or observations (from1ton) andjwill be used to index the variables (from1top). We letXdenote ann×pmatrix whose(i, j)th element isxij. That is,X=x11x12... x1px21x22... x2p............xn1xn2... xnp.For readers who are unfamiliar with matrices, it is useful to visualizeXasa spreadsheet of numbers withnrows andpcolumns.At times we will be interested in the rows ofX, which we write asx1,x2,...,xn. Herexiis a vector of lengthp, containing thepvariablemeasurements for theith observation. That is,xi=xi1xi2...xip.(1.1)(Vectors are by default represented as columns.) For example, for theWagedata,xiis a vector of length 11, consisting ofyear,age,race, and othervalues for theith individual. At other times we will instead be interestedin the columns ofX, which we write asx1,x2,...,xp. Each is a vector oflengthn. That is,xj=x1jx2j...xnj.For example, for theWagedata,x1contains then=3,000values foryear.Using this notation, the matrixXcan be written asX=/parenleftbigx1x2···xp/parenrightbig,orX=xT1xT2...xTn.TheTnotationdenotesthetransposeofamatrixorvector.So,forexample,XT=x11x21... xn1x12x22... xn2.........x1px2p... xnp, 10 1. Introduction while xT i=/parenleftbigxi1xi2···xip/parenrightbig . We useyito denote the ith observation of the variable on which we wish to make predictions, such as wage. Hence, we write the set of all n observations in vector form as y= y1 y2 ... yn . Then our observed data consists of {(x1,y1),(x2,y2),...,(xn,yn)}, where eachxiis a vector of length p. (Ifp=1, thenxiis simply a scalar.) In this text, a vector of length nwill always be denoted in lower case bold; e.g. a= a1 a2 ... an . However, vectors that are not of length n(such as feature vectors of length p, as in (1.1)) will be denoted in lower case normal font , e.g.a. Scalars will also be denoted in lower case normal font , e.g.a. In the rare cases in which these two uses for lower case normal font lead to ambiguity, we will clarify which use is intended. Matrices will be denoted using bold capitals , such asA. Random variables will be denoted using capital normal font ,", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 28, "start_word": 8960, "end_word": 9360, "chunk_words": 400}}, "ISLP_website::c000029": {"text": "are not of length n(such as feature vectors of length p, as in (1.1)) will be denoted in lower case normal font , e.g.a. Scalars will also be denoted in lower case normal font , e.g.a. In the rare cases in which these two uses for lower case normal font lead to ambiguity, we will clarify which use is intended. Matrices will be denoted using bold capitals , such asA. Random variables will be denoted using capital normal font , e.g.A, regardless of their dimensions. Occasionallywewillwanttoindicatethedimensionofaparticularobject. To indicate that an object is a scalar, we will use the notation a∈R.T o indicate that it is a vector of length k, we will use a∈Rk(ora∈Rnif it is of length n). We will indicate that an object is an r×smatrix using A∈Rr×s. We have avoided using matrix algebra whenever possible. However, in a few instances it becomes too cumbersome to avoid it entirely. In these rare instances it is important to understand the concept of multiplying two matrices. Suppose that A∈Rr×dandB∈Rd×s. Then the product ofAandBis denoted AB. The(i, j)th element of ABis computed by multiplying each element of the ith row of Aby the corresponding element of thejth column of B. That is, (AB)ij=/summationtextd k=1aikbkj. As an example, consider A=/parenleftbigg12 34/parenrightbigg andB=/parenleftbigg56 78/parenrightbigg . Then AB=/parenleftbigg12 34/parenrightbigg/parenleftbigg56 78/parenrightbigg =/parenleftbigg1×5+2 ×71 ×6+2 ×8 3×5+4 ×73 ×6+4 ×8/parenrightbigg =/parenleftbigg19 22 43 50/parenrightbigg . Note that this operation produces an r×smatrix. It is only possible to compute ABif the number of columns of Ais the same as the number of rows ofB. 1. Introduction 11 Organization of This Book Chapter 2introduces the basic terminology and concepts behind statisti- cal learning. This chapter also presents the K-nearest neighbor classifier, a very simple method that works surprisingly well on many problems. Chap- ters3and4cover classical linear methods for regression and classification. In particular, Chapter 3reviewslinear regression , the fundamental start- ing point for all regression methods. In Chapter 4we discuss two of the most important classical classification methods, logistic regression andlin- ear discriminant analysis . A central problem in all statistical learning situations involves choosing the best method for a given application. Hence, in Chapter 5we intro- ducecross-validation and thebootstrap , which can be used to estimate the accuracy of a number of different methods in order to choose the best one. Much of the recent research in statistical learning has concentrated on non-linear methods. However, linear methods", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 29, "start_word": 9280, "end_word": 9680, "chunk_words": 400}}, "ISLP_website::c000030": {"text": "4we discuss two of the most important classical classification methods, logistic regression andlin- ear discriminant analysis . A central problem in all statistical learning situations involves choosing the best method for a given application. Hence, in Chapter 5we intro- ducecross-validation and thebootstrap , which can be used to estimate the accuracy of a number of different methods in order to choose the best one. Much of the recent research in statistical learning has concentrated on non-linear methods. However, linear methods often have advantages over their non-linear competitors in terms of interpretability and sometimes also accuracy. Hence, in Chapter 6we consider a host of linear methods, both classical and more modern, which offer potential improvements over stan- dard linear regression. These include stepwise selection ,ridge regression , principal components regression , and the lasso. The remaining chapters move into the world of non-linear statistical learning. We first introduce in Chapter 7a number of non-linear meth- ods that work well for problems with a single input variable. We then show how these methods can be used to fit non-linear additive models for which there is more than one input. In Chapter 8, we investigate tree-based methods, including bagging,boosting, andrandom forests .Support vector machines , a set of approaches for performing both linear and non-linear classification, are discussed in Chapter 9. We cover deep learning , an ap- proach for non-linear regression and classification that has received a lot of attention in recent years, in Chapter 10. Chapter 11explores survival analysis, a regression approach that is specialized to the setting in which the output variable is censored, i.e. not fully observed. In Chapter 12, we consider the unsupervised setting in which we have input variables but no output variable. In particular, we present princi- pal components analysis ,K-means clustering , andhierarchical clustering . Finally, in Chapter 13we cover the very important topic of multiple hy- pothesis testing. At the end of each chapter, we present one or more Pythonlab sections in which we systematically work through applications of the various meth- ods discussed in that chapter. These labs demonstrate the strengths and weaknesses of the various approaches, and also provide a useful reference for the syntax required to implement the various methods. The reader may choose to work through the labs at their own pace, or the labs may be the focus of group sessions as part of a classroom environment. Within each", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 30, "start_word": 9600, "end_word": 10000, "chunk_words": 400}}, "ISLP_website::c000031": {"text": "we present one or more Pythonlab sections in which we systematically work through applications of the various meth- ods discussed in that chapter. These labs demonstrate the strengths and weaknesses of the various approaches, and also provide a useful reference for the syntax required to implement the various methods. The reader may choose to work through the labs at their own pace, or the labs may be the focus of group sessions as part of a classroom environment. Within each Pythonlab, we present the results that we obtained when we performed the lab at the time of writing this book. However, new versions of Pythonare continuously released, and over time, the packages called in the labs will be updated. Therefore, in the future, it is possible that the results shown in 12 1. Introduction Name Description Auto Gas mileage, horsepower, and other information for cars. Bikeshare Hourly usage of a bike sharing program in Washington, DC. Boston Housing values and other information about Boston census tracts. BrainCancer Survival times for patients diagnosed with brain cancer. Caravan Information about individuals offered caravan insurance. Carseats Information about car seat sales in 400 stores. College Demographic characteristics, tuition, and more for USA colleges. Credit Information about credit card debt for 400 customers. Default Customer default records for a credit card company. Fund Returns of 2,000 hedge fund managers over 50 months. Hitters Records and salaries for baseball players. Khan Gene expression measurements for four cancer types. NCI60 Gene expression measurements for 64 cancer cell lines. NYSE Returns, volatility, and volume for the New York Stock Exchange. OJ Sales information for Citrus Hill and Minute Maid orange juice. Portfolio Past values of financial assets, for use in portfolio allocation. Publication Time to publication for 244 clinical trials. Smarket Daily percentage returns for S&P 500 over a 5-year period. USArrests Crime statistics per 100,000 residents in 50 states of USA. Wage Income survey data for men in central Atlantic region of USA. Weekly 1,089 weekly stock market returns for 21 years. TABLE 1.1. A list of data sets needed to perform the labs and exercises in this textbook. All data sets are available in the ISLPpackage, with the exception of USArrests , which is part of the base Rdistribution, but accessible from Python. the lab sections may no longer correspond precisely to the results obtained by the reader who performs the labs. As necessary, we", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 31, "start_word": 9920, "end_word": 10320, "chunk_words": 400}}, "ISLP_website::c000032": {"text": "men in central Atlantic region of USA. Weekly 1,089 weekly stock market returns for 21 years. TABLE 1.1. A list of data sets needed to perform the labs and exercises in this textbook. All data sets are available in the ISLPpackage, with the exception of USArrests , which is part of the base Rdistribution, but accessible from Python. the lab sections may no longer correspond precisely to the results obtained by the reader who performs the labs. As necessary, we will post updates to the labs on the book website. We use the symbol to denote sections or exercises that contain more challenging concepts. These can be easily skipped by readers who do not wish to delve as deeply into the material, or who lack the mathematical background. Data Sets Used in Labs and Exercises In this textbook, we illustrate statistical learning methods using applica- tions from marketing, finance, biology, and other areas. The ISLPpackage contains a number of data sets that are required in order to perform the labs and exercises associated with this book. One other data set is part of the base Rdistribution (the USArrests data), and we show how to access it fromPythonin Section 12.5.1. Table1.1contains a summary of the data sets required to perform the labs and exercises. A couple of these data sets are also available as text files on the book website, for use in Chapter 2. 1. Introduction 13 Book Website The website for this book is located at www.statlearning.com It contains a number of resources, including the Pythonpackage associated with this book, and some additional data sets. Acknowledgements A few of the plots in this book were taken from ESL: Figures 6.7,8.3, and12.14. All other plots were produced for the Rversion of ISL, except for Figure 13.10which differs because of the Pythonsoftware supporting the plot. 2 Statistical Learning 2.1 What Is Statistical Learning? Inordertomotivateourstudyofstatisticallearning,webeginwithasimple example. Suppose that we are statistical consultants hired by a client to investigate the association between advertising and sales of a particular product. The Advertising data set consists of the salesof that product in200different markets, along with advertising budgets for the product in each of those markets for three different media: TV,radio, andnewspaper . The data are displayed in Figure 2.1. It is not possible for our client to directly increase sales of the product. On the other hand, they can control the advertising expenditure in each", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 32, "start_word": 10240, "end_word": 10640, "chunk_words": 400}}, "ISLP_website::c000033": {"text": "hired by a client to investigate the association between advertising and sales of a particular product. The Advertising data set consists of the salesof that product in200different markets, along with advertising budgets for the product in each of those markets for three different media: TV,radio, andnewspaper . The data are displayed in Figure 2.1. It is not possible for our client to directly increase sales of the product. On the other hand, they can control the advertising expenditure in each of the three media. Therefore, if we determine that there is an association between advertising and sales, then we can instruct our client to adjust advertising budgets, thereby indirectly increasing sales. In other words, our goal is to develop an accurate model that can be used to predict sales on the basis of the three media budgets. In this setting, the advertising budgets are input variables whilesalesinput variableis anoutput variable . The input variables are typically denoted using the output variablesymbolX, with a subscript to distinguish them. So X1might be the TV budget,X2theradiobudget, and X3thenewspaper budget. The inputs go by different names, such as predictors ,independent variables ,features,predictor independent variable featureor sometimes just variables . The output variable—in this case, sales—is variableoften called the response ordependent variable , and is typically denoted response dependent variableusing the symbol Y. Throughout this book, we will use all of these terms interchangeably. More generally, suppose that we observe a quantitative response Yandp different predictors, X1,X2,...,X p. We assume that there is some relationship between YandX=(X1,X2,...,X p), which can be written in the very general form Y=f(X)+/epsilon1. (2.1) © Springer Nature Switzerland AG 2023 G. James et al., An Introduction to Statistical Learning , Springer Texts in Statistics, https://doi.org/10.1007/978-3-031-38747-0_2 15 16 2. Statistical Learning 0 50 100 200 3005 10 15 20 25TVSales 0 10 20 30 40 505 10 15 20 25RadioSales 0 20 40 60 80 1005 10 15 20 25NewspaperSales FIGURE 2.1. TheAdvertising data set. The plot displays sales, in thousands of units, as a function of TV,radio, andnewspaper budgets, in thousands of dollars, for 200different markets. In each plot we show the simple least squares fit ofsalesto that variable, as described in Chapter 3. In other words, each blue line represents a simple model that can be used to predict salesusingTV,radio, andnewspaper , respectively. Herefissomefixedbutunknownfunctionof X1,...,X p,and/epsilon1isarandom error term , which is independent of Xand has mean zero. In this", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 33, "start_word": 10560, "end_word": 10960, "chunk_words": 400}}, "ISLP_website::c000034": {"text": "2.1. TheAdvertising data set. The plot displays sales, in thousands of units, as a function of TV,radio, andnewspaper budgets, in thousands of dollars, for 200different markets. In each plot we show the simple least squares fit ofsalesto that variable, as described in Chapter 3. In other words, each blue line represents a simple model that can be used to predict salesusingTV,radio, andnewspaper , respectively. Herefissomefixedbutunknownfunctionof X1,...,X p,and/epsilon1isarandom error term , which is independent of Xand has mean zero. In this formula-error termtion,frepresents the systematic information that Xprovides about Y.systematic 1012141618202220304050607080 Years of EducationIncome 1012141618202220304050607080 Years of EducationIncome FIGURE 2.2. TheIncomedata set. Left:The red dots are the observed values ofincome(in thousands of dollars) and years of education for30individuals. Right:The blue curve represents the true underlying relationship between income andyears of education , which is generally unknown (but is known in this case because the data were simulated). The black lines represent the error associated with each observation. Note that some errors are positive (if an observation lies above the blue curve) and some are negative (if an observation lies below the curve). Overall, these errors have approximately mean zero. As another example, consider the left-hand panel of Figure 2.2, a plot of incomeversusyears of education for30individuals in the Incomedata set. The plot suggests that one might be able to predict incomeusingyears of education . However, the function fthat connects the input variable to the 2.1 What Is Statistical Learning? 17 output variable is in general unknown. In this situation one must estimate fbased on the observed points. Since Incomeis a simulated data set, fis known and is shown by the blue curve in the right-hand panel of Figure 2.2. The vertical lines represent the error terms /epsilon1. We note that some of the 30 observations lie above the blue curve and some lie below it; overall, the errors have approximately mean zero. In general, the function fmay involve more than one input variable. In Figure 2.3we plot incomeas a function of years of education and seniority . Herefis a two-dimensional surface that must be estimated based on the observed data. In essence, statistical learning refers to a set of approaches for estimating f. In this chapter we outline some of the key theoretical concepts that arise in estimating f, as well as tools for evaluating the estimates obtained. 2.1.1 Why Estimate f? There are two main reasons that we may wish", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 34, "start_word": 10880, "end_word": 11280, "chunk_words": 400}}, "ISLP_website::c000035": {"text": "input variable. In Figure 2.3we plot incomeas a function of years of education and seniority . Herefis a two-dimensional surface that must be estimated based on the observed data. In essence, statistical learning refers to a set of approaches for estimating f. In this chapter we outline some of the key theoretical concepts that arise in estimating f, as well as tools for evaluating the estimates obtained. 2.1.1 Why Estimate f? There are two main reasons that we may wish to estimate f:prediction andinference . We discuss each in turn. Prediction In many situations, a set of inputs Xare readily available, but the output Ycannot be easily obtained. In this setting, since the error term averages to zero, we can predict Yusing ˆY=ˆf(X), (2.2) whereˆfrepresents our estimate for f, andˆYrepresents the resulting pre- diction for Y. In this setting, ˆfis often treated as a black box , in the sense that one is not typically concerned with the exact form of ˆf, provided that it yields accurate predictions for Y. As an example, suppose that X1,...,X pare characteristics of a patient’s blood sample that can be easily measured in a lab, and Yis a variable encoding the patient’s risk for a severe adverse reaction to a particular drug. It is natural to seek to predict YusingX, since we can then avoid giving the drug in question to patients who are at high risk of an adverse reaction—that is, patients for whom the estimate of Yis high. The accuracy of ˆYas a prediction for Ydepends on two quantities, which we will call the reducible error and theirreducible error . In general,reducible error irreducible errorˆfwill not be a perfect estimate for f, and this inaccuracy will introduce some error. This error is reducible because we can potentially improve the accuracyof ˆfbyusingthemostappropriatestatisticallearningtechniqueto estimate f. However, even if it were possible to form a perfect estimate for f, so that our estimated response took the form ˆY=f(X), our prediction would still have some error in it! This is because Yis also a function of /epsilon1, which, by definition, cannot be predicted using X. Therefore, variability associated with /epsilon1also affects the accuracy of our predictions. This is known as theirreducible error, because no matter how well we estimate f,w e cannot reduce the error introduced by /epsilon1. Why is the irreducible error larger than zero? The quantity /epsilon1may con- tain unmeasured variables that are useful", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 35, "start_word": 11200, "end_word": 11600, "chunk_words": 400}}, "ISLP_website::c000036": {"text": "the form ˆY=f(X), our prediction would still have some error in it! This is because Yis also a function of /epsilon1, which, by definition, cannot be predicted using X. Therefore, variability associated with /epsilon1also affects the accuracy of our predictions. This is known as theirreducible error, because no matter how well we estimate f,w e cannot reduce the error introduced by /epsilon1. Why is the irreducible error larger than zero? The quantity /epsilon1may con- tain unmeasured variables that are useful in predicting Y: since we don’t 18 2. Statistical Learning Years of EducationSeniorityIncome FIGURE 2.3.The plot displaysincomeas a function ofyears of educationandseniorityin theIncomedata set. The blue surface represents the trueunderlying relationship betweenincomeandyears of educationandseniority,which is known since the data are simulated. The red dots indicate the observedvalues of these quantities for30individuals.measure them,fcannot use them for its prediction. The quantity/epsilon1mayalso contain unmeasurable variation. For example, the risk of an adversereaction might vary for a given patient on a given day, depending onmanufacturing variation in the drug itself or the patient’s general feelingof well-being on that day.Consider a given estimateˆfand a set of predictorsX, which yields thepredictionˆY=ˆf(X). Assume for a moment that bothˆfandXare fixed,so that the only variability comes from/epsilon1. Then, it is easy to show thatE(Y−ˆY)2= E[f(X)+/epsilon1−ˆf(X)]2=[f(X)−ˆf(X)]2/bracehtipupleft/bracehtipdownright/bracehtipdownleft/bracehtipuprightReducible+ Var(/epsilon1)/bracehtipupleft/bracehtipdownright/bracehtipdownleft/bracehtipuprightIrreducible,(2.3)whereE(Y−ˆY)2represents the average, orexpected value, of the squaredexpectedvaluedifference between the predicted and actual value ofY, andVar(/epsilon1)repre-sents thevarianceassociated with the error term/epsilon1.varianceThe focus of this book is on techniques for estimatingfwith the aim ofminimizing the reducible error. It is important to keep in mind that theirreducible error will always provide an upper bound on the accuracy ofour prediction forY. This bound is almost always unknown in practice.InferenceWe are often interested in understanding the association betweenYandX1,...,Xp. In this situation we wish to estimatef, but our goal is notnecessarily to make predictions forY. Nowˆfcannot be treated as a blackbox, because we need to know its exact form. In this setting, one may beinterested in answering the following questions: 2.1 What Is Statistical Learning? 19 •Which predictors are associated with the response? It is often the case that only a small fraction of the available predictors are substantially associated with Y. Identifying the few important predictors among a large set of possible variables can be extremely useful, depending on the application. •What is the relationship between the response and each predictor? Some predictors may have a positive relationship with Y, in the sense that larger values of the", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 36, "start_word": 11520, "end_word": 11920, "chunk_words": 400}}, "ISLP_website::c000037": {"text": "questions: 2.1 What Is Statistical Learning? 19 •Which predictors are associated with the response? It is often the case that only a small fraction of the available predictors are substantially associated with Y. Identifying the few important predictors among a large set of possible variables can be extremely useful, depending on the application. •What is the relationship between the response and each predictor? Some predictors may have a positive relationship with Y, in the sense that larger values of the predictor are associated with larger values of Y. Other predictors may have the opposite relationship. Depending on the complexity of f, the relationship between the response and a given predictor may also depend on the values of the other predictors. •Can the relationship between Yand each predictor be adequately sum- marized using a linear equation, or is the relationship more compli- cated?Historically, most methods for estimating fhave taken a linear form.Insomesituations,suchanassumptionisreasonableorevende- sirable. But often the true relationship is more complicated, in which case a linear model may not provide an accurate representation of the relationship between the input and output variables. Inthisbook,wewillseeanumberofexamplesthatfallintotheprediction setting, the inference setting, or a combination of the two. For instance, consider a company that is interested in conducting a direct-marketing campaign. The goal is to identify individuals who are likely to respond positively to a mailing, based on observations of demo- graphic variables measured on each individual. In this case, the demo- graphic variables serve as predictors, and response to the marketing cam- paign (either positive or negative) serves as the outcome. The company is not interested in obtaining a deep understanding of the relationships be- tween each individual predictor and the response; instead, the company simply wants to accurately predict the response using the predictors. This is an example of modeling for prediction. In contrast, consider the Advertising data illustrated in Figure 2.1. One may be interested in answering questions such as: –Which media are associated with sales? –Which media generate the biggest boost in sales? or –How large of an increase in sales is associated with a given increase in TV advertising? This situation falls into the inference paradigm. Another example involves modeling the brand of a product that a customer might purchase based on variables such as price, store location, discount levels, competition price, and so forth. In this situation one might really be most interested in the association between each variable and", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 37, "start_word": 11840, "end_word": 12240, "chunk_words": 400}}, "ISLP_website::c000038": {"text": "associated with sales? –Which media generate the biggest boost in sales? or –How large of an increase in sales is associated with a given increase in TV advertising? This situation falls into the inference paradigm. Another example involves modeling the brand of a product that a customer might purchase based on variables such as price, store location, discount levels, competition price, and so forth. In this situation one might really be most interested in the association between each variable and the probability of purchase. For in- stance,to what extent is the product’s price associated with sales? This is an example of modeling for inference. Finally, some modeling could be conducted both for prediction and in- ference. For example, in a real estate setting, one may seek to relate values 20 2. Statistical Learning of homes to inputs such as crime rate, zoning, distance from a river, air quality, schools, income level of community, size of houses, and so forth. In this case one might be interested in the association between each individ- ual input variable and housing price—for instance, how much extra will a house be worth if it has a view of the river? This is an inference problem. Alternatively, one may simply be interested in predicting the value of a home given its characteristics: is this house under- or over-valued? This is a prediction problem. Depending on whether our ultimate goal is prediction, inference, or a combination of the two, different methods for estimating fmay be ap- propriate. For example, linear models allow for relatively simple and in-linear modelterpretable inference, but may not yield as accurate predictions as some other approaches. In contrast, some of the highly non-linear approaches that we discuss in the later chapters of this book can potentially provide quite accurate predictions for Y, but this comes at the expense of a less interpretable model for which inference is more challenging. 2.1.2 How Do We Estimate f? Throughout this book, we explore many linear and non-linear approaches for estimating f. However, these methods generally share certain charac- teristics. We provide an overview of these shared characteristics in this section. We will always assume that we have observed a set of ndifferent data points. For example in Figure 2.2we observed n= 30 data points. These observations are called the training data because we will use thesetraining dataobservations to train, or teach, our method how to estimate", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 38, "start_word": 12160, "end_word": 12560, "chunk_words": 400}}, "ISLP_website::c000039": {"text": "Estimate f? Throughout this book, we explore many linear and non-linear approaches for estimating f. However, these methods generally share certain charac- teristics. We provide an overview of these shared characteristics in this section. We will always assume that we have observed a set of ndifferent data points. For example in Figure 2.2we observed n= 30 data points. These observations are called the training data because we will use thesetraining dataobservations to train, or teach, our method how to estimate f. Letxij represent the value of the jth predictor, or input, for observation i, where i=1,2,...,n andj=1,2,...,p . Correspondingly, let yirepresent the response variable for the ith observation. Then our training data consist of {(x1,y1),(x2,y2),...,(xn,yn)}wherexi=(xi1,xi2,...,x ip)T. Our goal is to apply a statistical learning method to the training data in order to estimate the unknown function f. In other words, we want to find a function ˆfsuch that Y≈ˆf(X)for any observation (X,Y). Broadly speaking, most statistical learning methods for this task can be character- ized as either parametric ornon-parametric . We now briefly discuss theseparametric non- parametrictwo types of approaches. Parametric Methods Parametric methods involve a two-step model-based approach. 1. First, we make an assumption about the functional form, or shape, off. For example, one very simple assumption is that fis linear in X: f(X)=β0+β1X1+β2X2+···+βpXp. (2.4) This is a linear model , which will be discussed extensively in Chap- ter3. Once we have assumed that fis linear, the problem of estimat- ingfis greatly simplified. Instead of having to estimate an entirely arbitrary p-dimensional function f(X), one only needs to estimate thep+1coefficients β0,β1,...,βp. 2.1 What Is Statistical Learning? 21 Years of EducationSeniorityIncome FIGURE 2.4. A linear model fit by least squares to the Incomedata from Figure2.3. The observations are shown in red, and the yellow plane indicates the least squares fit to the data. 2. After a model has been selected, we need a procedure that uses the training data to fitortrainthe model. In the case of the linear modelfit train(2.4), we need to estimate the parameters β0,β1,...,βp. That is, we want to find values of these parameters such that Y≈β0+β1X1+β2X2+···+βpXp. The most common approach to fitting the model ( 2.4) is referred to as(ordinary) least squares , which we discuss in Chapter 3. However,least squaresleast squares is one of many possible ways to fit the linear model. In Chapter 6, we discuss other approaches for estimating the parameters in (2.4).", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 39, "start_word": 12480, "end_word": 12880, "chunk_words": 400}}, "ISLP_website::c000040": {"text": "fitortrainthe model. In the case of the linear modelfit train(2.4), we need to estimate the parameters β0,β1,...,βp. That is, we want to find values of these parameters such that Y≈β0+β1X1+β2X2+···+βpXp. The most common approach to fitting the model ( 2.4) is referred to as(ordinary) least squares , which we discuss in Chapter 3. However,least squaresleast squares is one of many possible ways to fit the linear model. In Chapter 6, we discuss other approaches for estimating the parameters in (2.4). The model-based approach just described is referred to as parametric ; it reduces the problem of estimating fdown to one of estimating a set of parameters. Assuming a parametric form for fsimplifies the problem of estimating fbecause it is generally much easier to estimate a set of pa- rameters, such as β0,β1,...,βpin the linear model ( 2.4), than it is to fit an entirely arbitrary function f. The potential disadvantage of a paramet- ric approach is that the model we choose will usually not match the true unknown form of f. If the chosen model is too far from the true f, then our estimate will be poor. We can try to address this problem by choos- ingflexiblemodels that can fit many different possible functional formsflexibleforf. But in general, fitting a more flexible model requires estimating a greater number of parameters. These more complex models can lead to a phenomenon known as overfitting the data, which essentially means theyoverfittingfollow the errors, or noise, too closely. These issues are discussed through-noiseout this book. Figure2.4shows an example of the parametric approach applied to the Incomedata from Figure 2.3. We have fit a linear model of the form income ≈β0+β1×education +β2×seniority . 22 2. Statistical Learning Years of EducationSeniorityIncome FIGURE 2.5. A smooth thin-plate spline fit to the Incomedata from Figure 2.3 is shown in yellow; the observations are displayed in red. Splines are discussed in Chapter 7. Since we have assumed a linear relationship between the response and the two predictors, the entire fitting problem reduces to estimating β0,β1, and β2, which we do using least squares linear regression. Comparing Figure 2.3 to Figure 2.4, we can see that the linear fit given in Figure 2.4is not quite right: the true fhas some curvature that is not captured in the linear fit. However, the linear fit still appears to do a reasonable job of capturing the positive relationship between years of education", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 40, "start_word": 12800, "end_word": 13200, "chunk_words": 400}}, "ISLP_website::c000041": {"text": "linear relationship between the response and the two predictors, the entire fitting problem reduces to estimating β0,β1, and β2, which we do using least squares linear regression. Comparing Figure 2.3 to Figure 2.4, we can see that the linear fit given in Figure 2.4is not quite right: the true fhas some curvature that is not captured in the linear fit. However, the linear fit still appears to do a reasonable job of capturing the positive relationship between years of education andincome, as well as the slightly less positive relationship between seniority andincome. It may be that with such a small number of observations, this is the best we can do. Non-Parametric Methods Non-parametric methods do not make explicit assumptions about the func- tional form of f. Instead they seek an estimate of fthat gets as close to the data points as possible without being too rough or wiggly. Such approaches can have a major advantage over parametric approaches: by avoiding the assumption of a particular functional form for f, they have the potential to accurately fit a wider range of possible shapes for f. Any parametric approach brings with it the possibility that the functional form used to estimate fis very different from the true f, in which case the resulting model will not fit the data well. In contrast, non-parametric approaches completely avoid this danger, since essentially no assumption about the form offis made. But non-parametric approaches do suffer from a major disadvantage: since they do not reduce the problem of estimating fto a small number of parameters, a very large number of observations (far more than is typically needed for a parametric approach) is required in order to obtain an accurate estimate for f. An example of a non-parametric approach to fitting the Incomedata is shown in Figure 2.5.Athin-plate spline is used to estimate f. This ap-thin-plate splineproach does not impose any pre-specified model on f. It instead attempts 2.1 What Is Statistical Learning? 23 Years of EducationSeniorityIncome FIGURE 2.6. A rough thin-plate spline fit to the Incomedata from Figure 2.3. This fit makes zero errors on the training data. to produce an estimate for fthat is as close as possible to the observed data, subject to the fit—that is, the yellow surface in Figure 2.5—being smooth. In this case, the non-parametric fit has produced a remarkably ac- curateestimateofthetrue fshowninFigure 2.3.Inordertofitathin-plate spline, the data analyst must select a", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 41, "start_word": 13120, "end_word": 13520, "chunk_words": 400}}, "ISLP_website::c000042": {"text": "attempts 2.1 What Is Statistical Learning? 23 Years of EducationSeniorityIncome FIGURE 2.6. A rough thin-plate spline fit to the Incomedata from Figure 2.3. This fit makes zero errors on the training data. to produce an estimate for fthat is as close as possible to the observed data, subject to the fit—that is, the yellow surface in Figure 2.5—being smooth. In this case, the non-parametric fit has produced a remarkably ac- curateestimateofthetrue fshowninFigure 2.3.Inordertofitathin-plate spline, the data analyst must select a level of smoothness. Figure 2.6shows the same thin-plate spline fit using a lower level of smoothness, allowing for a rougher fit. The resulting estimate fits the observed data perfectly! However, the spline fit shown in Figure 2.6is far more variable than the true function f, from Figure 2.3. This is an example of overfitting the data, which we discussed previously. It is an undesirable situation because the fit obtained will not yield accurate estimates of the response on new observations that were not part of the original training data set. We dis- cuss methods for choosing the correctamount of smoothness in Chapter 5. Splines are discussed in Chapter 7. As we have seen, there are advantages and disadvantages to parametric and non-parametric methods for statistical learning. We explore both types of methods throughout this book. 2.1.3 The Trade-Off Between Prediction Accuracy and Model Interpretability Of the many methods that we examine in this book, some are less flexible, or more restrictive, in the sense that they can produce just a relatively small range of shapes to estimate f. For example, linear regression is a relatively inflexible approach, because it can only generate linear functions such as the lines shown in Figure 2.1or the plane shown in Figure 2.4. Other methods, such as the thin plate splines shown in Figures 2.5and2.6, are considerably more flexible because they can generate a much wider range of possible shapes to estimate f. 24 2. Statistical Learning FlexibilityInterpretability LowHighLowHighSubset SelectionLassoLeast SquaresGeneralized Additive ModelsTreesBagging, BoostingSupport Vector MachinesDeep LearningFIGURE 2.7. A representation of the tradeoff between flexibility and inter- pretability, using different statistical learning methods. In general, as the flexibility of a method increases, its interpretability decreases. One might reasonably ask the following question: why would we ever choose to use a more restrictive method instead of a very flexible approach? There are several reasons that we might prefer a more restrictive model. If we are mainly", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 42, "start_word": 13440, "end_word": 13840, "chunk_words": 400}}, "ISLP_website::c000043": {"text": "Statistical Learning FlexibilityInterpretability LowHighLowHighSubset SelectionLassoLeast SquaresGeneralized Additive ModelsTreesBagging, BoostingSupport Vector MachinesDeep LearningFIGURE 2.7. A representation of the tradeoff between flexibility and inter- pretability, using different statistical learning methods. In general, as the flexibility of a method increases, its interpretability decreases. One might reasonably ask the following question: why would we ever choose to use a more restrictive method instead of a very flexible approach? There are several reasons that we might prefer a more restrictive model. If we are mainly interested in inference, then restrictive models are much more interpretable. For instance, when inference is the goal, the linear model may be a good choice since it will be quite easy to understand the relationship between YandX1,X2,...,X p. In contrast, very flexible approaches, such as the splines discussed in Chapter 7and displayed in Figures2.5and2.6, and the boosting methods discussed in Chapter 8, can lead to such complicated estimates of fthat it is difficult to understand how any individual predictor is associated with the response. Figure2.7provides an illustration of the trade-off between flexibility and interpretability for some of the methods that we cover in this book. Least squares linear regression, discussed in Chapter 3, is relatively inflexible but is quite interpretable. The lasso, discussed in Chapter 6, relies upon thelassolinear model ( 2.4) but uses an alternative fitting procedure for estimating the coefficients β0,β1,...,βp. The new procedure is more restrictive in es- timating the coefficients, and sets a number of them to exactly zero. Hence in this sense the lasso is a less flexible approach than linear regression. It is also more interpretable than linear regression, because in the final model the response variable will only be related to a small subset of the predictors—namely, those with nonzero coefficient estimates. Generalized additive models (GAMs), discussed in Chapter 7, instead extend the lin-generalized additive modelear model ( 2.4) to allow for certain non-linear relationships. Consequently, GAMs are more flexible than linear regression. They are also somewhat less interpretable than linear regression, because the relationship between each predictor and the response is now modeled using a curve. Finally, fully non-linear methods such as bagging,boosting,support vector machinesbagging boostingwith non-linear kernels, and neural networks (deep learning), discussed in support vector machineChapters 8,9, and10, are highly flexible approaches that are harder to interpret. 2.1 What Is Statistical Learning? 25 We have established that when inference is the goal, there are clear ad- vantages to using simple", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 43, "start_word": 13760, "end_word": 14160, "chunk_words": 400}}, "ISLP_website::c000044": {"text": "They are also somewhat less interpretable than linear regression, because the relationship between each predictor and the response is now modeled using a curve. Finally, fully non-linear methods such as bagging,boosting,support vector machinesbagging boostingwith non-linear kernels, and neural networks (deep learning), discussed in support vector machineChapters 8,9, and10, are highly flexible approaches that are harder to interpret. 2.1 What Is Statistical Learning? 25 We have established that when inference is the goal, there are clear ad- vantages to using simple and relatively inflexible statistical learning meth- ods. In some settings, however, we are only interested in prediction, and the interpretability of the predictive model is simply not of interest. For instance, if we seek to develop an algorithm to predict the price of a stock, our sole requirement for the algorithm is that it predict accurately— interpretability is not a concern. In this setting, we might expect that it will be best to use the most flexible model available. Surprisingly, this is not always the case! We will often obtain more accurate predictions using a less flexible method. This phenomenon, which may seem counterintu- itive at first glance, has to do with the potential for overfitting in highly flexible methods. We saw an example of overfitting in Figure 2.6. We will discuss this very important concept further in Section 2.2and throughout this book. 2.1.4 Supervised Versus Unsupervised Learning Most statistical learning problems fall into one of two categories: supervisedsupervisedorunsupervised . The examples that we have discussed so far in this chap-unsupervisedter all fall into the supervised learning domain. For each observation of the predictor measurement(s) xi,i=1,...,n there is an associated response measurement yi. We wish to fit a model that relates the response to the predictors, with the aim of accurately predicting the response for future observations (prediction) or better understanding the relationship between the response and the predictors (inference). Many classical statistical learn- ing methods such as linear regression and logistic regression (Chapter 4), aslogistic regressionwell as more modern approaches such as GAM, boosting, and support vec- tor machines, operate in the supervised learning domain. The vast majority of this book is devoted to this setting. By contrast, unsupervised learning describes the somewhat more chal- lenging situation in which for every observation i=1,...,n , we observe a vector of measurements xibut no associated response yi. It is not pos- sible to fit a linear regression model, since there is", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 44, "start_word": 14080, "end_word": 14480, "chunk_words": 400}}, "ISLP_website::c000045": {"text": "and logistic regression (Chapter 4), aslogistic regressionwell as more modern approaches such as GAM, boosting, and support vec- tor machines, operate in the supervised learning domain. The vast majority of this book is devoted to this setting. By contrast, unsupervised learning describes the somewhat more chal- lenging situation in which for every observation i=1,...,n , we observe a vector of measurements xibut no associated response yi. It is not pos- sible to fit a linear regression model, since there is no response variable to predict. In this setting, we are in some sense working blind; the sit- uation is referred to as unsupervised because we lack a response vari- able that can supervise our analysis. What sort of statistical analysis is possible?Wecanseektounderstandtherelationshipsbetweenthevariables or between the observations. One statistical learning tool that we may use in this setting is cluster analysis , or clustering. The goal of cluster analysiscluster analysisis to ascertain, on the basis of x1,...,x n, whether the observations fall into relatively distinct groups. For example, in a market segmentation study we might observe multiple characteristics (variables) for potential customers, such as zip code, family income, and shopping habits. We might believe that the customers fall into different groups, such as big spenders versus low spenders. If the information about each customer’s spending patterns were available, then a supervised analysis would be possible. However, this information is not available—that is, we do not know whether each poten- tial customer is a big spender or not. In this setting, we can try to cluster the customers on the basis of the variables measured, in order to identify 26 2. Statistical Learning 0 2 4 6 8 10 122 4 6 8 10 1202462468X1X1 X2X2 FIGURE 2.8. A clustering data set involving three groups. Each group is shown using a different colored symbol. Left:The three groups are well-separated. In this setting, a clustering approach should successfully identify the three groups. Right:There is some overlap among the groups. Now the clustering task is more challenging. distinct groups of potential customers. Identifying such groups can be of interest because it might be that the groups differ with respect to some property of interest, such as spending habits. Figure2.8provides a simple illustration of the clustering problem. We have plotted 150 observations with measurements on two variables, X1 andX2. Each observation corresponds to one of three distinct groups. For illustrative purposes, we have plotted the", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 45, "start_word": 14400, "end_word": 14800, "chunk_words": 400}}, "ISLP_website::c000046": {"text": "is some overlap among the groups. Now the clustering task is more challenging. distinct groups of potential customers. Identifying such groups can be of interest because it might be that the groups differ with respect to some property of interest, such as spending habits. Figure2.8provides a simple illustration of the clustering problem. We have plotted 150 observations with measurements on two variables, X1 andX2. Each observation corresponds to one of three distinct groups. For illustrative purposes, we have plotted the members of each group using different colors and symbols. However, in practice the group memberships are unknown, and the goal is to determine the group to which each obser- vation belongs. In the left-hand panel of Figure 2.8, this is a relatively easy task because the groups are well-separated. By contrast, the right-hand panel illustrates a more challenging setting in which there is some overlap between the groups. A clustering method could not be expected to assign all of the overlapping points to their correct group (blue, green, or orange). In the examples shown in Figure 2.8, there are only two variables, and so one can simply visually inspect the scatterplots of the observations in order to identify clusters. However, in practice, we often encounter data sets that contain many more than two variables. In this case, we cannot easily plot the observations. For instance, if there are pvariables in our data set, then p(p−1)/2distinct scatterplots can be made, and visual inspection is simply not a viable way to identify clusters. For this reason, automated clustering methods are important. We discuss clustering and other unsupervised learning approaches in Chapter 12. Many problems fall naturally into the supervised or unsupervised learn- ing paradigms. However, sometimes the question of whether an analysis should be considered supervised or unsupervised is less clear-cut. For in- stance, suppose that we have a set of nobservations. For mof the observa- tions, where m<n , we have both predictor measurements and a response 2.2 Assessing Model Accuracy 27 measurement. For the remaining n−mobservations, we have predictor measurements but no response measurement. Such a scenario can arise if the predictors can be measured relatively cheaply but the corresponding responses are much more expensive to collect. We refer to this setting as asemi-supervised learning problem. In this setting, we wish to use a sta-semi- supervised learningtistical learning method that can incorporate the mobservations for which response measurements are available", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 46, "start_word": 14720, "end_word": 15120, "chunk_words": 400}}, "ISLP_website::c000047": {"text": "both predictor measurements and a response 2.2 Assessing Model Accuracy 27 measurement. For the remaining n−mobservations, we have predictor measurements but no response measurement. Such a scenario can arise if the predictors can be measured relatively cheaply but the corresponding responses are much more expensive to collect. We refer to this setting as asemi-supervised learning problem. In this setting, we wish to use a sta-semi- supervised learningtistical learning method that can incorporate the mobservations for which response measurements are available as well as the n−mobservations for which they are not. Although this is an interesting topic, it is beyond the scope of this book. 2.1.5 Regression Versus Classification Problems Variables can be characterized as either quantitative orqualitative (alsoquantitative qualitativeknown as categorical ). Quantitative variables take on numerical values. Ex- categoricalamples include a person’s age, height, or income, the value of a house, and the price of a stock. In contrast, qualitative variables take on values in one ofKdifferent classes, or categories. Examples of qualitative variablesclassinclude a person’s marital status (married or not), the brand of product purchased (brand A, B, or C), whether a person defaults on a debt (yes or no), or a cancer diagnosis (Acute Myelogenous Leukemia, Acute Lym- phoblastic Leukemia, or No Leukemia). We tend to refer to problems with a quantitative response as regression problems, while those involving aregressionqualitative response are often referred to as classification problems. How-classificationever, the distinction is not always that crisp. Least squares linear regression (Chapter 3)isusedwithaquantitativeresponse,whereaslogisticregression (Chapter 4) is typically used with a qualitative (two-class, or binary) re-binarysponse.Thus,despiteitsname,logisticregressionisaclassificationmethod. But since it estimates class probabilities, it can be thought of as a regres- sion method as well. Some statistical methods, such as K-nearest neighbors (Chapters 2and4) and boosting (Chapter 8), can be used in the case of either quantitative or qualitative responses. We tend to select statistical learning methods on the basis of whether the response is quantitative or qualitative; i.e. we might use linear regres- sion when quantitative and logistic regression when qualitative. However, whether the predictors are qualitative or quantitative is generally consid- ered less important. Most of the statistical learning methods discussed in this book can be applied regardless of the predictor variable type, provided that any qualitative predictors are properly codedbefore the analysis is performed. This is discussed in Chapter 3. 2.2 Assessing Model Accuracy One of the key aims of this book is to introduce the reader", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 47, "start_word": 15040, "end_word": 15440, "chunk_words": 400}}, "ISLP_website::c000048": {"text": "might use linear regres- sion when quantitative and logistic regression when qualitative. However, whether the predictors are qualitative or quantitative is generally consid- ered less important. Most of the statistical learning methods discussed in this book can be applied regardless of the predictor variable type, provided that any qualitative predictors are properly codedbefore the analysis is performed. This is discussed in Chapter 3. 2.2 Assessing Model Accuracy One of the key aims of this book is to introduce the reader to a wide range of statistical learning methods that extend far beyond the standard linear regression approach. Why is it necessary to introduce so many different statisticallearningapproaches,ratherthanjustasingle bestmethod? There is no free lunch in statistics: no one method dominates all others over all possible data sets. On a particular data set, one specific method may work 28 2. Statistical Learning best, but some other method may work better on a similar but different data set. Hence it is an important task to decide for any given set of data which method produces the best results. Selecting the best approach can be one of the most challenging parts of performing statistical learning in practice. In this section, we discuss some of the most important concepts that arise in selecting a statistical learning procedure for a specific data set. As the book progresses, we will explain how the concepts presented here can be applied in practice. 2.2.1 Measuring the Quality of Fit In order to evaluate the performance of a statistical learning method on a given data set, we need some way to measure how well its predictions actually match the observed data. That is, we need to quantify the extent to which the predicted response value for a given observation is close to the true response value for that observation. In the regression setting, the most commonly-used measure is the mean squared error (MSE), given bymean squared errorMSE =1 nn/summationdisplay i=1(yi−ˆf(xi))2, (2.5) whereˆf(xi)is the prediction that ˆfgives for the ith observation. The MSE will be small if the predicted responses are very close to the true responses, and will be large if for some of the observations, the predicted and true responses differ substantially. The MSE in ( 2.5) is computed using the training data that was used to fit the model, and so should more accurately be referred to as the training MSE. But in general, we do not really", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 48, "start_word": 15360, "end_word": 15760, "chunk_words": 400}}, "ISLP_website::c000049": {"text": "(2.5) whereˆf(xi)is the prediction that ˆfgives for the ith observation. The MSE will be small if the predicted responses are very close to the true responses, and will be large if for some of the observations, the predicted and true responses differ substantially. The MSE in ( 2.5) is computed using the training data that was used to fit the model, and so should more accurately be referred to as the training MSE. But in general, we do not really care how well the method workstraining MSEon the training data. Rather, we are interested in the accuracy of the pre- dictions that we obtain when we apply our method to previously unseen test data. Why is this what we care about? Suppose that we are interestedtest datain developing an algorithm to predict a stock’s price based on previous stock returns. We can train the method using stock returns from the past 6months.Butwedon’treallycarehowwellourmethodpredictslastweek’s stock price. We instead care about how well it will predict tomorrow’s price or next month’s price. On a similar note, suppose that we have clinical measurements (e.g. weight, blood pressure, height, age, family history of disease)foranumberofpatients,aswellasinformationaboutwhethereach patient has diabetes. We can use these patients to train a statistical learn- ing method to predict risk of diabetes based on clinical measurements. In practice, we want this method to accurately predict diabetes risk for future patients based on their clinical measurements. We are not very interested in whether or not the method accurately predicts diabetes risk for patients used to train the model, since we already know which of those patients have diabetes. To state it more mathematically, suppose that we fit our statistical learn- ing method on our training observations {(x1,y1),(x2,y2),...,(xn,yn)}, andweobtaintheestimate ˆf.Wecanthencompute ˆf(x1),ˆf(x2),..., ˆf(xn). 2.2 Assessing Model Accuracy 29 0 20 40 60 80 1002 4 6 8 10 12XY 2 5 10 200.0 0.5 1.0 1.5 2.0 2.5FlexibilityMean Squared Error FIGURE 2.9. Left:Data simulated from f, shown in black. Three estimates of fare shown: the linear regression line (orange curve), and two smoothing spline fits (blue and green curves). Right:Training MSE (grey curve), test MSE (red curve), and minimum possible test MSE over all methods (dashed line). Squares represent the training and test MSEs for the three fits shown in the left-hand panel. If these are approximately equal to y1,y2,...,y n, then the training MSE given by ( 2.5) is small. However, we are really not", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 49, "start_word": 15680, "end_word": 16080, "chunk_words": 400}}, "ISLP_website::c000050": {"text": "shown in black. Three estimates of fare shown: the linear regression line (orange curve), and two smoothing spline fits (blue and green curves). Right:Training MSE (grey curve), test MSE (red curve), and minimum possible test MSE over all methods (dashed line). Squares represent the training and test MSEs for the three fits shown in the left-hand panel. If these are approximately equal to y1,y2,...,y n, then the training MSE given by ( 2.5) is small. However, we are really not interested in whether ˆf(xi)≈yi; instead, we want to know whether ˆf(x0)is approximately equal toy0, where(x0,y0)is apreviously unseen test observation not used to train the statistical learning method . We want to choose the method that gives thelowest test MSE ,asopposedtothelowesttrainingMSE.Inotherwords,test MSEif we had a large number of test observations, we could compute Ave(y0−ˆf(x0))2, (2.6) the average squared prediction error for these test observations (x0,y0). We’d like to select the model for which this quantity is as small as possible. How can we go about trying to select a method that minimizes the test MSE? In some settings, we may have a test data set available—that is, we may have access to a set of observations that were not used to train the statistical learning method. We can then simply evaluate ( 2.6) on the test observations, and select the learning method for which the test MSE is smallest. But what if no test observations are available? In that case, one mightimaginesimplyselectingastatisticallearningmethodthatminimizes the training MSE ( 2.5). This seems like it might be a sensible approach, since the training MSE and the test MSE appear to be closely related. Unfortunately, there is a fundamental problem with this strategy: there is no guarantee that the method with the lowest training MSE will also have the lowest test MSE. Roughly speaking, the problem is that many statistical methods specifically estimate coefficients so as to minimize the training set MSE. For these methods, the training set MSE can be quite small, but the test MSE is often much larger. Figure2.9illustrates this phenomenon on a simple example. In the left- hand panel of Figure 2.9, we have generated observations from ( 2.1) with 30 2. Statistical Learning thetruefgivenbythe blackcurve.The orange, blue andgreen curvesillus- trate three possible estimates for fobtained using methods with increasing levels of flexibility. The orange line is the linear regression fit, which is rela- tively inflexible. The blue and green curves were", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 50, "start_word": 16000, "end_word": 16400, "chunk_words": 400}}, "ISLP_website::c000051": {"text": "training set MSE can be quite small, but the test MSE is often much larger. Figure2.9illustrates this phenomenon on a simple example. In the left- hand panel of Figure 2.9, we have generated observations from ( 2.1) with 30 2. Statistical Learning thetruefgivenbythe blackcurve.The orange, blue andgreen curvesillus- trate three possible estimates for fobtained using methods with increasing levels of flexibility. The orange line is the linear regression fit, which is rela- tively inflexible. The blue and green curves were produced using smoothing splines, discussed in Chapter 7, with different levels of smoothness. It issmoothing splineclear that as the level of flexibility increases, the curves fit the observed data more closely. The green curve is the most flexible and matches the data very well; however, we observe that it fits the true f(shown in black) poorly because it is too wiggly. By adjusting the level of flexibility of the smoothing spline fit, we can produce many different fits to this data. We now move on to the right-hand panel of Figure 2.9. The grey curve displays the average training MSE as a function of flexibility, or more formally the degrees of freedom , for a number of smoothing splines. Thedegrees of freedomdegrees of freedom is a quantity that summarizes the flexibility of a curve; it is discussed more fully in Chapter 7. The orange, blue and green squares indicate the MSEs associated with the corresponding curves in the left- hand panel. A more restricted and hence smoother curve has fewer degrees of freedom than a wiggly curve—note that in Figure 2.9, linear regression is at the most restrictive end, with two degrees of freedom. The training MSE declines monotonically as flexibility increases. In this example the truefis non-linear, and so the orange linear fit is not flexible enough to estimate fwell. The green curve has the lowest training MSE of all three methods, since it corresponds to the most flexible of the three curves fit in the left-hand panel. In this example, we know the true function f, and so we can also com- pute the test MSE over a very large test set, as a function of flexibility. (Of course, in general fis unknown, so this will not be possible.) The test MSE is displayed using the red curve in the right-hand panel of Figure 2.9. As with the training MSE, the test MSE initially declines as the level", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 51, "start_word": 16320, "end_word": 16720, "chunk_words": 400}}, "ISLP_website::c000052": {"text": "of the three curves fit in the left-hand panel. In this example, we know the true function f, and so we can also com- pute the test MSE over a very large test set, as a function of flexibility. (Of course, in general fis unknown, so this will not be possible.) The test MSE is displayed using the red curve in the right-hand panel of Figure 2.9. As with the training MSE, the test MSE initially declines as the level of flex- ibility increases. However, at some point the test MSE levels off and then starts to increase again. Consequently, the orange and green curves both have high test MSE. The blue curve minimizes the test MSE, which should not be surprising given that visually it appears to estimate fthe best in the left-hand panel of Figure 2.9. The horizontal dashed line indicates Var (/epsilon1), the irreducible error in ( 2.3), which corresponds to the lowest achievable test MSE among all possible methods. Hence, the smoothing spline repre- sented by the blue curve is close to optimal. In the right-hand panel of Figure 2.9, as the flexibility of the statistical learning method increases, we observe a monotone decrease in the training MSE and a U-shape in the test MSE. This is a fundamental property of statistical learning that holds regardless of the particular data set at hand and regardless of the statistical method being used. As model flexibility increases, the training MSE will decrease, but the test MSE may not. When a given method yields a small training MSE but a large test MSE, we are saidtobe overfitting thedata.Thishappensbecauseourstatisticallearning procedure is working too hard to find patterns in the training data, and may be picking up some patterns that are just caused by random chance rather than by true properties of the unknown function f. When we overfit the training data, the test MSE will be very large because the supposed 2.2 Assessing Model Accuracy 31 0 20 40 60 80 1002 4 6 8 10 12XY 2 5 10 200.0 0.5 1.0 1.5 2.0 2.5FlexibilityMean Squared Error FIGURE 2.10. Details are as in Figure 2.9, using a different true fthat is much closer to linear. In this setting, linear regression provides a very good fit to the data. patterns that the method found in the training data simply don’t exist in the test data. Note that regardless of whether", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 52, "start_word": 16640, "end_word": 17040, "chunk_words": 400}}, "ISLP_website::c000053": {"text": "supposed 2.2 Assessing Model Accuracy 31 0 20 40 60 80 1002 4 6 8 10 12XY 2 5 10 200.0 0.5 1.0 1.5 2.0 2.5FlexibilityMean Squared Error FIGURE 2.10. Details are as in Figure 2.9, using a different true fthat is much closer to linear. In this setting, linear regression provides a very good fit to the data. patterns that the method found in the training data simply don’t exist in the test data. Note that regardless of whether or not overfitting has occurred, we almost always expect the training MSE to be smaller than the test MSE because most statistical learning methods either directly or indirectly seek to minimize the training MSE. Overfitting refers specifically to the case in which a less flexible model would have yielded a smaller test MSE. Figure2.10provides another example in which the true fis approxi- mately linear. Again we observe that the training MSE decreases mono- tonically as the model flexibility increases, and that there is a U-shape in the test MSE. However, because the truth is close to linear, the test MSE only decreases slightly before increasing again, so that the orange least squares fit is substantially better than the highly flexible green curve. Fi- nally, Figure 2.11displays an example in which fis highly non-linear. The training and test MSE curves still exhibit the same general patterns, but now there is a rapid decrease in both curves before the test MSE starts to increase slowly. In practice, one can usually compute the training MSE with relative ease, but estimating the test MSE is considerably more difficult because usuallynotestdata areavailable.Asthe previousthreeexamples illustrate, the flexibility level corresponding to the model with the minimal test MSE can vary considerably among data sets. Throughout this book, we discuss a varietyofapproachesthatcanbeusedinpracticetoestimatethisminimum point. One important method is cross-validation (Chapter 5), which is across- validation method for estimating the test MSE using the training data. 2.2.2 The Bias-Variance Trade-Off The U-shape observed in the test MSE curves (Figures 2.9–2.11) turns out to be the result of two competing properties of statistical learning methods. 32 2. Statistical Learning 0 20 40 60 80 100−10 0 10 20XY 2 5 10 200 5 10 15 20FlexibilityMean Squared Error FIGURE 2.11. Details are as in Figure 2.9, using a different fthat is far from linear. In this setting, linear regression provides a very poor fit to the data. Though the mathematical proof", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 53, "start_word": 16960, "end_word": 17360, "chunk_words": 400}}, "ISLP_website::c000054": {"text": "The U-shape observed in the test MSE curves (Figures 2.9–2.11) turns out to be the result of two competing properties of statistical learning methods. 32 2. Statistical Learning 0 20 40 60 80 100−10 0 10 20XY 2 5 10 200 5 10 15 20FlexibilityMean Squared Error FIGURE 2.11. Details are as in Figure 2.9, using a different fthat is far from linear. In this setting, linear regression provides a very poor fit to the data. Though the mathematical proof is beyond the scope of this book, it is possible to show that the expected test MSE, for a given value x0, can always be decomposed into the sum of three fundamental quantities: the variance ofˆf(x0), the squared biasofˆf(x0)and the variance of the errorvariance biasterms/epsilon1. That is, E/parenleftBig y0−ˆf(x0)/parenrightBig2 =Var(ˆf(x0)) + [ Bias(ˆf(x0))]2+Var(/epsilon1). (2.7) Here the notation E/parenleftBig y0−ˆf(x0)/parenrightBig2 defines the expected test MSE atx0,expected test MSE and refers to the average test MSE that we would obtain if we repeatedly estimated fusingalargenumberoftrainingsets,andtestedeachat x0.The overall expected test MSE can be computed by averaging E/parenleftBig y0−ˆf(x0)/parenrightBig2 over all possible values of x0in the test set. Equation 2.7tells us that in order to minimize the expected test error, we need to select a statistical learning method that simultaneously achieves low variance andlow bias. Note that variance is inherently a nonnegative quantity, and squared bias is also nonnegative. Hence, we see that the expected test MSE can never lie below Var (/epsilon1), the irreducible error from (2.3). What do we mean by the variance andbiasof a statistical learning method? Variance refers to the amount by which ˆfwould change if we estimated it using a different training data set. Since the training data are used to fit the statistical learning method, different training data sets will result in a different ˆf. But ideally the estimate for fshould not vary too much between training sets. However, if a method has high variance then small changes in the training data can result in large changes in ˆf. In general,moreflexiblestatisticalmethodshavehighervariance.Considerthe green and orange curves in Figure 2.9. The flexible green curve is following the observations very closely. It has high variance because changing any one of these data points may cause the estimate ˆfto change considerably. 2.2 Assessing Model Accuracy 33 2 5 10 200.0 0.5 1.0 1.5 2.0 2.5Flexibility2 5 10 200.0 0.5 1.0 1.5 2.0 2.5Flexibility2 5 10 2005 10 15 20 FlexibilityMSEBiasVar FIGURE 2.12.", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 54, "start_word": 17280, "end_word": 17680, "chunk_words": 400}}, "ISLP_website::c000055": {"text": "in the training data can result in large changes in ˆf. In general,moreflexiblestatisticalmethodshavehighervariance.Considerthe green and orange curves in Figure 2.9. The flexible green curve is following the observations very closely. It has high variance because changing any one of these data points may cause the estimate ˆfto change considerably. 2.2 Assessing Model Accuracy 33 2 5 10 200.0 0.5 1.0 1.5 2.0 2.5Flexibility2 5 10 200.0 0.5 1.0 1.5 2.0 2.5Flexibility2 5 10 2005 10 15 20 FlexibilityMSEBiasVar FIGURE 2.12. Squared bias (blue curve), variance (orange curve), Var (/epsilon1) (dashed line), and test MSE (red curve) for the three data sets in Figures 2.9–2.11. The vertical dotted line indicates the flexibility level corresponding to the smallest test MSE. In contrast, the orange least squares line is relatively inflexible and has low variance, because moving any single observation will likely cause only a small shift in the position of the line. On the other hand, biasrefers to the error that is introduced by approxi- matingareal-lifeproblem,whichmaybeextremelycomplicated,byamuch simpler model. For example, linear regression assumes that there is a linear relationship between YandX1,X2,...,X p. It is unlikely that any real-life problem truly has such a simple linear relationship, and so performing lin- ear regression will undoubtedly result in some bias in the estimate of f. In Figure2.11, the true fis substantially non-linear, so no matter how many training observations we are given, it will not be possible to produce an accurate estimate using linear regression. In other words, linear regression results in high bias in this example. However, in Figure 2.10the true f is very close to linear, and so given enough data, it should be possible for linear regression to produce an accurate estimate. Generally, more flexible methods result in less bias. As a general rule, as we use more flexible methods, the variance will increase and the bias will decrease. The relative rate of change of these two quantities determines whether the test MSE increases or decreases. As we increase the flexibility of a class of methods, the bias tends to initially decrease faster than the variance increases. Consequently, the expected test MSE declines. However, at some point increasing flexibility has little impact on the bias but starts to significantly increase the variance. When this happens the test MSE increases. Note that we observed this pattern of decreasing test MSE followed by increasing test MSE in the right-hand panels of Figures 2.9–2.11.", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 55, "start_word": 17600, "end_word": 18000, "chunk_words": 400}}, "ISLP_website::c000056": {"text": "test MSE increases or decreases. As we increase the flexibility of a class of methods, the bias tends to initially decrease faster than the variance increases. Consequently, the expected test MSE declines. However, at some point increasing flexibility has little impact on the bias but starts to significantly increase the variance. When this happens the test MSE increases. Note that we observed this pattern of decreasing test MSE followed by increasing test MSE in the right-hand panels of Figures 2.9–2.11. The three plots in Figure 2.12illustrate Equation 2.7for the examples in Figures2.9–2.11. In each case the blue solid curve represents the squared bias, for different levels of flexibility, while the orange curve corresponds to the variance. The horizontal dashed line represents Var (/epsilon1), the irreducible error. Finally, the red curve, corresponding to the test set MSE, is the sum 34 2. Statistical Learning of these three quantities. In all three cases, the variance increases and the bias decreases as the method’s flexibility increases. However, the flexibility level corresponding to the optimal test MSE differs considerably among the three data sets, because the squared bias and variance change at different rates in each of the data sets. In the left-hand panel of Figure 2.12, the bias initially decreases rapidly, resulting in an initial sharp decrease in the expected test MSE. On the other hand, in the center panel of Figure 2.12 the truefis close to linear, so there is only a small decrease in bias as flex- ibility increases, and the test MSE only declines slightly before increasing rapidly as the variance increases. Finally, in the right-hand panel of Fig- ure2.12, as flexibility increases, there is a dramatic decline in bias because the true fis very non-linear. There is also very little increase in variance as flexibility increases. Consequently, the test MSE declines substantially before experiencing a small increase as model flexibility increases. The relationship between bias, variance, and test set MSE given in Equa- tion2.7and displayed in Figure 2.12is referred to as the bias-variance trade-off. Good test set performance of a statistical learning method re-bias-variance trade-offquires low variance as well as low squared bias. This is referred to as a trade-off because it is easy to obtain a method with extremely low bias but high variance (for instance, by drawing a curve that passes through every single training observation) or a method with very low variance but high bias (by", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 56, "start_word": 17920, "end_word": 18320, "chunk_words": 400}}, "ISLP_website::c000057": {"text": "MSE given in Equa- tion2.7and displayed in Figure 2.12is referred to as the bias-variance trade-off. Good test set performance of a statistical learning method re-bias-variance trade-offquires low variance as well as low squared bias. This is referred to as a trade-off because it is easy to obtain a method with extremely low bias but high variance (for instance, by drawing a curve that passes through every single training observation) or a method with very low variance but high bias (by fitting a horizontal line to the data). The challenge lies in finding a method for which both the variance and the squared bias are low. This trade-off is one of the most important recurring themes in this book. In a real-life situation in which fis unobserved, it is generally not pos- sible to explicitly compute the test MSE, bias, or variance for a statistical learning method. Nevertheless, one should always keep the bias-variance trade-off in mind. In this book we explore methods that are extremely flexible and hence can essentially eliminate bias. However, this does not guarantee that they will outperform a much simpler method such as linear regression. To take an extreme example, suppose that the true fis linear. In this situation linear regression will have no bias, making it very hard for a more flexible method to compete. In contrast, if the true fis highly non-linear and we have an ample number of training observations, then we may do better using a highly flexible approach, as in Figure 2.11. In Chapter 5we discuss cross-validation, which is a way to estimate the test MSE using the training data. 2.2.3 The Classification Setting Thus far, our discussion of model accuracy has been focused on the regres- sion setting. But many of the concepts that we have encountered, such as the bias-variance trade-off, transfer over to the classification setting with only some modifications due to the fact that yiis no longer quan- titative. Suppose that we seek to estimate fon the basis of training obser- vations{(x1,y1),...,(xn,yn)}, where now y1,...,y nare qualitative. The most common approach for quantifying the accuracy of our estimate ˆfis thetraining error rate ,theproportionofmistakesthataremadeifweapplyerror rate 2.2 Assessing Model Accuracy 35 our estimate ˆfto the training observations: 1 nn/summationdisplay i=1I(yi/negationslash=ˆyi). (2.8) Hereˆyiis the predicted class label for the ith observation using ˆf. And I(yi/negationslash=ˆyi)is anindicator variable that equals 1ifyi/negationslash=ˆyiand zero if yi=ˆyi.indicator variableIfI(yi/negationslash=ˆyi)=0 then the ith observation was classified", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 57, "start_word": 18240, "end_word": 18640, "chunk_words": 400}}, "ISLP_website::c000058": {"text": "quan- titative. Suppose that we seek to estimate fon the basis of training obser- vations{(x1,y1),...,(xn,yn)}, where now y1,...,y nare qualitative. The most common approach for quantifying the accuracy of our estimate ˆfis thetraining error rate ,theproportionofmistakesthataremadeifweapplyerror rate 2.2 Assessing Model Accuracy 35 our estimate ˆfto the training observations: 1 nn/summationdisplay i=1I(yi/negationslash=ˆyi). (2.8) Hereˆyiis the predicted class label for the ith observation using ˆf. And I(yi/negationslash=ˆyi)is anindicator variable that equals 1ifyi/negationslash=ˆyiand zero if yi=ˆyi.indicator variableIfI(yi/negationslash=ˆyi)=0 then the ith observation was classified correctly by our classification method; otherwise it was misclassified. Hence Equation 2.8 computes the fraction of incorrect classifications. Equation 2.8is referred to as the training error rate because it is com-training errorputed based on the data that was used to train our classifier. As in the regression setting, we are most interested in the error rates that result from applying our classifier to test observations that were not used in training. Thetest error rate associated with a set of test observations of the formtest error(x0,y0)is given by Ave(I(y0/negationslash=ˆy0)), (2.9) whereˆy0is the predicted class label that results from applying the classifier to the test observation with predictor x0.Agoodclassifier is one for which the test error ( 2.9) is smallest. The Bayes Classifier It is possible to show (though the proof is outside of the scope of this book) that the test error rate given in ( 2.9) is minimized, on average, by a very simple classifier that assigns each observation to the most likely class, given its predictor values . In other words, we should simply assign a test observation with predictor vector x0to the class jfor which Pr(Y=j|X=x0) (2.10) is largest. Note that ( 2.10) is aconditional probability : it is the probabilityconditional probabilitythatY=j, given the observed predictor vector x0. This very simple clas- sifier is called the Bayes classifier . In a two-class problem where there areBayes classifieronly two possible response values, say class 1orclass 2, the Bayes classifier corresponds to predicting class one if Pr(Y=1|X=x0)>0.5, and class two otherwise. Figure2.13provides an example using a simulated data set in a two- dimensional space consisting of predictors X1andX2. The orange and blue circles correspond to training observations that belong to two different classes. For each value of X1andX2, there is a different probability of the response being orange or blue. Since this is simulated data, we know how the data were generated and we can calculate the conditional probabilities for", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 58, "start_word": 18560, "end_word": 18960, "chunk_words": 400}}, "ISLP_website::c000059": {"text": "corresponds to predicting class one if Pr(Y=1|X=x0)>0.5, and class two otherwise. Figure2.13provides an example using a simulated data set in a two- dimensional space consisting of predictors X1andX2. The orange and blue circles correspond to training observations that belong to two different classes. For each value of X1andX2, there is a different probability of the response being orange or blue. Since this is simulated data, we know how the data were generated and we can calculate the conditional probabilities for each value of X1andX2. The orange shaded region reflects the set of points for which Pr(Y=orange|X)is greater than 50 % , while the blue shaded region indicates the set of points for which the probability is below 50 % . The purple dashed line represents the points where the probability is exactly 50 % . This is called the Bayes decision boundary . The BayesBayes decision boundaryclassifier’s prediction is determined by the Bayes decision boundary; an observation that falls on the orange side of the boundary will be assigned 36 2. Statistical Learning ooooo oooooo oooo oo oooo ooooooooooooooooooo oooo oooooooooooooooooooooooooooooooooooooooooooooooo ooooooooo ooooooooooooooooooooooo oooooooooooo ooooooooooooooooooooooooooooooooooooooooooo ooooooooooooooo oooooo X1X2 FIGURE 2.13. A simulated data set consisting of 100observations in each of two groups, indicated in blue and in orange. The purple dashed line represents the Bayes decision boundary. The orange background grid indicates the region in which a test observation will be assigned to the orange class, and the blue background grid indicates the region in which a test observation will be assigned to the blue class. to the orange class, and similarly an observation on the blue side of the boundary will be assigned to the blue class. The Bayes classifier produces the lowest possible test error rate, called theBayes error rate . Since the Bayes classifier will always choose the classBayes error ratefor which ( 2.10) is largest, the error rate will be 1−max jPr(Y=j|X=x0) atX=x0. In general, the overall Bayes error rate is given by 1−E/parenleftbigg max jPr(Y=j|X)/parenrightbigg , (2.11) where the expectation averages the probability over all possible values of X. For our simulated data, the Bayes error rate is 0.133. It is greater than zero, because the classes overlap in the true population, which implies that max jPr(Y=j|X=x0)<1for some values of x0. The Bayes error rate is analogous to the irreducible error, discussed earlier. K-Nearest Neighbors In theory we would always like to predict qualitative responses", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 59, "start_word": 18880, "end_word": 19280, "chunk_words": 400}}, "ISLP_website::c000060": {"text": "overall Bayes error rate is given by 1−E/parenleftbigg max jPr(Y=j|X)/parenrightbigg , (2.11) where the expectation averages the probability over all possible values of X. For our simulated data, the Bayes error rate is 0.133. It is greater than zero, because the classes overlap in the true population, which implies that max jPr(Y=j|X=x0)<1for some values of x0. The Bayes error rate is analogous to the irreducible error, discussed earlier. K-Nearest Neighbors In theory we would always like to predict qualitative responses using the Bayes classifier. But for real data, we do not know the conditional distri- bution of YgivenX, and so computing the Bayes classifier is impossi- ble. Therefore, the Bayes classifier serves as an unattainable gold standard against which to compare other methods. Many approaches attempt to estimate the conditional distribution of YgivenX, and then classify a given observation to the class with highest estimated probability. One such method is the K-nearest neighbors (KNN) classifier. Given a positive in-K-nearest neighbors 2.2 Assessing Model Accuracy 37 tegerKand a test observation x0, the KNN classifier first identifies the Kpoints in the training data that are closest to x0, represented by N0. It then estimates the conditional probability for class jas the fraction of points in N0whose response values equal j: Pr(Y=j|X=x0)=1 K/summationdisplay i∈N0I(yi=j). (2.12) Finally, KNN classifies the test observation x0to the class with the largest probability from ( 2.12). Figure2.14provides an illustrative example of the KNN approach. In the left-hand panel, we have plotted a small training data set consisting of six blue and six orange observations. Our goal is to make a prediction for the point labeled by the black cross. Suppose that we choose K=3. Then KNN will first identify the three observations that are closest to the cross. This neighborhood is shown as a circle. It consists of two blue points and one orange point, resulting in estimated probabilities of 2/3for the blue class and 1/3for the orange class. Hence KNN will predict that the black cross belongs to the blue class. In the right-hand panel of Figure 2.14we have applied the KNN approach with K=3at all of the possible values for X1andX2, and have drawn in the corresponding KNN decision boundary. Despite the fact that it is a very simple approach, KNN can often pro- duce classifiers that are surprisingly close to the optimal Bayes classifier. Figure2.15displays the KNN decision boundary, using K= 10 , when ap-", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 60, "start_word": 19200, "end_word": 19600, "chunk_words": 400}}, "ISLP_website::c000061": {"text": "class. Hence KNN will predict that the black cross belongs to the blue class. In the right-hand panel of Figure 2.14we have applied the KNN approach with K=3at all of the possible values for X1andX2, and have drawn in the corresponding KNN decision boundary. Despite the fact that it is a very simple approach, KNN can often pro- duce classifiers that are surprisingly close to the optimal Bayes classifier. Figure2.15displays the KNN decision boundary, using K= 10 , when ap- plied to the larger simulated data set from Figure 2.13. Notice that even though the true distribution is not known by the KNN classifier, the KNN decision boundary is very close to that of the Bayes classifier. The test error rate using KNN is 0.1363 , which is close to the Bayes error rate of 0.1304 . The choice of Khas a drastic effect on the KNN classifier obtained. Figure2.16displays two KNN fits to the simulated data from Figure 2.13, usingK=1andK= 100 . WhenK=1, the decision boundary is overly flexible and finds patterns in the data that don’t correspond to the Bayes decision boundary. This corresponds to a classifier that has low bias but very high variance. As Kgrows, the method becomes less flexible and produces a decision boundary that is close to linear. This corresponds to a low-variance but high-bias classifier. On this simulated data set, neither K=1 norK= 100 give good predictions: they have test error rates of 0.1695 and0.1925 , respectively. Just as in the regression setting, there is not a strong relationship be- tween the training error rate and the test error rate. With K=1, the KNN training error rate is 0, but the test error rate may be quite high. In general, as we use more flexible classification methods, the training error rate will decline but the test error rate may not. In Figure 2.17, we have plotted the KNN test and training errors as a function of 1/K. As1/Kin- creases, the method becomes more flexible. As in the regression setting, the trainingerrorrateconsistentlydeclinesastheflexibilityincreases.However, the test error exhibits a characteristic U-shape, declining at first (with a minimum at approximately K= 10 ) before increasing again when the method becomes excessively flexible and overfits. 38 2. Statistical Learning oo ooooooo ooooo ooooooo oooFIGURE 2.14. The KNN approach, using K=3, is illustrated in a simple situation with six blue observations and six orange observations. Left:a test observation at", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 61, "start_word": 19520, "end_word": 19920, "chunk_words": 400}}, "ISLP_website::c000062": {"text": "a function of 1/K. As1/Kin- creases, the method becomes more flexible. As in the regression setting, the trainingerrorrateconsistentlydeclinesastheflexibilityincreases.However, the test error exhibits a characteristic U-shape, declining at first (with a minimum at approximately K= 10 ) before increasing again when the method becomes excessively flexible and overfits. 38 2. Statistical Learning oo ooooooo ooooo ooooooo oooFIGURE 2.14. The KNN approach, using K=3, is illustrated in a simple situation with six blue observations and six orange observations. Left:a test observation at which a predicted class label is desired is shown as a black cross. The three closest points to the test observation are identified, and it is predicted that the test observation belongs to the most commonly-occurring class, in this case blue. Right:The KNN decision boundary for this example is shown in black. The blue grid indicates the region in which a test observation will be assigned to the blue class, and the orange grid indicates the region in which it will be assigned to the orange class. ooooo oooooo oooo oo oooo ooooooooooooooooooo oooo oooooooooooooooooooooooooooooooooooooooooooooooo ooooooooo ooooooooooooooooooooooo oooooooooooo ooooooooooooooooooooooooooooooooooooooooooo ooooooooooooooo oooooo X1X2KNN: K=10 FIGURE 2.15. The black curve indicates the KNN decision boundary on the data from Figure 2.13, usingK= 10 . The Bayes decision boundary is shown as a purple dashed line. The KNN and Bayes decision boundaries are very similar. In both the regression and classification settings, choosing the correct levelofflexibilityiscriticaltothesuccessofanystatisticallearningmethod. The bias-variance tradeoff, and the resulting U-shape in the test error, can make this a difficult task. In Chapter 5, we return to this topic and discuss 2.2 Assessing Model Accuracy 39 ooooo oooooo oooo oo oooo oooooooooo ooooooooo oooo oooooooooooooooooooooo ooooooooooo oooooooo ooooooo ooo oooooo ooooooooooooooooooooooo oooooooooooo ooooooooooooooooo oo oooooooooooooooooooooooo ooooooooooooooo ooooooooooo oooooo oooo oo oooo oooooooooo ooooooooo oooo oooooooooooooooooooooo ooooooooooo oooooooo ooooooo ooo oooooo ooooooooooooooooooooooo oooooooooooo ooooooooooooooooo oo oooooooooooooooooooooooo ooooooooooooooo ooooooKNN: K=1KNN: K=100 FIGURE 2.16. A comparison of the KNN decision boundaries (solid black curves) obtained using K=1andK= 100 on the data from Figure 2.13. With K=1, the decision boundary is overly flexible, while with K= 100 it is not sufficiently flexible. The Bayes decision boundary is shown as a purple dashed line. 0.01 0.020.05 0.10 0.200.50 1.000.000.050.100.150.20 1/KError Rate Training ErrorsTest ErrorsFIGURE 2.17. The KNN training error rate (blue, 200 observations) and test error rate (orange, 5,000 observations) on the data from Figure 2.13, as the level of flexibility (assessed using 1/Kon the log", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 62, "start_word": 19840, "end_word": 20240, "chunk_words": 400}}, "ISLP_website::c000063": {"text": "obtained using K=1andK= 100 on the data from Figure 2.13. With K=1, the decision boundary is overly flexible, while with K= 100 it is not sufficiently flexible. The Bayes decision boundary is shown as a purple dashed line. 0.01 0.020.05 0.10 0.200.50 1.000.000.050.100.150.20 1/KError Rate Training ErrorsTest ErrorsFIGURE 2.17. The KNN training error rate (blue, 200 observations) and test error rate (orange, 5,000 observations) on the data from Figure 2.13, as the level of flexibility (assessed using 1/Kon the log scale) increases, or equivalently as the number of neighbors Kdecreases. The black dashed line indicates the Bayes error rate. The jumpiness of the curves is due to the small size of the training data set. various methods for estimating test error rates and thereby choosing the optimal level of flexibility for a given statistical learning method. 40 2. Statistical Learning 2.3 Lab: Introduction to Python 2.3.1 Getting Started To run the labs in this book, you will need two things: 1. An installation of Python3, which is the specific version of Pythonused in the labs. 2. Access to Jupyter, a very popular Pythoninterface that runs code through a file called a notebook.notebook You can download and install Python3by following the instructions avail- able atanaconda.com . There are a number of ways to get access to Jupyter. Here are just a few: 1. Using Google’s Colaboratory service:colab.research.google.com/ . 2. Using JupyterHub , available at jupyter.org/hub . 3. Using your own jupyter installation. Installation instructions are available at jupyter.org/install . Please see the Pythonresources page on the book website statlearning.com for up-to-date information about getting PythonandJupyterworking on your computer. You will need to install the ISLPpackage, which provides access to the datasets and custom-built functions that we provide. Inside a macOS or Linux terminal type pip install ISLP ; this also installs most other pack- ages needed in the labs. The Pythonresources page has a link to the ISLP documentation website. To run this lab, download the file Ch2-statlearn-lab.ipynb from the Pythonresources page. Now run the following code at the command line: jupyter lab Ch2-statlearn-lab.ipynb . If you’re using Windows, you can use the start menu to access anaconda , and follow the links. For example, to install ISLPand run this lab, you can run the same code above in an anaconda shell. 2.3.2 Basic Commands In this lab, we will introduce some simple Pythoncommands. For more resources about Pythonin general, readers", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 63, "start_word": 20160, "end_word": 20560, "chunk_words": 400}}, "ISLP_website::c000064": {"text": "run this lab, download the file Ch2-statlearn-lab.ipynb from the Pythonresources page. Now run the following code at the command line: jupyter lab Ch2-statlearn-lab.ipynb . If you’re using Windows, you can use the start menu to access anaconda , and follow the links. For example, to install ISLPand run this lab, you can run the same code above in an anaconda shell. 2.3.2 Basic Commands In this lab, we will introduce some simple Pythoncommands. For more resources about Pythonin general, readers may want to consult the tutorial atdocs.python.org/3/tutorial/ . Like most programming languages, Pythonusesfunctions to perform op-functionerations. To run a function called fun, we type fun(input1,input2) , where the inputs (or arguments )input1andinput2tellPythonhow to run the function. A function can have any number of inputs. For example, theargumentprint()function outputs a text representation of all of its arguments toprint()the console. In[1]: print('fit a model with' ,1 1 ,'variables' ) 2.3 Lab: Introduction to Python 41 fit a model with 11 variables The following command will provide information about the print()func- tion. In[2]: print? Adding two integers in Pythonis pretty intuitive. In[3]: 3+5 Out[3]: 8 InPython, textual data is handled using strings. For instance, \"hello\"andstring'hello'are strings. We can concatenate them using the addition +symbol. In[4]: \"hello\" +\"\"+\"world\" Out[4]: 'hello world' A string is actually a type of sequence: this is a generic term for an orderedsequence list. The three most important types of sequences are lists, tuples, and strings. We introduce lists now. The following command instructs Pythonto join together the numbers 3, 4, and 5, and to save them as a listnamedx. When we type x, it gives uslistback the list. In[5]: x=[ 3 ,4 ,5 ] x Out[5]: [3, 4, 5] Note that we used the brackets []to construct this list. We will often want to add two sets of numbers together. It is reasonable to try the following code, though it will not produce the desired results. In[6]: y=[ 4 ,9 ,7 ] x+y Out[6]: [3, 4, 5, 4, 9, 7] The result may appear slightly counterintuitive: why did Pythonnot add the entries of the lists element-by-element? In Python, lists hold arbitrary objects, and are added using concatenation . In fact, concatenation is theconcatenat- ion behavior that we saw earlier when we entered \"hello\" + \" \" + \"world\" . This example reflects the fact that Pythonis a general-purpose program- ming language. Much of Python’s data-specific functionality comes from otherpackages,notably", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 64, "start_word": 20480, "end_word": 20880, "chunk_words": 400}}, "ISLP_website::c000065": {"text": ",9 ,7 ] x+y Out[6]: [3, 4, 5, 4, 9, 7] The result may appear slightly counterintuitive: why did Pythonnot add the entries of the lists element-by-element? In Python, lists hold arbitrary objects, and are added using concatenation . In fact, concatenation is theconcatenat- ion behavior that we saw earlier when we entered \"hello\" + \" \" + \"world\" . This example reflects the fact that Pythonis a general-purpose program- ming language. Much of Python’s data-specific functionality comes from otherpackages,notably numpyandpandas.Inthenextsection,wewillintro- ducethe numpypackage.See docs.scipy.org/doc/numpy/user/quickstart.html for more information about numpy. 42 2. Statistical Learning 2.3.3 Introduction to Numerical Python As mentioned earlier, this book makes use of functionality that is contained in thenumpylibrary, orpackage. A package is a collection of modules thatnumpy packagearenotnecessarilyincludedinthebase Pythondistribution.Thename numpy is an abbreviation for numerical Python . To access numpy, we must first importit.import In[7]: import numpy as np In the previous line, we named the numpymodule np; an abbreviation formoduleeasier referencing. Innumpy,anarrayisagenerictermforamultidimensionalsetofnumbers.array Weusethe np.array() functiontodefine xandy,whichareone-dimensionalnp.array()arrays, i.e. vectors. In[8]: x=n p . a r r a y ( [ 3 ,4 ,5 ] ) y=n p . a r r a y ( [ 4 ,9 ,7 ] ) Note that if you forgot to run the import numpy as np command earlier, then you will encounter an error in calling the np.array() function in the previous line. The syntax np.array() indicates that the function be- ing called is part of the numpypackage, which we have abbreviated as np. Sincexandyhave been defined using np.array() , we get a sensible result when we add them together. Compare this to our results in the previous section, when we tried to add two lists without using numpy. In[9]: x+y Out[9]: array([ 7, 13, 12]) Innumpy, matrices are typically represented as two-dimensional arrays, and vectors as one-dimensional arrays.1We can create a two-dimensional array as follows. In[10]: x=n p . a r r a y ( [ [ 1 ,2 ] ,[ 3 ,4 ] ] ) x Out[10]: array([[1, 2], [3, 4]]) The object xhas several attributes , or associated objects. To access anattributeattribute of x, we type x.attribute , where we replace attribute with the name of the attribute. For instance, we can access the ndimattribute of xndimas follows. In[11]: x.ndim Out[11]: 2 The output indicates that xis a two-dimensional array. Similarly, x.dtype is thedata type attribute of the object x. This indicates that xis compriseddata typeof 64-bit", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 65, "start_word": 20800, "end_word": 21200, "chunk_words": 400}}, "ISLP_website::c000066": {"text": "] ,[ 3 ,4 ] ] ) x Out[10]: array([[1, 2], [3, 4]]) The object xhas several attributes , or associated objects. To access anattributeattribute of x, we type x.attribute , where we replace attribute with the name of the attribute. For instance, we can access the ndimattribute of xndimas follows. In[11]: x.ndim Out[11]: 2 The output indicates that xis a two-dimensional array. Similarly, x.dtype is thedata type attribute of the object x. This indicates that xis compriseddata typeof 64-bit integers: 1While it is also possible to create matrices using np.matrix() , we will use np.array() throughout the labs in this book. 2.3 Lab: Introduction to Python 43In[12]:x.dtypeOut[12]:dtype('int64')Why isxcomprised of integers? This is because we createdxby passingin exclusively integers to thenp.array()function. If we had passed in anydecimals, then we would have obtained an array offloating point numbersfloatingpoint(i.e. real-valued numbers).In[13]:np.array([[1, 2], [3.0, 4]]).dtypeOut[13]:dtype('float64')Typingfun?will causePythonto display documentation associated withthe functionfun, if it exists. We can try this fornp.array().In[14]:np.array?This documentation indicates that we could create a floating point arrayby passing adtypeargument intonp.array().dtypeIn[15]:np.array([[1, 2], [3, 4]], float).dtypeOut[15]:dtype('float64')The arrayxis two-dimensional. We can find out the number of rows andcolumns by looking at itsshapeattribute.shapeIn[16]:x.shapeOut[16]:(2, 2)Amethodis a function that is associated with an object. For instance,methodgiven an arrayx, the expressionx.sum()sums all of its elements, using thesum()method for arrays. The callx.sum()automatically providesxas the.sum()first argument to itssum()method.In[17]:x=n p . a r r a y ( [ 1 ,2 ,3 ,4 ] )x.sum()Out[17]:10We could also sum the elements ofxby passing inxas an argument to thenp.sum()function.np.sum()In[18]:x=n p . a r r a y ( [ 1 ,2 ,3 ,4 ] )np.sum(x)Out[18]:10As another example, thereshape()method returns a new array with the.reshape()same elements asx, but a different shape. We do this by passing in atupletuple 44 2. Statistical Learning in our call to reshape() , in this case (2, 3). This tuple specifies that we would like to create a two-dimensional array with 2rows and 3columns.2 In what follows, the \\ncharacter creates a new line. In[19]: x=n p . a r r a y ( [ 1 ,2 ,3 ,4 ,5 ,6 ] ) print('beginning x:\\n' ,x ) x_reshape = x.reshape((2, 3)) print('reshaped x:\\n' ,x _ r e s h a p e ) beginning x: [1 2 3 4 5 6] reshaped x: [[1 2 3] [4 5 6]] The previous output reveals that numpyarrays are specified as a sequence ofrows. This is called row-major ordering , as opposed to column-major ordering.", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 66, "start_word": 21120, "end_word": 21520, "chunk_words": 400}}, "ISLP_website::c000067": {"text": "new line. In[19]: x=n p . a r r a y ( [ 1 ,2 ,3 ,4 ,5 ,6 ] ) print('beginning x:\\n' ,x ) x_reshape = x.reshape((2, 3)) print('reshaped x:\\n' ,x _ r e s h a p e ) beginning x: [1 2 3 4 5 6] reshaped x: [[1 2 3] [4 5 6]] The previous output reveals that numpyarrays are specified as a sequence ofrows. This is called row-major ordering , as opposed to column-major ordering. Python(and hence numpy) uses 0-based indexing. This means that to access the top left element of x_reshape , we type in x_reshape[0,0] . In[20]: x_reshape[0, 0] Out[20]: 1 Similarly, x_reshape[1,2] yields the element in the second row and the third column of x_reshape . In[21]: x_reshape[1, 2] Out[21]: 6 Similarly, x[2]yields the third entry of x. Now, let’s modify the top left element of x_reshape . To our surprise, we discover that the first element of xhas been modified as well! In[22]: print('x before we modify x_reshape:\\n' ,x ) print('x_reshape before we modify x_reshape:\\n' ,x _ r e s h a p e ) x_reshape[0, 0] = 5 print('x_reshape after we modify its top left element:\\n' , x_reshape) print('x after we modify top left element of x_reshape:\\n' ,x ) Out[22]: xb e f o r ew em o d i f yx _ r e s h a p e : [1 2 3 4 5 6] x_reshape before we modify x_reshape: [[1 2 3] [4 5 6]] x_reshape after we modify its top left element: [[5 2 3] 2Like lists, tuples represent a sequence of objects. Why do we need more than one way to create a sequence? There are a few differences between tuples and lists, but perhaps the most important is that elements of a tuple cannot be modified, whereas elements of a list can be. 2.3 Lab: Introduction to Python 45[4 5 6]]xa f t e rw em o d i f yt o pl e f te l e m e n to fx _ r e s h a p e :[5 2 3 4 5 6]Modifyingx_reshapealso modifiedxbecause the two objects occupy thesame space in memory.Wejustsawthatwecanmodifyanelementofanarray.Canwealsomod-ify a tuple? It turns out that we cannot — and trying to do so introducesanexception, or error.exceptionIn[23]:my_tuple = (3, 4, 5)my_tuple[0] = 2TypeError:'tuple'object does not support item assignmentWenowbrieflymentionsomeattributesofarraysthatwillcomeinhandy.An array’sshapeattribute contains its dimension; this is always a tuple.Thendimattribute yields", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 67, "start_word": 21440, "end_word": 21840, "chunk_words": 400}}, "ISLP_website::c000068": {"text": "rw em o d i f yt o pl e f te l e m e n to fx _ r e s h a p e :[5 2 3 4 5 6]Modifyingx_reshapealso modifiedxbecause the two objects occupy thesame space in memory.Wejustsawthatwecanmodifyanelementofanarray.Canwealsomod-ify a tuple? It turns out that we cannot — and trying to do so introducesanexception, or error.exceptionIn[23]:my_tuple = (3, 4, 5)my_tuple[0] = 2TypeError:'tuple'object does not support item assignmentWenowbrieflymentionsomeattributesofarraysthatwillcomeinhandy.An array’sshapeattribute contains its dimension; this is always a tuple.Thendimattribute yields the number of dimensions, andTprovides itstranspose.In[24]:x_reshape.shape, x_reshape.ndim, x_reshape.TOut[24]:((2, 3),2,array([[5, 4],[2, 5],[3, 6]]))Notice that the three individual outputs(2,3),2, andarray([[5, 4],[2,5], [3,6]])are themselves output as a tuple.We will often want to apply functions to arrays. For instance, we cancompute the square root of the entries using thenp.sqrt()function:np.sqrt()In[25]:np.sqrt(x)Out[25]:array([2.24, 1.41, 1.73, 2., 2.24, 2.45])We can also square the elements:In[26]:x**2Out[26]:array([25, 4, 9, 16, 25, 36])We can compute the square roots using the same notation, raising to thepower of1/2instead of 2.In[27]:x**0.5Out[27]:array([2.24, 1.41, 1.73, 2., 2.24, 2.45])Throughout this book, we will often want to generate random data. Thenp.random.normal()functiongeneratesavectorofrandomnormalvariables.np.random.normal()Wecanlearnmoreaboutthisfunctionbylookingatthehelppage,viaacalltonp.random.normal?. The first line of the help page readsnormal(loc=0.0,scale=1.0, size=None). Thissignatureline tells us that the function’s ar-signature 46 2. Statistical Learning guments are loc,scale, andsize. These are keyword arguments, whichkeywordmeans that when they are passed into the function, they can be referred to by name (in any order).3By default, this function will generate random normal variable(s) with mean ( loc)0and standard deviation ( scale)1; fur- thermore, a single random variable will be generated unless the argument tosizeis changed. We now generate 50 independent random variables from a N(0,1)dis- tribution. In[28]: x=n p . r a n d o m . n o r m a l ( s i z e = 5 0 ) x Out[28]: array([-1.19, 0.41, 0.9 , -0.44, -0.9 , -0.38, 0.13, 1.87, -0.35, 1.16, 0.79, -0.97, -1.21, 0.06, -1.62, -0.6 , -0.77, -2.12, 0.38, -1.22, -0.06, -1.97, -1.74, -0.56, 1.7 , -0.95, 0.56, 0.35, 0.87, 0.88, -1.66, -0.32, -0.3 , -1.36, 0.92, -0.31, 1.28, -1.94, 1.07, 0.07, 0.79, -0.46, 2.19, -0.27, -0.64, 0.85, 0.13, 0.46, -0.09, 0.7 ]) We create an array yby adding an independent N(50,1)random variable to each element of x. In[29]: y=x+n p . r a n d o m . n o r m a l ( l o c = 5 0 ,s c a l e = 1 ,s i z e = 5 0 ) Thenp.corrcoef() functioncomputesthecorrelationmatrixbetween xandnp.corrcoef()y.", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 68, "start_word": 21760, "end_word": 22160, "chunk_words": 400}}, "ISLP_website::c000069": {"text": "0.88, -1.66, -0.32, -0.3 , -1.36, 0.92, -0.31, 1.28, -1.94, 1.07, 0.07, 0.79, -0.46, 2.19, -0.27, -0.64, 0.85, 0.13, 0.46, -0.09, 0.7 ]) We create an array yby adding an independent N(50,1)random variable to each element of x. In[29]: y=x+n p . r a n d o m . n o r m a l ( l o c = 5 0 ,s c a l e = 1 ,s i z e = 5 0 ) Thenp.corrcoef() functioncomputesthecorrelationmatrixbetween xandnp.corrcoef()y. The off-diagonal elements give the correlation between xandy. In[30]: np.corrcoef(x, y) Out[30]: array([[1. , 0.69], [0.69, 1. ]]) If you’re following along in your own Jupyternotebook, then you probably noticed that you got a different set of results when you ran the past few commands. In particular, each time we call np.random.normal() , we will get a different answer, as shown in the following example. In[31]: print(np.random.normal(scale=5, size=2)) print(np.random.normal(scale=5, size=2)) Out[31]: [4.28 2.59] [4.62 -2.54] In order to ensure that our code provides exactly the same results each time it is run, we can set a random seed using the np.random.default_rng()random seed np.random. default_rng()function. This function takes an arbitrary, user-specified integer argument. If we set a random seed before generating random data, then re-running our code will yield the same results. The object rnghas essentially all the 3Python also uses positional arguments. Positional arguments do not need to use a keyword. To see an example, type in np.sum? . We see that ais a positional argument, i.e. this function assumes that the first unnamed argument that it receives is the array to be summed. By contrast, axisanddtypeare keyword arguments: the position in which these arguments are entered into np.sum() does not matter. 2.3 Lab: Introduction to Python 47randomnumbergeneratingmethodsfoundinnp.random.Hence,togeneratenormal data we userng.normal().In[32]:rng = np.random.default_rng(1303)print(rng.normal(scale=5, size=2))rng2 = np.random.default_rng(1303)print(rng2.normal(scale=5, size=2))Out[32]:[4.09 -1.07 ][4.09 -1.07 ]Throughout the labs in this book, we usenp.random.default_rng()when-ever we perform calculations involving random quantities withinnumpy. Inprinciple, this should enable the reader to exactly reproduce the statedresults. However, as new versions ofnumpybecome available, it is possiblethat some small discrepancies may occur between the output in the labsand the output fromnumpy.Thenp.mean(),np.var(), andnp.std()functions can be used to computenp.mean()np.var()np.std()the mean, variance, and standard deviation of arrays. These functions arealso available as methods on the arrays.In[33]:rng = np.random.default_rng(3)y=r n g . s t a n d a r d _ n o r m a l ( 1 0 )np.mean(y), y.mean()Out[33]:(-0.11, -0.11)In[34]:np.var(y), y.var(), np.mean((y -", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 69, "start_word": 22080, "end_word": 22480, "chunk_words": 400}}, "ISLP_website::c000070": {"text": "reader to exactly reproduce the statedresults. However, as new versions ofnumpybecome available, it is possiblethat some small discrepancies may occur between the output in the labsand the output fromnumpy.Thenp.mean(),np.var(), andnp.std()functions can be used to computenp.mean()np.var()np.std()the mean, variance, and standard deviation of arrays. These functions arealso available as methods on the arrays.In[33]:rng = np.random.default_rng(3)y=r n g . s t a n d a r d _ n o r m a l ( 1 0 )np.mean(y), y.mean()Out[33]:(-0.11, -0.11)In[34]:np.var(y), y.var(), np.mean((y - y.mean())**2)Out[34]:(2.72, 2.72, 2.72)Notice that by defaultnp.var()divides by the sample sizenrather thann−1; see theddofargument innp.var?.In[35]:np.sqrt(np.var(y)), np.std(y)Out[35]:(1.65, 1.65)Thenp.mean(),np.var(), andnp.std()functions can also be applied to therows and columns of a matrix. To see this, we construct a10×3matrix ofN(0,1)random variables, and consider computing its row sums.In[36]:X=r n g . s t a n d a r d _ n o r m a l ( ( 1 0 ,3 ) )XOut[36]:array([[ 0.23, -0.35, -0.28],[-0.67, -1.06, -0.39],[0 . 4 8 ,- 0 . 2 4 , 0 . 9 6 ] ,[-0.2 , 0.02, 1.55],[0 . 5 5 ,- 0 . 5 1 ,- 0 . 1 8 ] ,[0 . 5 4 , 1 . 9 4 ,- 0 . 2 7 ] ,[-0.24, 1. , -0.89],[-0.29, 0.88, 0.58],[0 . 0 9 , 0 . 6 7 ,- 2 . 8 3 ] ,[1 . 0 2 ,- 0 . 9 6 ,- 1 . 6 7 ] ] ) 48 2. Statistical Learning Since arrays are row-major ordered, the first axis, i.e. axis=0, refers to its rows. We pass this argument into the mean()method for the object X..mean() In[37]: X.mean(axis=0) Out[37]: array([0.15, 0.14, -0.34]) The following yields the same result. In[38]: X.mean(0) Out[38]: array([0.15, 0.14, -0.34]) 2.3.4 Graphics InPython, common practice is to use the library matplotlib for graphics.matplotlibHowever, since Pythonwas not written with data analysis in mind, the no- tion of plotting is not intrinsic to the language. We will use the subplots() function from matplotlib.pyplot to create a figure and the axes onto which we plot our data. For many more examples of how to make plots in Python, readers are encouraged to visit matplotlib.org/stable/gallery/ . Inmatplotlib , a plot consists of a figureand one or more axes. You canfigure axesthink of the figure as the blank canvas upon which one or more plots will be displayed: it is the entire plotting window. The axescontain important information about each plot, such", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 70, "start_word": 22400, "end_word": 22800, "chunk_words": 400}}, "ISLP_website::c000071": {"text": "subplots() function from matplotlib.pyplot to create a figure and the axes onto which we plot our data. For many more examples of how to make plots in Python, readers are encouraged to visit matplotlib.org/stable/gallery/ . Inmatplotlib , a plot consists of a figureand one or more axes. You canfigure axesthink of the figure as the blank canvas upon which one or more plots will be displayed: it is the entire plotting window. The axescontain important information about each plot, such as its x- andy-axis labels, title, and more. (Note that in matplotlib , the word axesis not the plural of axis:a plot’saxescontains much more information than just the x-axis and the y-axis.) We begin by importing the subplots() function from matplotlib .W esubplots()use this function throughout when creating figures. The function returns a tuple of length two: a figure object as well as the relevant axes object. We will typically pass figsizeas a keyword argument. Having created our axes, we attempt our first plot using its plot()method. To learn more.plot()about it, type ax.plot? . In[39]: from matplotlib.pyplot import subplots fig, ax = subplots(figsize=(8, 8)) x=r n g . s t a n d a r d _ n o r m a l ( 1 0 0 ) y=r n g . s t a n d a r d _ n o r m a l ( 1 0 0 ) ax.plot(x, y); We pause here to note that we have unpacked the tuple of length two re- turned by subplots() into the two distinct variables figandax. Unpacking is typically preferred to the following equivalent but slightly more verbose code: In[40]: output = subplots(figsize=(8, 8)) fig = output[0] ax = output[1] We see that our earlier cell produced a line plot, which is the default. To create a scatterplot, we provide an additional argument to ax.plot() , indicating that circles should be displayed. 2.3 Lab: Introduction to Python 49In[41]:fig, ax = subplots(figsize=(8, 8))ax.plot(x, y,'o');Differentvaluesofthisadditionalargumentcanbeusedtoproducedifferentcolored lines as well as different linestyles.As an alternative, we could use theax.scatter()function to create a.scatter()scatterplot.In[42]:fig, ax = subplots(figsize=(8, 8))ax.scatter(x, y, marker='o');Notice that in the code blocks above, we have ended the last line with asemicolon. This preventsax.plot(x, y)from printing text to the notebook.However, it does not prevent a plot from being produced. If we omit thetrailing semi-colon, then we obtain the following output:In[43]:fig, ax = subplots(figsize=(8, 8))ax.scatter(x, y, marker='o')Out[43]:<matplotlib.collections.PathCollection at 0x7fb3d9c8f310>Figure(432x288)In what follows, we will", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 71, "start_word": 22720, "end_word": 23120, "chunk_words": 400}}, "ISLP_website::c000072": {"text": "ax = subplots(figsize=(8, 8))ax.plot(x, y,'o');Differentvaluesofthisadditionalargumentcanbeusedtoproducedifferentcolored lines as well as different linestyles.As an alternative, we could use theax.scatter()function to create a.scatter()scatterplot.In[42]:fig, ax = subplots(figsize=(8, 8))ax.scatter(x, y, marker='o');Notice that in the code blocks above, we have ended the last line with asemicolon. This preventsax.plot(x, y)from printing text to the notebook.However, it does not prevent a plot from being produced. If we omit thetrailing semi-colon, then we obtain the following output:In[43]:fig, ax = subplots(figsize=(8, 8))ax.scatter(x, y, marker='o')Out[43]:<matplotlib.collections.PathCollection at 0x7fb3d9c8f310>Figure(432x288)In what follows, we will use trailing semicolons whenever the text thatwould be output is not germane to the discussion at hand.To label our plot, we make use of theset_xlabel(),set_ylabel(), and.set_xlabel().set_ylabel()set_title()methods ofax..set_title()In[44]:fig, ax = subplots(figsize=(8, 8))ax.scatter(x, y, marker='o')ax.set_xlabel(\"this is the x-axis\")ax.set_ylabel(\"this is the y-axis\")ax.set_title(\"Plot of X vs Y\");Having access to the figure objectfigitself means that we can go in andchange some aspects and then redisplay it. Here, we change the size from(8, 8)to(12, 3).fig.set_size_inches(12,3)figOccasionally we will want to create several plots within a figure. Thiscan be achieved by passing additional arguments tosubplots(). Below, wecreate a2×3grid of plots in a figure of size determined by thefigsizeargument. In such situations, there is often a relationship between theaxes in the plots. For example, all plots may have a commonx-axis. Thesubplots()function can automatically handle this situation when passedthe keyword argumentsharex=True. Theaxesobject below is an arraypointing to different plots in the figure.In[45]:fig, axes = subplots(nrows=2,ncols=3,figsize=(15, 5))We now produce a scatter plot with'o'in the second column of the firstrow and a scatter plot with'+'in the third column of the second row. 50 2. Statistical LearningIn[46]:axes[0,1].plot(x, y,'o')axes[1,2].scatter(x, y, marker='+')figTypesubplots?to learn more aboutsubplots().To save the output offig, we call itssavefig()method. The argument.savefig()dpiis the dots per inch, used to determine how large the figure will be inpixels.In[47]:fig.savefig(\"Figure.png\",d p i = 4 0 0 )fig.savefig(\"Figure.pdf\",d p i = 2 0 0 ) ;We can continue to modifyfigusing step-by-step updates; for example,wecanmodifytherangeofthex-axis,re-savethefigure,andevenre-displayit.In[48]:axes[0,1].set_xlim([-1,1])fig.savefig(\"Figure_updated.jpg\")figWe now create some more sophisticated plots. Theax.contour()method.contour()producesacontourplotinordertorepresentthree-dimensionaldata,similarcontour plotto a topographical map. It takes three arguments:• A vector ofxvalues (the first dimension),• A vector ofyvalues (the second dimension), and• A matrix whose elements correspond to thezvalue (the third dimen-sion) for each pair of(x,y)coordinates.To createxandy, we’ll use the commandnp.linspace(a, b, n), whichnp.linspace()returns a vector ofnnumbers starting ataand ending atb.In[49]:fig, ax = subplots(figsize=(8, 8))x=n p . l i n s p a c e ( - n p . p i ,n p . p i ,5 0 )y=xf=n p . m u l t i p", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 72, "start_word": 23040, "end_word": 23440, "chunk_words": 400}}, "ISLP_website::c000073": {"text": "arguments:• A vector ofxvalues (the first dimension),• A vector ofyvalues (the second dimension), and• A matrix whose elements correspond to thezvalue (the third dimen-sion) for each pair of(x,y)coordinates.To createxandy, we’ll use the commandnp.linspace(a, b, n), whichnp.linspace()returns a vector ofnnumbers starting ataand ending atb.In[49]:fig, ax = subplots(figsize=(8, 8))x=n p . l i n s p a c e ( - n p . p i ,n p . p i ,5 0 )y=xf=n p . m u l t i p l y . o u t e r ( n p . c o s ( y ) ,1/( 1+x * * 2 ) )ax.contour(x, y, f);We can increase the resolution by adding more levels to the image.In[50]:fig, ax = subplots(figsize=(8, 8))ax.contour(x, y, f, levels=45);To fine-tune the output of theax.contour()function, take a look at thehelp file by typing?plt.contour.Theax.imshow()method is similar toax.contour(), except that it pro-.imshow()duces a color-coded plot whose colors depend on thezvalue. This is knownas aheatmap, and is sometimes used to plot temperature in weather fore-heatmapcasts.In[51]:fig, ax = subplots(figsize=(8, 8))ax.imshow(f); 2.3 Lab: Introduction to Python 512.3.5 Sequences and Slice NotationAs seen above, the functionnp.linspace()can be used to create a sequenceof numbers.In[52]:seq1 = np.linspace(0, 10, 11)seq1Out[52]:array([ 0., 1., 2., 3., 4., 5., 6., 7., 8., 9., 10.])The functionnp.arange()returns a sequence of numbers spaced out bynp.arange()step. Ifstepis not specified, then a default value of1is used. Let’s createa sequence that starts at0and ends at10.In[53]:seq2 = np.arange(0, 10)seq2Out[53]:array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])Why isn’t10output above? This has to do withslicenotation inPython.sliceSlice notation is used to index sequences such as lists, tuples and arrays.Suppose we want to retrieve the fourth through sixth (inclusive) entries ofa string. We obtain a slice of the string using the indexing notation[3:6].In[54]:\"hello world\"[3:6]Out[54]:'lo 'In the code block above, the notation3:6is shorthand forslice(3,6)whenused inside[].In[55]:\"hello world\"[slice(3,6)]Out[55]:'lo 'You might have expectedslice(3,6)to output the fourth through seventhcharacters in the text string (recalling thatPythonbegins its indexing atzero), but instead it output the fourth through sixth. This also explainswhy the earliernp.arange(0, 10)command output only the integers from0to9. See the documentationslice?for useful options in creating slices.2.3.6 Indexing DataTo begin, we create a two-dimensionalnumpyarray.In[56]:A=n p . a r r a y ( n p . a r a n g e ( 1 6 ) ) . r e s h a p e ( ( 4 ,4 ) )AOut[56]:array([[ 0, 1, 2, 3],[4 , 5 , 6 , 7 ] ,[8 ,", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 73, "start_word": 23360, "end_word": 23760, "chunk_words": 400}}, "ISLP_website::c000074": {"text": "output the fourth through sixth. This also explainswhy the earliernp.arange(0, 10)command output only the integers from0to9. See the documentationslice?for useful options in creating slices.2.3.6 Indexing DataTo begin, we create a two-dimensionalnumpyarray.In[56]:A=n p . a r r a y ( n p . a r a n g e ( 1 6 ) ) . r e s h a p e ( ( 4 ,4 ) )AOut[56]:array([[ 0, 1, 2, 3],[4 , 5 , 6 , 7 ] ,[8 , 9 ,1 0 ,1 1 ] ,[12, 13, 14, 15]])TypingA[1,2]retrieves the element corresponding to the second row andthird column. (As usual,Pythonindexes from0.) 52 2. Statistical LearningIn[57]:A[1,2]Out[57]:6The first number after the open-bracket symbol[refers to the row, andthe second number refers to the column.Indexing Rows, Columns, and SubmatricesTo select multiple rows at a time, we can pass in a list specifying ourselection. For instance,[1,3]will retrieve the second and fourth rows:In[58]:A[[1,3]]Out[58]:array([[ 4, 5, 6, 7],[12, 13, 14, 15]])To select the first and third columns, we pass in[0,2]as the second ar-gument in the square brackets. In this case we need to supply the firstargument:which selects all rows.In[59]:A[:,[0,2]]Out[59]:array([[ 0, 2],[4 , 6 ] ,[8 ,1 0 ] ,[12, 14]])Now, suppose that we want to select the submatrix made up of the secondand fourth rows as well as the first and third columns. This is where index-ing gets slightly tricky. It is natural to try to use lists to retrieve the rowsand columns:In[60]:A[[1,3],[0,2]]Out[60]:array([ 4, 14])Oops — what happened? We got a one-dimensional array of length twoidentical toIn[61]:np.array([A[1,0],A[3,2]])Out[61]:array([ 4, 14])Similarly, the following code fails to extract the submatrix comprised ofthe second and fourth rows and the first, third, and fourth columns:In[62]:A[[1,3],[0,2,3]]IndexError: shape mismatch: indexing arrays could not be broadcasttogether with shapes (2,) (3,) 2.3 Lab: Introduction to Python 53We can see what has gone wrong here. When supplied with two indexinglists, thenumpyinterpretation is that these provide pairs ofi, jindices fora series of entries. That is why the pair of lists must have the same length.However, that was not our intent, since we are looking for a submatrix.One easy way to do this is as follows. We first create a submatrix bysubsetting the rows ofA, and then on the fly we make a further submatrixby subsetting its columns.In[63]:A[[1,3]][:,[0,2]]Out[63]:array([[ 4, 6],[12, 14]])There are more efficient ways of achieving the same result.Theconvenience functionnp.ix_()allowsustoextractasubmatrixusingconveniencefunctionnp.ix_()lists, by creating an intermediatemeshobject.meshIn[64]:idx = np.ix_([1,3],[0,2,3])A[idx]Out[64]:array([[ 4, 6, 7],[12, 14, 15]])Alternatively, we can subset matrices efficiently using", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 74, "start_word": 23680, "end_word": 24080, "chunk_words": 400}}, "ISLP_website::c000075": {"text": "pair of lists must have the same length.However, that was not our intent, since we are looking for a submatrix.One easy way to do this is as follows. We first create a submatrix bysubsetting the rows ofA, and then on the fly we make a further submatrixby subsetting its columns.In[63]:A[[1,3]][:,[0,2]]Out[63]:array([[ 4, 6],[12, 14]])There are more efficient ways of achieving the same result.Theconvenience functionnp.ix_()allowsustoextractasubmatrixusingconveniencefunctionnp.ix_()lists, by creating an intermediatemeshobject.meshIn[64]:idx = np.ix_([1,3],[0,2,3])A[idx]Out[64]:array([[ 4, 6, 7],[12, 14, 15]])Alternatively, we can subset matrices efficiently using slices. The slice1:4:2captures the second and fourth items of a sequence, while the slice0:3:2captures the first and third items (the third element in a slice se-quence is the step size).In[65]:A[1:4:2,0:3:2]Out[65]:array([[ 4, 6],[12, 14]])Whyareweabletoretrieveasubmatrixdirectlyusingslicesbutnotusinglists? Its because they are differentPythontypes, and are treated differentlybynumpy. Slices can be used to extract objects from arbitrary sequences,such as strings, lists, and tuples, while the use of lists for indexing is morelimited.Boolean IndexingInnumpy,aBooleanis a type that equals eitherTrueorFalse(also rep-Booleanresented as1and0, respectively). The next line creates a vector of0’s,represented as Booleans, of length equal to the first dimension ofA.In[66]:keep_rows = np.zeros(A.shape[0], bool)keep_rowsOut[66]:array([False, False, False, False])We now set two of the elements toTrue.In[67]:keep_rows[[1,3]] = Truekeep_rows 54 2. Statistical LearningOut[67]:array([False, True, False, True])Note that the elements ofkeep_rows, when viewed as integers, are the sameasthe valuesofnp.array([0,1,0,1]).Below,weuse==toverifytheir equal-ity. When applied to two arrays, the==operation is applied elementwise.In[68]:np.all(keep_rows == np.array([0,1,0,1]))Out[68]:True(Here, the functionnp.all()has checked whether all entries of an arraynp.all()areTrue. A similar function,np.any(), can be used to check whether anynp.any()entries of an array areTrue.)However, even thoughnp.array([0,1,0,1])andkeep_rowsare equal ac-cording to==, they index different sets of rows! The former retrieves thefirst, second, first, and second rows ofA.In[69]:A[np.array([0,1,0,1])]Out[69]:array([[0, 1, 2, 3],[4, 5, 6, 7],[0, 1, 2, 3],[4, 5, 6, 7]])By contrast,keep_rowsretrieves only the second and fourth rows ofA—i.e. the rows for which the Boolean equalsTRUE.In[70]:A[keep_rows]Out[70]:array([[ 4, 5, 6, 7],[12, 13, 14, 15]])This example shows that Booleans and integers are treated differently bynumpy.We again make use of thenp.ix_()function to create a mesh containingthe second and fourth rows, and the first, third, and fourth columns. Thistime, we apply the function to Booleans, rather than lists.In[71]:keep_cols = np.zeros(A.shape[1], bool)keep_cols[[0, 2, 3]] = Trueidx_bool = np.ix_(keep_rows, keep_cols)A[idx_bool]Out[71]:array([[ 4, 6, 7],[12, 14, 15]])We can also mix a list with an array of Booleans in the arguments tonp.ix_():In[72]:idx_mixed = np.ix_([1,3], keep_cols)A[idx_mixed]Out[72]:array([[ 4, 6, 7],[12, 14, 15]])For more details on indexing innumpy, readers are referred to thenumpytutorial mentioned earlier. 2.3 Lab: Introduction to Python 552.3.7 Loading DataData sets often contain different types of", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 75, "start_word": 24000, "end_word": 24400, "chunk_words": 400}}, "ISLP_website::c000076": {"text": "and the first, third, and fourth columns. Thistime, we apply the function to Booleans, rather than lists.In[71]:keep_cols = np.zeros(A.shape[1], bool)keep_cols[[0, 2, 3]] = Trueidx_bool = np.ix_(keep_rows, keep_cols)A[idx_bool]Out[71]:array([[ 4, 6, 7],[12, 14, 15]])We can also mix a list with an array of Booleans in the arguments tonp.ix_():In[72]:idx_mixed = np.ix_([1,3], keep_cols)A[idx_mixed]Out[72]:array([[ 4, 6, 7],[12, 14, 15]])For more details on indexing innumpy, readers are referred to thenumpytutorial mentioned earlier. 2.3 Lab: Introduction to Python 552.3.7 Loading DataData sets often contain different types of data, and may have names as-sociated with the rows or columns. For these reasons, they typically arebest accommodated using adata frame. We can think of a data frame asdata framea sequence of arrays of identical length; these are the columns. Entries inthe different arrays can be combined to form a row. Thepandaslibrary canbe used to create and work with data frame objects.Reading in a Data SetThe first step of most analyses involves importing a data set intoPython.Before attempting to load a data set, we must make sure thatPythonknowswhere to find the file containing it. If the file is in the same location as thisnotebook file, then we are all set. Otherwise, the commandos.chdir()canos.chdir()be used tochange directory. (You will need to callimport osbefore callingos.chdir().)We will begin by reading inAuto.csv, available on the book website. Thisis a comma-separated file, and can be read in usingpd.read_csv():pd.read_csv()In[73]:import pandas as pdAuto = pd.read_csv('Auto.csv')AutoThe book website also has a whitespace-delimited version of this data,calledAuto.data. This can be read in as follows:In[74]:Auto = pd.read_csv('Auto.data',d e l i m _ w h i t e s p a c e = T r u e )BothAuto.csvandAuto.dataare simply text files. Before loading data intoPython, it is a good idea to view it using a text editor or other software,such as Microsoft Excel.We now take a look at the column ofAutocorresponding to the variablehorsepower:In[75]:Auto['horsepower']Out[75]:01 3 0 . 011 6 5 . 021 5 0 . 031 5 0 . 041 4 0 . 0...392 86.00393 52.00394 84.00395 79.00396 82.00Name: horsepower, Length: 397, dtype: objectWe see that thedtypeof this column isobject. It turns out that all valuesof thehorsepowercolumn were interpreted as strings when reading in thedata. We can find out why by looking at the unique values.In[76]:np.unique(Auto['horsepower']) 56 2. Statistical LearningTo save space, we have omitted the output of the previous code block. Wesee the culprit is the value?, which is being used to encode missing values.To fix the problem, we", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 76, "start_word": 24320, "end_word": 24720, "chunk_words": 400}}, "ISLP_website::c000077": {"text": "4 0 . 0...392 86.00393 52.00394 84.00395 79.00396 82.00Name: horsepower, Length: 397, dtype: objectWe see that thedtypeof this column isobject. It turns out that all valuesof thehorsepowercolumn were interpreted as strings when reading in thedata. We can find out why by looking at the unique values.In[76]:np.unique(Auto['horsepower']) 56 2. Statistical LearningTo save space, we have omitted the output of the previous code block. Wesee the culprit is the value?, which is being used to encode missing values.To fix the problem, we must providepd.read_csv()with an argumentcalledna_values. Now, each instance of?in the file is replaced with thevaluenp.nan, which meansnot a number:In[77]:Auto = pd.read_csv('Auto.data',na_values=['?'],delim_whitespace=True)Auto['horsepower'].sum()Out[77]:40952.0TheAuto.shapeattribute tells us that the data has 397 observations, orrows, and nine variables, or columns.In[78]:Auto.shapeOut[78]:(397, 9)There are various ways to deal with missing data. In this case, sinceonly five of the rows contain missing observations, we choose to use theAuto.dropna()method to simply remove these rows..dropna()In[79]:Auto_new = Auto.dropna()Auto_new.shapeOut[79]:(392, 9)Basics of Selecting Rows and ColumnsWe can useAuto.columnsto check the variable names.In[80]:Auto = Auto_new#o v e r w r i t et h ep r e v i o u sv a l u eAuto.columnsOut[80]:Index(['mpg','cylinders','displacement','horsepower','weight','acceleration','year','origin','name'],dtype='object')Accessing the rows and columns of a data frame is similar, but not iden-tical, to accessing the rows and columns of an array. Recall that the firstargument to the[]method is always applied to the rows of the array. Sim-ilarly, passing in a slice to the[]method creates a data frame whoserowsare determined by the slice:In[81]:Auto[:3]Out[81]:mpg cylinders displacement horsepower weight ...01 8 . 08307.0 130.0 3504.0 ...11 5 . 08350.0 165.0 3693.0 ...21 8 . 08318.0 150.0 3436.0 ...Similarly, an array of Booleans can be used to subset the rows: 2.3 Lab: Introduction to Python 57In[82]:idx_80 = Auto['year']>8 0Auto[idx_80]However, if we pass in a list of strings to the[]method, then we obtain adata frame containing the corresponding set ofcolumns.In[83]:Auto[['mpg','horsepower']]Out[83]:mpg horsepower01 8 . 0 1 3 0 . 011 5 . 0 1 6 5 . 021 8 . 0 1 5 0 . 0316.0 150.041 7 . 0 1 4 0 . 0... ... ...392 27.0 86.0393 44.0 52.0394 32.0 84.0395 28.0 79.0396 31.0 82.0392 rows x 2 columnsSince we did not specify anindexcolumn when we loaded our data frame,the rows are labeled using integers 0 to 396.In[84]:Auto.indexOut[84]:Int64Index([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,...387, 388, 389, 390, 391, 392, 393, 394, 395, 396],dtype='int64',l e n g t h = 3 9 2 )We can use theset_index()method to re-name", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 77, "start_word": 24640, "end_word": 25040, "chunk_words": 400}}, "ISLP_website::c000078": {"text": ". 0316.0 150.041 7 . 0 1 4 0 . 0... ... ...392 27.0 86.0393 44.0 52.0394 32.0 84.0395 28.0 79.0396 31.0 82.0392 rows x 2 columnsSince we did not specify anindexcolumn when we loaded our data frame,the rows are labeled using integers 0 to 396.In[84]:Auto.indexOut[84]:Int64Index([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,...387, 388, 389, 390, 391, 392, 393, 394, 395, 396],dtype='int64',l e n g t h = 3 9 2 )We can use theset_index()method to re-name the rows using the contents.set_index()ofAuto['name'].In[85]:Auto_re = Auto.set_index('name')Auto_reOut[85]:mpg cylinders displacement ...namechevrolet chevelle malibu 18.08307.0 ...buick skylark 32 15.08350.0 ...plymouth satellite 18.08318.0 ...amc rebel sst 16.08304.0 ...In[86]:Auto_re.columnsOut[86]:Index(['mpg','cylinders','displacement','horsepower','weight','acceleration','year','origin'],dtype='object')We see that the column'name'is no longer there.Now that the index has been set toname, we can access rows of the dataframe bynameusing theloc[]method ofAuto:.loc[] 58 2. Statistical LearningIn[87]:rows = ['amc rebel sst','ford torino']Auto_re.loc[rows]Out[87]:mpg cylinders displacement horsepower ...nameamc rebel sst 16.08304.0 150.0 ...ford torino 17.08302.0 140.0 ...As an alternative to using the index name, we could retrieve the 4th and5th rows ofAutousing theiloc[]method:.iloc[]In[88]:Auto_re.iloc[[3,4]]We can also use it to retrieve the 1st, 3rd and and 4th columns ofAuto_re:In[89]:Auto_re.iloc[:,[0,2,3]]We can extract the 4th and 5th rows, as well as the 1st, 3rd and 4thcolumns, using a single call toiloc[]:In[90]:Auto_re.iloc[[3,4],[0,2,3]]Out[90]:mpg displacement horsepowernameamc rebel sst 16.0304.0 150.0ford torino 17.0302.0 140.0Index entries need not be unique: there are several cars in the data framenamedford galaxie 500.In[91]:Auto_re.loc['ford galaxie 500',['mpg','origin']]Out[91]:mpg originnameford galaxie 500 15.01ford galaxie 500 14.01ford galaxie 500 14.01More on Selecting Rows and ColumnsSuppose now that we want to create a data frame consisting of theweightandoriginof the subset of cars withyeargreater than 80 — i.e. thosebuilt after 1980. To do this, we first create a Boolean array that indexesthe rows. Theloc[]method allows for Boolean entries as well as strings:In[92]:idx_80 = Auto_re['year']>8 0Auto_re.loc[idx_80, ['weight','origin']]To do this more concisely, we can use an anonymous function called alambda:lambdaIn[93]:Auto_re.loc[lambda df: df['year']>8 0 ,['weight','origin']]Thelambdacall creates a function that takes a single argument, heredf,and returnsdf['year']>80. Since it is created inside theloc[]method for 2.3 Lab: Introduction to Python 59the dataframeAuto_re, that dataframe will be the argument supplied. Asanother example of using alambda, suppose that we want all cars built after1980 that achieve greater than 30 miles per gallon:In[94]:Auto_re.loc[lambda df: (df['year']>8 0 )&( d f ['mpg']>3 0 ) ,['weight','origin']]The symbol&computes an element-wiseandoperation. As another ex-ample, suppose that we want to retrieve allFordandDatsuncars withdisplacementless than 300. We check whether eachnameentry containseither the stringfordordatsunusing thestr.contains()method of the.str.contains()indexattribute of of the dataframe:In[95]:Auto_re.loc[lambda df:", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 78, "start_word": 24960, "end_word": 25360, "chunk_words": 400}}, "ISLP_website::c000079": {"text": "created inside theloc[]method for 2.3 Lab: Introduction to Python 59the dataframeAuto_re, that dataframe will be the argument supplied. Asanother example of using alambda, suppose that we want all cars built after1980 that achieve greater than 30 miles per gallon:In[94]:Auto_re.loc[lambda df: (df['year']>8 0 )&( d f ['mpg']>3 0 ) ,['weight','origin']]The symbol&computes an element-wiseandoperation. As another ex-ample, suppose that we want to retrieve allFordandDatsuncars withdisplacementless than 300. We check whether eachnameentry containseither the stringfordordatsunusing thestr.contains()method of the.str.contains()indexattribute of of the dataframe:In[95]:Auto_re.loc[lambda df: (df['displacement']<3 0 0 )&( d f . i n d e x . s t r . c o n t a i n s ('ford')|d f . i n d e x . s t r . c o n t a i n s ('datsun')),['weight','origin']]Here, the symbol|computes an element-wiseoroperation.In summary, a powerful set of operations is available to index the rowsand columns of data frames. For integer based queries, use theiloc[]method. For string and Boolean selections, use theloc[]method. Forfunctional queries that filter rows, use theloc[]method with a function(typically alambda) in the rows argument.2.3.8 For LoopsAforloop is a standard tool in many languages that repeatedly evaluatesforsome chunk of code while varying different values inside the code. Forexample, suppose we loop over elements of a list and compute their sum.In[96]:total = 0for value in [3,2,19]:total += valueprint('Total is: {0}'.format(total))Total is: 24The indented code beneath the line with theforstatement is run for eachvalue in the sequence specified in theforstatement. The loop ends eitherwhen the cell ends or when code is indented at the same level as the originalforstatement. We see that the final line above which prints the total isexecuted only once after the for loop has terminated. Loops can be nestedby additional indentation.In[97]:total = 0for value in [2,3,19]:for weight in [3, 2, 1]:total += value * weightprint('Total is: {0}'.format(total))Total is: 144 60 2. Statistical LearningAbove, we summed over each combination ofvalueandweight. We alsotook advantage of theincrementnotation inPython: the expressiona += bincrementis equivalent toa=a+b. Besides being a convenient notation, this cansave time in computationally heavy tasks in which the intermediate valueofa+bneed not be explicitly created.Perhaps a more common task would be to sum over(value, weight)pairs. For instance, to compute the average value of a random variablethat takes on possible values 2, 3 or 19 with probability 0.2, 0.3, 0.5 respec-tively we would compute the weighted sum. Tasks such as this can often beaccomplished using thezip()function that loops over a sequence of", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 79, "start_word": 25280, "end_word": 25680, "chunk_words": 400}}, "ISLP_website::c000080": {"text": "bincrementis equivalent toa=a+b. Besides being a convenient notation, this cansave time in computationally heavy tasks in which the intermediate valueofa+bneed not be explicitly created.Perhaps a more common task would be to sum over(value, weight)pairs. For instance, to compute the average value of a random variablethat takes on possible values 2, 3 or 19 with probability 0.2, 0.3, 0.5 respec-tively we would compute the weighted sum. Tasks such as this can often beaccomplished using thezip()function that loops over a sequence of tuples.zip()In[98]:total = 0for value, weight in zip([2,3,19],[0.2,0.3,0.5]):total += weight * valueprint('Weighted average is: {0}'.format(total))Weighted average is: 10.8String FormattingIn the code chunk above we also printed a string displaying the total.However, the objecttotalis an integer and not a string. Inserting thevalue of something into a string is a common task, made simple using someof the powerful string formatting tools inPython. Many data cleaning tasksinvolve manipulating and programmatically producing strings.For example we may want to loop over the columns of a data frameand print the percent missing in each column. Let’s create a data frameDwith columns in which 20% of the entries are missing i.e. set tonp.nan.np.nanWe’ll create the values inDfrom a normal distribution with mean 0 andvariance 1 usingrng.standard_normal()and then overwrite some randomentries usingrng.choice().In[99]:rng = np.random.default_rng(1)A=r n g . s t a n d a r d _ n o r m a l ( ( 1 2 7 ,5 ) )M=r n g . c h o i c e ( [ 0 ,n p . n a n ] ,p = [ 0 . 8 , 0 . 2 ] ,s i z e = A . s h a p e )A+ =MD=p d . D a t a F r a m e ( A ,c o l u m n s = ['food','bar','pickle','snack','popcorn'])D[:3]Out[99]:food bar pickle snack popcorn00 . 3 4 5 5 8 40 . 8 2 1 6 1 8 0 . 3 3 0 4 3 7 - 1 . 3 0 3 1 5 7 N a N1N a N - 0 . 5 3 6 9 5 3 0 . 5 8 1 1 1 8 0 . 3 6 4 5 7 2 0 . 2 9 4 1 3 22N a N 0 . 5 4 6 7 1 3 N a N - 0 . 1 6 2 9 1 0 - 0 . 4 8 2 1 1", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 80, "start_word": 25600, "end_word": 26000, "chunk_words": 400}}, "ISLP_website::c000081": {"text": "4 3 7 - 1 . 3 0 3 1 5 7 N a N1N a N - 0 . 5 3 6 9 5 3 0 . 5 8 1 1 1 8 0 . 3 6 4 5 7 2 0 . 2 9 4 1 3 22N a N 0 . 5 4 6 7 1 3 N a N - 0 . 1 6 2 9 1 0 - 0 . 4 8 2 1 1 9In[100]:for col in D.columns:template ='Column \"{0}\" has {1:.2%} missing values'print(template.format(col,np.isnan(D[col]).mean())) 2.3 Lab: Introduction to Python 61 Column \"food\" has 16.54% missing values Column \"bar\"has 25.98% missing values Column \"pickle\" has 29.13% missing values Column \"snack\" has 21.26% missing values Column \"popcorn\" has 22.83% missing values We see that the template.format() method expects two arguments {0}and {1:.2%}, and the latter includes some formatting information. In particular, it specifies that the second argument should be expressed as a percent with two decimal digits. Thereference docs.python.org/3/library/string.html includesmanyhelp- ful and more complex examples. 2.3.9 Additional Graphical and Numerical Summaries We can use the ax.plot() orax.scatter() functions to display the quan- titative variables. However, simply typing the variable names will produce an error message, because Pythondoes not know to look in the Autodata set for those variables. In[101]: fig, ax = subplots(figsize=(8, 8)) ax.plot(horsepower, mpg, 'o'); NameError: name 'horsepower' is not defined We can address this by accessing the columns directly: In[102]: fig, ax = subplots(figsize=(8, 8)) ax.plot(Auto[ 'horsepower' ], Auto[ 'mpg'],'o'); Alternatively, we can use the plot()method with the call Auto.plot() . Us-.plot()ing this method, the variables can be accessed by name. The plot methods of a data frame return a familiar object: an axes. We can use it to update the plot as we did previously: In[103]: ax = Auto.plot.scatter( 'horsepower' ,'mpg'); ax.set_title( 'Horsepower vs. MPG' ) If we want to save the figure that contains a given axes, we can find the relevant figure by accessing the figureattribute: In[104]: fig = ax.figure fig.savefig( 'horsepower_mpg.png' ); Wecanfurtherinstructthedataframetoplottoaparticularaxesobject. In this case the corresponding plot()method will return the modified axes we passed in as an argument. Note that when we request a one-dimensional grid of plots, the object axesis similarly one-dimensional. We place our scatter plot in the middle plot of a row of three plots within a figure. In[105]: fig, axes = subplots(ncols=3, figsize=(15, 5)) Auto.plot.scatter( 'horsepower' ,'mpg',a x = a x e s", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 81, "start_word": 25920, "end_word": 26320, "chunk_words": 400}}, "ISLP_website::c000082": {"text": "relevant figure by accessing the figureattribute: In[104]: fig = ax.figure fig.savefig( 'horsepower_mpg.png' ); Wecanfurtherinstructthedataframetoplottoaparticularaxesobject. In this case the corresponding plot()method will return the modified axes we passed in as an argument. Note that when we request a one-dimensional grid of plots, the object axesis similarly one-dimensional. We place our scatter plot in the middle plot of a row of three plots within a figure. In[105]: fig, axes = subplots(ncols=3, figsize=(15, 5)) Auto.plot.scatter( 'horsepower' ,'mpg',a x = a x e s [ 1 ] ) ; Note also that the columns of a data frame can be accessed as attributes: try typing in Auto.horsepower . 62 2. Statistical LearningWenowconsiderthecylindersvariable.TypinginAuto.cylinders.dtypereveals that it is being treated as a quantitative variable. However, sincethere is only a small number of possible values for this variable, we maywish to treat it as qualitative. Below, we replace thecylinderscolumn witha categorical version ofAuto.cylinders. The functionpd.Series()owes itspd.Series()name to the fact thatpandasis often used in time series applications.In[106]:Auto.cylinders = pd.Series(Auto.cylinders, dtype='category')Auto.cylinders.dtypeNow thatcylindersis qualitative, we can display it using theboxplot().boxplot()method.In[107]:fig, ax = subplots(figsize=(8, 8))Auto.boxplot('mpg',b y ='cylinders',a x = a x ) ;Thehist()method can be used to plot ahistogram..hist()In[108]:fig, ax = subplots(figsize=(8, 8))Auto.hist('mpg',a x = a x ) ;The color of the bars and the number of bins can be changed:In[109]:fig, ax = subplots(figsize=(8, 8))Auto.hist('mpg',c o l o r ='red',b i n s = 1 2 ,a x = a x ) ;SeeAuto.hist?for more plotting options.We can use thepd.plotting.scatter_matrix()function to create ascat-pd.plotting.scatter_matrix()terplot matrixto visualize all of the pairwise relationships between thecolumns in a data frame.In[110]:pd.plotting.scatter_matrix(Auto);We can also produce scatterplots for a subset of the variables.In[111]:pd.plotting.scatter_matrix(Auto[['mpg','displacement','weight']]);Thedescribe()method produces a numerical summary of each column in.describe()a data frame.In[112]:Auto[['mpg','weight']].describe()We can also produce a summary of just a single column.In[113]:Auto['cylinders'].describe()Auto['mpg'].describe()To exitJupyter, selectFile / Close and Halt. 2.4 Exercises 632.4 ExercisesConceptual1. Foreachofparts(a)through(d),indicatewhetherwewouldgenerallyexpect the performance of a flexible statistical learning method to bebetter or worse than an inflexible method. Justify your answer.(a) The sample sizenis extremely large, and the number of predic-torspis small.(b) The number of predictorspis extremely large, and the numberof observationsnis small.(c) The relationship between the predictors and response is highlynon-linear.(d) The variance of the error terms, i.e.σ2=Var(/epsilon1), is extremelyhigh.2. Explain whether each scenario is a classification or regression prob-lem, and indicate whether we are most interested in inference or pre-diction. Finally, providenandp.(a) We collect a set of data on the top 500 firms in the US. For eachfirm we record profit, number of employees, industry and", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 82, "start_word": 26240, "end_word": 26640, "chunk_words": 400}}, "ISLP_website::c000083": {"text": "number of predic-torspis small.(b) The number of predictorspis extremely large, and the numberof observationsnis small.(c) The relationship between the predictors and response is highlynon-linear.(d) The variance of the error terms, i.e.σ2=Var(/epsilon1), is extremelyhigh.2. Explain whether each scenario is a classification or regression prob-lem, and indicate whether we are most interested in inference or pre-diction. Finally, providenandp.(a) We collect a set of data on the top 500 firms in the US. For eachfirm we record profit, number of employees, industry and theCEO salary. We are interested in understanding which factorsaffect CEO salary.(b) We are considering launching a new product and wish to knowwhether it will be asuccessor afailure. We collect data on 20similar products that were previously launched. For each prod-uct we have recorded whether it was a success or failure, pricecharged for the product, marketing budget, competition price,and ten other variables.(c) We are interested in predicting the % change in the USD/Euroexchange rate in relation to the weekly changes in the worldstock markets. Hence we collect weekly data for all of 2012. Foreach week we record the % change in the USD/Euro, the %change in the US market, the % change in the British market,and the % change in the German market.3. We now revisit the bias-variance decomposition.(a) Provide a sketch of typical (squared) bias, variance, training er-ror, test error, and Bayes (or irreducible) error curves, on a sin-gle plot, as we go from less flexible statistical learning methodstowards more flexible approaches. Thex-axis should representthe amount of flexibility in the method, and they-axis shouldrepresent the values for each curve. There should be five curves.Make sure to label each one.(b) Explain why each of the five curves has the shape displayed inpart (a). 64 2. Statistical Learning4. You will now think of some real-life applications for statistical learn-ing.(a) Describe three real-life applications in whichclassificationmightbe useful. Describe the response, as well as the predictors. Is thegoal of each application inference or prediction? Explain youranswer.(b) Describe three real-life applications in whichregressionmightbe useful. Describe the response, as well as the predictors. Is thegoal of each application inference or prediction? Explain youranswer.(c) Describe three real-life applications in whichcluster analysismight be useful.5. What are the advantages and disadvantages of a very flexible (versusa less flexible) approach for regression or classification? Under whatcircumstances might a more flexible approach be preferred to a lessflexible approach? When might a less flexible approach be preferred?6. Describe the differences between a", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 83, "start_word": 26560, "end_word": 26960, "chunk_words": 400}}, "ISLP_website::c000084": {"text": "Explain youranswer.(b) Describe three real-life applications in whichregressionmightbe useful. Describe the response, as well as the predictors. Is thegoal of each application inference or prediction? Explain youranswer.(c) Describe three real-life applications in whichcluster analysismight be useful.5. What are the advantages and disadvantages of a very flexible (versusa less flexible) approach for regression or classification? Under whatcircumstances might a more flexible approach be preferred to a lessflexible approach? When might a less flexible approach be preferred?6. Describe the differences between a parametric and a non-parametricstatistical learning approach. What are the advantages of a para-metric approach to regression or classification (as opposed to a non-parametric approach)? What are its disadvantages?7. The table below provides a training data set containing six observa-tions, three predictors, and one qualitative response variable.Obs.X1X2X3Y1030Red2200Red3013Red4012Green5−101Green6111RedSuppose we wish to use this data set to make a prediction forYwhenX1=X2=X3=0usingK-nearest neighbors.(a) Compute the Euclidean distance between each observation andthe test point,X1=X2=X3=0.(b) What is our prediction withK=1? Why?(c) What is our prediction withK=3? Why?(d) If the Bayes decision boundary in this problem is highly non-linear, then would we expect thebestvalue forKto be large orsmall? Why? 2.4 Exercises 65Applied8. This exercise relates to theCollegedata set, which can be found inthe fileCollege.csvon the book website. It contains a number ofvariables for 777 different universities and colleges in the US. Thevariables are•Private: Public/private indicator•Apps: Number of applications received•Accept: Number of applicants accepted•Enroll: Number of new students enrolled•Top10perc: New students from top 10% of high school class•Top25perc: New students from top 25% of high school class•F.Undergrad: Number of full-time undergraduates•P.Undergrad: Number of part-time undergraduates•Outstate: Out-of-state tuition•Room.Board: Room and board costs•Books: Estimated book costs•Personal: Estimated personal spending•PhD: Percent of faculty with Ph.D.s•Terminal: Percent of faculty with terminal degree•S.F.Ratio: Student/faculty ratio•perc.alumni: Percent of alumni who donate•Expend: Instructional expenditure per student•Grad.Rate: Graduation rateBefore reading the data intoPython, it can be viewed in Excel or atext editor.(a) Usethepd.read_csv()functiontoreadthedataintoPython.Callthe loaded datacollege. Make sure that you have the directoryset to the correct location for the data.(b) Look at the data used in the notebook by creating and runninga new cell with just the codecollegein it. You should noticethat the first column is just the name of each university in acolumn named something likeUnnamed: 0. We don’t really wantpandasto treat this as data. However, it may be handy to havethese names for later. Try the following commands and similarlylook at the resulting data frames:college2 = pd.read_csv('College.csv',i n d e x _ c o l", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 84, "start_word": 26880, "end_word": 27280, "chunk_words": 400}}, "ISLP_website::c000085": {"text": "for the data.(b) Look at the data used in the notebook by creating and runninga new cell with just the codecollegein it. You should noticethat the first column is just the name of each university in acolumn named something likeUnnamed: 0. We don’t really wantpandasto treat this as data. However, it may be handy to havethese names for later. Try the following commands and similarlylook at the resulting data frames:college2 = pd.read_csv('College.csv',i n d e x _ c o l = 0 )college3 = college.rename({'Unnamed: 0':'College'},axis=1)college3 = college3.set_index('College') 66 2. Statistical LearningThis has used the first column in the file as anindexfor thedata frame. This means thatpandashas given each row a namecorresponding to the appropriate university. Now you should seethat the first data column isPrivate. Note that the names ofthe colleges appear on the left of the table. We also introduceda new python object above: adictionary, which is specified bydictionary(key, value)pairs. Keep your modified version of the data withthe following:college = college3(c) Use thedescribe()method of to produce a numerical summaryof the variables in the data set.(d) Use thepd.plotting.scatter_matrix()function to produce ascatterplotmatrixofthefirstcolumns[Top10perc, Apps, Enroll].Recall that you can reference a listCof columns of a data frameAusingA[C].(e) Use theboxplot()method ofcollegeto produce side-by-sideboxplots ofOutstateversusPrivate.(f) Create a new qualitative variable, calledElite,b ybinningtheTop10percvariable into two groups based on whether or not theproportion of students coming from the top 10% of their highschool classes exceeds 50%.college['Elite']=p d . c u t ( c o l l e g e ['Top10perc'],[0,0.5,1],labels=['No','Yes'])Use thevalue_counts()method ofcollege['Elite']to see howmanyeliteuniversitiesthereare.Finally,usetheboxplot()methodagain to produce side-by-side boxplots ofOutstateversusElite.(g) Use theplot.hist()method ofcollegeto produce some his-tograms with differing numbers of bins for a few of the quanti-tative variables. The commandplt.subplots(2, 2)may be use-ful: it will divide the plot window into four regions so that fourplots can be made simultaneously. By changing the argumentsyou can divide the screen up in other combinations.(h) Continue exploring the data, and provide a brief summary ofwhat you discover.9. This exercise involves theAutodata set studied in the lab. Make surethat the missing values have been removed from the data.(a) Which of the predictors are quantitative, and which are quali-tative?(b) What is therangeof each quantitative predictor? You can an-swer this using themin()andmax()methods innumpy..min().max()(c) What is the mean and standard deviation of each quantitativepredictor? 2.4 Exercises 67(d) Now remove the 10th through 85th observations. What is therange, mean, and standard deviation of each predictor in thesubset of the data that remains?(e) Using the full data set,", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 85, "start_word": 27200, "end_word": 27600, "chunk_words": 400}}, "ISLP_website::c000086": {"text": "studied in the lab. Make surethat the missing values have been removed from the data.(a) Which of the predictors are quantitative, and which are quali-tative?(b) What is therangeof each quantitative predictor? You can an-swer this using themin()andmax()methods innumpy..min().max()(c) What is the mean and standard deviation of each quantitativepredictor? 2.4 Exercises 67(d) Now remove the 10th through 85th observations. What is therange, mean, and standard deviation of each predictor in thesubset of the data that remains?(e) Using the full data set, investigate the predictors graphically,usingscatterplotsorothertoolsofyourchoice.Createsomeplotshighlighting the relationships among the predictors. Commenton your findings.(f) Suppose that we wish to predict gas mileage (mpg) on the basisof the other variables. Do your plots suggest that any of theother variables might be useful in predictingmpg? Justify youranswer.10. This exercise involves theBostonhousing data set.(a) To begin, load in theBostondata set, which is part of theISLPlibrary.(b) How many rows are in this data set? How many columns? Whatdo the rows and columns represent?(c) Make some pairwise scatterplots of the predictors (columns) inthis data set. Describe your findings.(d) Are any of the predictors associated with per capita crime rate?If so, explain the relationship.(e) Do any of the suburbs of Boston appear to have particularlyhigh crime rates? Tax rates? Pupil-teacher ratios? Comment onthe range of each predictor.(f) How many of the suburbs in this data set bound the Charlesriver?(g) What is the median pupil-teacher ratio among the towns in thisdata set?(h) Which suburb of Boston has lowest median value of owner-occupied homes? What are the values of the other predictorsfor that suburb, and how do those values compare to the overallranges for those predictors? Comment on your findings.(i) In this data set, how many of the suburbs average more thanseven rooms per dwelling? More than eight rooms per dwelling?Comment on the suburbs that average more than eight roomsper dwelling. 3 Linear Regression This chapter is about linear regression , a very simple approach for super- vised learning. In particular, linear regression is a useful tool for predicting a quantitative response. It has been around for a long time and is the topic of innumerable textbooks. Though it may seem somewhat dull compared to some of the more modern statistical learning approaches described in later chapters of this book, linear regression is still a useful and widely used sta- tistical learning method. Moreover, it serves as a good jumping-off point for newer approaches: as we will see in later", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 86, "start_word": 27520, "end_word": 27920, "chunk_words": 400}}, "ISLP_website::c000087": {"text": "particular, linear regression is a useful tool for predicting a quantitative response. It has been around for a long time and is the topic of innumerable textbooks. Though it may seem somewhat dull compared to some of the more modern statistical learning approaches described in later chapters of this book, linear regression is still a useful and widely used sta- tistical learning method. Moreover, it serves as a good jumping-off point for newer approaches: as we will see in later chapters, many fancy statistical learning approaches can be seen as generalizations or extensions of linear regression. Consequently, the importance of having a good understanding of linear regression before studying more complex learning methods cannot be overstated. In this chapter, we review some of the key ideas underlying the linear regression model, as well as the least squares approach that is most commonly used to fit this model. Recall the Advertising data from Chapter 2. Figure 2.1displays sales (in thousands of units) for a particular product as a function of advertis- ing budgets (in thousands of dollars) for TV,radio, andnewspaper media. Suppose that in our role as statistical consultants we are asked to suggest, on the basis of this data, a marketing plan for next year that will result in high product sales. What information would be useful in order to provide such a recommendation? Here are a few important questions that we might seek to address: 1.Is there a relationship between advertising budget and sales? Our first goal should be to determine whether the data provide evi- dence of an association between advertising expenditure and sales. If the evidence is weak, then one might argue that no money should be spent on advertising! © Springer Nature Switzerland AG 2023 G. James et al., An Introduction to Statistical Learning , Springer Texts in Statistics, https://doi.org/10.1007/978-3-031-38747-0_3 69 70 3. Linear Regression 2.How strong is the relationship between advertising budget and sales? Assuming that there is a relationship between advertising and sales, we would like to know the strength of this relationship. Does knowl- edge of the advertising budget provide a lot of information about product sales? 3.Which media are associated with sales? Are all three media—TV, radio, and newspaper—associated with sales, or are just one or two of the media associated? To answer this question, we must find a way to separate out the individual contribu- tion of each medium to sales", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 87, "start_word": 27840, "end_word": 28240, "chunk_words": 400}}, "ISLP_website::c000088": {"text": "that there is a relationship between advertising and sales, we would like to know the strength of this relationship. Does knowl- edge of the advertising budget provide a lot of information about product sales? 3.Which media are associated with sales? Are all three media—TV, radio, and newspaper—associated with sales, or are just one or two of the media associated? To answer this question, we must find a way to separate out the individual contribu- tion of each medium to sales when we have spent money on all three media. 4.How large is the association between each medium and sales? For every dollar spent on advertising in a particular medium, by what amount will sales increase? How accurately can we predict this amount of increase? 5.How accurately can we predict future sales? Foranygivenleveloftelevision,radio,ornewspaperadvertising,what isourpredictionforsales,andwhatistheaccuracyofthisprediction? 6.Is the relationship linear? Ifthereisapproximatelyastraight-linerelationshipbetweenadvertis- ing expenditure in the various media and sales, then linear regression is an appropriate tool. If not, then it may still be possible to trans- form the predictor or the response so that linear regression can be used. 7.Is there synergy among the advertising media? Perhapsspending $50,000ontelevisionadvertisingand $50,000onra- dioadvertisingisassociatedwithhighersalesthanallocating $100 ,000 to either television or radio individually. In marketing, this is known as asynergyeffect, while in statistics it is called an interaction effect.synergy interactionIt turns out that linear regression can be used to answer each of these questions. We will first discuss all of these questions in a general context, and then return to them in this specific context in Section 3.4. 3.1 Simple Linear Regression Simple linear regression lives up to its name: it is a very straightforwardsimple linear regressionapproach for predicting a quantitative response Yon the basis of a sin- gle predictor variable X. It assumes that there is approximately a linear relationship between XandY. Mathematically, we can write this linear relationship as Y≈β0+β1X. (3.1) You might read “ ≈” as“is approximately modeled as” . We will sometimes describe ( 3.1) by saying that we are regressing YonX(orYontoX). 3.1 Simple Linear Regression 71 For example, Xmay represent TVadvertising and Ymay represent sales. Then we can regress salesontoTVby fitting the model sales ≈β0+β1×TV. In Equation 3.1,β0andβ1are two unknown constants that represent theintercept andslopeterms in the linear model. Together, β0andβ1areintercept slopeknown as the model coefficients orparameters . Once we have used our coefficient parametertraining data to produce estimates ˆβ0andˆβ1for the model coefficients, we can predict future sales on the basis of a", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 88, "start_word": 28160, "end_word": 28560, "chunk_words": 400}}, "ISLP_website::c000089": {"text": "3.1) by saying that we are regressing YonX(orYontoX). 3.1 Simple Linear Regression 71 For example, Xmay represent TVadvertising and Ymay represent sales. Then we can regress salesontoTVby fitting the model sales ≈β0+β1×TV. In Equation 3.1,β0andβ1are two unknown constants that represent theintercept andslopeterms in the linear model. Together, β0andβ1areintercept slopeknown as the model coefficients orparameters . Once we have used our coefficient parametertraining data to produce estimates ˆβ0andˆβ1for the model coefficients, we can predict future sales on the basis of a particular value of TV advertising by computing ˆy=ˆβ0+ˆβ1x, (3.2) whereˆyindicates a prediction of Yon the basis of X=x. Here we use a hatsymbol, ˆ, to denote the estimated value for an unknown parameter or coefficient, or to denote the predicted value of the response. 3.1.1 Estimating the Coefficients In practice, β0andβ1are unknown. So before we can use ( 3.1) to make predictions, we must use data to estimate the coefficients. Let (x1,y1),(x2,y2),..., (xn,yn) represent nobservation pairs, each of which consists of a measurement of Xand a measurement of Y. In the Advertising example, this data set con- sists of the TV advertising budget and product sales in n= 200 different markets. (Recall that the data are displayed in Figure 2.1.) Our goal is to obtain coefficient estimates ˆβ0andˆβ1such that the linear model ( 3.1) fits the available data well—that is, so that yi≈ˆβ0+ˆβ1xifori=1,...,n . In other words, we want to find an intercept ˆβ0and a slope ˆβ1such that the resulting line is as close as possible to the n= 200 data points. There are a number of ways of measuring closeness . However, by far the most com- mon approach involves minimizing the least squares criterion, and we takeleast squaresthat approach in this chapter. Alternative approaches will be considered in Chapter 6. Letˆyi=ˆβ0+ˆβ1xibe the prediction for Ybased on the ith value of X. Thenei=yi−ˆyirepresents the ithresidual—this is the difference betweenresidualtheith observed response value and the ith response value that is predicted by our linear model. We define the residual sum of squares (RSS) asresidual sum of squaresRSS = e2 1+e2 2+···+e2 n, or equivalently as RSS = ( y1−ˆβ0−ˆβ1x1)2+(y2−ˆβ0−ˆβ1x2)2+···+(yn−ˆβ0−ˆβ1xn)2.(3.3) The least squares approach chooses ˆβ0andˆβ1to minimize the RSS. Using some calculus, one can show that the minimizers are ˆβ1=/summationtextn i=1(xi−¯x)(yi−¯y)/summationtextn i=1(xi−¯x)2, ˆβ0=¯y−ˆβ1¯x,(3.4) 72 3. Linear Regression 0 50 100 150 200 250 3005 10 15 20 25TVSales FIGURE 3.1. For theAdvertising data, the least squares fit for the regression ofsalesontoTVis", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 89, "start_word": 28480, "end_word": 28880, "chunk_words": 400}}, "ISLP_website::c000090": {"text": "predicted by our linear model. We define the residual sum of squares (RSS) asresidual sum of squaresRSS = e2 1+e2 2+···+e2 n, or equivalently as RSS = ( y1−ˆβ0−ˆβ1x1)2+(y2−ˆβ0−ˆβ1x2)2+···+(yn−ˆβ0−ˆβ1xn)2.(3.3) The least squares approach chooses ˆβ0andˆβ1to minimize the RSS. Using some calculus, one can show that the minimizers are ˆβ1=/summationtextn i=1(xi−¯x)(yi−¯y)/summationtextn i=1(xi−¯x)2, ˆβ0=¯y−ˆβ1¯x,(3.4) 72 3. Linear Regression 0 50 100 150 200 250 3005 10 15 20 25TVSales FIGURE 3.1. For theAdvertising data, the least squares fit for the regression ofsalesontoTVis shown. The fit is found by minimizing the residual sum of squares. Each grey line segment represents a residual. In this case a linear fit captures the essence of the relationship, although it overestimates the trend in the left of the plot. where¯y≡1 n/summationtextn i=1yiand¯x≡1 n/summationtextn i=1xiare the sample means. In other words, (3.4) defines the least squares coefficient estimates for simple linear regression. Figure3.1displays the simple linear regression fit to the Advertising data, where ˆβ0=7.03andˆβ1=0.0475 . In other words, according to this approximation, an additional $1,000spent on TV advertising is asso- ciated with selling approximately 47.5additional units of the product. In Figure3.2, we have computed RSS for a number of values of β0andβ1, using the advertising data with salesas the response and TVas the predic- tor. In each plot, the red dot represents the pair of least squares estimates (ˆβ0,ˆβ1)given by ( 3.4). These values clearly minimize the RSS. 3.1.2 Assessing the Accuracy of the Coefficient Estimates Recall from ( 2.1) that we assume that the truerelationship between Xand Ytakes the form Y=f(X)+/epsilon1for some unknown function f, where/epsilon1 is a mean-zero random error term. If fis to be approximated by a linear function, then we can write this relationship as Y=β0+β1X+/epsilon1. (3.5) Hereβ0istheinterceptterm—thatis,theexpectedvalueof YwhenX=0, andβ1is the slope—the average increase in Yassociated with a one-unit increase in X. The error term is a catch-all for what we miss with this simple model: the true relationship is probably not linear, there may be other variables that cause variation in Y, and there may be measurement error. We typically assume that the error term is independent of X. 3.1 Simple Linear Regression 73 FIGURE 3.2. Contour and three-dimensional plots of the RSS on the Advertising data, using salesas the response and TVas the predictor. The red dots correspond to the least squares estimates ˆβ0andˆβ1, given by ( 3.4). The model given by ( 3.5) defines the population regression line , whichpopulation regression", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 90, "start_word": 28800, "end_word": 29200, "chunk_words": 400}}, "ISLP_website::c000091": {"text": "may be other variables that cause variation in Y, and there may be measurement error. We typically assume that the error term is independent of X. 3.1 Simple Linear Regression 73 FIGURE 3.2. Contour and three-dimensional plots of the RSS on the Advertising data, using salesas the response and TVas the predictor. The red dots correspond to the least squares estimates ˆβ0andˆβ1, given by ( 3.4). The model given by ( 3.5) defines the population regression line , whichpopulation regression lineis the best linear approximation to the true relationship between Xand Y.1The least squares regression coefficient estimates ( 3.4) characterize the least squares line (3.2). The left-hand panel of Figure 3.3displays theseleast squares linetwo lines in a simple simulated example. We created 100randomXs, and generated 100corresponding Ys from the model Y=2+3 X+/epsilon1, (3.6) where/epsilon1was generated from a normal distribution with mean zero. The red line in the left-hand panel of Figure 3.3displays the truerelationship, f(X)=2 + 3 X, while the blue line is the least squares estimate based on the observed data. The true relationship is generally not known for real data, but the least squares line can always be computed using the coefficient estimates given in ( 3.4). In other words, in real applications, we have access to a set of observations from which we can compute the least squares line; however, the population regression line is unobserved. In the right-hand panel of Figure 3.3we have generated ten different data sets from the model given by ( 3.6) and plotted the corresponding ten least squares lines. Notice that different data sets generated from the same true model result in slightly different least squares lines, but the unobserved population regression line does not change. At first glance, the difference between the population regression line and the least squares line may seem subtle and confusing. We only have one data set, and so what does it mean that two different lines describe the relationship between the predictor and the response? Fundamentally, the concept of these two lines is a natural extension of the standard statistical approachofusinginformationfromasampletoestimatecharacteristicsofa large population. For example, suppose that we are interested in knowing 1The assumption of linearity is often a useful working model. However, despite what many textbooks might tell us, we seldom believe that the true relationship is linear.β0β1 2.11 2.15 2.2 2.3 2.5 2.5 3 3 567890.03 0.04 0.05 0.06RSSβ1β0 74 3. Linear Regression −2", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 91, "start_word": 29120, "end_word": 29520, "chunk_words": 400}}, "ISLP_website::c000092": {"text": "describe the relationship between the predictor and the response? Fundamentally, the concept of these two lines is a natural extension of the standard statistical approachofusinginformationfromasampletoestimatecharacteristicsofa large population. For example, suppose that we are interested in knowing 1The assumption of linearity is often a useful working model. However, despite what many textbooks might tell us, we seldom believe that the true relationship is linear.β0β1 2.11 2.15 2.2 2.3 2.5 2.5 3 3 567890.03 0.04 0.05 0.06RSSβ1β0 74 3. Linear Regression −2 −1 0 1 2−10 −5 0 5 10XY −2 −1 0 1 2−10 −5 0 5 10XY FIGURE 3.3. A simulated data set. Left:The red line represents the true relationship, f(X)=2+3 X, which is known as the population regression line. The blue line is the least squares line; it is the least squares estimate for f(X) based on the observed data, shown in black. Right:The population regression line is again shown in red, and the least squares line in dark blue. In light blue, ten least squares lines are shown, each computed on the basis of a separate random set of observations. Each least squares line is different, but on average, the least squares lines are quite close to the population regression line. the population mean µof some random variable Y. Unfortunately, µis unknown, but we do have access to nobservations from Y,y1,...,y n, which we can use to estimate µ. A reasonable estimate is ˆµ=¯y, where ¯y=1 n/summationtextn i=1yiis the sample mean. The sample mean and the population mean are different, but in general the sample mean will provide a good estimate of the population mean. In the same way, the unknown coefficients β0andβ1in linear regression define the population regression line. We seek to estimate these unknown coefficients using ˆβ0andˆβ1given in ( 3.4). These coefficient estimates define the least squares line. The analogy between linear regression and estimation of the mean of a random variable is an apt one based on the concept of bias. If we use thebiassample mean ˆµto estimate µ, this estimate is unbiased, in the sense thatunbiasedon average, we expect ˆµto equalµ. What exactly does this mean? It means that on the basis of one particular set of observations y1,...,y n,ˆµmight overestimate µ, and on the basis of another set of observations, ˆµmight underestimate µ. But if we could average a huge number of estimates of µobtained from a huge number of sets of observations,", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 92, "start_word": 29440, "end_word": 29840, "chunk_words": 400}}, "ISLP_website::c000093": {"text": "based on the concept of bias. If we use thebiassample mean ˆµto estimate µ, this estimate is unbiased, in the sense thatunbiasedon average, we expect ˆµto equalµ. What exactly does this mean? It means that on the basis of one particular set of observations y1,...,y n,ˆµmight overestimate µ, and on the basis of another set of observations, ˆµmight underestimate µ. But if we could average a huge number of estimates of µobtained from a huge number of sets of observations, then this average wouldexactlyequalµ.Hence,anunbiasedestimatordoesnot systematically over- or under-estimate the true parameter. The property of unbiasedness holds for the least squares coefficient estimates given by ( 3.4) as well: if we estimate β0andβ1on the basis of a particular data set, then our estimates won’t be exactly equal to β0andβ1. But if we could average the estimates obtained over a huge number of data sets, then the average of these estimates would be spot on! In fact, we can see from the right- hand panel of Figure 3.3that the average of many least squares lines, each 3.1 Simple Linear Regression 75 estimated from a separate data set, is pretty close to the true population regression line. We continue the analogy with the estimation of the population mean µof a random variable Y. A natural question is as follows: how accurate is the sample mean ˆµas an estimate of µ? We have established that the average of ˆµ’s over many data sets will be very close to µ, but that a single estimate ˆµmay be a substantial underestimate or overestimate of µ. How far off will that single estimate of ˆµbe? In general, we answer this question by computing the standard error ofˆµ, written as SE(ˆµ). We havestandard errorthe well-known formula Var(ˆµ) = SE(ˆ µ)2=σ2 n, (3.7) whereσis the standard deviation of each of the realizations yiofY.2 Roughly speaking, the standard error tells us the average amount that this estimate ˆµdiffers from the actual value of µ. Equation 3.7also tells us how this deviation shrinks with n—the more observations we have, the smaller the standard error of ˆµ. In a similar vein, we can wonder how close ˆβ0 andˆβ1are to the true values β0andβ1. To compute the standard errors associated with ˆβ0andˆβ1, we use the following formulas: SE(ˆβ0)2=σ2/bracketleftbigg1 n+¯x2 /summationtextn i=1(xi−¯x)2/bracketrightbigg ,SE(ˆβ1)2=σ2 /summationtextn i=1(xi−¯x)2,(3.8) whereσ2=Var(/epsilon1). For these formulas to be strictly valid, we need to assumethattheerrors /epsilon1iforeachobservationhavecommonvariance σ2and are uncorrelated. This is clearly", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 93, "start_word": 29760, "end_word": 30160, "chunk_words": 400}}, "ISLP_website::c000094": {"text": "actual value of µ. Equation 3.7also tells us how this deviation shrinks with n—the more observations we have, the smaller the standard error of ˆµ. In a similar vein, we can wonder how close ˆβ0 andˆβ1are to the true values β0andβ1. To compute the standard errors associated with ˆβ0andˆβ1, we use the following formulas: SE(ˆβ0)2=σ2/bracketleftbigg1 n+¯x2 /summationtextn i=1(xi−¯x)2/bracketrightbigg ,SE(ˆβ1)2=σ2 /summationtextn i=1(xi−¯x)2,(3.8) whereσ2=Var(/epsilon1). For these formulas to be strictly valid, we need to assumethattheerrors /epsilon1iforeachobservationhavecommonvariance σ2and are uncorrelated. This is clearly not true in Figure 3.1, but the formula still turns out to be a good approximation. Notice in the formula that SE(ˆβ1)is smaller when the xiare more spread out; intuitively we have more leverage to estimate a slope when this is the case. We also see that SE(ˆβ0)would be the same as SE(ˆµ)if¯xwere zero (in which case ˆβ0would be equal to ¯y). In general,σ2isnotknown,butcanbeestimatedfromthedata.Thisestimate ofσis known as the residual standard error , and is given by the formularesidual standard errorRSE =/radicalbig RSS/(n−2). Strictly speaking, when σ2is estimated from the data we should write /hatwiderSE(ˆβ1)to indicate that an estimate has been made, but for simplicity of notation we will drop this extra “hat”. Standard errors can be used to compute confidence intervals . A 95%confidence intervalconfidence interval is defined as a range of values such that with 95% probability, the range will contain the true unknown value of the param- eter. The range is defined in terms of lower and upper limits computed from the sample of data. A 95% confidence interval has the following prop- erty: if we take repeated samples and construct the confidence interval for each sample, 95% of the intervals will contain the true unknown value of the parameter. For linear regression, the 95% confidence interval for β1 approximately takes the form ˆβ1±2·SE(ˆβ1). (3.9) 2This formula holds provided that the nobservations are uncorrelated. 76 3. Linear Regression That is, there is approximately a 95% chance that the interval /bracketleftBig ˆβ1−2·SE(ˆβ1),ˆβ1+2·SE(ˆβ1)/bracketrightBig (3.10) will contain the true value of β1.3Similarly, a confidence interval for β0 approximately takes the form ˆβ0±2·SE(ˆβ0). (3.11) In the case of the advertising data, the 95% confidence interval for β0 is[6.130,7.935] and the 95% confidence interval for β1is[0.042,0.053]. Therefore,wecanconcludethatintheabsenceofanyadvertising,saleswill, on average, fall somewhere between 6,130and7,935units. Furthermore, for each $1,000increase in television advertising, there will be an average increase in sales of between 42and53units. Standard errors can also be used to perform hypothesis tests on thehypothesis", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 94, "start_word": 30080, "end_word": 30480, "chunk_words": 400}}, "ISLP_website::c000095": {"text": "interval /bracketleftBig ˆβ1−2·SE(ˆβ1),ˆβ1+2·SE(ˆβ1)/bracketrightBig (3.10) will contain the true value of β1.3Similarly, a confidence interval for β0 approximately takes the form ˆβ0±2·SE(ˆβ0). (3.11) In the case of the advertising data, the 95% confidence interval for β0 is[6.130,7.935] and the 95% confidence interval for β1is[0.042,0.053]. Therefore,wecanconcludethatintheabsenceofanyadvertising,saleswill, on average, fall somewhere between 6,130and7,935units. Furthermore, for each $1,000increase in television advertising, there will be an average increase in sales of between 42and53units. Standard errors can also be used to perform hypothesis tests on thehypothesis testcoefficients. The most common hypothesis test involves testing the null hypothesis ofnull hypothesisH0:There is no relationship between XandY (3.12) versus the alternative hypothesisalternative hypothesisHa:There is some relationship between XandY. (3.13) Mathematically, this corresponds to testing H0:β1=0 versus Ha:β1/negationslash=0, since ifβ1=0 then the model ( 3.5) reduces to Y=β0+/epsilon1, andXis not associated with Y. To test the null hypothesis, we need to determine whether ˆβ1, our estimate for β1, is sufficiently far from zero that we can be confident that β1is non-zero. How far is far enough? This of course depends on the accuracy of ˆβ1—that is, it depends on SE(ˆβ1). IfSE(ˆβ1)is small, then even relatively small values of ˆβ1may provide strong evidence thatβ1/negationslash=0, and hence that there is a relationship between XandY. In contrast, if SE(ˆβ1)is large, then ˆβ1must be large in absolute value in order for us to reject the null hypothesis. In practice, we compute a t-statistic ,t-statisticgiven by t=ˆβ1−0 SE(ˆβ1), (3.14) 3Approximately for several reasons. Equation 3.10relies on the assumption that the errors are Gaussian. Also, the factor of 2in front of the SE(ˆβ1)term will vary slightly depending on the number of observations nin the linear regression. To be precise, rather than the number 2, ( 3.10) should contain the 97.5% quantile of a t-distribution with n−2degrees of freedom. Details of how to compute the 95% confidence interval precisely inRwill be provided later in this chapter. 3.1 Simple Linear Regression 77 Coefficient Std. error t-statistic p-value Intercept 7.0325 0.4578 15.36 <0.0001 TV 0.0475 0.0027 17.67 <0.0001 TABLE 3.1. For theAdvertising data, coefficients of the least squares model for the regression of number of units sold on TV advertising budget. An increase of$1,000in the TV advertising budget is associated with an increase in sales by around 50 units. (Recall that the salesvariable is in thousands of units, and the TVvariable is in thousands of dollars.) whichmeasuresthenumberofstandarddeviationsthat ˆβ1isawayfrom 0.If there really is no relationship between XandY, then we expect", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 95, "start_word": 30400, "end_word": 30800, "chunk_words": 400}}, "ISLP_website::c000096": {"text": "7.0325 0.4578 15.36 <0.0001 TV 0.0475 0.0027 17.67 <0.0001 TABLE 3.1. For theAdvertising data, coefficients of the least squares model for the regression of number of units sold on TV advertising budget. An increase of$1,000in the TV advertising budget is associated with an increase in sales by around 50 units. (Recall that the salesvariable is in thousands of units, and the TVvariable is in thousands of dollars.) whichmeasuresthenumberofstandarddeviationsthat ˆβ1isawayfrom 0.If there really is no relationship between XandY, then we expect that ( 3.14) will have a t-distribution with n−2degrees of freedom. The t-distribution has a bell shape and for values of ngreater than approximately 30it is quite similar to the standard normal distribution. Consequently, it is a simple matter to compute the probability of observing any number equal to|t|or larger in absolute value, assuming β1=0. We call this probability thep-value. Roughly speaking, we interpret the p-value as follows: a smallp-valuep-value indicates that it is unlikely to observe such a substantial association between the predictor and the response due to chance, in the absence of any real association between the predictor and the response. Hence, if we see a small p-value, then we can infer that there is an association between the predictor and the response. We reject the null hypothesis —that is, we declare a relationship to exist between XandY—if the p-value is small enough. Typical p-value cutoffs for rejecting the null hypothesis are 5% or 1%, although this topic will be explored in much greater detail in Chap- ter13. Whenn= 30, these correspond to t-statistics ( 3.14) of around 2 and 2.75, respectively. Table3.1provides details of the least squares model for the regression of number of units sold on TV advertising budget for the Advertising data. Notice that the coefficients for ˆβ0andˆβ1are very large relative to their standard errors, so the t-statistics are also large; the probabilities of seeing such values if H0is true are virtually zero. Hence we can conclude that β0/negationslash=0andβ1/negationslash=0.4 3.1.3 Assessing the Accuracy of the Model Once we have rejected the null hypothesis ( 3.12) in favor of the alternative hypothesis ( 3.13), it is natural to want to quantify the extent to which the model fits the data . The quality of a linear regression fit is typically assessed using two related quantities: the residual standard error (RSE) and the R2 R2 statistic. 4In Table 3.1, a small p-value for the intercept indicates that", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 96, "start_word": 30720, "end_word": 31120, "chunk_words": 400}}, "ISLP_website::c000097": {"text": "can conclude that β0/negationslash=0andβ1/negationslash=0.4 3.1.3 Assessing the Accuracy of the Model Once we have rejected the null hypothesis ( 3.12) in favor of the alternative hypothesis ( 3.13), it is natural to want to quantify the extent to which the model fits the data . The quality of a linear regression fit is typically assessed using two related quantities: the residual standard error (RSE) and the R2 R2 statistic. 4In Table 3.1, a small p-value for the intercept indicates that we can reject the null hypothesis that β0=0, and a small p-value for TVindicates that we can reject the null hypothesis that β1=0. Rejecting the latter null hypothesis allows us to conclude that there is a relationship between TVandsales. Rejecting the former allows us to conclude that in the absence of TVexpenditure, salesare non-zero. 78 3. Linear Regression Quantity Value Residual standard error 3.26 R20.612 F-statistic 312.1 TABLE 3.2. For the Advertising data, more information about the least squares model for the regression of number of units sold on TV advertising budget. Table3.2displays the RSE, the R2statistic, and the F-statistic (to be described in Section 3.2.2) for the linear regression of number of units sold on TV advertising budget. Residual Standard Error Recall from the model ( 3.5) that associated with each observation is an error term /epsilon1. Due to the presence of these error terms, even if we knew the true regression line (i.e. even if β0andβ1were known), we would not be able to perfectly predict YfromX. The RSE is an estimate of the standard deviationof /epsilon1.Roughlyspeaking,itistheaverageamountthattheresponse will deviate from the true regression line. It is computed using the formula RSE =/radicalbigg 1 n−2RSS =/radicaltp/radicalvertex/radicalvertex/radicalbt1 n−2n/summationdisplay i=1(yi−ˆyi)2. (3.15) Note that RSS was defined in Section 3.1.1, and is given by the formula RSS =n/summationdisplay i=1(yi−ˆyi)2. (3.16) In the case of the advertising data, we see from the linear regression output in Table 3.2that the RSE is 3.26. In other words, actual sales in each market deviate from the true regression line by approximately 3,260 units, on average. Another way to think about this is that even if the model were correct and the true values of the unknown coefficients β0 andβ1were known exactly, any prediction of sales on the basis of TV advertising would still be off by about 3,260units on average. Of course, whether or not 3,260units is an acceptable prediction error depends on the problem context. In", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 97, "start_word": 31040, "end_word": 31440, "chunk_words": 400}}, "ISLP_website::c000098": {"text": "words, actual sales in each market deviate from the true regression line by approximately 3,260 units, on average. Another way to think about this is that even if the model were correct and the true values of the unknown coefficients β0 andβ1were known exactly, any prediction of sales on the basis of TV advertising would still be off by about 3,260units on average. Of course, whether or not 3,260units is an acceptable prediction error depends on the problem context. In the advertising data set, the mean value of salesover all markets is approximately 14,000units, and so the percentage error is 3,260/14,000 = 23 %. The RSE is considered a measure of the lack of fit of the model ( 3.5) to the data. If the predictions obtained using the model are very close to the true outcome values—that is, if ˆyi≈yifori=1,...,n —then (3.15) will be small, and we can conclude that the model fits the data very well. On the other hand, if ˆyiis very far from yifor one or more observations, then the RSE may be quite large, indicating that the model doesn’t fit the data well. R2Statistic The RSE provides an absolute measure of lack of fit of the model ( 3.5) to the data. But since it is measured in the units of Y, it is not always 3.1 Simple Linear Regression 79 clear what constitutes a good RSE. The R2statistic provides an alternative measure of fit. It takes the form of a proportion —the proportion of variance explained—and so it always takes on a value between 0and1, and is independent of the scale of Y. To calculate R2, we use the formula R2=TSS −RSS TSS=1−RSS TSS(3.17) whereTSS =/summationtext(yi−¯y)2is thetotal sum of squares , and RSS is definedtotal sum of squaresin (3.16). TSS measures the total variance in the response Y, and can be thought of as the amount of variability inherent in the response before the regressionisperformed.Incontrast,RSSmeasurestheamountofvariability that is left unexplained after performing the regression. Hence, TSS −RSS measures the amount of variability in the response that is explained (or removed) by performing the regression, and R2measures the proportion of variability in Ythat can be explained using X. AnR2statistic that is close to1indicates that a large proportion of the variability in the response is explained by the regression. A number near 0indicates that the regression does not explain much of the variability in the response; this", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 98, "start_word": 31360, "end_word": 31760, "chunk_words": 400}}, "ISLP_website::c000099": {"text": "regressionisperformed.Incontrast,RSSmeasurestheamountofvariability that is left unexplained after performing the regression. Hence, TSS −RSS measures the amount of variability in the response that is explained (or removed) by performing the regression, and R2measures the proportion of variability in Ythat can be explained using X. AnR2statistic that is close to1indicates that a large proportion of the variability in the response is explained by the regression. A number near 0indicates that the regression does not explain much of the variability in the response; this might occur because the linear model is wrong, or the error variance σ2is high, or both. In Table 3.2, theR2was0.61, and so just under two-thirds of the variability insalesis explained by a linear regression on TV. TheR2statistic ( 3.17) has an interpretational advantage over the RSE (3.15), since unlike the RSE, it always lies between 0 and 1. However, it can still be challenging to determine what is a goodR2value, and in general, this will depend on the application. For instance, in certain problems in physics, we may know that the data truly comes from a linear model with a small residual error. In this case, we would expect to see an R2value that isextremelycloseto 1,andasubstantiallysmaller R2valuemightindicatea serious problem with the experiment in which the data were generated. On the other hand, in typical applications in biology, psychology, marketing, and other domains, the linear model ( 3.5) is at best an extremely rough approximation to the data, and residual errors due to other unmeasured factors are often very large. In this setting, we would expect only a very small proportion of the variance in the response to be explained by the predictor, and an R2value well below 0.1might be more realistic! TheR2statistic is a measure of the linear relationship between Xand Y. Recall that correlation , defined ascorrelation Cor(X,Y)=/summationtextn i=1(xi−x)(yi−y)/radicalbig/summationtextn i=1(xi−x)2/radicalbig/summationtextn i=1(yi−y)2, (3.18) is also a measure of the linear relationship between XandY.5This sug- gests that we might be able to use r=Cor(X,Y)instead of R2in order to assess the fit of the linear model. In fact, it can be shown that in the simple 5We note that in fact, the right-hand side of ( 3.18) is the sample correlation; thus, it would be more correct to write /hatwiderCor(X,Y); however, we omit the “hat” for ease of notation. 80 3. Linear Regression Simple regression of salesonradio Coefficient Std. error t-statistic p-value Intercept 9.312 0.563 16.54 <0.0001 radio 0.203 0.020 9.92 <0.0001", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 99, "start_word": 31680, "end_word": 32080, "chunk_words": 400}}, "ISLP_website::c000100": {"text": "to use r=Cor(X,Y)instead of R2in order to assess the fit of the linear model. In fact, it can be shown that in the simple 5We note that in fact, the right-hand side of ( 3.18) is the sample correlation; thus, it would be more correct to write /hatwiderCor(X,Y); however, we omit the “hat” for ease of notation. 80 3. Linear Regression Simple regression of salesonradio Coefficient Std. error t-statistic p-value Intercept 9.312 0.563 16.54 <0.0001 radio 0.203 0.020 9.92 <0.0001 Simple regression of salesonnewspaper Coefficient Std. error t-statistic p-value Intercept 12.351 0.621 19.88 <0.0001 newspaper 0.055 0.017 3.30 0.00115 TABLE 3.3. More simple linear regression models for the Advertising data. Coefficients of the simple linear regression model for number of units sold on Top: radio advertising budget and Bottom: newspaper advertising budget. A $ 1,000in- crease in spending on radio advertising is associated with an average increase in sales by around 203 units, while the same increase in spending on newspaper ad- vertising is associated with an average increase in sales by around 55 units. (Note that the salesvariable is in thousands of units, and the radioandnewspaper variables are in thousands of dollars.) linear regression setting, R2=r2. In other words, the squared correlation and the R2statistic are identical. However, in the next section we will discuss the multiple linear regression problem, in which we use several pre- dictors simultaneously to predict the response. The concept of correlation between the predictors and the response does not extend automatically to this setting, since correlation quantifies the association between a single pair of variables rather than between a larger number of variables. We will see that R2fills this role. 3.2 Multiple Linear Regression Simplelinearregressionisausefulapproachforpredictingaresponseonthe basis of a single predictor variable. However, in practice we often have more thanonepredictor.Forexample,inthe Advertising data,wehaveexamined the relationship between sales and TV advertising. We also have data for the amount of money spent advertising on the radio and in newspapers, and we may want to know whether either of these two media is associated with sales. How can we extend our analysis of the advertising data in order to accommodate these two additional predictors? One option is to run three separate simple linear regressions, each of which uses a different advertising medium as a predictor. For instance, we can fit a simple linear regression to predict sales on the basis of the amount spent on radio advertisements. Results are", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 100, "start_word": 32000, "end_word": 32400, "chunk_words": 400}}, "ISLP_website::c000101": {"text": "newspapers, and we may want to know whether either of these two media is associated with sales. How can we extend our analysis of the advertising data in order to accommodate these two additional predictors? One option is to run three separate simple linear regressions, each of which uses a different advertising medium as a predictor. For instance, we can fit a simple linear regression to predict sales on the basis of the amount spent on radio advertisements. Results are shown in Table 3.3(top table). We find that a $ 1,000increase in spending on radio advertising is associated with an increase in sales of around 203 units. Table 3.3(bottom table) contains the least squares coefficients for a simple linear regression of sales onto newspaper advertising budget. A $1,000increase in newspaper advertising budget is associated with an increase in sales of approximately 55 units. 3.2 Multiple Linear Regression 81 However,theapproachoffittingaseparatesimplelinearregressionmodel foreachpredictorisnotentirelysatisfactory.Firstofall,itisunclearhowto make a single prediction of sales given the three advertising media budgets, since each of the budgets is associated with a separate regression equation. Second, each of the three regression equations ignores the other two media in forming estimates for the regression coefficients. We will see shortly that if the media budgets are correlated with each other in the 200 markets in our data set, then this can lead to very misleading estimates of the association between each media budget and sales. Instead of fitting a separate simple linear regression model for each pre- dictor, a better approach is to extend the simple linear regression model (3.5) so that it can directly accommodate multiple predictors. We can do this by giving each predictor a separate slope coefficient in a single model. In general, suppose that we have pdistinct predictors. Then the multiple linear regression model takes the form Y=β0+β1X1+β2X2+···+βpXp+/epsilon1, (3.19) whereXjrepresents the jth predictor and βjquantifies the association between that variable and the response. We interpret βjas theaverage effect on Yof a one unit increase in Xj,holding all other predictors fixed . In the advertising example, ( 3.19) becomes sales=β0+β1×TV+β2×radio+β3×newspaper +/epsilon1. (3.20) 3.2.1 Estimating the Regression Coefficients As was the case in the simple linear regression setting, the regression coef- ficientsβ0,β1,...,βpin (3.19) are unknown, and must be estimated. Given estimates ˆβ0,ˆβ1,..., ˆβp, we can make predictions using the formula ˆy=ˆβ0+ˆβ1x1+ˆβ2x2+···+ˆβpxp. (3.21) Theparametersareestimatedusingthesameleastsquaresapproachthat we saw in the context of simple linear regression. We choose β0,β1,...,βp to minimize the sum of squared", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 101, "start_word": 32320, "end_word": 32720, "chunk_words": 400}}, "ISLP_website::c000102": {"text": "Yof a one unit increase in Xj,holding all other predictors fixed . In the advertising example, ( 3.19) becomes sales=β0+β1×TV+β2×radio+β3×newspaper +/epsilon1. (3.20) 3.2.1 Estimating the Regression Coefficients As was the case in the simple linear regression setting, the regression coef- ficientsβ0,β1,...,βpin (3.19) are unknown, and must be estimated. Given estimates ˆβ0,ˆβ1,..., ˆβp, we can make predictions using the formula ˆy=ˆβ0+ˆβ1x1+ˆβ2x2+···+ˆβpxp. (3.21) Theparametersareestimatedusingthesameleastsquaresapproachthat we saw in the context of simple linear regression. We choose β0,β1,...,βp to minimize the sum of squared residuals RSS =n/summationdisplay i=1(yi−ˆyi)2 =n/summationdisplay i=1(yi−ˆβ0−ˆβ1xi1−ˆβ2xi2−···−ˆβpxip)2.(3.22) Thevalues ˆβ0,ˆβ1,..., ˆβpthatminimize( 3.22)arethemultipleleastsquares regression coefficient estimates. Unlike the simple linear regression esti- mates given in ( 3.4), the multiple regression coefficient estimates have somewhat complicated forms that are most easily represented using ma- trix algebra. For this reason, we do not provide them here. Any statistical software package can be used to compute these coefficient estimates, and later in this chapter we will show how this can be done in R. Figure 3.4 82 3. Linear Regression X1X2Y FIGURE 3.4. In a three-dimensional setting, with two predictors and one response, the least squares regression line becomes a plane. The plane is chosen to minimize the sum of the squared vertical distances between each observation (shown in red) and the plane. illustrates an example of the least squares fit to a toy data set with p=2 predictors. Table3.4displays the multiple regression coefficient estimates when TV, radio, and newspaper advertising budgets are used to predict product sales usingthe Advertising data.Weinterprettheseresultsasfollows:foragiven amountofTVandnewspaperadvertising,spendinganadditional $1,000on radio advertising is associated with approximately 189 units of additional sales. Comparing these coefficient estimates to those displayed in Tables 3.1 and3.3, we notice that the multiple regression coefficient estimates for TVandradioare pretty similar to the simple linear regression coefficient estimates. However, while the newspaper regression coefficient estimate in Table3.3was significantly non-zero, the coefficient estimate for newspaper in the multiple regression model is close to zero, and the corresponding p- value is no longer significant, with a value around 0.86. This illustrates that the simple and multiple regression coefficients can be quite different. This difference stems from the fact that in the simple regression case, the slope term represents the average increase in product sales associated with a $1,000increase in newspaper advertising, ignoring other predictors such as TVandradio. By contrast, in the multiple regression setting, the coefficient fornewspaper represents the average increase in product sales associated with increasing newspaper spending by $1,000while holding", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 102, "start_word": 32640, "end_word": 33040, "chunk_words": 400}}, "ISLP_website::c000103": {"text": "longer significant, with a value around 0.86. This illustrates that the simple and multiple regression coefficients can be quite different. This difference stems from the fact that in the simple regression case, the slope term represents the average increase in product sales associated with a $1,000increase in newspaper advertising, ignoring other predictors such as TVandradio. By contrast, in the multiple regression setting, the coefficient fornewspaper represents the average increase in product sales associated with increasing newspaper spending by $1,000while holding TVandradio fixed. Does it make sense for the multiple regression to suggest no relationship between salesandnewspaper while the simple linear regression implies the 3.2 Multiple Linear Regression 83 Coefficient Std. error t-statistic p-value Intercept 2.939 0.3119 9.42 <0.0001 TV 0.046 0.0014 32.81 <0.0001 radio 0.189 0.0086 21.89 <0.0001 newspaper −0.001 0.0059 −0.18 0.8599 TABLE 3.4. For theAdvertising data, least squares coefficient estimates of the multiple linear regression of number of units sold on TV, radio, and newspaper advertising budgets. TV radio newspaper sales TV 1.0000 0.0548 0.0567 0.7822 radio 1.0000 0.3541 0.5762 newspaper 1.0000 0.2283 sales 1.0000 TABLE 3.5. Correlation matrix for TV,radio,newspaper , andsalesfor the Advertising data. opposite? In fact it does. Consider the correlation matrix for the three predictor variables and response variable, displayed in Table 3.5. Notice that the correlation between radioandnewspaper is0.35. This indicates that markets with high newspaper advertising tend to also have high ra- dio advertising. Now suppose that the multiple regression is correct and newspaper advertising is not associated with sales, but radio advertising is associated with sales. Then in markets where we spend more on radio our sales will tend to be higher, and as our correlation matrix shows, we also tend to spend more on newspaper advertising in those same mar- kets. Hence, in a simple linear regression which only examines salesversus newspaper , we will observe that higher values of newspaper tend to be as- sociated with higher values of sales, even though newspaper advertising is not directly associated with sales. So newspaper advertising is a surrogate forradioadvertising; newspaper gets “credit” for the association between radioonsales. This slightly counterintuitive result is very common in many real life situations. Consider an absurd example to illustrate the point. Running a regression of shark attacks versus ice cream sales for data collected at a given beach community over a period of time would show a positive relationship, similar to that seen between salesandnewspaper", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 103, "start_word": 32960, "end_word": 33360, "chunk_words": 400}}, "ISLP_website::c000104": {"text": "sales, even though newspaper advertising is not directly associated with sales. So newspaper advertising is a surrogate forradioadvertising; newspaper gets “credit” for the association between radioonsales. This slightly counterintuitive result is very common in many real life situations. Consider an absurd example to illustrate the point. Running a regression of shark attacks versus ice cream sales for data collected at a given beach community over a period of time would show a positive relationship, similar to that seen between salesandnewspaper . Of course no one has (yet) suggested that ice creams should be banned at beaches to reduce shark attacks. In reality, higher temperatures cause more people to visit the beach, which in turn results in more ice cream sales and more shark attacks. A multiple regression of shark attacks onto ice cream sales and temperature reveals that, as intuition implies, ice cream sales is no longer a significant predictor after adjusting for temperature. 3.2.2 Some Important Questions When we perform multiple linear regression, we usually are interested in answering a few important questions. 84 3. Linear Regression 1.Is at least one of the predictors X1,X2,...,X puseful in predicting the response? 2.Do all the predictors help to explain Y, or is only a subset of the predictors useful? 3.How well does the model fit the data? 4.Given a set of predictor values, what response value should we predict, and how accurate is our prediction? We now address each of these questions in turn. One: Is There a Relationship Between the Response and Predictors? Recall that in the simple linear regression setting, in order to determine whether there is a relationship between the response and the predictor we can simply check whether β1=0. In the multiple regression setting with p predictors, we need to ask whether all of the regression coefficients are zero, i.e. whether β1=β2=···=βp=0. As in the simple linear regression setting, we use a hypothesis test to answer this question. We test the null hypothesis, H0:β1=β2=···=βp=0 versus the alternative Ha:at least one βjis non-zero. This hypothesis test is performed by computing the F-statistic ,F-statistic F=(TSS −RSS) /p RSS/(n−p−1), (3.23) where, as with simple linear regression, TSS =/summationtext(yi−¯y)2andRSS =/summationtext(yi−ˆyi)2. If the linear model assumptions are correct, one can show that E{RSS/(n−p−1)}=σ2 and that, provided H0is true, E{(TSS −RSS) /p}=σ2. Hence, when there is no relationship between the response and predictors, one would expect the F-statistic to take on a value", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 104, "start_word": 33280, "end_word": 33680, "chunk_words": 400}}, "ISLP_website::c000105": {"text": "question. We test the null hypothesis, H0:β1=β2=···=βp=0 versus the alternative Ha:at least one βjis non-zero. This hypothesis test is performed by computing the F-statistic ,F-statistic F=(TSS −RSS) /p RSS/(n−p−1), (3.23) where, as with simple linear regression, TSS =/summationtext(yi−¯y)2andRSS =/summationtext(yi−ˆyi)2. If the linear model assumptions are correct, one can show that E{RSS/(n−p−1)}=σ2 and that, provided H0is true, E{(TSS −RSS) /p}=σ2. Hence, when there is no relationship between the response and predictors, one would expect the F-statistic to take on a value close to 1. On the other hand, if Hais true, then E{(TSS −RSS) /p}>σ2, so we expect Fto be greater than 1. TheF-statistic for the multiple linear regression model obtained by re- gressing salesontoradio,TV, andnewspaper is shown in Table 3.6. In this example the F-statistic is 570. Since this is far larger than 1, it provides compelling evidence against the null hypothesis H0. In other words, the largeF-statistic suggests that at least one of the advertising media must be related to sales. However, what if the F-statistic had been closer to 1? How large does the F-statistic need to be before we can reject H0and 3.2 Multiple Linear Regression 85 Quantity Value Residual standard error 1.69 R20.897 F-statistic 570 TABLE 3.6. More information about the least squares model for the regression of number of units sold on TV, newspaper, and radio advertising budgets in the Advertising data. Other information about this model was displayed in Table 3.4. conclude that there is a relationship? It turns out that the answer depends on the values of nandp. Whennis large, an F-statistic that is just a little larger than 1might still provide evidence against H0. In contrast, a larger F-statistic is needed to reject H0ifnis small. When H0is true and the errors /epsilon1ihave a normal distribution, the F-statistic follows an F-distribution.6For any given value of nandp, any statistical software package can be used to compute the p-value associated with the F-statistic using this distribution. Based on this p-value, we can determine whether or not to reject H0. For the advertising data, the p-value associated with theF-statistic in Table 3.6is essentially zero, so we have extremely strong evidence that at least one of the media is associated with increased sales. In (3.23) we are testing H0that all the coefficients are zero. Sometimes we want to test that a particular subset of qof the coefficients are zero. This corresponds to a null hypothesis H0:βp−q+1=βp−q+2=···=βp=0, where", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 105, "start_word": 33600, "end_word": 34000, "chunk_words": 400}}, "ISLP_website::c000106": {"text": "distribution. Based on this p-value, we can determine whether or not to reject H0. For the advertising data, the p-value associated with theF-statistic in Table 3.6is essentially zero, so we have extremely strong evidence that at least one of the media is associated with increased sales. In (3.23) we are testing H0that all the coefficients are zero. Sometimes we want to test that a particular subset of qof the coefficients are zero. This corresponds to a null hypothesis H0:βp−q+1=βp−q+2=···=βp=0, where for convenience we have put the variables chosen for omission at the end of the list. In this case we fit a second model that uses all the variables exceptthose last q. Suppose that the residual sum of squares for that model isRSS 0. Then the appropriate F-statistic is F=(RSS 0−RSS) /q RSS/(n−p−1). (3.24) Notice that in Table 3.4, for each individual predictor a t-statistic and ap-value were reported. These provide information about whether each individual predictor is related to the response, after adjusting for the other predictors. It turns out that each of these is exactly equivalent7to theF- test that omits that single variable from the model, leaving all the others in—i.e.q=1 in (3.24). So it reports the partial effect of adding that variable to the model. For instance, as we discussed earlier, these p-values indicate thatTVandradioare related to sales, but that there is no evidence that newspaper is associated with sales, whenTVandradioare held fixed. Given these individual p-values for each variable, why do we need to look at the overall F-statistic? After all, it seems likely that if any one of the p-values for the individual variables is very small, then at least one of the predictors is related to the response . However, this logic is flawed, especially when the number of predictors pis large. 6Even if the errors are not normally-distributed, the F-statistic approximately follows anF-distribution provided that the sample size nis large. 7The square of each t-statistic is the corresponding F-statistic. 86 3. Linear Regression For instance, consider an example in which p= 100 andH0:β1=β2= ···=βp=0is true, so no variable is truly associated with the response. In this situation, about 5% of the p-values associated with each variable (of the type shown in Table 3.4) will be below 0.05by chance. In other words, we expect to see approximately five smallp-values even in the absence of any true association between the predictors and the response.8In fact,", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 106, "start_word": 33920, "end_word": 34320, "chunk_words": 400}}, "ISLP_website::c000107": {"text": "each t-statistic is the corresponding F-statistic. 86 3. Linear Regression For instance, consider an example in which p= 100 andH0:β1=β2= ···=βp=0is true, so no variable is truly associated with the response. In this situation, about 5% of the p-values associated with each variable (of the type shown in Table 3.4) will be below 0.05by chance. In other words, we expect to see approximately five smallp-values even in the absence of any true association between the predictors and the response.8In fact, it is likely that we will observe at least one p-value below 0.05by chance! Hence, if we use the individual t-statistics and associated p-values in order to decide whether or not there is any association between the variables and the response, there is a very high chance that we will incorrectly conclude that there is a relationship. However, the F-statistic does not suffer from this problem because it adjusts for the number of predictors. Hence, if H0 is true, there is only a 5% chance that the F-statistic will result in a p- value below 0.05, regardless of the number of predictors or the number of observations. The approach of using an F-statistic to test for any association between the predictors and the response works when pis relatively small, and cer- tainly small compared to n. However, sometimes we have a very large num- ber of variables. If p>n then there are more coefficients βjto estimate than observations from which to estimate them. In this case we cannot even fit the multiple linear regression model using least squares, so the F- statistic cannot be used, and neither can most of the other concepts that we have seen so far in this chapter. When pis large, some of the approaches discussed in the next section, such as forward selection , can be used. This high-dimensional setting is discussed in greater detail in Chapter 6.high- dimensional Two: Deciding on Important Variables As discussed in the previous section, the first step in a multiple regression analysis is to compute the F-statistic and to examine the associated p- value. If we conclude on the basis of that p-value that at least one of the predictors is related to the response, then it is natural to wonder whichare the guilty ones! We could look at the individual p-values as in Table 3.4, but as discussed (and as further explored in Chapter 13), ifpis large we", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 107, "start_word": 34240, "end_word": 34640, "chunk_words": 400}}, "ISLP_website::c000108": {"text": "discussed in the previous section, the first step in a multiple regression analysis is to compute the F-statistic and to examine the associated p- value. If we conclude on the basis of that p-value that at least one of the predictors is related to the response, then it is natural to wonder whichare the guilty ones! We could look at the individual p-values as in Table 3.4, but as discussed (and as further explored in Chapter 13), ifpis large we are likely to make some false discoveries. It is possible that all of the predictors are associated with the response, but it is more often the case that the response is only associated with a subset of the predictors. The task of determining which predictors are associated with the response, in order to fit a single model involving only those predictors, is referred to as variable selection . The variable selectionvariable selectionproblem is studied extensively in Chapter 6, and so here we will provide only a brief outline of some classical approaches. Ideally, we would like to perform variable selection by trying out a lot of different models, each containing a different subset of the predictors. For instance, if p=2, then we can consider four models: (1) a model contain- ing no variables, (2) a model containing X1only, (3) a model containing 8This is related to the important concept of multiple testing , which is the focus of Chapter 13. 3.2 Multiple Linear Regression 87 X2only, and (4) a model containing both X1andX2. We can then se- lect thebestmodel out of all of the models that we have considered. How do we determine which model is best? Various statistics can be used to judge the quality of a model. These include Mallow’s Cp,Akaike informa-Mallow’s Cption criterion (AIC),Bayesian information criterion (BIC), and adjusted Akaike information criterion Bayesian information criterionR2. These are discussed in more detail in Chapter 6. We can also deter- adjusted R2mine which model is best by plotting various model outputs, such as the residuals, in order to search for patterns. Unfortunately, there are a total of 2pmodels that contain subsets of p variables. This means that even for moderate p, trying out every possible subsetofthepredictorsisinfeasible.Forinstance,wesawthatif p=2,then there are 22=4models to consider. But if p= 30 , then we must consider 230=1,073,741,824models!Thisisnotpractical.Therefore,unless pisvery small, we cannot consider all 2pmodels, and instead we need an automated and efficient approach to", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 108, "start_word": 34560, "end_word": 34960, "chunk_words": 400}}, "ISLP_website::c000109": {"text": "deter- adjusted R2mine which model is best by plotting various model outputs, such as the residuals, in order to search for patterns. Unfortunately, there are a total of 2pmodels that contain subsets of p variables. This means that even for moderate p, trying out every possible subsetofthepredictorsisinfeasible.Forinstance,wesawthatif p=2,then there are 22=4models to consider. But if p= 30 , then we must consider 230=1,073,741,824models!Thisisnotpractical.Therefore,unless pisvery small, we cannot consider all 2pmodels, and instead we need an automated and efficient approach to choose a smaller set of models to consider. There are three classical approaches for this task: •Forward selection . We begin with the null model —a model that con-forward selection null modeltains an intercept but no predictors. We then fit psimple linear re- gressions and add to the null model the variable that results in the lowest RSS. We then add to that model the variable that results in the lowest RSS for the new two-variable model. This approach is continued until some stopping rule is satisfied. •Backward selection . We start with all variables in the model, andbackward selectionremove the variable with the largest p-value—that is, the variable that is the least statistically significant. The new (p−1)-variable model is fit, and the variable with the largest p-value is removed. This procedure continues until a stopping rule is reached. For instance, we may stop when all remaining variables have a p-value below some threshold. •Mixed selection . This is a combination of forward and backward se-mixed selectionlection. We start with no variables in the model, and as with forward selection, we add the variable that provides the best fit. We con- tinue to add variables one-by-one. Of course, as we noted with the Advertising example, the p-values for variables can become larger as new predictors are added to the model. Hence, if at any point the p-value for one of the variables in the model rises above a certain threshold, then we remove that variable from the model. We con- tinue to perform these forward and backward steps until all variables in the model have a sufficiently low p-value, and all variables outside the model would have a large p-value if added to the model. Backward selection cannot be used if p>n , while forward selection can always be used. Forward selection is a greedy approach, and might include variables early that later become redundant. Mixed selection can remedy this.", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 109, "start_word": 34880, "end_word": 35280, "chunk_words": 400}}, "ISLP_website::c000110": {"text": "then we remove that variable from the model. We con- tinue to perform these forward and backward steps until all variables in the model have a sufficiently low p-value, and all variables outside the model would have a large p-value if added to the model. Backward selection cannot be used if p>n , while forward selection can always be used. Forward selection is a greedy approach, and might include variables early that later become redundant. Mixed selection can remedy this. 88 3. Linear Regression Three: Model Fit Two of the most common numerical measures of model fit are the RSE and R2, the fraction of variance explained. These quantities are computed and interpreted in the same fashion as for simple linear regression. Recall that in simple regression, R2is the square of the correlation of the response and the variable. In multiple linear regression, it turns out that it equals Cor (Y,ˆY)2, the square of the correlation between the response and the fitted linear model; in fact one property of the fitted linear model is that it maximizes this correlation among all possible linear models. AnR2value close to 1indicates that the model explains a large por- tion of the variance in the response variable. As an example, we saw in Table3.6that for the Advertising data, the model that uses all three ad- vertising media to predict saleshas anR2of0.8972 . On the other hand, the model that uses only TVandradioto predict saleshas anR2value of0.89719 . In other words, there is a smallincrease in R2if we include newspaper advertising in the model that already contains TV and radio advertising, even though we saw earlier that the p-value for newspaper ad- vertising in Table 3.4is not significant. It turns out that R2will always increase when more variables are added to the model, even if those vari- ables are only weakly associated with the response. This is due to the fact that adding another variable always results in a decrease in the residual sum of squares on the training data (though not necessarily the testing data). Thus, the R2statistic, which is also computed on the training data, must increase. The fact that adding newspaper advertising to the model containing only TV and radio advertising leads to just a tiny increase in R2provides additional evidence that newspaper can be dropped from the model. Essentially, newspaper provides no real improvement in the model fit to the training", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 110, "start_word": 35200, "end_word": 35600, "chunk_words": 400}}, "ISLP_website::c000111": {"text": "always results in a decrease in the residual sum of squares on the training data (though not necessarily the testing data). Thus, the R2statistic, which is also computed on the training data, must increase. The fact that adding newspaper advertising to the model containing only TV and radio advertising leads to just a tiny increase in R2provides additional evidence that newspaper can be dropped from the model. Essentially, newspaper provides no real improvement in the model fit to the training samples, and its inclusion will likely lead to poor results on independent test samples due to overfitting. By contrast, the model containing only TVas a predictor had an R2of 0.61(Table3.2). Adding radioto the model leads to a substantial improve- ment inR2. This implies that a model that uses TV and radio expenditures to predict sales is substantially better than one that uses only TV advertis- ing. We could further quantify this improvement by looking at the p-value for the radiocoefficient in a model that contains only TVandradioas predictors. The model that contains only TVandradioas predictors has an RSE of 1.681, and the model that also contains newspaper as a predictor has an RSE of 1.686 (Table 3.6). In contrast, the model that contains only TV has an RSE of 3.26(Table3.2). This corroborates our previous conclusion that a model that uses TV and radio expenditures to predict sales is much more accurate (on the training data) than one that only uses TV spending. Furthermore, given that TV and radio expenditures are used as predictors, there is no point in also using newspaper spending as a predictor in the model. The observant reader may wonder how RSE can increase when newspaper is added to the model given that RSS must decrease. In general RSE is defined as RSE =/radicalbigg1 n−p−1RSS, (3.25) 3.2 Multiple Linear Regression 89Sales RadioTVFIGURE 3.5. For theAdvertising data, a linear regression fit to salesusing TVandradioas predictors. From the pattern of the residuals, we can see that there is a pronounced non-linear relationship in the data. The positive residuals (those visible above the surface), tend to lie along the 45-degree line, where TV and Radio budgets are split evenly. The negative residuals (most not visible), tend to lie away from this line, where budgets are more lopsided. which simplifies to ( 3.15) for a simple linear regression. Thus, models with more variables can have higher RSE if the decrease in", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 111, "start_word": 35520, "end_word": 35920, "chunk_words": 400}}, "ISLP_website::c000112": {"text": "of the residuals, we can see that there is a pronounced non-linear relationship in the data. The positive residuals (those visible above the surface), tend to lie along the 45-degree line, where TV and Radio budgets are split evenly. The negative residuals (most not visible), tend to lie away from this line, where budgets are more lopsided. which simplifies to ( 3.15) for a simple linear regression. Thus, models with more variables can have higher RSE if the decrease in RSS is small relative to the increase in p. In addition to looking at the RSE and R2statistics just discussed, it can be useful to plot the data. Graphical summaries can reveal problems with a model that are not visible from numerical statistics. For example, Figure3.5displays a three-dimensional plot of TVandradioversussales. We see that some observations lie above and some observations lie below the least squares regression plane. In particular, the linear model seems to overestimate salesfor instances in which most of the advertising money was spent exclusively on either TVorradio. It underestimates salesfor instances where the budget was split between the two media. This pro- nounced non-linear pattern suggests a synergyorinteraction effect betweeninteractionthe advertising media, whereby combining the media together results in a bigger boost to sales than using any single medium. In Section 3.3.2,w e will discuss extending the linear model to accommodate such synergistic effects through the use of interaction terms. Four: Predictions Once we have fit the multiple regression model, it is straightforward to apply (3.21) in order to predict the response Yon the basis of a set of values for the predictors X1,X2,...,X p. However, there are three sorts of uncertainty associated with this prediction. 1. Thecoefficientestimates ˆβ0,ˆβ1,..., ˆβpareestimatesfor β0,β1,...,βp. That is, the least squares plane ˆY=ˆβ0+ˆβ1X1+···+ˆβpXp 90 3. Linear Regression is only an estimate for the true population regression plane f(X)=β0+β1X1+···+βpXp. The inaccuracy in the coefficient estimates is related to the reducible errorfrom Chapter 2. We can compute a confidence interval in order to determine how close ˆYwill be to f(X). 2. Of course, in practice assuming a linear model for f(X)is almost always an approximation of reality, so there is an additional source of potentially reducible error which we call model bias . So when we use a linear model, we are in fact estimating the best linear approximation to the true surface. However, here we will ignore this discrepancy, and operate as", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 112, "start_word": 35840, "end_word": 36240, "chunk_words": 400}}, "ISLP_website::c000113": {"text": "2. We can compute a confidence interval in order to determine how close ˆYwill be to f(X). 2. Of course, in practice assuming a linear model for f(X)is almost always an approximation of reality, so there is an additional source of potentially reducible error which we call model bias . So when we use a linear model, we are in fact estimating the best linear approximation to the true surface. However, here we will ignore this discrepancy, and operate as if the linear model were correct. 3. Even if we knew f(X)—that is, even if we knew the true values forβ0,β1,...,βp—the response value cannot be predicted perfectly because of the random error /epsilon1in the model ( 3.20). In Chapter 2,w e referred to this as the irreducible error . How much will Yvary from ˆY? We use prediction intervals to answer this question. Prediction intervals are always wider than confidence intervals, because they incorporate both the error in the estimate for f(X)(the reducible error) and the uncertainty as to how much an individual point will differ from the population regression plane (the irreducible error). We use a confidence interval to quantify the uncertainty surroundingconfidence intervaltheaverage salesover a large number of cities. For example, given that $100 ,000isspenton TVadvertisingand $20,000isspenton radioadvertising in each city, the 95% confidence interval is [10,985,11,528]. We interpret this to mean that 95% of intervals of this form will contain the true value of f(X).9On the other hand, a prediction interval can be used to quantify theprediction intervaluncertainty surrounding salesfor aparticular city. Given that $100 ,000is spenton TVadvertisingand $20,000isspenton radioadvertisinginthatcity the 95% prediction interval is [7,930,14,580]. We interpret this to mean that 95% of intervals of this form will contain the true value of Yfor this city.Notethatbothintervalsarecenteredat 11,256,butthattheprediction interval is substantially wider than the confidence interval, reflecting the increased uncertainty about salesfor a given city in comparison to the average salesover many locations. 9In other words, if we collect a large number of data sets like the Advertising data set, and we construct a confidence interval for the average saleson the basis of each data set (given $100 ,000inTVand$20,000inradioadvertising), then 95% of these confidence intervals will contain the true value of average sales. 3.3 Other Considerations in the Regression Model 91 3.3 Other Considerations in the Regression Model 3.3.1 Qualitative Predictors In our discussion so far, we have assumed that all variables in our linear regression model", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 113, "start_word": 36160, "end_word": 36560, "chunk_words": 400}}, "ISLP_website::c000114": {"text": "we collect a large number of data sets like the Advertising data set, and we construct a confidence interval for the average saleson the basis of each data set (given $100 ,000inTVand$20,000inradioadvertising), then 95% of these confidence intervals will contain the true value of average sales. 3.3 Other Considerations in the Regression Model 91 3.3 Other Considerations in the Regression Model 3.3.1 Qualitative Predictors In our discussion so far, we have assumed that all variables in our linear regression model are quantitative . But in practice, this is not necessarily the case; often some predictors are qualitative . For example, the Creditdata set displayed in Figure 3.6records variables for a number of credit card holders. The response is balance(average credit card debt for each individual) and there are several quantitative predictors: age,cards(number of credit cards), education (years of education), income (in thousands of dollars), limit(credit limit), and rating(credit rating). Each panel of Figure 3.6is a scatterplot for a pair of variables whose iden- tities are given by the corresponding row and column labels. For example, the scatterplot directly to the right of the word “Balance” depicts balance versusage, while the plot directly to the right of “Age” corresponds to ageversuscards. In addition to these quantitative variables, we also have four qualitative variables: own(house ownership), student(student status), status(marital status), and region(East, West or South). Predictors with Only Two Levels Suppose that we wish to investigate differences in credit card balance be- tween those who own a house and those who don’t, ignoring the other vari- ables for the moment. If a qualitative predictor (also known as a factor)factoronly has two levels, or possible values, then incorporating it into a regres-levelsion model is very simple. We simply create an indicator or dummy variabledummy variablethat takes on two possible numerical values.10For example, based on the ownvariable, we can create a new variable that takes the form xi=/braceleftBigg 1 ifith person owns a house 0 ifith person does not own a house ,(3.26) and use this variable as a predictor in the regression equation. This results in the model yi=β0+β1xi+/epsilon1i=/braceleftBigg β0+β1+/epsilon1iifith person owns a house β0+/epsilon1i ifith person does not .(3.27) Nowβ0can be interpreted as the average credit card balance among those who do not own, β0+β1as the average credit card balance among those who do own their house, and β1as the average difference in credit card balance between owners and non-owners. Table3.7displays the", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 114, "start_word": 36480, "end_word": 36880, "chunk_words": 400}}, "ISLP_website::c000115": {"text": "0 ifith person does not own a house ,(3.26) and use this variable as a predictor in the regression equation. This results in the model yi=β0+β1xi+/epsilon1i=/braceleftBigg β0+β1+/epsilon1iifith person owns a house β0+/epsilon1i ifith person does not .(3.27) Nowβ0can be interpreted as the average credit card balance among those who do not own, β0+β1as the average credit card balance among those who do own their house, and β1as the average difference in credit card balance between owners and non-owners. Table3.7displays the coefficient estimates and other information asso- ciated with the model ( 3.27). The average credit card debt for non-owners is estimated to be $509 .80, whereas owners are estimated to carry $19.73 in additional debt for a total of $509 .80 + $19 .73 = $529 .53. However, we 10In the machine learning community, the creation of dummy variables to handle qualitative predictors is known as “one-hot encoding”. 92 3. Linear RegressionBalance20 40 60 80 1005 10 15 202000 8000 14000 0 500 150020 40 60 80 100AgeCards 24685 10 15 20EducationIncome 50 100 1502000 8000 14000Limit 0 500 1500246850 100 150200 600 1000 200 600 1000RatingFIGURE 3.6. TheCreditdata set contains information about balance,age, cards,education ,income,limit, andratingfor a number of potential cus- tomers. notice that the p-value for the dummy variable is very high. This indicates that there is no statistical evidence of a difference in average credit card balance based on house ownership. The decision to code owners as 1 and non-owners as 0 in ( 3.27) is ar- bitrary, and has no effect on the regression fit, but does alter the inter- pretation of the coefficients. If we had coded non-owners as 1and own- ers as0, then the estimates for β0andβ1would have been 529.53and −19.73, respectively, leading once again to a prediction of credit card debt of$529 .53−$19.73 = $509 .80for non-owners and a prediction of $529 .53 for owners. Alternatively, instead of a 0/1coding scheme, we could create a dummy variable xi=/braceleftBigg 1 ifith person owns a house −1 ifith person does not own a house and use this variable in the regression equation. This results in the model yi=β0+β1xi+/epsilon1i=/braceleftBigg β0+β1+/epsilon1iifith person owns a house β0−β1+/epsilon1iifith person does not own a house. 3.3 Other Considerations in the Regression Model 93 Coefficient Std. error t-statistic p-value Intercept 509.80 33.13 15.389 <0.0001 own[Yes] 19.73 46.05 0.429 0.6690 TABLE 3.7. Least squares coefficient estimates associated with the regression ofbalance ontoownin", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 115, "start_word": 36800, "end_word": 37200, "chunk_words": 400}}, "ISLP_website::c000116": {"text": "create a dummy variable xi=/braceleftBigg 1 ifith person owns a house −1 ifith person does not own a house and use this variable in the regression equation. This results in the model yi=β0+β1xi+/epsilon1i=/braceleftBigg β0+β1+/epsilon1iifith person owns a house β0−β1+/epsilon1iifith person does not own a house. 3.3 Other Considerations in the Regression Model 93 Coefficient Std. error t-statistic p-value Intercept 509.80 33.13 15.389 <0.0001 own[Yes] 19.73 46.05 0.429 0.6690 TABLE 3.7. Least squares coefficient estimates associated with the regression ofbalance ontoownin theCreditdata set. The linear model is given in ( 3.27). That is, ownership is encoded as a dummy variable, as in ( 3.26). Nowβ0can be interpreted as the overall average credit card balance (ig- noring the house ownership effect), and β1is the amount by which house owners and non-owners have credit card balances that are above and below the average, respectively.11In this example, the estimate for β0is$519.665, halfway between the non-owner and owner averages of $509.80and$529.53. The estimate for β1is$9.865, which is half of $19.73, the average difference between owners and non-owners. It is important to note that the final pre- dictions for the credit balances of owners and non-owners will be identical regardless of the coding scheme used. The only difference is in the way that the coefficients are interpreted. Qualitative Predictors with More than Two Levels When a qualitative predictor has more than two levels, a single dummy variablecannotrepresentallpossiblevalues.Inthissituation, wecan create additional dummy variables. For example, for the regionvariable we create two dummy variables. The first could be xi1=/braceleftBigg 1ifith person is from the South 0ifith person is not from the South ,(3.28) and the second could be xi2=/braceleftBigg 1ifith person is from the West 0ifith person is not from the West .(3.29) Then both of these variables can be used in the regression equation, in order to obtain the model yi=β0+β1xi1+β2xi2+/epsilon1i=  β0+β1+/epsilon1iifith person is from the South β0+β2+/epsilon1iifith person is from the West β0+/epsilon1iifith person is from the East . (3.30) Nowβ0canbeinterpretedastheaveragecreditcardbalanceforindividuals fromtheEast, β1canbeinterpretedasthedifferenceintheaveragebalance between people from the South versus the East, and β2can be interpreted as the difference in the average balance between those from the West versus the East. There will always be one fewer dummy variable than the number of levels. The level with no dummy variable—East in this example—is known as the baseline.baseline 11Technically β0is half the sum of the average debt for house owners and the average debt for non-house owners.", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 116, "start_word": 37120, "end_word": 37520, "chunk_words": 400}}, "ISLP_website::c000117": {"text": "from the East . (3.30) Nowβ0canbeinterpretedastheaveragecreditcardbalanceforindividuals fromtheEast, β1canbeinterpretedasthedifferenceintheaveragebalance between people from the South versus the East, and β2can be interpreted as the difference in the average balance between those from the West versus the East. There will always be one fewer dummy variable than the number of levels. The level with no dummy variable—East in this example—is known as the baseline.baseline 11Technically β0is half the sum of the average debt for house owners and the average debt for non-house owners. Hence, β0is exactly equal to the overall average only if the two groups have an equal number of members. 94 3. Linear Regression Coefficient Std. error t-statistic p-value Intercept 531.00 46.32 11.464 <0.0001 region[South] −12.50 56.68 −0.221 0.8260 region[West] −18.69 65.02 −0.287 0.7740 TABLE 3.8. Least squares coefficient estimates associated with the regression of balance ontoregionin theCreditdata set. The linear model is given in ( 3.30). That is, region is encoded via two dummy variables ( 3.28) and (3.29). From Table 3.8, we see that the estimated balancefor the baseline, East, is$531.00. It is estimated that those in the South will have $18.69less debt than those in the East, and that those in the West will have $12.50 less debt than those in the East. However, the p-values associated with the coefficient estimates for the two dummy variables are very large, suggesting no statistical evidence of a real difference in average credit card balance between South and East or between West and East.12Once again, the level selected as the baseline category is arbitrary, and the final predictions for each group will be the same regardless of this choice. However, the coefficients and their p-values do depend on the choice of dummy variable coding.Ratherthanrelyontheindividualcoefficients,wecanusean F-test to testH0:β1=β2=0; this does not depend on the coding. This F-test has ap-value of 0.96, indicating that we cannot reject the null hypothesis that there is no relationship between balanceandregion. Using this dummy variable approach presents no difficulties when in- corporating both quantitative and qualitative predictors. For example, to regressbalanceon both a quantitative variable such as incomeand a qual- itative variable such as student, we must simply create a dummy variable forstudentand then fit a multiple regression model using incomeand the dummy variable as predictors for credit card balance. There are many different ways of coding qualitative variables besides the dummy variable approach taken here. All of these approaches lead to equivalent model fits, but the", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 117, "start_word": 37440, "end_word": 37840, "chunk_words": 400}}, "ISLP_website::c000118": {"text": "no difficulties when in- corporating both quantitative and qualitative predictors. For example, to regressbalanceon both a quantitative variable such as incomeand a qual- itative variable such as student, we must simply create a dummy variable forstudentand then fit a multiple regression model using incomeand the dummy variable as predictors for credit card balance. There are many different ways of coding qualitative variables besides the dummy variable approach taken here. All of these approaches lead to equivalent model fits, but the coefficients are different and have different interpretations,andaredesignedtomeasureparticular contrasts .Thistopiccontrastis beyond the scope of the book. 3.3.2 Extensions of the Linear Model The standard linear regression model ( 3.19) provides interpretable results and works quite well on many real-world problems. However, it makes sev- eral highly restrictive assumptions that are often violated in practice. Two of the most important assumptions state that the relationship between the predictors and response are additiveandlinear. The additivity assumptionadditive linearmeans that the association between a predictor Xjand the response Ydoes not depend on the values of the other predictors. The linearity assumption states that the change in the response Yassociated with a one-unit change inXjis constant, regardless of the value of Xj. In later chapters of this book, we examine a number of sophisticated methods that relax these two 12There could still in theory be a difference between South and West, although the data here does not suggest any difference. 3.3 Other Considerations in the Regression Model 95 assumptions. Here, we briefly examine some common classical approaches for extending the linear model. Removing the Additive Assumption In our previous analysis of the Advertising data, we concluded that both TV andradioseem to be associated with sales. The linear models that formed the basis for this conclusion assumed that the effect on salesof increasing one advertising medium is independent of the amount spent on the other media.Forexample,thelinearmodel( 3.20)statesthattheaverageincrease insalesassociated with a one-unit increase in TVis always β1, regardless of the amount spent on radio. However, this simple model may be incorrect. Suppose that spending money on radio advertising actually increases the effectiveness of TV ad- vertising, so that the slope term for TVshould increase as radioincreases. In this situation, given a fixed budget of $100 ,000, spending half on radio and half on TVmay increase salesmore than allocating the entire amount to either TVor toradio. In marketing, this is known as a synergyeffect, and in statistics it is", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 118, "start_word": 37760, "end_word": 38160, "chunk_words": 400}}, "ISLP_website::c000119": {"text": "of the amount spent on radio. However, this simple model may be incorrect. Suppose that spending money on radio advertising actually increases the effectiveness of TV ad- vertising, so that the slope term for TVshould increase as radioincreases. In this situation, given a fixed budget of $100 ,000, spending half on radio and half on TVmay increase salesmore than allocating the entire amount to either TVor toradio. In marketing, this is known as a synergyeffect, and in statistics it is referred to as an interaction effect. Figure 3.5sug- gests that such an effect may be present in the advertising data. Notice that when levels of either TVorradioare low, then the true salesare lower than predicted by the linear model. But when advertising is split between the two media, then the model tends to underestimate sales. Consider the standard linear regression model with two variables, Y=β0+β1X1+β2X2+/epsilon1. According to this model, a one-unit increase in X1is associated with an average increase in Yofβ1units. Notice that the presence of X2does not alter this statement—that is, regardless of the value of X2, a one- unit increase in X1is associated with a β1-unit increase in Y. One way of extending this model is to include a third predictor, called an interaction term, which is constructed by computing the product of X1andX2. This results in the model Y=β0+β1X1+β2X2+β3X1X2+/epsilon1. (3.31) How does inclusion of this interaction term relax the additive assumption? Notice that ( 3.31) can be rewritten as Y=β0+(β1+β3X2)X1+β2X2+/epsilon1 (3.32) =β0+˜β1X1+β2X2+/epsilon1 where˜β1=β1+β3X2. Since˜β1is now a function of X2, the association between X1andYis no longer constant: a change in the value of X2will change the association between X1andY. A similar argument shows that a change in the value of X1changes the association between X2andY. For example, suppose that we are interested in studying the productiv- ity of a factory. We wish to predict the number of unitsproduced on the basis of the number of production linesand the total number of workers. It seems likely that the effect of increasing the number of production lines 96 3. Linear Regression Coefficient Std. error t-statistic p-value Intercept 6.7502 0.248 27.23 <0.0001 TV 0.0191 0.002 12.70 <0.0001 radio 0.0289 0.009 3.24 0.0014 TV×radio 0.0011 0.000 20.73 <0.0001 TABLE 3.9. For theAdvertising data, least squares coefficient estimates asso- ciated with the regression of salesontoTVandradio, with an interaction term, as in (3.33). will depend on the number of workers, since if no workers", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 119, "start_word": 38080, "end_word": 38480, "chunk_words": 400}}, "ISLP_website::c000120": {"text": "total number of workers. It seems likely that the effect of increasing the number of production lines 96 3. Linear Regression Coefficient Std. error t-statistic p-value Intercept 6.7502 0.248 27.23 <0.0001 TV 0.0191 0.002 12.70 <0.0001 radio 0.0289 0.009 3.24 0.0014 TV×radio 0.0011 0.000 20.73 <0.0001 TABLE 3.9. For theAdvertising data, least squares coefficient estimates asso- ciated with the regression of salesontoTVandradio, with an interaction term, as in (3.33). will depend on the number of workers, since if no workers are available to operate the lines, then increasing the number of lines will not increase production. This suggests that it would be appropriate to include an inter- action term between linesandworkersin a linear model to predict units. Suppose that when we fit the model, we obtain units≈1.2+3.4×lines+0.22×workers+1.4×(lines×workers) =1.2 + (3.4+1.4×workers)×lines+0.22×workers. In other words, adding an additional line will increase the number of units produced by 3.4+1.4×workers. Hence the more workers we have, the stronger will be the effect of lines. We now return to the Advertising example. A linear model that uses radio,TV, and an interaction between the two to predict salestakes the form sales=β0+β1×TV+β2×radio+β3×(radio×TV)+/epsilon1 =β0+(β1+β3×radio)×TV+β2×radio+/epsilon1.(3.33) We can interpret β3as the increase in the effectiveness of TV advertising associated with a one-unit increase in radio advertising (or vice-versa). The coefficients that result from fitting the model ( 3.33) are given in Table 3.9. Theresults in Table 3.9stronglysuggest that the modelthat includes the interaction term is superior to the model that contains only main effects .main effectThep-value for the interaction term, TV×radio, is extremely low, indicating that there is strong evidence for Ha:β3/negationslash=0. In other words, it is clear that the true relationship is not additive. The R2for the model ( 3.33) is 96.8%, compared to only 89.7% for the model that predicts salesusingTVand radiowithout an interaction term. This means that (96.8−89.7)/(100− 89.7) = 69% of the variability in salesthat remains after fitting the ad- ditive model has been explained by the interaction term. The coefficient estimatesinTable 3.9suggestthatanincreaseinTVadvertisingof $1,000is associated with increased sales of (ˆβ1+ˆβ3×radio)×1,000 = 19+1 .1×radio units. And an increase in radio advertising of $1,000will be associated with an increase in sales of (ˆβ2+ˆβ3×TV)×1,000 = 29 + 1 .1×TVunits. In this example, the p-values associated with TV,radio, and the interac- tion term all are statistically significant (Table 3.9), and so it is obvious that all three variables should be included in the model. However, it is sometimes the case", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 120, "start_word": 38400, "end_word": 38800, "chunk_words": 400}}, "ISLP_website::c000121": {"text": "the interaction term. The coefficient estimatesinTable 3.9suggestthatanincreaseinTVadvertisingof $1,000is associated with increased sales of (ˆβ1+ˆβ3×radio)×1,000 = 19+1 .1×radio units. And an increase in radio advertising of $1,000will be associated with an increase in sales of (ˆβ2+ˆβ3×TV)×1,000 = 29 + 1 .1×TVunits. In this example, the p-values associated with TV,radio, and the interac- tion term all are statistically significant (Table 3.9), and so it is obvious that all three variables should be included in the model. However, it is sometimes the case that an interaction term has a very small p-value, but the associated main effects (in this case, TVandradio) do not. The hier- archical principle states that if we include an interaction in a model, wehierarchical principle 3.3 Other Considerations in the Regression Model 97 should also include the main effects, even if the p-values associated with their coefficients are not significant. In other words, if the interaction be- tweenX1andX2seems important, then we should include both X1and X2in the model even if their coefficient estimates have large p-values. The rationale for this principle is that if X1×X2is related to the response, then whether or not the coefficients of X1orX2are exactly zero is of lit- tle interest. Also X1×X2is typically correlated with X1andX2, and so leaving them out tends to alter the meaning of the interaction. In the previous example, we considered an interaction between TVand radio, both of which are quantitative variables. However, the concept of interactions applies just as well to qualitative variables, or to a combination of quantitative and qualitative variables. In fact, an interaction between a qualitative variable and a quantitative variable has a particularly nice interpretation.Considerthe CreditdatasetfromSection 3.3.1,andsuppose thatwewishtopredict balanceusingthe income(quantitative)and student (qualitative) variables. In the absence of an interaction term, the model takes the form balance i≈β0+β1×income i+/braceleftBigg β2 ifith person is a student 0 ifith person is not a student =β1×income i+/braceleftBigg β0+β2 ifith person is a student β0 ifith person is not a student . (3.34) Notice that this amounts to fitting two parallel lines to the data, one for students and one for non-students. The lines for students and non-students have different intercepts, β0+β2versusβ0, but the same slope, β1. This is illustrated in the left-hand panel of Figure 3.7. The fact that the lines are parallel means that the average effect on balanceof a one-unit increase inincomedoes not depend on whether or not the individual is a student. This represents a potentially serious", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 121, "start_word": 38720, "end_word": 39120, "chunk_words": 400}}, "ISLP_website::c000122": {"text": ". (3.34) Notice that this amounts to fitting two parallel lines to the data, one for students and one for non-students. The lines for students and non-students have different intercepts, β0+β2versusβ0, but the same slope, β1. This is illustrated in the left-hand panel of Figure 3.7. The fact that the lines are parallel means that the average effect on balanceof a one-unit increase inincomedoes not depend on whether or not the individual is a student. This represents a potentially serious limitation of the model, since in fact a change in incomemay have a very different effect on the credit card balance of a student versus a non-student. This limitation can be addressed by adding an interaction variable, cre- ated by multiplying incomewith the dummy variable for student. Our model now becomes balance i≈β0+β1×income i+/braceleftBigg β2+β3×income iif student 0 if not student =/braceleftBigg (β0+β2)+( β1+β3)×income iif student β0+β1×income i if not student . (3.35) Once again, we have two different regression lines for the students and the non-students. But now those regression lines have different intercepts, β0+β2versusβ0,aswellasdifferentslopes, β1+β3versusβ1.Thisallowsfor the possibility that changes in income may affect the credit card balances of students and non-students differently. The right-hand panel of Figure 3.7 98 3. Linear Regression 0 50 100 150200 600 1000 1400IncomeBalance0 50 100 150200 600 1000 1400IncomeBalancestudentnon−student FIGURE 3.7. For theCreditdata, the least squares lines are shown for pre- diction of balance fromincomefor students and non-students. Left:The model (3.34) was fit. There is no interaction between incomeandstudent.Right:The model (3.35) was fit. There is an interaction term between incomeandstudent. shows the estimated relationships between incomeandbalancefor students and non-students in the model ( 3.35). We note that the slope for students is lower than the slope for non-students. This suggests that increases in income are associated with smaller increases in credit card balance among students as compared to non-students. Non-linear Relationships As discussed previously, the linear regression model ( 3.19) assumes a linear relationship between the response and predictors. But in some cases, the true relationship between the response and the predictors may be non- linear.Herewepresentaverysimplewaytodirectlyextendthelinearmodel to accommodate non-linear relationships, using polynomial regression . Inpolynomial regressionlater chapters, we will present more complex approaches for performing non-linear fits in more general settings. Consider Figure 3.8, in which the mpg(gas mileage in miles per gallon) versushorsepower is shown for a number of cars in the Autodata set. The orange line represents the linear regression", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 122, "start_word": 39040, "end_word": 39440, "chunk_words": 400}}, "ISLP_website::c000123": {"text": "linear relationship between the response and predictors. But in some cases, the true relationship between the response and the predictors may be non- linear.Herewepresentaverysimplewaytodirectlyextendthelinearmodel to accommodate non-linear relationships, using polynomial regression . Inpolynomial regressionlater chapters, we will present more complex approaches for performing non-linear fits in more general settings. Consider Figure 3.8, in which the mpg(gas mileage in miles per gallon) versushorsepower is shown for a number of cars in the Autodata set. The orange line represents the linear regression fit. There is a pronounced rela- tionship between mpgandhorsepower , but it seems clear that this relation- ship is in fact non-linear: the data suggest a curved relationship. A simple approach for incorporating non-linear associations in a linear model is to include transformed versions of the predictors. For example, the points in Figure3.8seem to have a quadratic shape, suggesting that a model of thequadraticform mpg=β0+β1×horsepower +β2×horsepower2+/epsilon1 (3.36) may provide a better fit. Equation 3.36involves predicting mpgusing a non-linear function of horsepower .But it is still a linear model! That is, (3.36) is simply a multiple linear regression model with X1=horsepower andX2=horsepower2. So we can use standard linear regression software to estimate β0,β1, andβ2in order to produce a non-linear fit. The blue curve in Figure 3.8shows the resulting quadratic fit to the data. The quadratic 3.3 Other Considerations in the Regression Model 99 5010015020010 20 30 40 50HorsepowerMiles per gallonLinearDegree 2Degree 5 FIGURE 3.8. TheAutodata set. For a number of cars, mpgandhorsepower are shown. The linear regression fit is shown in orange. The linear regression fit for a model that includes horsepower2is shown as a blue curve. The linear regression fit for a model that includes all polynomials of horsepower up to fifth-degree is shown in green. Coefficient Std. error t-statistic p-value Intercept 56.9001 1.8004 31.6 <0.0001 horsepower −0.4662 0.0311 −15.0<0.0001 horsepower20.0012 0.0001 10.1 <0.0001 TABLE 3.10. FortheAutodataset,leastsquarescoefficientestimatesassociated with the regression of mpgontohorsepower andhorsepower2. fit appears to be substantially better than the fit obtained when just the linear term is included. The R2of the quadratic fit is 0.688, compared to 0.606for the linear fit, and the p-value in Table 3.10for the quadratic term is highly significant. If including horsepower2led to such a big improvement in the model, why notinclude horsepower3,horsepower4,oreven horsepower5?Thegreencurve in Figure 3.8displays the fit that results from including all polynomials up to fifth degree in the model ( 3.36). The resulting fit seems unnecessarily wiggly—that is, it is unclear", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 123, "start_word": 39360, "end_word": 39760, "chunk_words": 400}}, "ISLP_website::c000124": {"text": "the fit obtained when just the linear term is included. The R2of the quadratic fit is 0.688, compared to 0.606for the linear fit, and the p-value in Table 3.10for the quadratic term is highly significant. If including horsepower2led to such a big improvement in the model, why notinclude horsepower3,horsepower4,oreven horsepower5?Thegreencurve in Figure 3.8displays the fit that results from including all polynomials up to fifth degree in the model ( 3.36). The resulting fit seems unnecessarily wiggly—that is, it is unclear that including the additional terms really has led to a better fit to the data. The approach that we have just described for extending the linear model to accommodate non-linear relationships is known as polynomial regres- sion, since we have included polynomial functions of the predictors in the regression model. We further explore this approach and other non-linear extensions of the linear model in Chapter 7. 100 3. Linear Regression3.3.3 Potential ProblemsWhen we fit a linear regression model to a particular data set, many prob-lems may occur. Most common among these are the following:1.Non-linearity of the response-predictor relationships.2.Correlation of error terms.3.Non-constant variance of error terms.4.Outliers.5.High-leverage points.6.Collinearity.In practice, identifying and overcoming these problems is as much anart as a science. Many pages in countless books have been written on thistopic. Since the linear regression model is not our primary focus here, wewill provide only a brief summary of some key points.1. Non-linearity of the Data 5 10 15 20 25 30−15 −10 −5 0 5 10 15 20Fitted valuesResidualsResidual Plot for Linear Fit323330334 15 20 25 30 35−15 −10 −5 0 5 10 15Fitted valuesResidualsResidual Plot for Quadratic Fit334323 155FIGURE 3.9.Plots of residuals versus predicted (or fitted) values for theAutodata set. In each plot, the red line is a smooth fit to the residuals, intended to makeit easier to identify a trend.Left:A linear regression ofmpgonhorsepower.Astrong pattern in the residuals indicates non-linearity in the data.Right:A linearregression ofmpgonhorsepowerandhorsepower2. There is little pattern in theresiduals.The linear regression model assumes that there is a straight-line rela-tionship between the predictors and the response. If the true relationshipis far from linear, then virtually all of the conclusions that we draw fromthe fit are suspect. In addition, the prediction accuracy of the model canbe significantly reduced.Residual plotsare a useful graphical tool for identifying non-linearity.residual plotGiven a simple linear regression model, we can plot the residuals,ei= 3.3 Other Considerations in the Regression Model 101 yi−ˆyi, versus the predictor xi.", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 124, "start_word": 39680, "end_word": 40080, "chunk_words": 400}}, "ISLP_website::c000125": {"text": "theresiduals.The linear regression model assumes that there is a straight-line rela-tionship between the predictors and the response. If the true relationshipis far from linear, then virtually all of the conclusions that we draw fromthe fit are suspect. In addition, the prediction accuracy of the model canbe significantly reduced.Residual plotsare a useful graphical tool for identifying non-linearity.residual plotGiven a simple linear regression model, we can plot the residuals,ei= 3.3 Other Considerations in the Regression Model 101 yi−ˆyi, versus the predictor xi. In the case of a multiple regression model, since there are multiple predictors, we instead plot the residuals versus the predicted (or fitted) values ˆyi. Ideally, the residual plot will show nofitteddiscernible pattern. The presence of a pattern may indicate a problem with some aspect of the linear model. The left panel of Figure 3.9displays a residual plot from the linear re- gression of mpgontohorsepower on theAutodata set that was illustrated in Figure3.8.Theredlineisasmoothfittotheresiduals,whichisdisplayedin order to make it easier to identify any trends. The residuals exhibit a clear U-shape, which provides a strong indication of non-linearity in the data. In contrast, the right-hand panel of Figure 3.9displays the residual plot that results from the model ( 3.36), which contains a quadratic term. There appears to be little pattern in the residuals, suggesting that the quadratic term improves the fit to the data. If the residual plot indicates that there are non-linear associations in the data, then a simple approach is to use non-linear transformations of the predictors, such as logX,√ X, andX2, in the regression model. In the later chapters of this book, we will discuss other more advanced non-linear approaches for addressing this issue. 2. Correlation of Error Terms An important assumption of the linear regression model is that the error terms,/epsilon11,/epsilon12,...,/epsilon1n, are uncorrelated. What does this mean? For instance, if the errors are uncorrelated, then the fact that /epsilon1iis positive provides little or no information about the sign of /epsilon1i+1. The standard errors that are computed for the estimated regression coefficients or the fitted values are based on the assumption of uncorrelated error terms. If in fact there is correlation among the error terms, then the estimated standard errors will tend to underestimate the true standard errors. As a result, confidence and prediction intervals will be narrower than they should be. For example, a 95% confidence interval may in reality have a much lower probability than0.95of containing the true", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 125, "start_word": 40000, "end_word": 40400, "chunk_words": 400}}, "ISLP_website::c000126": {"text": "/epsilon1i+1. The standard errors that are computed for the estimated regression coefficients or the fitted values are based on the assumption of uncorrelated error terms. If in fact there is correlation among the error terms, then the estimated standard errors will tend to underestimate the true standard errors. As a result, confidence and prediction intervals will be narrower than they should be. For example, a 95% confidence interval may in reality have a much lower probability than0.95of containing the true value of the parameter. In addition, p- values associated with the model will be lower than they should be; this could cause us to erroneously conclude that a parameter is statistically significant. In short, if the error terms are correlated, we may have an unwarranted sense of confidence in our model. As an extreme example, suppose we accidentally doubled our data, lead- ing to observations and error terms identical in pairs. If we ignored this, our standard error calculations would be as if we had a sample of size 2n, when in fact we have only nsamples. Our estimated parameters would be the same for the 2nsamples as for the nsamples, but the confidence intervals would be narrower by a factor of√ 2! Why might correlations among the error terms occur? Such correlations frequently occur in the context of time series data, which consists of ob-time seriesservations for which measurements are obtained at discrete points in time. In many cases, observations that are obtained at adjacent time points will have positively correlated errors. In order to determine if this is the case for a given data set, we can plot the residuals from our model as a function of time. If the errors are uncorrelated, then there should be no discernible pat- 102 3. Linear Regression 020406080100−3 −1 0 1 2 3ρ=0.0Residual 020406080100−4 −2 0 1 2ρ=0.5Residual 020406080100−1.5 −0.5 0.5 1.5ρ=0.9ResidualObservationFIGURE 3.10. Plots of residuals from simulated time series data sets generated with differing levels of correlation ρbetween error terms for adjacent time points. tern. On the other hand, if the error terms are positively correlated, then we may see tracking in the residuals—that is, adjacent residuals may havetrackingsimilar values. Figure 3.10provides an illustration. In the top panel, we see the residuals from a linear regression fit to data generated with uncorre- lated errors. There is no evidence of a time-related trend in the residuals. In contrast, the residuals in", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 126, "start_word": 40320, "end_word": 40720, "chunk_words": 400}}, "ISLP_website::c000127": {"text": "sets generated with differing levels of correlation ρbetween error terms for adjacent time points. tern. On the other hand, if the error terms are positively correlated, then we may see tracking in the residuals—that is, adjacent residuals may havetrackingsimilar values. Figure 3.10provides an illustration. In the top panel, we see the residuals from a linear regression fit to data generated with uncorre- lated errors. There is no evidence of a time-related trend in the residuals. In contrast, the residuals in the bottom panel are from a data set in which adjacent errors had a correlation of 0.9. Now there is a clear pattern in the residuals—adjacent residuals tend to take on similar values. Finally, the center panel illustrates a more moderate case in which the residuals had a correlation of 0.5. There is still evidence of tracking, but the pattern is less clear. Many methods have been developed to properly take account of corre- lations in the error terms in time series data. Correlation among the error terms can also occur outside of time series data. For instance, consider a study in which individuals’ heights are predicted from their weights. The assumption of uncorrelated errors could be violated if some of the indi- viduals in the study are members of the same family, eat the same diet, or have been exposed to the same environmental factors. In general, the assumption of uncorrelated errors is extremely important for linear regres- sion as well as for other statistical methods, and good experimental design is crucial in order to mitigate the risk of such correlations. 3.3 Other Considerations in the Regression Model 103 10 15 20 25 30−10 −5 0 5 10 15Fitted valuesResidualsResponse Y998975845 2.4 2.6 2.8 3.0 3.2 3.4−0.8 −0.6 −0.4 −0.2 0.0 0.2 0.4Fitted valuesResidualsResponse log(Y) 437671605FIGURE 3.11. Residual plots. In each plot, the red line is a smooth fit to the residuals, intended to make it easier to identify a trend. The blue lines track the outer quantiles of the residuals, and emphasize patterns. Left:The funnel shape indicates heteroscedasticity. Right:The response has been log transformed, and there is now no evidence of heteroscedasticity. 3. Non-constant Variance of Error Terms Another important assumption of the linear regression model is that the error terms have a constant variance, Var (/epsilon1i)=σ2. The standard errors, confidence intervals, and hypothesis tests associated with the linear model rely upon this assumption. Unfortunately,itisoftenthecasethatthevariancesoftheerrortermsare non-constant. For instance,", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 127, "start_word": 40640, "end_word": 41040, "chunk_words": 400}}, "ISLP_website::c000128": {"text": "a trend. The blue lines track the outer quantiles of the residuals, and emphasize patterns. Left:The funnel shape indicates heteroscedasticity. Right:The response has been log transformed, and there is now no evidence of heteroscedasticity. 3. Non-constant Variance of Error Terms Another important assumption of the linear regression model is that the error terms have a constant variance, Var (/epsilon1i)=σ2. The standard errors, confidence intervals, and hypothesis tests associated with the linear model rely upon this assumption. Unfortunately,itisoftenthecasethatthevariancesoftheerrortermsare non-constant. For instance, the variances of the error terms may increase with the value of the response. One can identify non-constant variances in the errors, or heteroscedasticity , from the presence of a funnel shape inhetero- scedasticitytheresidualplot.Anexampleisshownintheleft-handpanelofFigure 3.11, in which the magnitude of the residuals tends to increase with the fitted values. When faced with this problem, one possible solution is to trans- form the response Yusing a concave function such as logYor√ Y. Such a transformation results in a greater amount of shrinkage of the larger re- sponses, leading to a reduction in heteroscedasticity. The right-hand panel of Figure 3.11displays the residual plot after transforming the response usinglogY. The residuals now appear to have constant variance, though there is some evidence of a slight non-linear relationship in the data. Sometimes we have a good idea of the variance of each response. For example, the ith response could be an average of niraw observations. If each of these raw observations is uncorrelated with variance σ2, then their average has variance σ2 i=σ2/ni. In this case a simple remedy is to fit our model by weighted least squares , with weights proportional to the inverseweighted least squaresvariances—i.e. wi=niin this case. Most linear regression software allows for observation weights. 4. Outliers Anoutlieris a point for which yiis far from the value predicted by theoutlier 104 3. Linear Regression −2 −1 0 1 2−4 −2 0 2 4 620 −2 0 2 4 6−1 0 1 2 3 4Fitted ValuesResiduals20 −2 0 2 4 60246Fitted ValuesStudentized Residuals20 XYFIGURE 3.12. Left:The least squares regression line is shown in red, and the regression line after removing the outlier is shown in blue. Center:The residual plot clearly identifies the outlier. Right:The outlier has a studentized residual of 6; typically we expect values between −3and3. model.Outlierscanariseforavarietyofreasons,suchasincorrectrecording of an observation during data collection. The red point (observation 20) in the left-hand panel of Figure 3.12 illustrates a typical outlier. The red", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 128, "start_word": 40960, "end_word": 41360, "chunk_words": 400}}, "ISLP_website::c000129": {"text": "2 3 4Fitted ValuesResiduals20 −2 0 2 4 60246Fitted ValuesStudentized Residuals20 XYFIGURE 3.12. Left:The least squares regression line is shown in red, and the regression line after removing the outlier is shown in blue. Center:The residual plot clearly identifies the outlier. Right:The outlier has a studentized residual of 6; typically we expect values between −3and3. model.Outlierscanariseforavarietyofreasons,suchasincorrectrecording of an observation during data collection. The red point (observation 20) in the left-hand panel of Figure 3.12 illustrates a typical outlier. The red solid line is the least squares regression fit, while the blue dashed line is the least squares fit after removal of the outlier.Inthiscase,removingtheoutlierhaslittleeffectontheleastsquares line: it leads to almost no change in the slope, and a miniscule reduction in the intercept. It is typical for an outlier that does not have an unusual predictor value to have little effect on the least squares fit. However, even if an outlier does not have much effect on the least squares fit, it can cause other problems. For instance, in this example, the RSE is 1.09when the outlier is included in the regression, but it is only 0.77when the outlier is removed. Since the RSE is used to compute all confidence intervals and p-values, such a dramatic increase caused by a single data point can have implications for the interpretation of the fit. Similarly, inclusion of the outlier causes the R2to decline from 0.892to0.805. Residual plots can be used to identify outliers. In this example, the out- lier is clearly visible in the residual plot illustrated in the center panel of Figure3.12. But in practice, it can be difficult to decide how large a resid- ual needs to be before we consider the point to be an outlier. To address this problem, instead of plotting the residuals, we can plot the studentized residuals , computed by dividing each residual eiby its estimated standardstudentized residualerror. Observations whose studentized residuals are greater than 3 in abso- lute value are possible outliers. In the right-hand panel of Figure 3.12, the outlier’s studentized residual exceeds 6, while all other observations have studentized residuals between −2and2. If we believe that an outlier has occurred due to an error in data collec- tion or recording, then one solution is to simply remove the observation. However, care should be taken, since an outlier may instead indicate a deficiency with the model, such as a missing predictor. 5. High Leverage Points We", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 129, "start_word": 41280, "end_word": 41680, "chunk_words": 400}}, "ISLP_website::c000130": {"text": "lute value are possible outliers. In the right-hand panel of Figure 3.12, the outlier’s studentized residual exceeds 6, while all other observations have studentized residuals between −2and2. If we believe that an outlier has occurred due to an error in data collec- tion or recording, then one solution is to simply remove the observation. However, care should be taken, since an outlier may instead indicate a deficiency with the model, such as a missing predictor. 5. High Leverage Points We just saw that outliers are observations for which the response yiis unusual given the predictor xi. In contrast, observations with high leveragehigh leveragehave an unusual value for xi. For example, observation 41in the left-hand 3.3 Other Considerations in the Regression Model 105 −2 −1 0 1 2 3 40 5 102041 −2 −1 0 1 2−2 −1 0 1 20.00 0.05 0.10 0.15 0.20 0.25−1 0 1 2 3 4 5LeverageStudentized Residuals2041 XY X1X2FIGURE 3.13. Left:Observation 41 is a high leverage point, while 20 is not. The red line is the fit to all the data, and the blue line is the fit with observation 41 removed. Center:The red observation is not unusual in terms of its X1value or itsX2value, but still falls outside the bulk of the data, and hence has high leverage. Right:Observation 41has a high leverage and a high residual. panel of Figure 3.13has high leverage, in that the predictor value for this observation is large relative to the other observations. (Note that the data displayed in Figure 3.13are the same as the data displayed in Figure 3.12, but with the addition of a single high leverage observation.) The red solid line is the least squares fit to the data, while the blue dashed line is the fit produced when observation 41is removed. Comparing the left-hand panels of Figures 3.12and3.13, we observe that removing the high leverage observation has a much more substantial impact on the least squares line than removing the outlier. In fact, high leverage observations tend to have a sizable impact on the estimated regression line. It is cause for concern if the least squares line is heavily affected by just a couple of observations, because any problems with these points may invalidate the entire fit. For this reason, it is important to identify high leverage observations. In a simple linear regression, high leverage observations are fairly easy to identify, since we can simply", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 130, "start_word": 41600, "end_word": 42000, "chunk_words": 400}}, "ISLP_website::c000131": {"text": "squares line than removing the outlier. In fact, high leverage observations tend to have a sizable impact on the estimated regression line. It is cause for concern if the least squares line is heavily affected by just a couple of observations, because any problems with these points may invalidate the entire fit. For this reason, it is important to identify high leverage observations. In a simple linear regression, high leverage observations are fairly easy to identify, since we can simply look for observations for which the predictor value is outside of the normal range of the observations. But in a multiple linear regression with many predictors, it is possible to have an observation that is well within the range of each individual predictor’s values, but that is unusual in terms of the full set of predictors. An example is shown in the center panel of Figure 3.13, for a data set with two predictors, X1and X2. Most of the observations’ predictor values fall within the blue dashed ellipse, but the red observation is well outside of this range. But neither its value for X1nor its value for X2is unusual. So if we examine just X1or justX2, we will fail to notice this high leverage point. This problem is more pronounced in multiple regression settings with more than two predictors, because then there is no simple way to plot all dimensions of the data simultaneously. In order to quantify an observation’s leverage, we compute the leverage statistic. A large value of this statistic indicates an observation with highleverage statisticleverage. For a simple linear regression, hi=1 n+(xi−¯x)2 /summationtextn i/prime=1(xi/prime−¯x)2. (3.37) 106 3. Linear Regression 2000 4000 6000 8000 1200030 40 50 60 70 80LimitAge 2000 4000 6000 8000 12000200 400 600 800LimitRating FIGURE 3.14. Scatterplots of the observations from the Creditdata set. Left: A plot of ageversuslimit. These two variables are not collinear. Right:A plot ofratingversuslimit. There is high collinearity. Itisclearfromthisequationthat hiincreaseswiththedistanceof xifrom¯x. There is a simple extension of hito the case of multiple predictors, though we do not provide the formula here. The leverage statistic hiis always between 1/nand1, and the average leverage for all the observations is always equal to (p+ 1)/n. So if a given observation has a leverage statistic that greatly exceeds (p+1)/n, then we may suspect that the corresponding point has high leverage. The right-hand panel of Figure 3.13provides a plot of the studentized residuals versus hifor", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 131, "start_word": 41920, "end_word": 42320, "chunk_words": 400}}, "ISLP_website::c000132": {"text": "xifrom¯x. There is a simple extension of hito the case of multiple predictors, though we do not provide the formula here. The leverage statistic hiis always between 1/nand1, and the average leverage for all the observations is always equal to (p+ 1)/n. So if a given observation has a leverage statistic that greatly exceeds (p+1)/n, then we may suspect that the corresponding point has high leverage. The right-hand panel of Figure 3.13provides a plot of the studentized residuals versus hifor the data in the left-hand panel of Figure 3.13. Ob- servation 41stands out as having a very high leverage statistic as well as a high studentized residual. In other words, it is an outlier as well as a high leverage observation. This is a particularly dangerous combination! This plot also reveals the reason that observation 20 had relatively little effect on the least squares fit in Figure 3.12: it has low leverage. 6. Collinearity Collinearity refers to the situation in which two or more predictor variablescollinearityare closely related to one another. The concept of collinearity is illustrated in Figure 3.14using the Creditdata set. In the left-hand panel of Fig- ure3.14, the two predictors limitandageappear to have no obvious rela- tionship. In contrast, in the right-hand panel of Figure 3.14, the predictors limitandratingare very highly correlated with each other, and we say that they are collinear. The presence of collinearity can pose problems in the regression context, since it can be difficult to separate out the indi- vidual effects of collinear variables on the response. In other words, since limitandratingtend to increase or decrease together, it can be difficult to determinehoweachoneseparatelyisassociatedwiththeresponse, balance. Figure3.15illustratessomeofthedifficultiesthatcanresultfromcollinear- ity. The left-hand panel of Figure 3.15is a contour plot of the RSS ( 3.22) associated with different possible coefficient estimates for the regression ofbalanceonlimitandage. Each ellipse represents a set of coefficients 3.3 Other Considerations in the Regression Model 107 21.25 21.5 21.8 0.16 0.17 0.18 0.19−5 −4 −3 −2 −1 0 21.5 21.8 −0.1 0.0 0.1 0.2012345βLimitβLimitβAge βRating FIGURE 3.15. Contour plots for the RSS values as a function of the parameters βfor various regressions involving the Creditdata set. In each plot, the black dots represent the coefficient values corresponding to the minimum RSS. Left: A contour plot of RSS for the regression of balance ontoageandlimit. The minimum value is well defined. Right:A contour plot of RSS for the regression ofbalance ontoratingandlimit. Because of the collinearity, there", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 132, "start_word": 42240, "end_word": 42640, "chunk_words": 400}}, "ISLP_website::c000133": {"text": "−3 −2 −1 0 21.5 21.8 −0.1 0.0 0.1 0.2012345βLimitβLimitβAge βRating FIGURE 3.15. Contour plots for the RSS values as a function of the parameters βfor various regressions involving the Creditdata set. In each plot, the black dots represent the coefficient values corresponding to the minimum RSS. Left: A contour plot of RSS for the regression of balance ontoageandlimit. The minimum value is well defined. Right:A contour plot of RSS for the regression ofbalance ontoratingandlimit. Because of the collinearity, there are many pairs(βLimit,βRating )with a similar value for RSS. that correspond to the same RSS, with ellipses nearest to the center tak- ing on the lowest values of RSS. The black dots and associated dashed lines represent the coefficient estimates that result in the smallest possible RSS—in other words, these are the least squares estimates. The axes for limitandagehave been scaled so that the plot includes possible coeffi- cient estimates that are up to four standard errors on either side of the least squares estimates. Thus the plot includes all plausible values for the coefficients. For example, we see that the true limitcoefficient is almost certainly somewhere between 0.15and0.20. In contrast, the right-hand panel of Figure 3.15displays contour plots of the RSS associated with possible coefficient estimates for the regression ofbalanceontolimitandrating, which we know to be highly collinear. Now the contours run along a narrow valley; there is a broad range of values for the coefficient estimates that result in equal values for RSS. Hence a small change in the data could cause the pair of coefficient values that yield the smallest RSS—that is, the least squares estimates—to move anywhere along this valley. This results in a great deal of uncertainty in the coefficientestimates.Noticethatthescaleforthe limitcoefficientnowruns from roughly −0.2to0.2; this is an eight-fold increase over the plausible range of the limitcoefficient in the regression with age. Interestingly, even though the limitandratingcoefficients now have much more individual uncertainty, they will almost certainly lie somewhere in this contour valley. For example, we would not expect the true value of the limitandrating coefficients to be −0.1and1respectively, even though such a value is plausible for each coefficient individually. Since collinearity reduces the accuracy of the estimates of the regression coefficients, it causes the standard error for ˆβjto grow. Recall that the t-statistic for each predictor is calculated by dividing ˆβjby its standard 108 3. Linear Regression Coefficient Std. error t-statistic p-value Intercept −173.411 43.828 −3.957<0.0001", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 133, "start_word": 42560, "end_word": 42960, "chunk_words": 400}}, "ISLP_website::c000134": {"text": "lie somewhere in this contour valley. For example, we would not expect the true value of the limitandrating coefficients to be −0.1and1respectively, even though such a value is plausible for each coefficient individually. Since collinearity reduces the accuracy of the estimates of the regression coefficients, it causes the standard error for ˆβjto grow. Recall that the t-statistic for each predictor is calculated by dividing ˆβjby its standard 108 3. Linear Regression Coefficient Std. error t-statistic p-value Intercept −173.411 43.828 −3.957<0.0001 Model 1 age −2.292 0.672 −3.407 0.0007 limit 0.173 0.005 34.496 <0.0001 Intercept −377.537 45.254 −8.343<0.0001 Model 2 rating 2.202 0.952 2.312 0.0213 limit 0.025 0.064 0.384 0.7012 TABLE 3.11. The results for two multiple regression models involving the Credit data set are shown. Model 1 is a regression of balance onageandlimit, and Model 2 a regression of balance onratingandlimit. The standard error of ˆβlimitincreases 12-fold in the second regression, due to collinearity. error. Consequently, collinearity results in a decline in the t-statistic. As a result, in the presence of collinearity, we may fail to reject H0:βj=0. This means that the powerof the hypothesis test—the probability of correctlypower detecting a non-zero coefficient—is reduced by collinearity. Table3.11compares the coefficient estimates obtained from two separate multiple regression models. The first is a regression of balanceonageand limit, and the second is a regression of balanceonratingandlimit. In the first regression, both ageandlimitare highly significant with very small p- values. In the second, the collinearity between limitandratinghas caused the standard error for the limitcoefficient estimate to increase by a factor of12and thep-value to increase to 0.701. In other words, the importance of thelimitvariable has been masked due to the presence of collinearity. To avoid such a situation, it is desirable to identify and address potential collinearity problems while fitting the model. A simple way to detect collinearity is to look at the correlation matrix of the predictors. An element of this matrix that is large in absolute value indicates a pair of highly correlated variables, and therefore a collinearity problem in the data. Unfortunately, not all collinearity problems can be detected by inspection of the correlation matrix: it is possible for collinear- ity to exist between three or more variables even if no pair of variables has a particularly high correlation. We call this situation multicollinearity .multi- collinearityInstead of inspecting the correlation matrix, a better way to assess multi- collinearity is to compute the variance", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 134, "start_word": 42880, "end_word": 43280, "chunk_words": 400}}, "ISLP_website::c000135": {"text": "in absolute value indicates a pair of highly correlated variables, and therefore a collinearity problem in the data. Unfortunately, not all collinearity problems can be detected by inspection of the correlation matrix: it is possible for collinear- ity to exist between three or more variables even if no pair of variables has a particularly high correlation. We call this situation multicollinearity .multi- collinearityInstead of inspecting the correlation matrix, a better way to assess multi- collinearity is to compute the variance inflation factor (VIF). The VIF isvariance inflation factorthe ratio of the variance of ˆβjwhen fitting the full model divided by the variance of ˆβjif fit on its own. The smallest possible value for VIF is 1, which indicates the complete absence of collinearity. Typically in practice there is a small amount of collinearity among the predictors. As a rule of thumb, a VIF value that exceeds 5or10indicates a problematic amount of collinearity. The VIF for each variable can be computed using the formula VIF(ˆβj)=1 1−R2 Xj|X−j, whereR2 Xj|X−jis theR2from a regression of Xjonto all of the other predictors. If R2 Xj|X−jis close to one, then collinearity is present, and so the VIF will be large. 3.4 The Marketing Plan 109 In theCreditdata, a regression of balanceonage,rating, andlimit indicates that the predictors have VIF values of 1.01, 160.67, and 160.59. As we suspected, there is considerable collinearity in the data! When faced with the problem of collinearity, there are two simple solu- tions. The first is to drop one of the problematic variables from the regres- sion. This can usually be done without much compromise to the regression fit, since the presence of collinearity implies that the information that this variable provides about the response is redundant in the presence of the other variables. For instance, if we regress balance ontoageandlimit, without the ratingpredictor, then the resulting VIF values are close to the minimum possible value of 1, and the R2drops from 0.754to0.75. So dropping ratingfrom the set of predictors has effectively solved the collinearity problem without compromising the fit. The second solution is to combine the collinear variables together into a single predictor. For in- stance, we might take the average of standardized versions of limitand ratingin order to create a new variable that measures credit worthiness . 3.4 The Marketing Plan We now briefly return to the seven questions about the Advertising data that we set out to answer", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 135, "start_word": 43200, "end_word": 43600, "chunk_words": 400}}, "ISLP_website::c000136": {"text": "from 0.754to0.75. So dropping ratingfrom the set of predictors has effectively solved the collinearity problem without compromising the fit. The second solution is to combine the collinear variables together into a single predictor. For in- stance, we might take the average of standardized versions of limitand ratingin order to create a new variable that measures credit worthiness . 3.4 The Marketing Plan We now briefly return to the seven questions about the Advertising data that we set out to answer at the beginning of this chapter. 1.Is there a relationship between sales and advertising budget? This question can be answered by fitting a multiple regression model ofsalesontoTV,radio, andnewspaper , as in (3.20), and testing the hypothesis H0:βTV=βradio=βnewspaper =0. In Section 3.2.2, we showed that the F-statistic can be used to determine whether or not we should reject this null hypothesis. In this case the p-value corresponding to the F-statistic in Table 3.6is very low, indicating clear evidence of a relationship between advertising and sales. 2.How strong is the relationship? We discussed two measures of model accuracy in Section 3.1.3. First, the RSE estimates the standard deviation of the response from the population regression line. For the Advertising data, the RSE is 1.69 units while the mean value for the response is 14.022, indicating a percentage error of roughly 12%. Second, the R2statistic records the percentage of variability in the response that is explained by the predictors. The predictors explain almost 90% of the variance in sales. The RSE and R2statistics are displayed in Table 3.6. 3.Which media are associated with sales? To answer this question, we can examine the p-values associated with each predictor’s t-statistic (Section 3.1.2). In the multiple linear re- gression displayed in Table 3.4, thep-values for TVandradioare low, but thep-value for newspaper is not. This suggests that only TVand radioare related to sales. In Chapter 6we explore this question in greater detail. 110 3. Linear Regression 4.How large is the association between each medium and sales? We saw in Section 3.1.2that the standard error of ˆβjcan be used to construct confidence intervals for βj. For the Advertising data, we can use the results in Table 3.4to compute the 95% confidence inter- vals for the coefficients in a multiple regression model using all three media budgets as predictors. The confidence intervals are as follows: (0.043,0.049) forTV,(0.172,0.206) forradio, and(−0.013,0.011) for newspaper . The confidence intervals for TVandradioare narrow and", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 136, "start_word": 43520, "end_word": 43920, "chunk_words": 400}}, "ISLP_website::c000137": {"text": "large is the association between each medium and sales? We saw in Section 3.1.2that the standard error of ˆβjcan be used to construct confidence intervals for βj. For the Advertising data, we can use the results in Table 3.4to compute the 95% confidence inter- vals for the coefficients in a multiple regression model using all three media budgets as predictors. The confidence intervals are as follows: (0.043,0.049) forTV,(0.172,0.206) forradio, and(−0.013,0.011) for newspaper . The confidence intervals for TVandradioare narrow and far from zero, providing evidence that these media are related to sales. But the interval for newspaper includes zero, indicating that the variable is not statistically significant given the values of TVand radio. We saw in Section 3.3.3that collinearity can result in very wide stan- dard errors. Could collinearity be the reason that the confidence in- terval associated with newspaper is so wide? The VIF scores are 1.005, 1.145, and1.145forTV,radio, andnewspaper , suggesting no evidence of collinearity. In order to assess the association of each medium individually on sales, we can perform three separate simple linear regressions. Re- sults are shown in Tables 3.1and3.3. There is evidence of an ex- tremely strong association between TVandsalesand between radio andsales. There is evidence of a mild association between newspaper andsales, when the values of TVandradioare ignored. 5.How accurately can we predict future sales? The response can be predicted using ( 3.21). The accuracy associ- ated with this estimate depends on whether we wish to predict an individual response, Y=f(X)+/epsilon1, or the average response, f(X) (Section 3.2.2). If the former, we use a prediction interval, and if the latter, we use a confidence interval. Prediction intervals will al- ways be wider than confidence intervals because they account for the uncertainty associated with /epsilon1, the irreducible error. 6.Is the relationship linear? In Section 3.3.3, we saw that residual plots can be used in order to identify non-linearity. If the relationships are linear, then the residual plots should display no pattern. In the case of the Advertising data, we observe a non-linear effect in Figure 3.5, though this effect could also be observed in a residual plot. In Section 3.3.2, we discussed the inclusion of transformations of the predictors in the linear regression model in order to accommodate non-linear relationships. 7.Is there synergy among the advertising media? The standard linear regression model assumes an additive relation- ship between the predictors and the response. An additive", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 137, "start_word": 43840, "end_word": 44240, "chunk_words": 400}}, "ISLP_website::c000138": {"text": "residual plots should display no pattern. In the case of the Advertising data, we observe a non-linear effect in Figure 3.5, though this effect could also be observed in a residual plot. In Section 3.3.2, we discussed the inclusion of transformations of the predictors in the linear regression model in order to accommodate non-linear relationships. 7.Is there synergy among the advertising media? The standard linear regression model assumes an additive relation- ship between the predictors and the response. An additive model is easy to interpret because the association between each predictor and the response is unrelated to the values of the other predictors. However, the additive assumption may be unrealistic for certain data sets. In Section 3.3.2, we showed how to include an interaction term 111 in the regression model in order to accommodate non-additive rela- tionships. A small p-value associated with the interaction term indi- cates the presence of such relationships. Figure 3.5suggested that the Advertising data may not be additive. Including an interaction term in the model results in a substantial increase in R2, from around 90% to almost 97%. 3.5 Comparison of Linear Regression withK-Nearest Neighbors As discussed in Chapter 2, linear regression is an example of a parametric approach because it assumes a linear functional form for f(X). Parametric methods have several advantages. They are often easy to fit, because one need estimate only a small number of coefficients. In the case of linear re- gression, the coefficients have simple interpretations, and tests of statistical significance can be easily performed. But parametric methods do have a disadvantage: by construction, they make strong assumptions about the form off(X). If the specified functional form is far from the truth, and prediction accuracy is our goal, then the parametric method will perform poorly. For instance, if we assume a linear relationship between XandY but the true relationship is far from linear, then the resulting model will provide a poor fit to the data, and any conclusions drawn from it will be suspect. In contrast, non-parametric methods do not explicitly assume a para- metric form for f(X), and thereby provide an alternative and more flexi- ble approach for performing regression. We discuss various non-parametric methods in this book. Here we consider one of the simplest and best-known non-parametricmethods, K-nearest neighbors regression (KNNregression).K-nearest neighbors regressionThe KNN regression method is closely related to the KNN classifier dis- cussed in Chapter 2. Given", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 138, "start_word": 44160, "end_word": 44560, "chunk_words": 400}}, "ISLP_website::c000139": {"text": "fit to the data, and any conclusions drawn from it will be suspect. In contrast, non-parametric methods do not explicitly assume a para- metric form for f(X), and thereby provide an alternative and more flexi- ble approach for performing regression. We discuss various non-parametric methods in this book. Here we consider one of the simplest and best-known non-parametricmethods, K-nearest neighbors regression (KNNregression).K-nearest neighbors regressionThe KNN regression method is closely related to the KNN classifier dis- cussed in Chapter 2. Given a value for Kand a prediction point x0, KNN regression first identifies the Ktraining observations that are closest to x0, represented by N0. It then estimates f(x0)using the average of all the training responses in N0. In other words, ˆf(x0)=1 K/summationdisplay xi∈N0yi. Figure3.16illustratestwoKNNfitsonadatasetwith p=2predictors.The fit withK=1is shown in the left-hand panel, while the right-hand panel corresponds to K=9. We see that when K=1, the KNN fit perfectly interpolates the training observations, and consequently takes the form of a step function. When K=9, the KNN fit still is a step function, but averaging over nine observations results in much smaller regions of constant prediction, and consequently a smoother fit. In general, the optimal value forKwill depend on the bias-variance tradeoff , which we introduced in Chapter 2. A small value for Kprovides the most flexible fit, which will have low bias but high variance. This variance is due to the fact that the prediction in a given region is entirely dependent on just one observation.3.5ComparisonofLinearRegressionwithK-NearestNeighbors 112 3. Linear Regression yyx1x1x2x2yyy FIGURE 3.16. Plots of ˆf(X)using KNN regression on a two-dimensional data set with 64observations (orange dots). Left:K=1results in a rough step function fit. Right:K=9produces a much smoother fit. In contrast, larger values of Kprovide a smoother and less variable fit; the prediction in a region is an average of several points, and so changing one observation has a smaller effect. However, the smoothing may cause bias by masking some of the structure in f(X). In Chapter 5, we introduce several approaches for estimating test error rates. These methods can be used to identify the optimal value of Kin KNN regression. Inwhatsettingwillaparametricapproachsuchasleastsquareslinearre- gression outperform a non-parametric approach such as KNN regression? The answer is simple: the parametric approach will outperform the non- parametric approach if the parametric form that has been selected is close to the true form of f. Figure3.17provides an example with data generated from a one-dimensional linear regression model.", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 139, "start_word": 44480, "end_word": 44880, "chunk_words": 400}}, "ISLP_website::c000140": {"text": "structure in f(X). In Chapter 5, we introduce several approaches for estimating test error rates. These methods can be used to identify the optimal value of Kin KNN regression. Inwhatsettingwillaparametricapproachsuchasleastsquareslinearre- gression outperform a non-parametric approach such as KNN regression? The answer is simple: the parametric approach will outperform the non- parametric approach if the parametric form that has been selected is close to the true form of f. Figure3.17provides an example with data generated from a one-dimensional linear regression model. The black solid lines rep- resentf(X), while the blue curves correspond to the KNN fits using K=1 andK=9. In this case, the K=1predictions are far too variable, while the smoother K=9 fit is much closer to f(X). However, since the true relationship is linear, it is hard for a non-parametric approach to compete with linear regression: a non-parametric approach incurs a cost in variance that is not offset by a reduction in bias. The blue dashed line in the left- hand panel of Figure 3.18represents the linear regression fit to the same data. It is almost perfect. The right-hand panel of Figure 3.18reveals that linear regression outperforms KNN for this data. The green solid line, plot- ted as a function of 1/K, represents the test set mean squared error (MSE) for KNN. The KNN errors are well above the black dashed line, which is the test MSE for linear regression. When the value of Kis large, then KNN performs only a little worse than least squares regression in terms of MSE. It performs far worse when Kis small. In practice, the true relationship between XandYis rarely exactly lin- ear. Figure 3.19examines the relative performances of least squares regres- sion and KNN under increasing levels of non-linearity in the relationship between XandY. In the top row, the true relationship is nearly linear. In this case we see that the test MSE for linear regression is still superior 3.5ComparisonofLinearRegressionwithK-NearestNeighbors113 −1.0 −0.5 0.0 0.5 1.01234−1.0 −0.5 0.0 0.5 1.01234yyxxFIGURE 3.17. Plots of ˆf(X)using KNN regression on a one-dimensional data set with 50observations. The true relationship is given by the black solid line. Left:The blue curve corresponds to K=1and interpolates (i.e. passes directly through) the training data. Right:The blue curve corresponds to K=9, and represents a smoother fit. −1.0 −0.5 0.0 0.5 1.012340.20.5 1.00.00 0.05 0.10 0.15Mean Squared Erroryx1/KFIGURE 3.18. The same data set shown in Figure 3.17is investigated further. Left:The blue dashed line", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 140, "start_word": 44800, "end_word": 45200, "chunk_words": 400}}, "ISLP_website::c000141": {"text": "0.5 1.01234−1.0 −0.5 0.0 0.5 1.01234yyxxFIGURE 3.17. Plots of ˆf(X)using KNN regression on a one-dimensional data set with 50observations. The true relationship is given by the black solid line. Left:The blue curve corresponds to K=1and interpolates (i.e. passes directly through) the training data. Right:The blue curve corresponds to K=9, and represents a smoother fit. −1.0 −0.5 0.0 0.5 1.012340.20.5 1.00.00 0.05 0.10 0.15Mean Squared Erroryx1/KFIGURE 3.18. The same data set shown in Figure 3.17is investigated further. Left:The blue dashed line is the least squares fit to the data. Since f(X)is in fact linear (displayed as the black line), the least squares regression line provides a very good estimate of f(X).Right:The dashed horizontal line represents the least squares test set MSE, while the green solid line corresponds to the MSE for KNN as a function of 1/K(on the log scale). Linear regression achieves a lower test MSE than does KNN regression, since f(X)is in fact linear. For KNN regression, the best results occur with a very large value of K, corresponding to a small value of 1/K. 114 3. Linear Regression −1.0 −0.5 0.0 0.5 1.00.5 1.0 1.5 2.0 2.5 3.0 3.50.20.51.00.00 0.02 0.04 0.06 0.08Mean Squared Error −1.0 −0.5 0.0 0.5 1.01.0 1.5 2.0 2.5 3.0 3.50.20.51.00.00 0.05 0.10 0.15Mean Squared Erroryy xx 1/K1/K FIGURE 3.19. Top Left: In a setting with a slightly non-linear relationship between XandY(solid black line), the KNN fits with K=1(blue) and K=9 (red) are displayed. Top Right: For the slightly non-linear data, the test set MSE for least squares regression (horizontal black) and KNN with various values of 1/K(green) are displayed. Bottom Left and Bottom Right: As in the top panel, but with a strongly non-linear relationship between XandY. to that of KNN for low values of K. However, for K≥4, KNN out- performs linear regression. The second row illustrates a more substantial deviation from linearity. In this situation, KNN substantially outperforms linear regression for all values of K. Note that as the extent of non-linearity increases, there is little change in the test set MSE for the non-parametric KNN method, but there is a large increase in the test set MSE of linear regression. Figures3.18and3.19display situations in which KNN performs slightly worse than linear regression when the relationship is linear, but much bet- ter than linear regression for nonlinear situations. In a real life situation in which the true relationship is unknown, one might", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 141, "start_word": 45120, "end_word": 45520, "chunk_words": 400}}, "ISLP_website::c000142": {"text": "all values of K. Note that as the extent of non-linearity increases, there is little change in the test set MSE for the non-parametric KNN method, but there is a large increase in the test set MSE of linear regression. Figures3.18and3.19display situations in which KNN performs slightly worse than linear regression when the relationship is linear, but much bet- ter than linear regression for nonlinear situations. In a real life situation in which the true relationship is unknown, one might suspect that KNN should be favored over linear regression because it will at worst be slightly inferior to linear regression if the true relationship is linear, and may give substantially better results if the true relationship is non-linear. But in re- ality, even when the true relationship is highly non-linear, KNN may still provide inferior results to linear regression. In particular, both Figures 3.18 3.5 Comparison of Linear Regression with K-Nearest Neighbors 115 0.2 0.5 1.00.0 0.2 0.4 0.6 0.8 1.0p=1 0.2 0.5 1.00.0 0.2 0.4 0.6 0.8 1.0p=2 0.2 0.5 1.00.0 0.2 0.4 0.6 0.8 1.0p=3 0.2 0.5 1.00.0 0.2 0.4 0.6 0.8 1.0p=4 0.2 0.5 1.00.0 0.2 0.4 0.6 0.8 1.0p=10 0.2 0.5 1.00.0 0.2 0.4 0.6 0.8 1.0p=20Mean Squared Error1/KFIGURE 3.20. Test MSE for linear regression (black dashed lines) and KNN (green curves) as the number of variables pincreases. The true function is non- linear in the first variable, as in the lower panel in Figure 3.19, and does not depend on the additional variables. The performance of linear regression deteri- orates slowly in the presence of these additional noise variables, whereas KNN’s performance degrades much more quickly as pincreases. and3.19illustrate settings with p=1predictor. But in higher dimensions, KNN often performs worse than linear regression. Figure3.20considers the same strongly non-linear situation as in the second row of Figure 3.19, except that we have added additional noise predictors that are not associated with the response. When p=1orp=2, KNN outperforms linear regression. But for p=3 the results are mixed, and forp≥4linear regression is superior to KNN. In fact, the increase in dimension has only caused a small deterioration in the linear regression test set MSE, but it has caused more than a ten-fold increase in the MSE for KNN.Thisdecreaseinperformanceasthedimensionincreasesisacommon problem for KNN, and results from the fact that in higher dimensions there is effectively a reduction in sample size. In this data set there are 50training observations; when p=1,", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 142, "start_word": 45440, "end_word": 45840, "chunk_words": 400}}, "ISLP_website::c000143": {"text": "outperforms linear regression. But for p=3 the results are mixed, and forp≥4linear regression is superior to KNN. In fact, the increase in dimension has only caused a small deterioration in the linear regression test set MSE, but it has caused more than a ten-fold increase in the MSE for KNN.Thisdecreaseinperformanceasthedimensionincreasesisacommon problem for KNN, and results from the fact that in higher dimensions there is effectively a reduction in sample size. In this data set there are 50training observations; when p=1, this provides enough information to accurately estimate f(X). However, spreading 50observations over p= 20 dimensions results in a phenomenon in which a given observation has no nearby neighbors —this is the so-called curse of dimensionality . That is,curse of di- mensionalitytheKobservations that are nearest to a given test observation x0may be very far away from x0inp-dimensional space when pis large, leading to a very poor prediction of f(x0)and hence a poor KNN fit. As a general rule, parametric methods will tend to outperform non-parametric approaches when there is a small number of observations per predictor. Even when the dimension is small, we might prefer linear regression to KNN from an interpretability standpoint. If the test MSE of KNN is only slightly lower than that of linear regression, we might be willing to forego a little bit of prediction accuracy for the sake of a simple model that can be described in terms of just a few coefficients, and for which p-values are available. 116 3. Linear Regression3.6 Lab: Linear Regression3.6.1 Importing packagesWe import our standard libraries at this top level.In[1]:import numpy as npimport pandas as pdfrom matplotlib.pyplot import subplotsNew importsThroughoutthislabwewillintroducenewfunctionsandlibraries.However,we will import them here to emphasize these are the new code objects inthis lab. Keeping imports near the top of a notebook makes the code morereadable, since scanning the first few lines tells us what libraries are used.In[2]:import statsmodels.api as smWe will provide relevant details about the functions below as they areneeded.Besides importing whole modules, it is also possible to import only afew items from a given module. This will help keep thenamespaceclean.namespaceWe will use a few specific objects from thestatsmodelspackage which westatsmodelsimport here.In[3]:from statsmodels.stats.outliers_influence \\import variance_inflation_factor as VIFfrom statsmodels.stats.anova import anova_lmAs one of the import statements above is quite a long line, we inserted aline break\\to ease readability.We will also use some functions written for the labs in this book in theISLPpackage.In[4]:from ISLP import load_datafrom ISLP.models import (ModelSpec as", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 143, "start_word": 45760, "end_word": 46160, "chunk_words": 400}}, "ISLP_website::c000144": {"text": "they areneeded.Besides importing whole modules, it is also possible to import only afew items from a given module. This will help keep thenamespaceclean.namespaceWe will use a few specific objects from thestatsmodelspackage which westatsmodelsimport here.In[3]:from statsmodels.stats.outliers_influence \\import variance_inflation_factor as VIFfrom statsmodels.stats.anova import anova_lmAs one of the import statements above is quite a long line, we inserted aline break\\to ease readability.We will also use some functions written for the labs in this book in theISLPpackage.In[4]:from ISLP import load_datafrom ISLP.models import (ModelSpec as MS,summarize,poly)Inspecting Objects and NamespacesThe functiondir()provides a list of objects in a namespace.dir()In[5]:dir()Out[5]:['In','MS','_','__','___','__builtin__','__builtins__',... 3.6 Lab: Linear Regression 117'poly','quit','sm','summarize']This shows you everything thatPythoncan find at the top level. Thereare certain objects like__builtins__that contain references to built-infunctions likeprint().Every python object has its own notion of namespace, also accessiblewithdir(). This will include both the attributes of the object as well asany methods associated with it. For instance, we see'sum'in the listingfor an array.In[6]:A=n p . a r r a y ( [ 3 , 5 , 1 1 ] )dir(A)Out[6]:...'strides','sum','swapaxes',...This indicates that the objectA.sumexists. In this case it is a method thatcan be used to compute the sum of the arrayAas can be seen by typingA.sum?.In[7]:A.sum()Out[7]:193.6.2 Simple Linear RegressionIn this section we will construct model matrices (also called design matri-ces) using theModelSpec()transform fromISLP.models.We will use theBostonhousing data set, which is contained in theISLPpackage. TheBostondataset recordsmedv(median house value) for506neighborhoods around Boston. We will build a regression model to pre-dictmedvusing13predictors such asrmvar(average number of rooms perhouse),age(proportion of owner-occupied units built prior to 1940), andlstat(percent of households with low socioeconomic status). We will usestatsmodelsfor this task, aPythonpackage that implements several com-monly used regression methods.Wehaveincludedasimpleloadingfunctionload_data()intheISLPpack-load_data()age:In[8]:Boston = load_data(\"Boston\")Boston.columnsOut[8]:Index(['crim','zn','indus','chas','nox','rm','age','dis','rad','tax','ptratio','black','lstat','medv'],dtype='object') 118 3. Linear RegressionTypeBoston?to find out more about these data.We start by using thesm.OLS()function to fit a simple linear regressionsm.OLS()model. Our response will bemedvandlstatwill be the single predictor.For this model, we can create the model matrix by hand.In[9]:X=p d . D a t a F r a m e ( {'intercept':n p . o n e s ( B o s t o n . s h a p e [ 0 ] ) ,'lstat':B o s t o n ['lstat']})X[:4]Out[9]:intercept lstat01 . 0 4 . 9 811 . 0 9 . 1 421 . 0 4 . 0 331 . 0 2 . 9 4We extract the response, and fit the model.In[10]:y=B o s t o n ['medv']model = sm.OLS(y, X)results = model.fit()Note thatsm.OLS()does not fit the model; it specifies", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 144, "start_word": 46080, "end_word": 46480, "chunk_words": 400}}, "ISLP_website::c000145": {"text": "p . o n e s ( B o s t o n . s h a p e [ 0 ] ) ,'lstat':B o s t o n ['lstat']})X[:4]Out[9]:intercept lstat01 . 0 4 . 9 811 . 0 9 . 1 421 . 0 4 . 0 331 . 0 2 . 9 4We extract the response, and fit the model.In[10]:y=B o s t o n ['medv']model = sm.OLS(y, X)results = model.fit()Note thatsm.OLS()does not fit the model; it specifies the model, and thenmodel.fit()does the actual fitting.OurISLPfunctionsummarize()produces a simple table of the parame-summarize()ter estimates, their standard errors, t-statistics and p-values. The functiontakes a single argument, such as the objectresultsreturned here by thefitmethod, and returns such a summary.In[11]:summarize(results)Out[11]:coef std err t P>|t|intercept 34.5538 0.563 61.415 0.0lstat -0.9500 0.039 -24.528 0.0Before we describe other methods for working with fitted models, weoutline a more useful and general framework for constructing a model ma-trixX.Using Transformations: Fit and TransformOur model above has a single predictor, and constructingXwas straight-forward. In practice we often fit models with more than one predictor,typically selected from an array or data frame. We may wish to introducetransformations to the variables before fitting the model, specify interac-tions between variables, and expand some particular variables into sets ofvariables (e.g. polynomials). Thesklearnpackage has a particular notionsklearnfor this type of task: atransform. A transform is an object that is createdwith some parameters as arguments. The object has two main methods:fit()andtransform()..fit().transform()We provide a general approach for specifying models and constructingthe model matrix through the transformModelSpec()in theISLPlibrary.ModelSpec()ModelSpec()(renamedMS()in the preamble) creates a transform object,and then a pair of methodstransform()andfit()are used to construct acorresponding model matrix. 3.6 Lab: Linear Regression 119We first describe this process for our simple regression model using asingle predictorlstatin theBostondata frame, but will use it repeatedlyin more complex tasks in this and other labs in this book. In our case thetransform is created by the expressiondesign = MS(['lstat']).Thefit()method takes the original array and may do some initial com-putations on it, as specified in the transform object. For example, it maycompute means and standard deviations for centering and scaling. Thetransform()method applies the fitted transformation to the array of data,and produces the model matrix.In[12]:design = MS(['lstat'])design = design.fit(Boston)X=d e s i g n . t r a n s f o r m ( B o s t o n )X[:4]Out[12]:intercept lstat01 . 0 4 . 9 811 . 0 9 . 1 421 . 0 4", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 145, "start_word": 46400, "end_word": 46800, "chunk_words": 400}}, "ISLP_website::c000146": {"text": "some initial com-putations on it, as specified in the transform object. For example, it maycompute means and standard deviations for centering and scaling. Thetransform()method applies the fitted transformation to the array of data,and produces the model matrix.In[12]:design = MS(['lstat'])design = design.fit(Boston)X=d e s i g n . t r a n s f o r m ( B o s t o n )X[:4]Out[12]:intercept lstat01 . 0 4 . 9 811 . 0 9 . 1 421 . 0 4 . 0 331 . 0 2 . 9 4In this simple case, thefit()method does very little; it simply checks thatthe variable'lstat'specified indesignexists inBoston. Thentransform()constructs the model matrix with two columns: aninterceptand the vari-ablelstat.Thesetwooperationscanbecombinedwiththefit_transform()method..fit_transform()In[13]:design = MS(['lstat'])X=d e s i g n . f i t _ t r a n s f o r m ( B o s t o n )X[:4]Out[13]:intercept lstat01 . 0 4 . 9 811 . 0 9 . 1 421 . 0 4 . 0 331 . 0 2 . 9 4Note that, as in the previous code chunk when the two steps were doneseparately, thedesignobject is changed as a result of thefit()operation.The power of this pipeline will become clearer when we fit more complexmodels that involve interactions and transformations.Let’sreturntoourfittedregressionmodel.Theobjectresultshasseveralmethods that can be used for inference. We already presented a functionsummarize()for showing the essentials of the fit. For a full and somewhatexhaustive summary of the fit, we can use thesummary()method (outputnot shown).In[14]:results.summary()The fitted coefficients can also be retrieved as theparamsattribute ofresults.In[15]:results.params 120 3. Linear RegressionOut[15]:intercept 34.553841lstat -0.950049dtype: float64Theget_prediction()method can be used to obtain predictions, and.get_prediction()produce confidence intervals and prediction intervals for the prediction ofmedvfor given values oflstat.We first create a new data frame, in this case containing only the vari-ablelstat, with the values for this variable at which we wish to makepredictions. We then use thetransform()method ofdesignto create thecorresponding model matrix.In[16]:new_df = pd.DataFrame({'lstat':[5, 10, 15]})newX = design.transform(new_df)newXOut[16]:intercept lstat01 . 0511 . 0 1 021 . 0 1 5Next we compute the predictions atnewX, and view them by extractingthepredicted_meanattribute.In[17]:new_predictions = results.get_prediction(newX);new_predictions.predicted_meanOut[17]:array([29.80359411, 25.05334734, 20.30310057])We can produce confidence intervals for the predicted values.In[18]:new_predictions.conf_int(alpha=0.05)Out[18]:array([[29.00741194, 30.59977628],[24.47413202, 25.63256267],[19.73158815, 20.87461299]])Prediction intervals are computing by settingobs=True:In[19]:new_predictions.conf_int(obs=True, alpha=0.05)Out[19]:array([[17.56567478, 42.04151344],[12.82762635, 37.27906833],[8 . 0 7 7 7 4 2 1,3 2 . 5 2 8 4 5 9 0 5 ] ] )For instance, the 95% confidence interval associated with anlstatvalue of10 is (24.47, 25.63), and the 95% prediction interval is (12.82, 37.28). Asexpected, the confidence", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 146, "start_word": 46720, "end_word": 47120, "chunk_words": 400}}, "ISLP_website::c000147": {"text": "0 1 5Next we compute the predictions atnewX, and view them by extractingthepredicted_meanattribute.In[17]:new_predictions = results.get_prediction(newX);new_predictions.predicted_meanOut[17]:array([29.80359411, 25.05334734, 20.30310057])We can produce confidence intervals for the predicted values.In[18]:new_predictions.conf_int(alpha=0.05)Out[18]:array([[29.00741194, 30.59977628],[24.47413202, 25.63256267],[19.73158815, 20.87461299]])Prediction intervals are computing by settingobs=True:In[19]:new_predictions.conf_int(obs=True, alpha=0.05)Out[19]:array([[17.56567478, 42.04151344],[12.82762635, 37.27906833],[8 . 0 7 7 7 4 2 1,3 2 . 5 2 8 4 5 9 0 5 ] ] )For instance, the 95% confidence interval associated with anlstatvalue of10 is (24.47, 25.63), and the 95% prediction interval is (12.82, 37.28). Asexpected, the confidence and prediction intervals are centered around thesame point (a predicted value of 25.05 formedvwhenlstatequals 10), butthe latter are substantially wider.Next we will plotmedvandlstatusingDataFrame.plot.scatter(), and.plot.scatter()wish to add the regression line to the resulting plot. 3.6 Lab: Linear Regression 121 Defining Functions While there is a function within the ISLPpackage that adds a line to an existing plot, we take this opportunity to define our first function to do so.def In[20]: def abline(ax, b, m): \"Add a line with slope m and intercept b to ax\" xlim = ax.get_xlim() ylim = [m * xlim[0] + b, m * xlim[1] + b] ax.plot(xlim, ylim) A few things are illustrated above. First we see the syntax for defining a function: def funcname(...) . The function has arguments ax, b, m where axis an axis object for an exisiting plot, bis the intercept and mis the slope of the desired line. Other plotting options can be passed on to ax.plotby including additional optional arguments as follows: In[21]: def abline(ax, b, m, *args, **kwargs): \"Add a line with slope m and intercept b to ax\" xlim = ax.get_xlim() ylim = [m * xlim[0] + b, m * xlim[1] + b] ax.plot(xlim, ylim, *args, **kwargs) The addition of *argsallows any number of non-named arguments to abline, while *kwargs allows any number of named arguments (such as linewidth=3 ) toabline. In our function, we pass these arguments verbatim toax.plotabove. Readers interested in learning more about functions are referred to the section on defining functions in docs.python.org/tutorial . Let’s use our new function to add this regression line to a plot of medv vs.lstat. In[22]: ax = Boston.plot.scatter( 'lstat' ,'medv') abline(ax, results.params[0], results.params[1], 'r--', linewidth=3) Thus,thefinalcallto ax.plot() isax.plot(xlim, ylim, 'r--', linewidth=3) . We have used the argument 'r--'to produce a red dashed line, and added an argument to make it of width 3. There is some evidence for non-linearity in the relationship between lstatandmedv. We will explore this issue", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 147, "start_word": 47040, "end_word": 47440, "chunk_words": 400}}, "ISLP_website::c000148": {"text": "to the section on defining functions in docs.python.org/tutorial . Let’s use our new function to add this regression line to a plot of medv vs.lstat. In[22]: ax = Boston.plot.scatter( 'lstat' ,'medv') abline(ax, results.params[0], results.params[1], 'r--', linewidth=3) Thus,thefinalcallto ax.plot() isax.plot(xlim, ylim, 'r--', linewidth=3) . We have used the argument 'r--'to produce a red dashed line, and added an argument to make it of width 3. There is some evidence for non-linearity in the relationship between lstatandmedv. We will explore this issue later in this lab. As mentioned above, there is an existing function to add a line to a plot —ax.axline() — but knowing how to write such functions empowers us to create more expressive displays. Next we examine some diagnostic plots, several of which were discussed in Section 3.3.3. We can find the fitted values and residuals of the fit as attributes of the resultsobject. Various influence measures describing the regression model are computed with the get_influence() method. As we.get_ influence() will not use the figcomponent returned as the first value from subplots() , we simply capture the second returned value in axbelow. In[23]: ax = subplots(figsize=(8,8))[1] 122 3. Linear Regressionax.scatter(results.fittedvalues, results.resid)ax.set_xlabel('Fitted value')ax.set_ylabel('Residual')ax.axhline(0, c='k',l s ='--');We add a horizontal line at 0 for reference using theax.axhline()method,.axhline()indicating it should be black (c='k') and have a dashed linestyle (ls='--').On the basis of the residual plot (not shown), there is some evidenceof non-linearity. Leverage statistics can be computed for any number ofpredictors using thehat_matrix_diagattribute of the value returned by theget_influence()method.In[24]:infl = results.get_influence()ax = subplots(figsize=(8,8))[1]ax.scatter(np.arange(X.shape[0]), infl.hat_matrix_diag)ax.set_xlabel('Index')ax.set_ylabel('Leverage')np.argmax(infl.hat_matrix_diag)Out[24]:374Thenp.argmax()function identifies the index of the largest element of annp.argmax()array, optionally computed over an axis of the array. In this case, we maxi-mized over the entire array to determine which observation has the largestleverage statistic.3.6.3 Multiple Linear RegressionIn order to fit a multiple linear regression model using least squares, weagainusetheModelSpec()transformtoconstructtherequiredmodelmatrixand response. The arguments toModelSpec()can be quite general, but inthis case a list of column names suffice. We consider a fit here with the twovariableslstatandage.In[25]:X=M S ( ['lstat','age']).fit_transform(Boston)model1 = sm.OLS(y, X)results1 = model1.fit()summarize(results1)Out[25]:coef std err t P>|t|intercept 33.2228 0.731 45.458 0.000lstat -1.0321 0.048 -21.416 0.000age 0.0345 0.012 2.826 0.005Notice how we have compacted the first line into a succinct expressiondescribing the construction ofX.TheBostondatasetcontains12variables,andsoitwouldbecumbersometo have to type all of these in order to perform a regression using all of thepredictors. Instead, we can use the following short-hand:.columns.drop()In[26]:terms = Boston.columns.drop('medv')terms 3.6 Lab: Linear Regression 123 Out[26]: Index([ 'crim','zn','indus' ,'chas','nox','rm','age','dis', 'rad','tax','ptratio' ,'lstat' ],", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 148, "start_word": 47360, "end_word": 47760, "chunk_words": 400}}, "ISLP_website::c000149": {"text": "fit here with the twovariableslstatandage.In[25]:X=M S ( ['lstat','age']).fit_transform(Boston)model1 = sm.OLS(y, X)results1 = model1.fit()summarize(results1)Out[25]:coef std err t P>|t|intercept 33.2228 0.731 45.458 0.000lstat -1.0321 0.048 -21.416 0.000age 0.0345 0.012 2.826 0.005Notice how we have compacted the first line into a succinct expressiondescribing the construction ofX.TheBostondatasetcontains12variables,andsoitwouldbecumbersometo have to type all of these in order to perform a regression using all of thepredictors. Instead, we can use the following short-hand:.columns.drop()In[26]:terms = Boston.columns.drop('medv')terms 3.6 Lab: Linear Regression 123 Out[26]: Index([ 'crim','zn','indus' ,'chas','nox','rm','age','dis', 'rad','tax','ptratio' ,'lstat' ], dtype='object' ) We can now fit the model with all the variables in termsusing the same model matrix builder. In[27]: X=M S ( t e r m s ) . f i t _ t r a n s f o r m ( B o s t o n ) model = sm.OLS(y, X) results = model.fit() summarize(results) Out[27]: coef std err t P>|t| intercept 41.6173 4.936 8.431 0.000 crim -0.1214 0.033 -3.678 0.000 zn 0.0470 0.014 3.384 0.001 indus 0.0135 0.062 0.217 0.829 chas 2.8400 0.870 3.264 0.001 nox -18.7580 3.851 -4.870 0.000 rm 3.6581 0.420 8.705 0.000 age 0.0036 0.013 0.271 0.787 dis -1.4908 0.202 -7.394 0.000 rad 0.2894 0.067 4.325 0.000 tax -0.0127 0.004 -3.337 0.001 ptratio -0.9375 0.132 -7.091 0.000 lstat -0.5520 0.051 -10.897 0.000 Whatifwewouldliketoperformaregressionusingallofthevariablesbut one? For example, in the above regression output, agehas a high p-value. So we may wish to run a regression excluding this predictor. The following syntax results in a regression using all predictors except age(output not shown). In[28]: minus_age = Boston.columns.drop([ 'medv','age']) Xma = MS(minus_age).fit_transform(Boston) model1 = sm.OLS(y, Xma) summarize(model1.fit()) 3.6.4 Multivariate Goodness of Fit Wecanaccesstheindividualcomponentsof resultsbyname( dir(results) shows us what is available). Hence results.rsquared gives us the R2, and np.sqrt(results.scale) gives us the RSE. Variance inflation factors (section 3.3.3) are sometimes useful to assess the effect of collinearity in the model matrix of a regression model. We will compute the VIFs in our multiple regression fit, and use the opportunity to introduce the idea of list comprehension .list compre- hension List Comprehension Often we encounter a sequence of objects which we would like to transform for some other task. Below, we compute the VIF for each feature in our X matrix and produce a data frame whose index agrees with the columns of X. The notion of list comprehension can often make such a task easier. 124 3. Linear RegressionList comprehensions are simple and powerful ways to form", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 149, "start_word": 47680, "end_word": 48080, "chunk_words": 400}}, "ISLP_website::c000150": {"text": "the opportunity to introduce the idea of list comprehension .list compre- hension List Comprehension Often we encounter a sequence of objects which we would like to transform for some other task. Below, we compute the VIF for each feature in our X matrix and produce a data frame whose index agrees with the columns of X. The notion of list comprehension can often make such a task easier. 124 3. Linear RegressionList comprehensions are simple and powerful ways to form lists ofPythonobjects. The language also supports dictionary andgeneratorcomprehen-sion, though these are beyond our scope here. Let’s look at an example.We compute the VIF for each of the variables in the model matrixX, usingthe functionvariance_inflation_factor().variance_inflation_factor()In[29]:vals = [VIF(X, i)for i in range(1, X.shape[1])]vif = pd.DataFrame({'vif':vals},index=X.columns[1:])vifOut[29]:vifcrim 1.767zn 2.298indus 3.987chas 1.071nox 4.369rm 1.913age 3.088dis 3.954rad 7.445tax 9.002ptratio 1.797lstat 2.871The functionVIF()takes two arguments: a dataframe or array, and a vari-ablecolumnindex.InthecodeabovewecallVIF()ontheflyforallcolumnsinX. We have excluded column 0 above (the intercept), which is not of in-terest. In this case the VIFs are not that exciting.The objectvalsabove could have been constructed with the followingfor loop:In[30]:vals = []for i in range(1, X.values.shape[1]):vals.append(VIF(X.values, i))List comprehension allows us to perform such repetitive operations in amore straightforward way.3.6.5 Interaction TermsIt is easy to include interaction terms in a linear model usingModelSpec().Including a tuple(\"lstat\",\"age\")tells the model matrix builder to includean interaction term betweenlstatandage.In[31]:X=M S ( ['lstat','age',('lstat','age')]).fit_transform(Boston)model2 = sm.OLS(y, X)summarize(model2.fit())Out[31]:coef std err t P>|t|intercept 36.0885 1.470 24.553 0.000lstat -1.3921 0.167 -8.313 0.000 3.6 Lab: Linear Regression 125 age -0.0007 0.020 -0.036 0.971 lstat:age 0.0042 0.002 2.244 0.025 3.6.6 Non-linear Transformations of the Predictors Themodelmatrixbuildercanincludetermsbeyondjustcolumnnamesand interactions. For instance, the poly()function supplied in ISLPspecifiespoly()that columns representing polynomial functions of its first argument are added to the model matrix. In[32]: X=M S ( [ p o l y ( 'lstat' ,d e g r e e = 2 ) , 'age']).fit_transform(Boston) model3 = sm.OLS(y, X) results3 = model3.fit() summarize(results3) Out[32]: coef std err t P>|t| intercept 17.7151 0.781 22.681 0.000 poly(lstat, degree=2)[0] -179.2279 6.733 -26.620 0.000 poly(lstat, degree=2)[1] 72.9908 5.482 13.315 0.000 age 0.0703 0.011 6.471 0.000 The effectively zero p-value associated with the quadratic term (i.e. the third row above) suggests that it leads to an improved model. By default, poly()creates a basis matrix for inclusion in the model ma- trix whose columns are orthogonal polynomials , which are designed for sta-orthogonal polynomialble least squares computations.13Alternatively, had we included an argu- mentraw=True in the above call to", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 150, "start_word": 48000, "end_word": 48400, "chunk_words": 400}}, "ISLP_website::c000151": {"text": "22.681 0.000 poly(lstat, degree=2)[0] -179.2279 6.733 -26.620 0.000 poly(lstat, degree=2)[1] 72.9908 5.482 13.315 0.000 age 0.0703 0.011 6.471 0.000 The effectively zero p-value associated with the quadratic term (i.e. the third row above) suggests that it leads to an improved model. By default, poly()creates a basis matrix for inclusion in the model ma- trix whose columns are orthogonal polynomials , which are designed for sta-orthogonal polynomialble least squares computations.13Alternatively, had we included an argu- mentraw=True in the above call to poly(), the basis matrix would consist simplyof lstatandlstat**2 .Sinceeitherofthesebasesrepresentquadratic polynomials, the fitted values would not change in this case, just the poly- nomial coefficients. Also by default, the columns created by poly()do not include an intercept column as that is automatically added by MS(). We use the anova_lm() function to further quantify the extent to whichanova_lm()the quadratic fit is superior to the linear fit. In[33]: anova_lm(results1, results3) Out[33]: df_resid ssr df_diff ss_diff F Pr(>F) 05 0 3 . 0 1 9 1 6 8 . 1 3 0 . 0 N a N N a NN a N 15 0 2 . 0 1 4 1 6 5 . 6 1 1 . 0 5 0 0 2 . 5 2 1 7 7 . 2 8 7 . 4 7 e - 3 5 Hereresults1 represents the linear submodel containing predictors lstat andage, while results3 corresponds to the larger model above with a quadratic term in lstat. Theanova_lm() function performs a hypothesis test comparing the two models. The null hypothesis is that the quadratic term in the bigger model is not needed, and the alternative hypothesis is that the bigger model is superior. Here the F-statistic is 177.28 and the associated p-value is zero. In this case the F-statistic is the square of the t-statistic for the quadratic term in the linear model summary for results3 —aconsequenceofthefactthatthesenestedmodelsdifferbyonedegreeof 13Actually, poly() is a wrapper for the workhorse and standalone function Poly() that does the work in building the model matrix. 126 3. Linear Regressionfreedom. This provides very clear evidence that the quadratic polynomialinlstatimproves the linear model. This is not surprising, since earlier wesaw evidence for non-linearity in the relationship betweenmedvandlstat.The functionanova_lm()can take more than two nested models as input,inwhichcaseitcompareseverysuccessivepairofmodels.Thatalsoexplainswhy their areNaNs in the first row above, since there is no previous modelwith which to compare the first.In[34]:ax = subplots(figsize=(8,8))[1]ax.scatter(results3.fittedvalues, results3.resid)ax.set_xlabel('Fitted value')ax.set_ylabel('Residual')ax.axhline(0, c='k',l s ='--')We see that when the quadratic term is", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 151, "start_word": 48320, "end_word": 48720, "chunk_words": 400}}, "ISLP_website::c000152": {"text": "that does the work in building the model matrix. 126 3. Linear Regressionfreedom. This provides very clear evidence that the quadratic polynomialinlstatimproves the linear model. This is not surprising, since earlier wesaw evidence for non-linearity in the relationship betweenmedvandlstat.The functionanova_lm()can take more than two nested models as input,inwhichcaseitcompareseverysuccessivepairofmodels.Thatalsoexplainswhy their areNaNs in the first row above, since there is no previous modelwith which to compare the first.In[34]:ax = subplots(figsize=(8,8))[1]ax.scatter(results3.fittedvalues, results3.resid)ax.set_xlabel('Fitted value')ax.set_ylabel('Residual')ax.axhline(0, c='k',l s ='--')We see that when the quadratic term is included in the model, there islittle discernible pattern in the residuals. In order to create a cubic orhigher-degree polynomial fit, we can simply change the degree argument topoly().3.6.7 Qualitative PredictorsHere we use theCarseatsdata, which is included in theISLPpackage. Wewill attempt to predictSales(child car seat sales) in 400 locations basedon a number of predictors.In[35]:Carseats = load_data('Carseats')Carseats.columnsOut[35]:Index(['Sales','CompPrice','Income','Advertising','Population','Price','ShelveLoc','Age','Education','Urban','US'],dtype='object')TheCarseatsdata includes qualitative predictors such asShelveLoc, anindicator of the quality of the shelving location — that is, the space withina store in which the car seat is displayed. The predictorShelveLoctakes onthree possible values,Bad,Medium, andGood. Given a qualitative variablesuch asShelveLoc,ModelSpec()generates dummy variables automatically.Thesevariablesareoftenreferredtoasaone-hot encodingofthecategoricalone-hotencodingfeature. Their columns sum to one, so to avoid collinearity with an inter-cept, the first column is dropped. Below we see the columnShelveLoc[Bad]has been dropped, sinceBadis the first level ofShelveLoc. Below we fit amultiple regression model that includes some interaction terms.In[36]:allvars = list(Carseats.columns.drop('Sales'))y=C a r s e a t s ['Sales']final = allvars + [('Income','Advertising'),('Price','Age')]X=M S ( f i n a l ) . f i t _ t r a n s f o r m ( C a r s e a t s )model = sm.OLS(y, X)summarize(model.fit())Out[36]:coef std err t P>|t|intercept 6.5756 1.009 6.519 0.000 3.7 Exercises 127 CompPrice 0.0929 0.004 22.567 0.000 Income 0.0109 0.003 4.183 0.000 Advertising 0.0702 0.023 3.107 0.002 Population 0.0002 0.000 0.433 0.665 Price -0.1008 0.007 -13.549 0.000 ShelveLoc[Good] 4.8487 0.153 31.724 0.000 ShelveLoc[Medium] 1.9533 0.126 15.531 0.000 Age -0.0579 0.016 -3.633 0.000 Education -0.0209 0.020 -1.063 0.288 Urban[Yes] 0.1402 0.112 1.247 0.213 US[Yes] -0.1576 0.149 -1.058 0.291 Income:Advertising 0.0008 0.000 2.698 0.007 Price:Age 0.0001 0.000 0.801 0.424 In the first line above, we made allvarsa list, so that we could add the interaction terms two lines down. Our model-matrix builder has created a ShelveLoc[Good] dummy variable that takes on a value of 1 if the shelving location is good, and 0 otherwise. It has also created a ShelveLoc[Medium] dummy variable that equals 1 if the", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 152, "start_word": 48640, "end_word": 49040, "chunk_words": 400}}, "ISLP_website::c000153": {"text": "-1.063 0.288 Urban[Yes] 0.1402 0.112 1.247 0.213 US[Yes] -0.1576 0.149 -1.058 0.291 Income:Advertising 0.0008 0.000 2.698 0.007 Price:Age 0.0001 0.000 0.801 0.424 In the first line above, we made allvarsa list, so that we could add the interaction terms two lines down. Our model-matrix builder has created a ShelveLoc[Good] dummy variable that takes on a value of 1 if the shelving location is good, and 0 otherwise. It has also created a ShelveLoc[Medium] dummy variable that equals 1 if the shelving location is medium, and 0 oth- erwise. A bad shelving location corresponds to a zero for each of the two dummy variables. The fact that the coefficient for ShelveLoc[Good] in the regression output is positive indicates that a good shelving location is asso- ciated with high sales (relative to a bad location). And ShelveLoc[Medium] has a smaller positive coefficient, indicating that a medium shelving loca- tion leads to higher sales than a bad shelving location, but lower sales than a good shelving location. 3.7 Exercises Conceptual 1. Describe the null hypotheses to which the p-values given in Table 3.4 correspond. Explain what conclusions you can draw based on these p-values. Your explanation should be phrased in terms of sales,TV, radio, andnewspaper , rather than in terms of the coefficients of the linear model. 2. CarefullyexplainthedifferencesbetweentheKNNclassifierandKNN regression methods. 3. Suppose we have a data set with five predictors, X1=GPA,X2= IQ,X3=Level (1for College and 0for High School), X4=Interac- tion between GPA and IQ, and X5=Interaction between GPA and Level. The response is starting salary after graduation (in thousands of dollars). Suppose we use least squares to fit the model, and get ˆβ0= 50 ,ˆβ1= 20 ,ˆβ2=0.07,ˆβ3= 35 ,ˆβ4=0.01,ˆβ5=−10. (a) Which answer is correct, and why? i. For a fixed value of IQ and GPA, high school graduates earn more, on average, than college graduates. ii. For a fixed value of IQ and GPA, college graduates earn more, on average, than high school graduates. 128 3. Linear Regressioniii. For a fixed value of IQ and GPA, high school graduates earnmore, on average, than college graduates provided that theGPA is high enough.iv. For a fixed value of IQ and GPA, college graduates earnmore, on average, than high school graduates provided thatthe GPA is high enough.(b) Predict the salary of a college graduate with IQ of110and aGPA of4.0.(c) True or false: Since the coefficient for the GPA/IQ interactionterm is very small, there is very", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 153, "start_word": 48960, "end_word": 49360, "chunk_words": 400}}, "ISLP_website::c000154": {"text": "school graduates. 128 3. Linear Regressioniii. For a fixed value of IQ and GPA, high school graduates earnmore, on average, than college graduates provided that theGPA is high enough.iv. For a fixed value of IQ and GPA, college graduates earnmore, on average, than high school graduates provided thatthe GPA is high enough.(b) Predict the salary of a college graduate with IQ of110and aGPA of4.0.(c) True or false: Since the coefficient for the GPA/IQ interactionterm is very small, there is very little evidence of an interactioneffect. Justify your answer.4. I collect a set of data (n= 100observations) containing a singlepredictor and a quantitative response. I then fit a linear regressionmodel to the data, as well as a separate cubic regression, i.e.Y=β0+β1X+β2X2+β3X3+/epsilon1.(a) Suppose that the true relationship between X and Y is linear,i.e.Y=β0+β1X+/epsilon1. Consider the training residual sum ofsquares (RSS) for the linear regression, and also the trainingRSS for the cubic regression. Would we expect one to be lowerthan the other, would we expect them to be the same, or is therenot enough information to tell? Justify your answer.(b) Answer (a) using test rather than training RSS.(c) SupposethatthetruerelationshipbetweenXandYisnotlinear,butwedon’tknowhowfaritisfromlinear.ConsiderthetrainingRSS for the linear regression, and also the training RSS for thecubic regression. Would we expect one to be lower than theother, would we expect them to be the same, or is there notenough information to tell? Justify your answer.(d) Answer (c) using test rather than training RSS.5. Consider the fitted values that result from performing linear regres-sion without an intercept. In this setting, theith fitted value takesthe formˆyi=xiˆβ,whereˆβ=/parenleftBiggn/summationdisplayi=1xiyi/parenrightBigg//parenleftBiggn/summationdisplayi/prime=1x2i/prime/parenrightBigg.(3.38)Show that we can writeˆyi=n/summationdisplayi/prime=1ai/primeyi/prime.What isai/prime?Note: We interpret this result by saying that the fitted values fromlinear regression arelinear combinationsof the response values. 3.7 Exercises 129 6. Using ( 3.4), argue that in the case of simple linear regression, the least squares line always passes through the point (¯x,¯y). 7. It is claimed in the text that in the case of simple linear regression ofYontoX, theR2statistic ( 3.17) is equal to the square of the correlation between XandY(3.18). Prove that this is the case. For simplicity, you may assume that ¯x=¯y=0. Applied 8. This question involves the use of simple linear regression on the Auto data set. (a) Use the sm.OLS() function to perform a simple linear regression withmpgas the response and horsepower as the predictor. Use thesummarize() function to print the results. Comment on the output. For example: i. Is there a relationship between the predictor", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 154, "start_word": 49280, "end_word": 49680, "chunk_words": 400}}, "ISLP_website::c000155": {"text": "3.17) is equal to the square of the correlation between XandY(3.18). Prove that this is the case. For simplicity, you may assume that ¯x=¯y=0. Applied 8. This question involves the use of simple linear regression on the Auto data set. (a) Use the sm.OLS() function to perform a simple linear regression withmpgas the response and horsepower as the predictor. Use thesummarize() function to print the results. Comment on the output. For example: i. Is there a relationship between the predictor and the re- sponse? ii. How strong is the relationship between the predictor and the response? iii. Is the relationship between the predictor and the response positive or negative? iv. What is the predicted mpgassociated with a horsepower of 98? What are the associated 95% confidence and prediction intervals? (b) Plot the response and the predictor in a new set of axes ax. Use theax.axline() method or the abline() function defined in the lab to display the least squares regression line. (c) Produce some of diagnostic plots of the least squares regression fit as described in the lab. Comment on any problems you see with the fit. 9. This question involves the use of multiple linear regression on the Autodata set. (a) Produce a scatterplot matrix which includes all of the variables in the data set. (b) Compute the matrix of correlations between the variables using theDataFrame.corr() method..corr() (c) Usethe sm.OLS() functiontoperformamultiplelinearregression withmpgas the response and all other variables except nameas the predictors. Use the summarize() function to print the results. Comment on the output. For instance: i. Is there a relationship between the predictors and the re- sponse? Use the anova_lm() function from statsmodels to answer this question. 130 3. Linear Regressionii. Which predictors appear to have a statistically significantrelationship to the response?iii. What does the coefficient for theyearvariable suggest?(d) Produce some of diagnostic plots of the linear regression fit asdescribed in the lab. Comment on any problems you see with thefit. Do the residual plots suggest any unusually large outliers?Does the leverage plot identify any observations with unusuallyhigh leverage?(e) Fit some models with interactions as described in the lab. Doany interactions appear to be statistically significant?(f) Try a few different transformations of the variables, such aslog(X),√X,X2. Comment on your findings.10. This question should be answered using theCarseatsdata set.(a) Fit a multiple regression model to predictSalesusingPrice,Urban, andUS.(b) Provide an interpretation of each coefficient in the model. Becareful—some of the", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 155, "start_word": 49600, "end_word": 50000, "chunk_words": 400}}, "ISLP_website::c000156": {"text": "see with thefit. Do the residual plots suggest any unusually large outliers?Does the leverage plot identify any observations with unusuallyhigh leverage?(e) Fit some models with interactions as described in the lab. Doany interactions appear to be statistically significant?(f) Try a few different transformations of the variables, such aslog(X),√X,X2. Comment on your findings.10. This question should be answered using theCarseatsdata set.(a) Fit a multiple regression model to predictSalesusingPrice,Urban, andUS.(b) Provide an interpretation of each coefficient in the model. Becareful—some of the variables in the model are qualitative!(c) Write out the model in equation form, being careful to handlethe qualitative variables properly.(d) For which of the predictors can you reject the null hypothesisH0:βj=0?(e) On the basis of your response to the previous question, fit asmaller model that only uses the predictors for which there isevidence of association with the outcome.(f) How well do the models in (a) and (e) fit the data?(g) Using the model from (e), obtain 95% confidence intervals forthe coefficient(s).(h) Is there evidence of outliers or high leverage observations in themodel from (e)?11. In this problem we will investigate thet-statistic for the null hypoth-esisH0:β=0in simple linear regression without an intercept. Tobegin, we generate a predictorxand a responseyas follows.rng = np.random.default_rng(1)x=r n g . n o r m a l ( s i z e = 1 0 0 )y=2*x+r n g . n o r m a l ( s i z e = 1 0 0 )(a) Perform a simple linear regression ofyontox,withoutan in-tercept. Report the coefficient estimateˆβ, the standard error ofthis coefficient estimate, and thet-statistic andp-value associ-ated with the null hypothesisH0:β=0. Comment on theseresults. (You can perform regression without an intercept usingthe keywords argumentintercept=FalsetoModelSpec().) 3.7 Exercises 131 (b) Now perform a simple linear regression of xontoywithout an intercept, and report the coefficient estimate, its standard error, and the corresponding t-statistic and p-values associated with the null hypothesis H0:β=0. Comment on these results. (c) What is the relationship between the results obtained in (a) and (b)? (d) For the regression of YontoXwithout an intercept, the t- statistic for H0:β=0 takes the form ˆβ/SE(ˆβ), where ˆβis given by ( 3.38), and where SE(ˆβ)=/radicalBigg/summationtextn i=1(yi−xiˆβ)2 (n−1)/summationtextn i/prime=1x2 i/prime. (These formulas are slightly different from those given in Sec- tions3.1.1and3.1.2, since here we are performing regression without an intercept.) Show algebraically, and confirm numeri- cally in R, that the t-statistic can be written as (√n−1)/summationtextn i=1xiyi/radicalbig (/summationtextn i=1x2 i)(/summationtextn i/prime=1y2 i/prime)−(/summationtextn", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 156, "start_word": 49920, "end_word": 50320, "chunk_words": 400}}, "ISLP_website::c000157": {"text": "between the results obtained in (a) and (b)? (d) For the regression of YontoXwithout an intercept, the t- statistic for H0:β=0 takes the form ˆβ/SE(ˆβ), where ˆβis given by ( 3.38), and where SE(ˆβ)=/radicalBigg/summationtextn i=1(yi−xiˆβ)2 (n−1)/summationtextn i/prime=1x2 i/prime. (These formulas are slightly different from those given in Sec- tions3.1.1and3.1.2, since here we are performing regression without an intercept.) Show algebraically, and confirm numeri- cally in R, that the t-statistic can be written as (√n−1)/summationtextn i=1xiyi/radicalbig (/summationtextn i=1x2 i)(/summationtextn i/prime=1y2 i/prime)−(/summationtextn i/prime=1xi/primeyi/prime)2. (e) Using the results from (d), argue that the t-statistic for the re- gressionof yontoxisthesameasthe t-statisticfortheregression ofxontoy. (f) InR, show that when regression is performed withan intercept, thet-statistic for H0:β1=0is the same for the regression of y ontoxas it is for the regression of xontoy. 12. This problem involves simple linear regression without an intercept. (a) Recall that the coefficient estimate ˆβfor the linear regression of YontoXwithout an intercept is given by ( 3.38). Under what circumstance is the coefficient estimate for the regression of X ontoYthe same as the coefficient estimate for the regression of YontoX? (b) Generate an example in Pythonwithn= 100 observations in which the coefficient estimate for the regression of XontoY isdifferent from the coefficient estimate for the regression of Y ontoX. (c) Generate an example in Pythonwithn= 100 observations in which the coefficient estimate for the regression of XontoYis the same as the coefficient estimate for the regression of Yonto X. 13. In this exercise you will create some simulated data and will fit simple linear regression models to it. Make sure to use the default random number generator with seed set to 1 prior to starting part (a) to ensure consistent results. 132 3. Linear Regression (a) Using the normal() method of your random number generator, create a vector, x, containing 100 observations drawn from a N(0,1)distribution. This represents a feature, X. (b) Using the normal() method, create a vector, eps, containing 100 observations drawn from a N(0,0.25)distribution—a normal distribution with mean zero and variance 0.25. (c) Using xandeps, generate a vector yaccording to the model Y=−1+0 .5X+/epsilon1. (3.39) What is the length of the vector y? What are the values of β0 andβ1in this linear model? (d) Create a scatterplot displaying the relationship between xand y. Comment on what you observe. (e) Fit a least squares linear model to predict yusingx. Comment on the model obtained. How do ˆβ0andˆβ1compare to β0and β1?", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 157, "start_word": 50240, "end_word": 50640, "chunk_words": 400}}, "ISLP_website::c000158": {"text": "observations drawn from a N(0,0.25)distribution—a normal distribution with mean zero and variance 0.25. (c) Using xandeps, generate a vector yaccording to the model Y=−1+0 .5X+/epsilon1. (3.39) What is the length of the vector y? What are the values of β0 andβ1in this linear model? (d) Create a scatterplot displaying the relationship between xand y. Comment on what you observe. (e) Fit a least squares linear model to predict yusingx. Comment on the model obtained. How do ˆβ0andˆβ1compare to β0and β1? (f) Display the least squares line on the scatterplot obtained in (d). Draw the population regression line on the plot, in a different color. Use the legend() method of the axes to create an appro- priate legend. (g) Now fit a polynomial regression model that predicts yusingx andx2. Is there evidence that the quadratic term improves the model fit? Explain your answer. (h) Repeat (a)–(f) after modifying the data generation process in such a way that there is lessnoise in the data. The model ( 3.39) should remain the same. You can do this by decreasing the vari- ance of the normal distribution used to generate the error term /epsilon1in (b). Describe your results. (i) Repeat (a)–(f) after modifying the data generation process in such a way that there is morenoise in the data. The model (3.39) should remain the same. You can do this by increasing the variance of the normal distribution used to generate the error term /epsilon1in (b). Describe your results. (j) What are the confidence intervals for β0andβ1based on the original data set, the noisier data set, and the less noisy data set? Comment on your results. 14. This problem focuses on the collinearity problem. (a) Perform the following commands in Python: rng = np.random.default_rng(10) x1 = rng.uniform(0, 1, size=100) x2 = 0.5 * x1 + rng.normal(size=100) / 10 y=2+2*x 1+0 . 3*x 2+r n g . n o r m a l ( s i z e = 1 0 0 ) The last line corresponds to creating a linear model in which yis a function of x1andx2. Write out the form of the linear model. What are the regression coefficients? 3.7 Exercises 133(b) What is the correlation betweenx1andx2? Create a scatterplotdisplaying the relationship between the variables.(c) Using this data, fit a least squares regression to predictyusingx1andx2. Describe the results obtained. What areˆβ0,ˆβ1, andˆβ2? How do these relate to the trueβ0,β1, andβ2? Can youreject the", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 158, "start_word": 50560, "end_word": 50960, "chunk_words": 400}}, "ISLP_website::c000159": {"text": "z e = 1 0 0 ) The last line corresponds to creating a linear model in which yis a function of x1andx2. Write out the form of the linear model. What are the regression coefficients? 3.7 Exercises 133(b) What is the correlation betweenx1andx2? Create a scatterplotdisplaying the relationship between the variables.(c) Using this data, fit a least squares regression to predictyusingx1andx2. Describe the results obtained. What areˆβ0,ˆβ1, andˆβ2? How do these relate to the trueβ0,β1, andβ2? Can youreject the null hypothesisH0:β1=0? How about the nullhypothesisH0:β2=0?(d) Now fit a least squares regression to predictyusing onlyx1.Comment on your results. Can you reject the null hypothesisH0:β1=0?(e) Now fit a least squares regression to predictyusing onlyx2.Comment on your results. Can you reject the null hypothesisH0:β1=0?(f) Dotheresultsobtainedin(c)–(e)contradicteachother?Explainyour answer.(g) Suppose we obtain one additional observation, which was unfor-tunately mismeasured. We use the functionnp.concatenate()tonp.conca-tenate()add this additional observation to each ofx1,x2andy.x1 = np.concatenate([x1, [0.1]])x2 = np.concatenate([x2, [0.8]])y=n p . c o n c a t e n a t e ( [ y ,[ 6 ] ] )Re-fitthelinearmodelsfrom(c)to(e)usingthisnewdata.Whateffect does this new observation have on the each of the models?In each model, is this observation an outlier? A high-leveragepoint? Both? Explain your answers.15. This problem involves theBostondata set, which we saw in the labfor this chapter. We will now try to predict per capita crime rateusing the other variables in this data set. In other words, per capitacrime rate is the response, and the other variables are the predictors.(a) For each predictor, fit a simple linear regression model to predictthe response. Describe your results. In which of the models isthere a statistically significant association between the predictorand the response? Create some plots to back up your assertions.(b) Fit a multiple regression model to predict the response usingall of the predictors. Describe your results. For which predictorscan we reject the null hypothesisH0:βj=0?(c) How do your results from (a) compare to your results from (b)?Create a plot displaying the univariate regression coefficientsfrom (a) on thex-axis, and the multiple regression coefficientsfrom (b) on they-axis. That is, each predictor is displayed as asingle point in the plot. Its coefficient in a simple linear regres-sion model is shown on thex-axis, and its coefficient estimatein the multiple linear regression model is shown on they-axis. 134 3. Linear Regression(d) Is there evidence of non-linear association between any of thepredictors and the response? To answer this question, for eachpredictorX, fit a model of the formY=β0+β1X+β2X2+β3X3+/epsilon1. 4", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 159, "start_word": 50880, "end_word": 51280, "chunk_words": 400}}, "ISLP_website::c000160": {"text": "regression coefficientsfrom (a) on thex-axis, and the multiple regression coefficientsfrom (b) on they-axis. That is, each predictor is displayed as asingle point in the plot. Its coefficient in a simple linear regres-sion model is shown on thex-axis, and its coefficient estimatein the multiple linear regression model is shown on they-axis. 134 3. Linear Regression(d) Is there evidence of non-linear association between any of thepredictors and the response? To answer this question, for eachpredictorX, fit a model of the formY=β0+β1X+β2X2+β3X3+/epsilon1. 4 Classification The linear regression model discussed in Chapter 3assumes that the re- sponse variable Yis quantitative. But in many situations, the response variable is instead qualitative . For example, eye color is qualitative. Of-qualitativeten qualitative variables are referred to as categorical ; we will use these terms interchangeably. In this chapter, we study approaches for predicting qualitative responses, a process that is known as classification . Predictingclassificationa qualitative response for an observation can be referred to as classifying that observation, since it involves assigning the observation to a category, or class. On the other hand, often the methods used for classification first predict the probability that the observation belongs to each of the cate- gories of a qualitative variable, as the basis for making the classification. In this sense they also behave like regression methods. There are many possible classification techniques, or classifiers , that oneclassifiermight use to predict a qualitative response. We touched on some of these in Sections 2.1.5and2.2.3. In this chapter we discuss some widely-used classifiers: logistic regression ,linear discriminant analysis ,quadratic dis-logistic regression linear discriminant analysiscriminant analysis ,naive Bayes , andK-nearest neighbors . The discussion quadratic discriminant analysis naive Bayes K-nearest neighborsof logistic regression is used as a jumping-off point for a discussion of gen- eralized linear models , and in particular, Poisson regression . We discuss generalized linear models Poisson regressionmore computer-intensive classification methods in later chapters: these in- clude generalized additive models (Chapter 7); trees, random forests, and boosting (Chapter 8); and support vector machines (Chapter 9). 4.1 An Overview of Classification Classification problems occur often, perhaps even more so than regression problems. Some examples include: © Springer Nature Switzerland AG 2023 G. James et al., An Introduction to Statistical Learning , Springer Texts in Statistics, https://doi.org/10.1007/978-3-031-38747-0_4 135 136 4. Classification 1. A person arrives at the emergency room with a set of symptoms that could possibly be attributed to one of three medical", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 160, "start_word": 51200, "end_word": 51600, "chunk_words": 400}}, "ISLP_website::c000161": {"text": "trees, random forests, and boosting (Chapter 8); and support vector machines (Chapter 9). 4.1 An Overview of Classification Classification problems occur often, perhaps even more so than regression problems. Some examples include: © Springer Nature Switzerland AG 2023 G. James et al., An Introduction to Statistical Learning , Springer Texts in Statistics, https://doi.org/10.1007/978-3-031-38747-0_4 135 136 4. Classification 1. A person arrives at the emergency room with a set of symptoms that could possibly be attributed to one of three medical conditions. Which of the three conditions does the individual have? 2. An online banking service must be able to determine whether or not a transaction being performed on the site is fraudulent, on the basis of the user’s IP address, past transaction history, and so forth. 3. On the basis of DNA sequence data for a number of patients with and without a given disease, a biologist would like to figure out which DNA mutations are deleterious (disease-causing) and which are not. Just as in the regression setting, in the classification setting we have a set of training observations (x1,y1),...,(xn,yn)that we can use to build a classifier. We want our classifier to perform well not only on the training data, but also on test observations that were not used to train the classifier. In this chapter, we will illustrate the concept of classification using the simulated Default data set. We are interested in predicting whether an individual will default on his or her credit card payment, on the basis of annual income and monthly credit card balance. The data set is displayed in Figure 4.1. In the left-hand panel of Figure 4.1, we have plotted annual incomeand monthly credit card balancefor a subset of 10,000individuals. The individuals who defaulted in a given month are shown in orange, and those who did not in blue. (The overall default rate is about 3%, so we have plotted only a fraction of the individuals who did not default.) It appears that individuals who defaulted tended to have higher credit card balances than those who did not. In the center and right-hand panels of Figure4.1, two pairs of boxplots are shown. The first shows the distribution ofbalancesplit by the binary defaultvariable; the second is a similar plot forincome.Inthischapter,welearnhowtobuildamodeltopredict default (Y) for any given value of balance(X1) andincome(X2). SinceYis not quantitative, the simple linear regression model of Chapter 3is not a good choice: we will", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 161, "start_word": 51520, "end_word": 51920, "chunk_words": 400}}, "ISLP_website::c000162": {"text": "individuals who did not default.) It appears that individuals who defaulted tended to have higher credit card balances than those who did not. In the center and right-hand panels of Figure4.1, two pairs of boxplots are shown. The first shows the distribution ofbalancesplit by the binary defaultvariable; the second is a similar plot forincome.Inthischapter,welearnhowtobuildamodeltopredict default (Y) for any given value of balance(X1) andincome(X2). SinceYis not quantitative, the simple linear regression model of Chapter 3is not a good choice: we will elaborate on this further in Section 4.2. It is worth noting that Figure 4.1displays a very pronounced relation- ship between the predictor balanceand the response default. In most real applications, the relationship between the predictor and the response will not be nearly so strong. However, for the sake of illustrating the classifica- tion procedures discussed in this chapter, we use an example in which the relationship between the predictor and the response is somewhat exagger- ated. 4.2 Why Not Linear Regression? We have stated that linear regression is not appropriate in the case of a qualitative response. Why not? Suppose that we are trying to predict the medical condition of a patient in the emergency room on the basis of her symptoms. In this simplified example, there are three possible diagnoses: stroke,drug overdose , and 4.2 Why Not Linear Regression? 137 0 500 1000 1500 2000 25000 20000 40000 60000BalanceIncome No Yes0 500 1000 1500 2000 2500DefaultBalance No Yes020000 40000 60000DefaultIncome FIGURE 4.1.TheDefaultdata set.Left:The annual incomes and monthlycredit card balances of a number of individuals. The individuals who defaulted ontheir credit card payments are shown in orange, and those who did not are shownin blue.Center:Boxplots ofbalanceas a function ofdefaultstatus.Right:Boxplots ofincomeas a function ofdefaultstatus.epileptic seizure. We could consider encoding these values as a quantita-tive response variable,Y, as follows:Y=1ifstroke;2ifdrug overdose;3ifepileptic seizure.Usingthiscoding,leastsquarescouldbeusedtofitalinearregressionmodelto predictYon the basis of a set of predictorsX1,...,Xp. Unfortunately,this coding implies an ordering on the outcomes, puttingdrug overdoseinbetweenstrokeandepileptic seizure, and insisting that the differencebetweenstrokeanddrug overdoseis the same as the difference betweendrug overdoseandepileptic seizure. In practice there is no particularreason that this needs to be the case. For instance, one could choose anequally reasonable coding,Y=1ifepileptic seizure;2ifstroke;3ifdrug overdose,which would imply a totally different relationship among the three condi-tions. Each of these codings would produce fundamentally different linearmodels that would ultimately lead to different sets of predictions on testobservations.If the response variable’s values did take on a natural ordering, such asmild,moderate, andsevere, and we", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 162, "start_word": 51840, "end_word": 52240, "chunk_words": 400}}, "ISLP_website::c000163": {"text": "that the differencebetweenstrokeanddrug overdoseis the same as the difference betweendrug overdoseandepileptic seizure. In practice there is no particularreason that this needs to be the case. For instance, one could choose anequally reasonable coding,Y=1ifepileptic seizure;2ifstroke;3ifdrug overdose,which would imply a totally different relationship among the three condi-tions. Each of these codings would produce fundamentally different linearmodels that would ultimately lead to different sets of predictions on testobservations.If the response variable’s values did take on a natural ordering, such asmild,moderate, andsevere, and we felt the gap between mild and moderatewas similar to the gap between moderate and severe, then a 1, 2, 3 codingwould be reasonable. Unfortunately, in general there is no natural way to 138 4. Classification convert a qualitative response variable with more than two levels into a quantitative response that is ready for linear regression. For abinary(two level) qualitative response, the situation is better. Forbinaryinstance, perhaps there are only two possibilities for the patient’s medical condition: strokeanddrug overdose . We could then potentially use the dummyvariable approachfromSection 3.3.1tocodetheresponseasfollows: Y=/braceleftBigg 0ifstroke; 1ifdrug overdose . We could then fit a linear regression to this binary response, and predict drug overdose ifˆY>0.5andstrokeotherwise. In the binary case it is not hard to show that even if we flip the above coding, linear regression will produce the same final predictions. For a binary response with a 0/1 coding as above, regression by least squares is not completely unreasonable: it can be shown that the Xˆβob- tained using linear regression is in fact an estimate of Pr(drug overdose |X) in this special case. However, if we use linear regression, some of our es- timates might be outside the [0,1]interval (see Figure 4.2), making them hard to interpret as probabilities! Nevertheless, the predictions provide an ordering and can be interpreted as crude probability estimates. Curiously, it turns out that the classifications that we get if we use linear regression to predict a binary response will be the same as for the linear discriminant analysis (LDA) procedure we discuss in Section 4.4. To summarize, there are at least two reasons not to perform classifica- tion using a regression method: (a) a regression method cannot accommo- date a qualitative response with more than two classes; (b) a regression method will not provide meaningful estimates of Pr(Y|X), even with just two classes. Thus, it is preferable to use a classification method that is truly suited for qualitative response values. In", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 163, "start_word": 52160, "end_word": 52560, "chunk_words": 400}}, "ISLP_website::c000164": {"text": "same as for the linear discriminant analysis (LDA) procedure we discuss in Section 4.4. To summarize, there are at least two reasons not to perform classifica- tion using a regression method: (a) a regression method cannot accommo- date a qualitative response with more than two classes; (b) a regression method will not provide meaningful estimates of Pr(Y|X), even with just two classes. Thus, it is preferable to use a classification method that is truly suited for qualitative response values. In the next section, we present logistic regression, which is well-suited for the case of a binary qualita- tive response; in later sections we will cover classification methods that are appropriate when the qualitative response has two or more classes. 4.3 Logistic Regression Consider again the Defaultdata set, where the response defaultfalls into one of two categories, YesorNo. Rather than modeling this response Y directly, logistic regression models the probability thatYbelongs to a par- ticular category. FortheDefaultdata,logisticregressionmodelstheprobabilityofdefault. For example, the probability of default given balancecan be written as Pr(default=Yes|balance). Thevaluesof Pr(default=Yes|balance),whichweabbreviate p(balance), willrangebetween0and1.Thenforanygivenvalueof balance,aprediction can be made for default. For example, one might predict default =Yes 4.3 Logistic Regression 139 0 500 1000 1500 2000 25000.0 0.2 0.4 0.6 0.8 1.0BalanceProbability of Default|| |||| | |||||||||||||||||| | |||||| |||||||| | |||||||||||||||| | ||| ||||||||| |||||| | |||||| | | ||||||| |||||||||||||||| | |||||||||||||||||||||||| |||| |||||| ||||| |||| ||||||||||||||||||| | || |||||||||||||||||||||||||||| ||||| ||| |||||||||||||||||||||||||||||||| || ||||| ||||| |||||||||| ||||||| | | | |||||||||||||||||||| ||||||||| | | | |||||||||||| | | |||||||||||||||||||| || |||| || || |||||||| ||||||||||||||||| |||||||||||||||||||||||||||||||| || ||||||||||| | | ||||||||||||||||||| |||||||||||| ||||||||||||||||| | ||||||||||||||||| ||||||||||||||||||||| ||||||||||| ||||||||||||||||| | | || ||||| |||||| ||||| ||| || ||||||||||||||| ||||| |||||||||||||||||||||||||||||||| |||| | ||||||||||||||||||||| || |||||||||| || | |||||||| | | |||||||| | ||||||||||||||||||||||||| | | | | | |||||||||| ||||||||||||||||| |||||||||| |||||| ||| ||||||||| ||| || | ||| ||||||||| |||||||||||||| ||| |||||||||| ||||| |||||||||||| ||||| |||||||| ||||||||| |||||||||| ||||||||||||| || ||||| |||| |||||||||||||||||||||||||||||||||||||||||||| |||||||||||| ||| | ||||||||||||||||| ||| | | |||||||||||||||| ||| |||| || ||||||||||||| ||| ||||||||||||||||||| ||| || ||||||||||| | |||||||| || ||||||||| | ||||||||||||||||||||||||||||||||||||||||||| ||||||||| | | ||||||||||| |||||||||||||||| ||||||| |||||||||| ||||||| ||||||| |||||||||||||||| ||| | | |||| |||||||| |||||| ||| |||||| || ||| | ||||||||||| ||||||||| |||||||||||||| || |||||||||| ||||||| | ||||||||||||||||| ||||||||||||||||||||||||||| | |||||||||||||| | ||||||||||| | ||||| ||| |||| || ||||||| | ||||||||||||||||| ||||||||| ||||||||| |||||| |||||||||||||||||| |||||||||||||| | || || |||||||| | | |", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 164, "start_word": 52480, "end_word": 52880, "chunk_words": 400}}, "ISLP_website::c000165": {"text": "||||| |||| |||||||||||||||||||||||||||||||||||||||||||| |||||||||||| ||| | ||||||||||||||||| ||| | | |||||||||||||||| ||| |||| || ||||||||||||| ||| ||||||||||||||||||| ||| || ||||||||||| | |||||||| || ||||||||| | ||||||||||||||||||||||||||||||||||||||||||| ||||||||| | | ||||||||||| |||||||||||||||| ||||||| |||||||||| ||||||| ||||||| |||||||||||||||| ||| | | |||| |||||||| |||||| ||| |||||| || ||| | ||||||||||| ||||||||| |||||||||||||| || |||||||||| ||||||| | ||||||||||||||||| ||||||||||||||||||||||||||| | |||||||||||||| | ||||||||||| | ||||| ||| |||| || ||||||| | ||||||||||||||||| ||||||||| ||||||||| |||||| |||||||||||||||||| |||||||||||||| | || || |||||||| | | | | | | | | |||||||||||||||| ||||| ||| ||||||||| |||||| |||||||||||||| | |||||| | |||||| |||| ||||||||| | | ||| |||||||||||||||||||| | ||||||| |||||||||||||| ||| |||||||||||||||| |||||||||||||||| |||||||||||||||||||||| ||||||||||||||||||||| | | ||| |||| ||||| |||||||||| |||||||||| ||||||| ||||| |||||| | ||||||||||||||||||||||||||| |||||||||||||||||||||||||||||||| |||||||||||||| |||| ||||||||||| |||||||| | | ||||||||| |||| |||||||| |||| |||| |||||||||| | ||| |||||| | ||||||| || | ||||||| ||| | | ||||| |||||||| | |||| ||||| | |||| |||||||||||||||| | ||| || || ||||||| ||||||||||||||||||||||||||||||||| ||||||||| |||||| |||| ||||| ||| ||||||||||||||||| |||||| |||||||||||||||| ||||||| | | |||||| ||||||||||||||||||||||||||| ||||| ||||||||||||||||| ||||||||||||| |||||||| |||||||| | | |||| | |||||||| || || |||| |||||||| || ||| || |||| ||||| |||||||||||| |||| |||| | ||||||| ||||||||||||||||||||||| |||||||| |||||| |||| |||||||||| ||||| ||| | | ||||| || ||| ||||||||||||| | | | | | |||| ||||||||||||| ||| ||||||||| | |||| |||||||||||||| |||| |||||||||||||||||||||||||||| |||||||||||||||||||||||||||||||||||||||| |||||||||||||||||||||| |||||||||||| || ||||| | |||| | |||| ||||||||||||||||||||||||||| |||||||||||||||||||||||||| |||||||| ||||| ||||||| || ||||||||||||||| | | | ||||||||||||||| ||||||||||||||||||| ||||||||||||||||||||| |||||||||||||||||||| |||||||| |||||||||||||||| | ||||||||||||||| | |||||||| ||| ||| |||||||||||||||||||||||||||||| | |||||| |||| |||| | ||| ||| |||||||||||| |||||||| |||||||||||| ||||| | | | |||||||| |||||||||||||||||||||||||| |||||||||||||||||||||||| |||| | | | |||||||||| | |||||||||| ||||||||||| || |||||||||||||||||||||||||||||| | | |||||| |||| ||||||||||||||||||||||||||||||||| ||||||| ||||| |||||||||| |||| | | | ||||||||||||||||||||||| | | |||||||||||||||||||| ||||| | | | ||||| |||||| ||||||||||| ||||||||||||||||| | ||||||| | ||||||| |||||| | ||||||| |||||| |||||| | |||||| | ||||||||| ||| | | | |||| |||| || ||||||||||||||||||| || |||| || |||| |||| ||||||||||| | || |||| ||||| |||||||||||| | ||||| ||||||| ||| ||||||||||||||| | |||||| | |||||||||||||| |||||||||||| ||||||||| |||||||| ||||||||| |||||||| ||||| | ||||||||||||||||||||||||||||| |||| |||||| ||| |||||| |||||| |||||||||||||||| | ||||||||| |||||||||||||||||||| ||||||||||||||||||||| |||||||||||||||||||||||||||| || || ||||| |||||||||||||||||||| ||||| | ||||||||||| |||||||||||| |||||||||||||||||| |||||| | |||||| | | |||||||||| |||||| |||| ||||||||| ||| ||| |||||||||||| | ||||||| | |||||||| |||||||| | |||||||||||||||| ||||| ||||||||||||||||| | | ||||||||||||||||||| |", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 165, "start_word": 52800, "end_word": 53200, "chunk_words": 400}}, "ISLP_website::c000166": {"text": "| | | |||| |||| || ||||||||||||||||||| || |||| || |||| |||| ||||||||||| | || |||| ||||| |||||||||||| | ||||| ||||||| ||| ||||||||||||||| | |||||| | |||||||||||||| |||||||||||| ||||||||| |||||||| ||||||||| |||||||| ||||| | ||||||||||||||||||||||||||||| |||| |||||| ||| |||||| |||||| |||||||||||||||| | ||||||||| |||||||||||||||||||| ||||||||||||||||||||| |||||||||||||||||||||||||||| || || ||||| |||||||||||||||||||| ||||| | ||||||||||| |||||||||||| |||||||||||||||||| |||||| | |||||| | | |||||||||| |||||| |||| ||||||||| ||| ||| |||||||||||| | ||||||| | |||||||| |||||||| | |||||||||||||||| ||||| ||||||||||||||||| | | ||||||||||||||||||| | | ||| |||| |||| || ||||||||||||||||||||||||| ||||||||| | |||||||| ||||||||||||||||| |||| |||||||| | |||||||||||||||||||||||||||||||||| |||| ||||||||| ||||||||||| |||||||||||||||||||||||||| ||||| ||| | |||||||| ||||||||||||||| ||| ||| || || ||||||||||||| ||||| |||||||||||||||| |||||||||||| || |||||||||||||||||||||||||||||||||| || |||||||| ||||||||||||||||||||| ||||||||||||| |||||||| | || |||| | |||||||| |||| || ||||||||||||||||||| ||||||||||||| |||||||||||||||||||||||||||||| | || ||||||||||| |||| |||||||| ||||||||||||||||||||||||||||||||||||||||||| ||||||||||| ||| ||||||| ||||| ||||||||||||| |||| |||||||||||| | |||||||||| | |||||| ||||||||||||| ||| | | ||||||| ||||||||||||| ||| | |||||||||||||||||||||||||| |||||||||||||| | ||||| |||||| | ||||||| ||||||| |||||||||||||||| ||||||||| |||||| ||| | ||| ||||| |||||||||||||||||||||||| |||| ||||||||| ||||| |||||||||||||||| ||| | ||||| ||||||| |||| |||||||||||||||||||| |||||||| | | ||||||||||| | ||||||||||||| ||||||||||||| ||||||||| |||| || |||||||||||||||||| |||||||||||| ||| ||||||||||||||||| |||||||||||| || |||| |||| ||||| |||||||| || |||||||||||||| |||||||||||| || |||||||||| ||||| || |||||||||||||||||||||||||| | |||||||||| |||||| | || |||||||||||||||| | | | |||||||||||||||||||||| ||||||||||| ||||||||||||||||| | |||||||||||||| ||||||||||||||||||||||||||||||||||||||||||||||||| |||| | |||| | | ||||||||||||| |||||| |||| | | | |||| |||| ||| ||||||||| ||| ||||||||||||||| |||||||||||||||||||||||||||||||| |||||||||||||||| | | |||| || ||||||||||| |||| ||||||||||||||||||||||||||||||||||| ||| |||||||||||||||||||||||||||| |||||||||||||||||||||||||||||||||||||| |||| |||||| ||||| | ||||||||||| | |||| |||||||||||||| |||||| ||||| ||| ||||||||||||| |||||||||||||||||| |||||||||||||||||||||||||||||| | |||||| |||||||| |||||||| | | | | ||||||||| |||||||||||||||||||||||||| | | | |||||||| ||| || |||| |||| ||||| |||| | ||||| ||||||||||| |||| || || |||||||||||| ||||||| | ||||||||||| || |||||||| |||||||||||||||||||||| ||||||||||||||||||||||| ||||||||||| ||||| |||||| ||||| | |||||| | | | |||| | | | | | | |||||||||| | | ||| | | | ||||||||||||||| ||||| ||| || || | ||| ||| ||||||| |||||||||||||||||||||||||||||||||||||| | ||||| | | ||||||| | |||||||| ||||||| ||| ||| ||||||||| ||||||||||||||||||||| ||||||||| | ||| ||||||| | ||||| | |||| ||| ||| ||||||||||| | |||||||||| |||||||||||||||| |||||||||||| || ||| ||||||||||||||||||||||||||||||||| ||||||| |||||||||||||||| |||| |||||||||| |||||||||||||||||||||||| ||||||||| ||||||||||||| |||||||||| ||||| ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||| || ||||||||| |||||| ||||||| | ||| |||| | ||||| ||||||| |||||| |||| |||||||| |||||||||||| | |||||||||||||||||| || ||||||||||||||||| | || || | ||||||||| ||||||| ||||| |||||||||||||||| |||||||||||||||||||| |||||||||||||||", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 166, "start_word": 53120, "end_word": 53520, "chunk_words": 400}}, "ISLP_website::c000167": {"text": "| | ||||||||||||||| ||||| ||| || || | ||| ||| ||||||| |||||||||||||||||||||||||||||||||||||| | ||||| | | ||||||| | |||||||| ||||||| ||| ||| ||||||||| ||||||||||||||||||||| ||||||||| | ||| ||||||| | ||||| | |||| ||| ||| ||||||||||| | |||||||||| |||||||||||||||| |||||||||||| || ||| ||||||||||||||||||||||||||||||||| ||||||| |||||||||||||||| |||| |||||||||| |||||||||||||||||||||||| ||||||||| ||||||||||||| |||||||||| ||||| ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||| || ||||||||| |||||| ||||||| | ||| |||| | ||||| ||||||| |||||| |||| |||||||| |||||||||||| | |||||||||||||||||| || ||||||||||||||||| | || || | ||||||||| ||||||| ||||| |||||||||||||||| |||||||||||||||||||| ||||||||||||||| ||||| ||| ||||||||||| ||| |||| |||| |||| ||||||||||||||||| ||||||||| |||||||||| ||||||| |||||||||||| |||||||||||| |||||||| |||||||||||||||||||||| | |||||| ||| | | |||||||||| ||||||||| || | | |||| ||||||||||| | | ||||| | |||||||||| ||||||| ||||||||||||||||||||| |||| |||||||||||||||||| ||||||||||| ||||||| |||||||||| ||||| ||||||| ||||||||||||| |||||||||||||||||||||||||||||||||||||||||||||| |||||||| ||||||||||||| || ||| | | | | |||||| ||||||||| |||| |||||||||||| | ||||||| ||||||| || ||| ||||||||||| |||||||||||||| | ||||||| ||||||||| || ||| | ||||||||||||||||||||||||||||||||||||| |||||||||||| |||||||| ||| |||||||||||||| | ||||||||||||||||||||||||||||||| ||||||||||||||||||||||||||| ||||||||| ||| ||||||||| ||||||||| | ||||| ||||||||| ||| ||||||||| | | | ||||| ||| ||||||||||| |||| ||||||| |||||||||| |||||| |||||||||||||| | |||||||||||||||||||| |||| ||||||| | | ||||||||||| |||||||||||||||||| |||| ||| ||||||||| |||| ||||| |||||| ||||||||| | |||||||| ||||| | | ||||||||||||||||||||||||| |||||||||||||| | |||||||||||||||||||||| | | ||| | |||| ||||||||||| ||||||||||| ||||||| |||||||||||||||||| ||||||||||||||||||||||||||||| ||| ||||||||||||||||||||||||||| |||||||||||||||||| ||||||||||||| | ||||||||||||||| |||||||| |||| ||||| ||||||||||||||||||||||||||||||||||||||||||||| |||||||||||| ||||||||||||| || || |||||| |||||||||||||||| ||| |||||||||||||||| ||||||||||||||||||||||||||| ||||| ||||| ||||||| ||| ||| ||||||||| || ||||||| | | ||||| ||||||||||||||||||||||||||| |||||| ||| ||||||| | |||||||||||||||||| ||||||||| ||||||||||||| | | ||||||||||||| |||||||||||||| | |||| | | |||||||| |||||||||||||||||||||||||||||||||||||||| ||||||| | |||||||||||||| |||||||||||||||||| |||||||||||||||||||| | | |||||| |||| |||||| |||||||||||| | | ||| ||| | | | ||| |||||| |||||||| |||||||||| | ||||||||||||||||| | |||||||||||||||| |||||||||||||| ||||||||||||| || || |||||||||||| ||||||||||||||||||||||||||||||||||| ||||||| ||||||||| || ||||||||||||||||||||||| |||||||||||||||||||||||||| ||||||||||| | ||||||||||| |||||| ||||||||||||||||||||||| ||||||||||||||||||||||||||||||||||| |||||||||||||||||||| |||| ||| | ||||| | | ||||||||||||||||||||||||||||||| |||||||||||||||||| ||||||||| ||| | | |||||| |||||||||||||||||||| ||| ||||||||| | ||| |||| ||| | | | |||||||||| ||| ||||||||||| |||| ||||||||||||||||||||||||||||||||||||||||||||||||| ||||||| ||| ||||| |||||| ||||||||||||||||||||||||| |||||||||||||||||||| ||||||||||||||||||| | ||| |||||| |||| |||||||||||| || |||||||| ||||||| |||||||||||||||||||||||||||| ||||||||||| || |||| ||||||||||| ||||| |||| ||||||| | |||||||||||| ||| |||| |||||| |||||||||| ||| ||||||| || | ||| ||||||||||||||||||||||| |||||||||||||||||||||||| |||||||||||||||||||||||||| ||| | || |||| | | | | ||||||||||||||||||| | | | |||||||||||| ||||| |||| | | | ||||||||| | |||||||||||||||||||||||||| ||||| |||||||||||||||| | ||| |||||||||||||||| |||| ||||||||||||||| ||||||||||||| |||||||||||||||||||||||||||||| |||||||||||||||| ||||||| ||", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 167, "start_word": 53440, "end_word": 53840, "chunk_words": 400}}, "ISLP_website::c000168": {"text": "|||| ||| | | | |||||||||| ||| ||||||||||| |||| ||||||||||||||||||||||||||||||||||||||||||||||||| ||||||| ||| ||||| |||||| ||||||||||||||||||||||||| |||||||||||||||||||| ||||||||||||||||||| | ||| |||||| |||| |||||||||||| || |||||||| ||||||| |||||||||||||||||||||||||||| ||||||||||| || |||| ||||||||||| ||||| |||| ||||||| | |||||||||||| ||| |||| |||||| |||||||||| ||| ||||||| || | ||| ||||||||||||||||||||||| |||||||||||||||||||||||| |||||||||||||||||||||||||| ||| | || |||| | | | | ||||||||||||||||||| | | | |||||||||||| ||||| |||| | | | ||||||||| | |||||||||||||||||||||||||| ||||| |||||||||||||||| | ||| |||||||||||||||| |||| ||||||||||||||| ||||||||||||| |||||||||||||||||||||||||||||| |||||||||||||||| ||||||| || ||||||| ||||||| ||||||||||||| ||||||||||||| ||| ||||||||||||||||||||||| | ||| | |||||||||||||||||||||||||||||| | ||||||||||||| |||||||||||| |||||||||||||||||| | |||||||||||||||||||||| | |||||||||| ||||||||||||||||||||| |||||||||||||||||| | |||| ||||||||||||||||||||||||| ||| || ||||||||| |||||||||||||||| ||||||||| ||||| || ||||| |||||||||||||||||| |||||||||||||||||||||||||||||||||||| ||||||||||||||| ||||||||||||||| |||| |||||||||||||||||||||||||||||||| | | | ||| ||||||||||||||||||| |||||||||||||||||||| ||| | ||||||||| || ||||||||||||||||||||| ||| ||||| ||||||||||||||||||| | | | |||||| |||||||||||||||| ||||||||||||||||||||||| || |||||||||| ||||||||||| |||||||||||||||||||||||||||||||||||||||||| || | || |||| ||||||| |||||||||| ||||||||||||||||||| |||||||| |||||||| | | ||||| || |||||||| || | || ||||||| ||||||||| ||||||| ||||||||||||||||||||||| ||||||||||||||||||| | ||||||||| |||||||||||||||||||| |||||| | ||||||||||||||||| |||| |||||||||| | | | ||| |||||| ||| ||| | ||||||||| | ||||||||| | ||||||||||||||||||||||| ||||||||||| | |||||||||||| | |||||||||| |||||||||||||||||| ||||||||||||||||| ||| ||| |||||||||| ||||| |||||||||||| |||||||||||||||||||||||||||||| ||||||||||||| |||||||||||||||||||||| ||||| ||| ||||||| ||||||||| | | | |||| | || |||||| ||| ||||||| ||| | ||||||||| | ||||| || || ||| |||||||||||||| ||||| | |||| ||| | |||||||||||||| |||0 500 1000 1500 2000 25000.0 0.2 0.4 0.6 0.8 1.0BalanceProbability of Default|| |||| | |||||||||||||||||| | |||||| |||||||| | |||||||||||||||| | ||| ||||||||| |||||| | |||||| | | ||||||| |||||||||||||||| | |||||||||||||||||||||||| |||| |||||| ||||| |||| ||||||||||||||||||| | || |||||||||||||||||||||||||||| ||||| ||| |||||||||||||||||||||||||||||||| || ||||| ||||| |||||||||| ||||||| | | | |||||||||||||||||||| ||||||||| | | | |||||||||||| | | |||||||||||||||||||| || |||| || || |||||||| ||||||||||||||||| |||||||||||||||||||||||||||||||| || ||||||||||| | | ||||||||||||||||||| |||||||||||| ||||||||||||||||| | ||||||||||||||||| ||||||||||||||||||||| ||||||||||| ||||||||||||||||| | | || ||||| |||||| ||||| ||| || ||||||||||||||| ||||| |||||||||||||||||||||||||||||||| |||| | ||||||||||||||||||||| || |||||||||| || | |||||||| | | |||||||| | ||||||||||||||||||||||||| | | | | | |||||||||| ||||||||||||||||| |||||||||| |||||| ||| ||||||||| ||| || | ||| ||||||||| |||||||||||||| ||| |||||||||| ||||| |||||||||||| ||||| |||||||| ||||||||| |||||||||| ||||||||||||| || ||||| |||| |||||||||||||||||||||||||||||||||||||||||||| |||||||||||| ||| | ||||||||||||||||| ||| | | |||||||||||||||| ||| |||| || ||||||||||||| ||| ||||||||||||||||||| ||| || ||||||||||| | |||||||| || ||||||||| | ||||||||||||||||||||||||||||||||||||||||||| ||||||||| | | ||||||||||| |||||||||||||||| ||||||| |||||||||| ||||||| ||||||| |||||||||||||||| ||| | | |||| |||||||| ||||||", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 168, "start_word": 53760, "end_word": 54160, "chunk_words": 400}}, "ISLP_website::c000169": {"text": "||||||||||||||||||||| || |||||||||| || | |||||||| | | |||||||| | ||||||||||||||||||||||||| | | | | | |||||||||| ||||||||||||||||| |||||||||| |||||| ||| ||||||||| ||| || | ||| ||||||||| |||||||||||||| ||| |||||||||| ||||| |||||||||||| ||||| |||||||| ||||||||| |||||||||| ||||||||||||| || ||||| |||| |||||||||||||||||||||||||||||||||||||||||||| |||||||||||| ||| | ||||||||||||||||| ||| | | |||||||||||||||| ||| |||| || ||||||||||||| ||| ||||||||||||||||||| ||| || ||||||||||| | |||||||| || ||||||||| | ||||||||||||||||||||||||||||||||||||||||||| ||||||||| | | ||||||||||| |||||||||||||||| ||||||| |||||||||| ||||||| ||||||| |||||||||||||||| ||| | | |||| |||||||| |||||| ||| |||||| || ||| | ||||||||||| ||||||||| |||||||||||||| || |||||||||| ||||||| | ||||||||||||||||| ||||||||||||||||||||||||||| | |||||||||||||| | ||||||||||| | ||||| ||| |||| || ||||||| | ||||||||||||||||| ||||||||| ||||||||| |||||| |||||||||||||||||| |||||||||||||| | || || |||||||| | | | | | | | | |||||||||||||||| ||||| ||| ||||||||| |||||| |||||||||||||| | |||||| | |||||| |||| ||||||||| | | ||| |||||||||||||||||||| | ||||||| |||||||||||||| ||| |||||||||||||||| |||||||||||||||| |||||||||||||||||||||| ||||||||||||||||||||| | | ||| |||| ||||| |||||||||| |||||||||| ||||||| ||||| |||||| | ||||||||||||||||||||||||||| |||||||||||||||||||||||||||||||| |||||||||||||| |||| ||||||||||| |||||||| | | ||||||||| |||| |||||||| |||| |||| |||||||||| | ||| |||||| | ||||||| || | ||||||| ||| | | ||||| |||||||| | |||| ||||| | |||| |||||||||||||||| | ||| || || ||||||| ||||||||||||||||||||||||||||||||| ||||||||| |||||| |||| ||||| ||| ||||||||||||||||| |||||| |||||||||||||||| ||||||| | | |||||| ||||||||||||||||||||||||||| ||||| ||||||||||||||||| ||||||||||||| |||||||| |||||||| | | |||| | |||||||| || || |||| |||||||| || ||| || |||| ||||| |||||||||||| |||| |||| | ||||||| ||||||||||||||||||||||| |||||||| |||||| |||| |||||||||| ||||| ||| | | ||||| || ||| ||||||||||||| | | | | | |||| ||||||||||||| ||| ||||||||| | |||| |||||||||||||| |||| |||||||||||||||||||||||||||| |||||||||||||||||||||||||||||||||||||||| |||||||||||||||||||||| |||||||||||| || ||||| | |||| | |||| ||||||||||||||||||||||||||| |||||||||||||||||||||||||| |||||||| ||||| ||||||| || ||||||||||||||| | | | ||||||||||||||| ||||||||||||||||||| ||||||||||||||||||||| |||||||||||||||||||| |||||||| |||||||||||||||| | ||||||||||||||| | |||||||| ||| ||| |||||||||||||||||||||||||||||| | |||||| |||| |||| | ||| ||| |||||||||||| |||||||| |||||||||||| ||||| | | | |||||||| |||||||||||||||||||||||||| |||||||||||||||||||||||| |||| | | | |||||||||| | |||||||||| ||||||||||| || |||||||||||||||||||||||||||||| | | |||||| |||| ||||||||||||||||||||||||||||||||| ||||||| ||||| |||||||||| |||| | | | ||||||||||||||||||||||| | | |||||||||||||||||||| ||||| | | | ||||| |||||| ||||||||||| ||||||||||||||||| | ||||||| | ||||||| |||||| | ||||||| |||||| |||||| | |||||| | ||||||||| ||| | | | |||| |||| || ||||||||||||||||||| || |||| || |||| |||| ||||||||||| | || |||| ||||| |||||||||||| | ||||| ||||||| ||| ||||||||||||||| | |||||| | |||||||||||||| |||||||||||| ||||||||| |||||||| ||||||||| |||||||| ||||| | ||||||||||||||||||||||||||||| |||| |||||| ||| |||||| |||||| |||||||||||||||| |", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 169, "start_word": 54080, "end_word": 54480, "chunk_words": 400}}, "ISLP_website::c000170": {"text": "| | |||||| |||| ||||||||||||||||||||||||||||||||| ||||||| ||||| |||||||||| |||| | | | ||||||||||||||||||||||| | | |||||||||||||||||||| ||||| | | | ||||| |||||| ||||||||||| ||||||||||||||||| | ||||||| | ||||||| |||||| | ||||||| |||||| |||||| | |||||| | ||||||||| ||| | | | |||| |||| || ||||||||||||||||||| || |||| || |||| |||| ||||||||||| | || |||| ||||| |||||||||||| | ||||| ||||||| ||| ||||||||||||||| | |||||| | |||||||||||||| |||||||||||| ||||||||| |||||||| ||||||||| |||||||| ||||| | ||||||||||||||||||||||||||||| |||| |||||| ||| |||||| |||||| |||||||||||||||| | ||||||||| |||||||||||||||||||| ||||||||||||||||||||| |||||||||||||||||||||||||||| || || ||||| |||||||||||||||||||| ||||| | ||||||||||| |||||||||||| |||||||||||||||||| |||||| | |||||| | | |||||||||| |||||| |||| ||||||||| ||| ||| |||||||||||| | ||||||| | |||||||| |||||||| | |||||||||||||||| ||||| ||||||||||||||||| | | ||||||||||||||||||| | | ||| |||| |||| || ||||||||||||||||||||||||| ||||||||| | |||||||| ||||||||||||||||| |||| |||||||| | |||||||||||||||||||||||||||||||||| |||| ||||||||| ||||||||||| |||||||||||||||||||||||||| ||||| ||| | |||||||| ||||||||||||||| ||| ||| || || ||||||||||||| ||||| |||||||||||||||| |||||||||||| || |||||||||||||||||||||||||||||||||| || |||||||| ||||||||||||||||||||| ||||||||||||| |||||||| | || |||| | |||||||| |||| || ||||||||||||||||||| ||||||||||||| |||||||||||||||||||||||||||||| | || ||||||||||| |||| |||||||| ||||||||||||||||||||||||||||||||||||||||||| ||||||||||| ||| ||||||| ||||| ||||||||||||| |||| |||||||||||| | |||||||||| | |||||| ||||||||||||| ||| | | ||||||| ||||||||||||| ||| | |||||||||||||||||||||||||| |||||||||||||| | ||||| |||||| | ||||||| ||||||| |||||||||||||||| ||||||||| |||||| ||| | ||| ||||| |||||||||||||||||||||||| |||| ||||||||| ||||| |||||||||||||||| ||| | ||||| ||||||| |||| |||||||||||||||||||| |||||||| | | ||||||||||| | ||||||||||||| ||||||||||||| ||||||||| |||| || |||||||||||||||||| |||||||||||| ||| ||||||||||||||||| |||||||||||| || |||| |||| ||||| |||||||| || |||||||||||||| |||||||||||| || |||||||||| ||||| || |||||||||||||||||||||||||| | |||||||||| |||||| | || |||||||||||||||| | | | |||||||||||||||||||||| ||||||||||| ||||||||||||||||| | |||||||||||||| ||||||||||||||||||||||||||||||||||||||||||||||||| |||| | |||| | | ||||||||||||| |||||| |||| | | | |||| |||| ||| ||||||||| ||| ||||||||||||||| |||||||||||||||||||||||||||||||| |||||||||||||||| | | |||| || ||||||||||| |||| ||||||||||||||||||||||||||||||||||| ||| |||||||||||||||||||||||||||| |||||||||||||||||||||||||||||||||||||| |||| |||||| ||||| | ||||||||||| | |||| |||||||||||||| |||||| ||||| ||| ||||||||||||| |||||||||||||||||| |||||||||||||||||||||||||||||| | |||||| |||||||| |||||||| | | | | ||||||||| |||||||||||||||||||||||||| | | | |||||||| ||| || |||| |||| ||||| |||| | ||||| ||||||||||| |||| || || |||||||||||| ||||||| | ||||||||||| || |||||||| |||||||||||||||||||||| ||||||||||||||||||||||| ||||||||||| ||||| |||||| ||||| | |||||| | | | |||| | | | | | | |||||||||| | | ||| | | | ||||||||||||||| ||||| ||| || || | ||| ||| ||||||| |||||||||||||||||||||||||||||||||||||| | ||||| | | ||||||| | |||||||| ||||||| ||| ||| ||||||||| ||||||||||||||||||||| ||||||||| | ||| ||||||| | ||||| | |||| ||| ||| ||||||||||| | |||||||||| |||||||||||||||| |||||||||||| || ||| |||||||||||||||||||||||||||||||||", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 170, "start_word": 54400, "end_word": 54800, "chunk_words": 400}}, "ISLP_website::c000171": {"text": "|||| ||||| |||| | ||||| ||||||||||| |||| || || |||||||||||| ||||||| | ||||||||||| || |||||||| |||||||||||||||||||||| ||||||||||||||||||||||| ||||||||||| ||||| |||||| ||||| | |||||| | | | |||| | | | | | | |||||||||| | | ||| | | | ||||||||||||||| ||||| ||| || || | ||| ||| ||||||| |||||||||||||||||||||||||||||||||||||| | ||||| | | ||||||| | |||||||| ||||||| ||| ||| ||||||||| ||||||||||||||||||||| ||||||||| | ||| ||||||| | ||||| | |||| ||| ||| ||||||||||| | |||||||||| |||||||||||||||| |||||||||||| || ||| ||||||||||||||||||||||||||||||||| ||||||| |||||||||||||||| |||| |||||||||| |||||||||||||||||||||||| ||||||||| ||||||||||||| |||||||||| ||||| ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||| || ||||||||| |||||| ||||||| | ||| |||| | ||||| ||||||| |||||| |||| |||||||| |||||||||||| | |||||||||||||||||| || ||||||||||||||||| | || || | ||||||||| ||||||| ||||| |||||||||||||||| |||||||||||||||||||| ||||||||||||||| ||||| ||| ||||||||||| ||| |||| |||| |||| ||||||||||||||||| ||||||||| |||||||||| ||||||| |||||||||||| |||||||||||| |||||||| |||||||||||||||||||||| | |||||| ||| | | |||||||||| ||||||||| || | | |||| ||||||||||| | | ||||| | |||||||||| ||||||| ||||||||||||||||||||| |||| |||||||||||||||||| ||||||||||| ||||||| |||||||||| ||||| ||||||| ||||||||||||| |||||||||||||||||||||||||||||||||||||||||||||| |||||||| ||||||||||||| || ||| | | | | |||||| ||||||||| |||| |||||||||||| | ||||||| ||||||| || ||| ||||||||||| |||||||||||||| | ||||||| ||||||||| || ||| | ||||||||||||||||||||||||||||||||||||| |||||||||||| |||||||| ||| |||||||||||||| | ||||||||||||||||||||||||||||||| ||||||||||||||||||||||||||| ||||||||| ||| ||||||||| ||||||||| | ||||| ||||||||| ||| ||||||||| | | | ||||| ||| ||||||||||| |||| ||||||| |||||||||| |||||| |||||||||||||| | |||||||||||||||||||| |||| ||||||| | | ||||||||||| |||||||||||||||||| |||| ||| ||||||||| |||| ||||| |||||| ||||||||| | |||||||| ||||| | | ||||||||||||||||||||||||| |||||||||||||| | |||||||||||||||||||||| | | ||| | |||| ||||||||||| ||||||||||| ||||||| |||||||||||||||||| ||||||||||||||||||||||||||||| ||| ||||||||||||||||||||||||||| |||||||||||||||||| ||||||||||||| | ||||||||||||||| |||||||| |||| ||||| ||||||||||||||||||||||||||||||||||||||||||||| |||||||||||| ||||||||||||| || || |||||| |||||||||||||||| ||| |||||||||||||||| ||||||||||||||||||||||||||| ||||| ||||| ||||||| ||| ||| ||||||||| || ||||||| | | ||||| ||||||||||||||||||||||||||| |||||| ||| ||||||| | |||||||||||||||||| ||||||||| ||||||||||||| | | ||||||||||||| |||||||||||||| | |||| | | |||||||| |||||||||||||||||||||||||||||||||||||||| ||||||| | |||||||||||||| |||||||||||||||||| |||||||||||||||||||| | | |||||| |||| |||||| |||||||||||| | | ||| ||| | | | ||| |||||| |||||||| |||||||||| | ||||||||||||||||| | |||||||||||||||| |||||||||||||| ||||||||||||| || || |||||||||||| ||||||||||||||||||||||||||||||||||| ||||||| ||||||||| || ||||||||||||||||||||||| |||||||||||||||||||||||||| ||||||||||| | ||||||||||| |||||| ||||||||||||||||||||||| ||||||||||||||||||||||||||||||||||| |||||||||||||||||||| |||| ||| | ||||| | | ||||||||||||||||||||||||||||||| |||||||||||||||||| ||||||||| ||| | | |||||| |||||||||||||||||||| ||| ||||||||| | ||| |||| ||| | | | |||||||||| ||| ||||||||||| |||| ||||||||||||||||||||||||||||||||||||||||||||||||| ||||||| ||| ||||| |||||| ||||||||||||||||||||||||| |||||||||||||||||||| ||||||||||||||||||| | ||| |||||| |||| |||||||||||| || |||||||| ||||||| |||||||||||||||||||||||||||| ||||||||||| || |||| ||||||||||| ||||| |||| ||||||| | |||||||||||| ||| |||| |||||| |||||||||| ||| ||||||| ||", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 171, "start_word": 54720, "end_word": 55120, "chunk_words": 400}}, "ISLP_website::c000172": {"text": "| |||||||||||||||| |||||||||||||| ||||||||||||| || || |||||||||||| ||||||||||||||||||||||||||||||||||| ||||||| ||||||||| || ||||||||||||||||||||||| |||||||||||||||||||||||||| ||||||||||| | ||||||||||| |||||| ||||||||||||||||||||||| ||||||||||||||||||||||||||||||||||| |||||||||||||||||||| |||| ||| | ||||| | | ||||||||||||||||||||||||||||||| |||||||||||||||||| ||||||||| ||| | | |||||| |||||||||||||||||||| ||| ||||||||| | ||| |||| ||| | | | |||||||||| ||| ||||||||||| |||| ||||||||||||||||||||||||||||||||||||||||||||||||| ||||||| ||| ||||| |||||| ||||||||||||||||||||||||| |||||||||||||||||||| ||||||||||||||||||| | ||| |||||| |||| |||||||||||| || |||||||| ||||||| |||||||||||||||||||||||||||| ||||||||||| || |||| ||||||||||| ||||| |||| ||||||| | |||||||||||| ||| |||| |||||| |||||||||| ||| ||||||| || | ||| ||||||||||||||||||||||| |||||||||||||||||||||||| |||||||||||||||||||||||||| ||| | || |||| | | | | ||||||||||||||||||| | | | |||||||||||| ||||| |||| | | | ||||||||| | |||||||||||||||||||||||||| ||||| |||||||||||||||| | ||| |||||||||||||||| |||| ||||||||||||||| ||||||||||||| |||||||||||||||||||||||||||||| |||||||||||||||| ||||||| || ||||||| ||||||| ||||||||||||| ||||||||||||| ||| ||||||||||||||||||||||| | ||| | |||||||||||||||||||||||||||||| | ||||||||||||| |||||||||||| |||||||||||||||||| | |||||||||||||||||||||| | |||||||||| ||||||||||||||||||||| |||||||||||||||||| | |||| ||||||||||||||||||||||||| ||| || ||||||||| |||||||||||||||| ||||||||| ||||| || ||||| |||||||||||||||||| |||||||||||||||||||||||||||||||||||| ||||||||||||||| ||||||||||||||| |||| |||||||||||||||||||||||||||||||| | | | ||| ||||||||||||||||||| |||||||||||||||||||| ||| | ||||||||| || ||||||||||||||||||||| ||| ||||| ||||||||||||||||||| | | | |||||| |||||||||||||||| ||||||||||||||||||||||| || |||||||||| ||||||||||| |||||||||||||||||||||||||||||||||||||||||| || | || |||| ||||||| |||||||||| ||||||||||||||||||| |||||||| |||||||| | | ||||| || |||||||| || | || ||||||| ||||||||| ||||||| ||||||||||||||||||||||| ||||||||||||||||||| | ||||||||| |||||||||||||||||||| |||||| | ||||||||||||||||| |||| |||||||||| | | | ||| |||||| ||| ||| | ||||||||| | ||||||||| | ||||||||||||||||||||||| ||||||||||| | |||||||||||| | |||||||||| |||||||||||||||||| ||||||||||||||||| ||| ||| |||||||||| ||||| |||||||||||| |||||||||||||||||||||||||||||| ||||||||||||| |||||||||||||||||||||| ||||| ||| ||||||| ||||||||| | | | |||| | || |||||| ||| ||||||| ||| | ||||||||| | ||||| || || ||| |||||||||||||| ||||| | |||| ||| | |||||||||||||| |||FIGURE 4.2. Classification using the Default data.Left:Estimated probability ofdefault using linear regression. Some estimated probabilities are negative! The orangeticks indicatethe 0/1values codedfor default(NoorYes).Right:Predicted probabilities of default using logistic regression. All probabilities lie between 0 and1. for any individual for whom p(balance )>0.5. Alternatively, if a company wishes to be conservative in predicting individuals who are at risk for de- fault, then they may choose to use a lower threshold, such as p(balance )> 0.1. 4.3.1 The Logistic Model How should we model the relationship between p(X) = Pr( Y=1|X)and X? (For convenience we are using the generic 0/1 coding for the response.) In Section 4.2we considered using a linear regression model to represent these probabilities: p(X)=β0+β1X. (4.1) If we use this approach to predict default=Yesusingbalance, then we obtain the model shown in the left-hand panel", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 172, "start_word": 55040, "end_word": 55440, "chunk_words": 400}}, "ISLP_website::c000173": {"text": "at risk for de- fault, then they may choose to use a lower threshold, such as p(balance )> 0.1. 4.3.1 The Logistic Model How should we model the relationship between p(X) = Pr( Y=1|X)and X? (For convenience we are using the generic 0/1 coding for the response.) In Section 4.2we considered using a linear regression model to represent these probabilities: p(X)=β0+β1X. (4.1) If we use this approach to predict default=Yesusingbalance, then we obtain the model shown in the left-hand panel of Figure 4.2. Here we see the problem with this approach: for balances close to zero we predict a negative probability of default; if we were to predict for very large balances, we would get values bigger than 1. These predictions are not sensible, since of course the true probability of default, regardless of credit card balance, must fall between 0and1. This problem is not unique to the credit default data. Any time a straight line is fit to a binary response that is coded as 0or1, in principle we can always predict p(X)<0for some values of X andp(X)>1for others (unless the range of Xis limited). To avoid this problem, we must model p(X)using a function that gives outputs between 0and1for all values of X. Many functions meet this description. In logistic regression, we use the logistic function ,logistic function p(X)=eβ0+β1X 1+eβ0+β1X. (4.2) To fit the model ( 4.2), we use a method called maximum likelihood , whichmaximum likelihoodwediscussinthenextsection.Theright-handpanelofFigure 4.2illustrates the fit of the logistic regression model to the Defaultdata. Notice that for 140 4. Classification low balances we now predict the probability of default as close to, but never below, zero. Likewise, for high balances we predict a default probability close to, but never above, one. The logistic function will always produce anS-shaped curve of this form, and so regardless of the value of X,w e will obtain a sensible prediction. We also see that the logistic model is better able to capture the range of probabilities than is the linear regression model in the left-hand plot. The average fitted probability in both cases is 0.0333 (averaged over the training data), which is the same as the overall proportion of defaulters in the data set. After a bit of manipulation of ( 4.2), we find that p(X) 1−p(X)=eβ0+β1X. (4.3) The quantity p(X)/[1−p(X)]is called the odds, and can take on any valueoddsbetween 0and∞. Values of the odds close to 0and∞indicate", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 173, "start_word": 55360, "end_word": 55760, "chunk_words": 400}}, "ISLP_website::c000174": {"text": "better able to capture the range of probabilities than is the linear regression model in the left-hand plot. The average fitted probability in both cases is 0.0333 (averaged over the training data), which is the same as the overall proportion of defaulters in the data set. After a bit of manipulation of ( 4.2), we find that p(X) 1−p(X)=eβ0+β1X. (4.3) The quantity p(X)/[1−p(X)]is called the odds, and can take on any valueoddsbetween 0and∞. Values of the odds close to 0and∞indicate very low and very high probabilities of default, respectively. For example, on average 1in5people with an odds of 1/4will default, since p(X)=0 .2implies an odds of0.2 1−0.2=1/4. Likewise, on average nine out of every ten people with an odds of 9will default, since p(X)=0 .9implies an odds of0.9 1−0.9=9. Odds are traditionally used instead of probabilities in horse-racing, since they relate more naturally to the correct betting strategy. By taking the logarithm of both sides of ( 4.3), we arrive at log/parenleftbiggp(X) 1−p(X)/parenrightbigg =β0+β1X. (4.4) The left-hand side is called the log odds orlogit. We see that the logisticlog odds logitregression model ( 4.2) has a logit that is linear in X. Recall from Chapter 3that in a linear regression model, β1gives the average change in Yassociated with a one-unit increase in X. By contrast, in a logistic regression model, increasing Xby one unit changes the log odds byβ1(4.4). Equivalently, it multiplies the odds by eβ1(4.3). However, because the relationship between p(X)andXin (4.2) is not a straight line, β1doesnotcorrespond to the change in p(X)associated with a one-unit increase in X. The amount that p(X)changes due to a one-unit change in Xdepends on the current value of X. But regardless of the value of X, if β1is positive then increasing Xwill be associated with increasing p(X), and ifβ1is negative then increasing Xwill be associated with decreasing p(X). The fact that there is not a straight-line relationship between p(X) andX, and the fact that the rate of change in p(X)per unit change in X depends on the current value of X, can also be seen by inspection of the right-hand panel of Figure 4.2. 4.3.2 Estimating the Regression Coefficients The coefficients β0andβ1in (4.2) are unknown, and must be estimated basedontheavailabletrainingdata.InChapter 3,weusedtheleastsquares approach to estimate the unknown linear regression coefficients. Although we could use (non-linear) least squares to fit the model ( 4.4), the more general method of maximum likelihood is preferred, since", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 174, "start_word": 55680, "end_word": 56080, "chunk_words": 400}}, "ISLP_website::c000175": {"text": "fact that the rate of change in p(X)per unit change in X depends on the current value of X, can also be seen by inspection of the right-hand panel of Figure 4.2. 4.3.2 Estimating the Regression Coefficients The coefficients β0andβ1in (4.2) are unknown, and must be estimated basedontheavailabletrainingdata.InChapter 3,weusedtheleastsquares approach to estimate the unknown linear regression coefficients. Although we could use (non-linear) least squares to fit the model ( 4.4), the more general method of maximum likelihood is preferred, since it has better sta- tistical properties. The basic intuition behind using maximum likelihood 4.3 Logistic Regression 141 to fit a logistic regression model is as follows: we seek estimates for β0and β1such that the predicted probability ˆp(xi)of default for each individual, using (4.2), corresponds as closely as possible to the individual’s observed default status. In other words, we try to find ˆβ0andˆβ1such that plugging these estimates into the model for p(X), given in ( 4.2), yields a number close to one for all individuals who defaulted, and a number close to zero for all individuals who did not. This intuition can be formalized using a mathematical equation called a likelihood function :likelihood function /lscript(β0,β1)=/productdisplay i:yi=1p(xi)/productdisplay i/prime:yi/prime=0(1−p(xi/prime)). (4.5) The estimates ˆβ0andˆβ1are chosen to maximize this likelihood function. Maximum likelihood is a very general approach that is used to fit many of the non-linear models that we examine throughout this book. In the linear regression setting, the least squares approach is in fact a special case of maximum likelihood. The mathematical details of maximum likelihood are beyond the scope of this book. However, in general, logistic regression and other models can be easily fit using statistical software such as R, and so we do not need to concern ourselves with the details of the maximum likelihood fitting procedure. Table4.1shows the coefficient estimates and related information that result from fitting a logistic regression model on the Defaultdata in order to predict the probability of default=Yesusingbalance. We see that ˆβ1= 0.0055 ; this indicates that an increase in balance is associated with an increase in the probability of default. To be precise, a one-unit increase in balanceis associated with an increase in the log odds of defaultby0.0055 units. Many aspects of the logistic regression output shown in Table 4.1are similar to the linear regression output of Chapter 3. For example, we can measure the accuracy of the coefficient estimates by computing their stan- darderrors.The", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 175, "start_word": 56000, "end_word": 56400, "chunk_words": 400}}, "ISLP_website::c000176": {"text": "of default=Yesusingbalance. We see that ˆβ1= 0.0055 ; this indicates that an increase in balance is associated with an increase in the probability of default. To be precise, a one-unit increase in balanceis associated with an increase in the log odds of defaultby0.0055 units. Many aspects of the logistic regression output shown in Table 4.1are similar to the linear regression output of Chapter 3. For example, we can measure the accuracy of the coefficient estimates by computing their stan- darderrors.The z-statisticinTable 4.1playsthesameroleasthe t-statistic in the linear regression output, for example in Table 3.1on page 77. For instance, the z-statistic associated with β1is equal to ˆβ1/SE(ˆβ1), and so a large (absolute) value of the z-statistic indicates evidence against the null hypothesis H0:β1=0. This null hypothesis implies that p(X)=eβ0 1+eβ0: in other words, that the probability of defaultdoes not depend on balance. Since the p-value associated with balancein Table 4.1is tiny, we can reject H0. In other words,we conclude that there is indeed an association between balanceand probability of default. The estimated intercept in Table 4.1 is typically not of interest; its main purpose is to adjust the average fitted probabilities to the proportion of ones in the data (in this case, the overall default rate). 4.3.3 Making Predictions Once the coefficients have been estimated, we can compute the probability ofdefaultfor any given credit card balance. For example, using the coeffi- cient estimates given in Table 4.1, we predict that the default probability 142 4. Classification Coefficient Std. error z-statistic p-value Intercept −10.6513 0.3612 −29.5<0.0001 balance 0.0055 0.0002 24.9 <0.0001 TABLE 4.1. For theDefault data, estimated coefficients of the logistic regres- sion model that predicts the probability of default usingbalance. A one-unit increase in balance is associated with an increase in the log odds of default by 0.0055units. Coefficient Std. error z-statistic p-value Intercept −3.5041 0.0707 −49.55<0.0001 student[Yes] 0.4049 0.1150 3.52 0.0004 TABLE 4.2. FortheDefault data,estimatedcoefficientsofthelogisticregression model that predicts the probability of default using student status. Student status is encoded as a dummy variable, with a value of 1for a student and a value of 0 for a non-student, and represented by the variable student[Yes] in the table. for an individual with a balanceof$1,000is ˆp(X)=eˆβ0+ˆβ1X 1+eˆβ0+ˆβ1X=e−10.6513+0.0055×1,000 1+e−10.6513+0.0055×1,000=0.00576, which is below 1%. In contrast, the predicted probability of default for an individual with a balance of $2,000is much higher, and equals 0.586or 58.6%. One can use qualitative predictors with the logistic regression model", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 176, "start_word": 56320, "end_word": 56720, "chunk_words": 400}}, "ISLP_website::c000177": {"text": "default using student status. Student status is encoded as a dummy variable, with a value of 1for a student and a value of 0 for a non-student, and represented by the variable student[Yes] in the table. for an individual with a balanceof$1,000is ˆp(X)=eˆβ0+ˆβ1X 1+eˆβ0+ˆβ1X=e−10.6513+0.0055×1,000 1+e−10.6513+0.0055×1,000=0.00576, which is below 1%. In contrast, the predicted probability of default for an individual with a balance of $2,000is much higher, and equals 0.586or 58.6%. One can use qualitative predictors with the logistic regression model us- ing the dummy variable approach from Section 3.3.1. As an example, the Defaultdata set contains the qualitative variable student. To fit a model that uses student status as a predictor variable, we simply create a dummy variable that takes on a value of 1for students and 0for non-students. The logistic regression model that results from predicting probability of default from student status can be seen in Table 4.2. The coefficient associated with the dummy variable is positive, and the associated p-value is statisti- cally significant. This indicates that students tend to have higher default probabilities than non-students: /hatwiderPr(default=Yes|student=Yes)=e−3.5041+0.4049×1 1+e−3.5041+0.4049×1=0.0431, /hatwiderPr(default=Yes|student=No)=e−3.5041+0.4049×0 1+e−3.5041+0.4049×0=0.0292. 4.3.4 Multiple Logistic Regression Wenowconsidertheproblemofpredictingabinaryresponseusingmultiple predictors. By analogy with the extension from simple to multiple linear regression in Chapter 3, we can generalize ( 4.4) as follows: log/parenleftbiggp(X) 1−p(X)/parenrightbigg =β0+β1X1+···+βpXp, (4.6) whereX=(X1,...,X p)areppredictors. Equation 4.6can be rewritten as p(X)=eβ0+β1X1+···+βpXp 1+eβ0+β1X1+···+βpXp. (4.7) 4.3 Logistic Regression 143 Coefficient Std. error z-statistic p-value Intercept −10.8690 0.4923 −22.08<0.0001 balance 0.0057 0.0002 24.74 <0.0001 income 0.0030 0.0082 0.37 0.7115 student[Yes] −0.6468 0.2362 −2.74 0.0062 TABLE 4.3. FortheDefault data,estimatedcoefficientsofthelogisticregression model that predicts the probability of default usingbalance,income, and student status. Student status is encoded as a dummy variable student[Yes] , with a value of1for a student and a value of 0for a non-student. In fitting this model, income was measured in thousands of dollars. JustasinSection 4.3.2,weusethemaximumlikelihoodmethodtoestimate β0,β1,...,βp. Table4.3shows the coefficient estimates for a logistic regression model that uses balance,income(in thousands of dollars), and studentstatus to predict probability of default. There is a surprising result here. The p- values associated with balanceand the dummy variable for studentstatus are very small, indicating that each of these variables is associated with the probability of default. However, the coefficient for the dummy variable is negative, indicating that students are less likely to default than non- students. In contrast, the coefficient for the dummy variable is positive in Table4.2. How is it possible for student status to be associated", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 177, "start_word": 56640, "end_word": 57040, "chunk_words": 400}}, "ISLP_website::c000178": {"text": "to predict probability of default. There is a surprising result here. The p- values associated with balanceand the dummy variable for studentstatus are very small, indicating that each of these variables is associated with the probability of default. However, the coefficient for the dummy variable is negative, indicating that students are less likely to default than non- students. In contrast, the coefficient for the dummy variable is positive in Table4.2. How is it possible for student status to be associated with an increase in probability of default in Table 4.2and adecrease in probability of default in Table 4.3? The left-hand panel of Figure 4.3provides a graph- ical illustration of this apparent paradox. The orange and blue solid lines show the average default rates for students and non-students, respectively, as a function of credit card balance. The negative coefficient for studentin the multiple logistic regression indicates that for a fixed value of balance andincome, a student is less likely to default than a non-student. Indeed, we observe from the left-hand panel of Figure 4.3that the student default rate is at or below that of the non-student default rate for every value of balance. But the horizontal broken lines near the base of the plot, which show the default rates for students and non-students averaged over all val- ues ofbalanceandincome, suggest the opposite effect: the overall student defaultrateishigherthanthenon-studentdefaultrate.Consequently,there is a positive coefficient for studentin the single variable logistic regression output shown in Table 4.2. The right-hand panel of Figure 4.3provides an explanation for this dis- crepancy. The variables studentandbalanceare correlated. Students tend to hold higher levels of debt, which is in turn associated with higher prob- ability of default. In other words, students are more likely to have large credit card balances, which, as we know from the left-hand panel of Fig- ure4.3, tend to be associated with high default rates. Thus, even though an individual student with a given credit card balance will tend to have a lower probability of default than a non-student with the same credit card balance, the fact that students on the whole tend to have higher credit card balances means that overall, students tend to default at a higher rate than non-students. This is an important distinction for a credit card company that is trying to determine to whom they should offer credit. A student is riskier than a non-student if no information about the student’s", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 178, "start_word": 56960, "end_word": 57360, "chunk_words": 400}}, "ISLP_website::c000179": {"text": "balance will tend to have a lower probability of default than a non-student with the same credit card balance, the fact that students on the whole tend to have higher credit card balances means that overall, students tend to default at a higher rate than non-students. This is an important distinction for a credit card company that is trying to determine to whom they should offer credit. A student is riskier than a non-student if no information about the student’s credit card 144 4. Classification 500 1000 1500 20000.0 0.2 0.4 0.6 0.8Credit Card BalanceDefault RateNoYes0 500 1000 1500 2000 2500Student StatusCredit Card BalanceFIGURE 4.3. Confounding in the Default data.Left:Default rates are shown for students (orange) and non-students (blue). The solid lines display default rate as a function of balance, while the horizontal broken lines display the overall default rates. Right:Boxplots of balance for students (orange) and non-students (blue) are shown. balance is available. However, that student is less risky than a non-student with the same credit card balance ! This simple example illustrates the dangers and subtleties associated with performing regressions involving only a single predictor when other predictors may also be relevant. As in the linear regression setting, the results obtained using one predictor may be quite different from those ob- tained using multiple predictors, especially when there is correlation among the predictors. In general, the phenomenon seen in Figure 4.3is known as confounding .confoundingBy substituting estimates for the regression coefficients from Table 4.3 into (4.7), we can make predictions. For example, a student with a credit card balance of $1,500and an income of $40,000has an estimated proba- bility of default of ˆp(X)=e−10.869+0 .00574 ×1,500+0 .003×40−0.6468 ×1 1+e−10.869+0 .00574 ×1,500+0 .003×40−0.6468 ×1=0.058. (4.8) A non-student with the same balance and income has an estimated prob- ability of default of ˆp(X)=e−10.869+0 .00574 ×1,500+0 .003×40−0.6468 ×0 1+e−10.869+0 .00574 ×1,500+0 .003×40−0.6468 ×0=0.105. (4.9) (Here we multiply the incomecoefficient estimate from Table 4.3by 40, rather than by 40,000, because in that table the model was fit with income measured in units of $1,000.) 4.3.5 Multinomial Logistic Regression We sometimes wish to classify a response variable that has more than two classes. For example, in Section 4.2we had three categories of medical con- dition in the emergency room: stroke,drug overdose ,epileptic seizure . However, the logistic regression approach that we have seen in this section only allows for K=2classes for the response variable.", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 179, "start_word": 57280, "end_word": 57680, "chunk_words": 400}}, "ISLP_website::c000180": {"text": "4.3by 40, rather than by 40,000, because in that table the model was fit with income measured in units of $1,000.) 4.3.5 Multinomial Logistic Regression We sometimes wish to classify a response variable that has more than two classes. For example, in Section 4.2we had three categories of medical con- dition in the emergency room: stroke,drug overdose ,epileptic seizure . However, the logistic regression approach that we have seen in this section only allows for K=2classes for the response variable. 4.3 Logistic Regression 145 It turns out that it is possible to extend the two-class logistic regression approach to the setting of K> 2classes. This extension is sometimes known as multinomial logistic regression . To do this, we first select a singlemultinomial logistic regressionclass to serve as the baseline; without loss of generality, we select the Kth class for this role. Then we replace the model ( 4.7) with the model Pr(Y=k|X=x)=eβk0+βk1x1+···+βkpxp 1+/summationtextK−1 l=1eβl0+βl1x1+···+βlpxp(4.10) fork=1,...,K −1, and Pr(Y=K|X=x)=1 1+/summationtextK−1 l=1eβl0+βl1x1+···+βlpxp. (4.11) It is not hard to show that for k=1,...,K −1, log/parenleftbiggPr(Y=k|X=x) Pr(Y=K|X=x)/parenrightbigg =βk0+βk1x1+···+βkpxp. (4.12) Noticethat( 4.12)isquitesimilarto( 4.6).Equation 4.12indicatesthatonce again, the log odds between any pair of classes is linear in the features. It turns out that in ( 4.10)–(4.12), the decision to treat the Kth class as thebaselineisunimportant.Forexample,whenclassifyingemergencyroom visits into stroke,drug overdose , andepileptic seizure , suppose that we fit two multinomial logistic regression models: one treating strokeas the baseline, another treating drug overdose as the baseline. The coefficient estimates will differ between the two fitted models due to the differing choice of baseline, but the fitted values (predictions), the log odds between any pair of classes, and the other key model outputs will remain the same. Nonetheless, interpretation of the coefficients in a multinomial logistic regression model must be done with care, since it is tied to the choice of baseline. For example, if we set epileptic seizure to be the baseline, then we can interpret βstroke 0as the log odds of strokeversusepileptic seizure, given that x1=···=xp=0. Furthermore, a one-unit increase inXjis associated with a βstroke jincrease in the log odds of strokeover epileptic seizure . Stated another way, if Xjincreases by one unit, then Pr(Y=stroke|X=x) Pr(Y=epileptic seizure |X=x) increases by eβstroke j. We now briefly present an alternative coding for multinomial logistic regression, known as the softmaxcoding. The softmax coding is equivalentsoftmaxto the coding just described in the sense that the fitted values, log odds between any", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 180, "start_word": 57600, "end_word": 58000, "chunk_words": 400}}, "ISLP_website::c000181": {"text": "the log odds of strokeversusepileptic seizure, given that x1=···=xp=0. Furthermore, a one-unit increase inXjis associated with a βstroke jincrease in the log odds of strokeover epileptic seizure . Stated another way, if Xjincreases by one unit, then Pr(Y=stroke|X=x) Pr(Y=epileptic seizure |X=x) increases by eβstroke j. We now briefly present an alternative coding for multinomial logistic regression, known as the softmaxcoding. The softmax coding is equivalentsoftmaxto the coding just described in the sense that the fitted values, log odds between any pair of classes, and other key model outputs will remain the same, regardless of coding. But the softmax coding is used extensively in some areas of the machine learning literature (and will appear again in Chapter 10), so it is worth being aware of it. In the softmax coding, rather than selecting a baseline class, we treat all Kclasses symmetrically, and assume that for k=1,...,K , Pr(Y=k|X=x)=eβk0+βk1x1+···+βkpxp /summationtextK l=1eβl0+βl1x1+···+βlpxp. (4.13) 146 4. Classification Thus, rather than estimating coefficients for K−1classes, we actually estimate coefficients for all Kclasses. It is not hard to see that as a result of (4.13), the log odds ratio between the kth andk/primeth classes equals log/parenleftbiggPr(Y=k|X=x) Pr(Y=k/prime|X=x)/parenrightbigg =(βk0−βk/prime0)+(βk1−βk/prime1)x1+···+(βkp−βk/primep)xp. (4.14) 4.4 Generative Models for Classification Logistic regression involves directly modeling Pr(Y=k|X=x)using the logistic function, given by ( 4.7) for the case of two response classes. In statistical jargon, we model the conditional distribution of the response Y, given the predictor(s) X. We now consider an alternative and less direct approach to estimating these probabilities. In this new approach, we model the distribution of the predictors Xseparately in each of the response classes (i.e. for each value of Y). We then use Bayes’ theorem to flip these around into estimates for Pr(Y=k|X=x). When the distribution of X within each class is assumed to be normal, it turns out that the model is very similar in form to logistic regression. Why do we need another method, when we have logistic regression? There are several reasons: • When there is substantial separation between the two classes, the parameter estimates for the logistic regression model are surprisingly unstable. The methods that we consider in this section do not suffer from this problem. • If the distribution of the predictors Xis approximately normal in each of the classes and the sample size is small, then the approaches in this section may be more accurate than logistic regression. • The methods in this", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 181, "start_word": 57920, "end_word": 58320, "chunk_words": 400}}, "ISLP_website::c000182": {"text": "logistic regression? There are several reasons: • When there is substantial separation between the two classes, the parameter estimates for the logistic regression model are surprisingly unstable. The methods that we consider in this section do not suffer from this problem. • If the distribution of the predictors Xis approximately normal in each of the classes and the sample size is small, then the approaches in this section may be more accurate than logistic regression. • The methods in this section can be naturally extended to the case of more than two response classes. (In the case of more than two response classes, we can also use multinomial logistic regression from Section4.3.5.) Suppose that we wish to classify an observation into one of Kclasses, whereK≥2. In other words, the qualitative response variable Ycan take onKpossible distinct and unordered values. Let πkrepresent the overall orpriorprobability that a randomly chosen observation comes from thepriorkth class. Let fk(X)≡Pr(X|Y=k)1denote the density function ofXdensity functionfor an observation that comes from the kth class. In other words, fk(x)is relatively large if there is a high probability that an observation in the kth class has X≈x, andfk(x)is small if it is very unlikely that an observation in thekth class has X≈x. ThenBayes’ theorem states thatBayes’ theorem 1Technically, this definition is only correct if Xis a qualitative random variable. If Xis quantitative, then fk(x)dxcorresponds to the probability of Xfalling in a small regiondxaroundx. 4.4 Generative Models for Classification 147 Pr(Y=k|X=x)=πkfk(x)/summationtextK l=1πlfl(x). (4.15) Inaccordancewithourearliernotation,wewillusetheabbreviation pk(x)= Pr(Y=k|X=x); this is the posterior probability that an observationposteriorX=xbelongs to the kth class. That is, it is the probability that the observation belongs to the kth class, giventhe predictor value for that observation. Equation 4.15suggests that instead of directly computing the posterior probability pk(x)as in Section 4.3.1, we can simply plug in estimates of πk andfk(x)into (4.15). In general, estimating πkis easy if we have a random sample from the population: we simply compute the fraction of the training observations that belong to the kth class. However, estimating the density function fk(x)is much more challenging. As we will see, to estimate fk(x), we will typically have to make some simplifying assumptions. We know from Chapter 2that the Bayes classifier, which classifies an observation xto the class for which pk(x)is largest, has the lowest possible error rate out of all classifiers. (Of course, this is only true if all of the terms in ( 4.15)", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 182, "start_word": 58240, "end_word": 58640, "chunk_words": 400}}, "ISLP_website::c000183": {"text": "the fraction of the training observations that belong to the kth class. However, estimating the density function fk(x)is much more challenging. As we will see, to estimate fk(x), we will typically have to make some simplifying assumptions. We know from Chapter 2that the Bayes classifier, which classifies an observation xto the class for which pk(x)is largest, has the lowest possible error rate out of all classifiers. (Of course, this is only true if all of the terms in ( 4.15) are correctly specified.) Therefore, if we can find a way to estimate fk(x), then we can plug it into ( 4.15) in order to approximate the Bayes classifier. In the following sections, we discuss three classifiers that use different estimates of fk(x)in (4.15) to approximate the Bayes classifier: linear dis- criminant analysis, quadratic discriminant analysis, andnaive Bayes . 4.4.1 Linear Discriminant Analysis for p=1 For now, assume that p=1—that is, we have only one predictor. We would like to obtain an estimate for fk(x)that we can plug into ( 4.15) in order to estimate pk(x). We will then classify an observation to the class for which pk(x)is greatest. To estimate fk(x), we will first make some assumptions about its form. In particular, we assume that fk(x)isnormalorGaussian . In the one-normal Gaussiandimensional setting, the normal density takes the form fk(x)=1√ 2πσkexp/parenleftbigg −1 2σ2 k(x−µk)2/parenrightbigg , (4.16) whereµkandσ2 kare the mean and variance parameters for the kth class. For now, let us further assume that σ2 1=···=σ2 K: that is, there is a shared variance term across all Kclasses, which for simplicity we can denote by σ2. Plugging ( 4.16) into (4.15), we find that pk(x)=πk1√ 2πσexp/parenleftbig −1 2σ2(x−µk)2/parenrightbig /summationtextK l=1πl1√ 2πσexp/parenleftbig −1 2σ2(x−µl)2/parenrightbig. (4.17) (Note that in ( 4.17),πkdenotes the prior probability that an observation belongs to the kth class, not to be confused with π≈3.14159 , the math- ematical constant.) The Bayes classifier2involves assigning an observation 2Recall that the Bayes classifier assigns an observation to the class for which pk(x) is largest. This is different from Bayes’ theorem in (4.15), which allows us to manipulate conditional distributions. 148 4. Classification −4 −2 0 2 4−3 −2 −1 0 1 2 3 4012345FIGURE 4.4. Left:Two one-dimensional normal density functions are shown. The dashed vertical line represents the Bayes decision boundary. Right:20 obser- vations were drawn from each of the two classes, and are shown as histograms. The Bayes decision boundary is", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 183, "start_word": 58560, "end_word": 58960, "chunk_words": 400}}, "ISLP_website::c000184": {"text": "classifier assigns an observation to the class for which pk(x) is largest. This is different from Bayes’ theorem in (4.15), which allows us to manipulate conditional distributions. 148 4. Classification −4 −2 0 2 4−3 −2 −1 0 1 2 3 4012345FIGURE 4.4. Left:Two one-dimensional normal density functions are shown. The dashed vertical line represents the Bayes decision boundary. Right:20 obser- vations were drawn from each of the two classes, and are shown as histograms. The Bayes decision boundary is again shown as a dashed vertical line. The solid vertical line represents the LDA decision boundary estimated from the training data. X=xto the class for which ( 4.17) is largest. Taking the logof (4.17) and rearranging the terms, it is not hard to show3that this is equivalent to assigning the observation to the class for which δk(x)=x·µk σ2−µ2 k 2σ2+ log( πk) (4.18) is largest. For instance, if K=2 andπ1=π2, then the Bayes classifier assigns an observation to class 1if2x(µ1−µ2)>µ2 1−µ2 2, and to class 2 otherwise. The Bayes decision boundary is the point for which δ1(x)= δ2(x); one can show that this amounts to x=µ2 1−µ2 2 2(µ1−µ2)=µ1+µ2 2. (4.19) Anexampleisshownintheleft-handpanelofFigure 4.4.Thetwonormal density functions that are displayed, f1(x)andf2(x), represent two distinct classes. The mean and variance parameters for the two density functions areµ1=−1.25,µ2=1.25, andσ2 1=σ2 2=1. The two densities overlap, and so given that X=x, there is some uncertainty about the class to which the observation belongs. If we assume that an observation is equally likely to come from either class—that is, π1=π2=0.5—then by inspection of (4.19), we see that the Bayes classifier assigns the observation to class 1 ifx< 0and class 2 otherwise. Note that in this case, we can compute the Bayes classifier because we know that Xis drawn from a Gaussian distribution within each class, and we know all of the parameters involved. In a real-life situation, we are not able to calculate the Bayes classifier. In practice, even if we are quite certain of our assumption that Xis drawn from a Gaussian distribution within each class, to apply the Bayes classifier we still have to estimate the parameters µ1,...,µ K,π1,...,πK, andσ2. Thelinear discriminant analysis (LDA) method approximates thelinear discriminant analysisBayes classifier by plugging estimates for πk,µk, andσ2into (4.18). In 3See Exercise 2 at the end of this chapter. 4.4 Generative Models for Classification 149 particular, the following estimates are used: ˆµk=1 nk/summationdisplay i:yi=kxi ˆσ2=1 n−KK/summationdisplay", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 184, "start_word": 58880, "end_word": 59280, "chunk_words": 400}}, "ISLP_website::c000185": {"text": "In practice, even if we are quite certain of our assumption that Xis drawn from a Gaussian distribution within each class, to apply the Bayes classifier we still have to estimate the parameters µ1,...,µ K,π1,...,πK, andσ2. Thelinear discriminant analysis (LDA) method approximates thelinear discriminant analysisBayes classifier by plugging estimates for πk,µk, andσ2into (4.18). In 3See Exercise 2 at the end of this chapter. 4.4 Generative Models for Classification 149 particular, the following estimates are used: ˆµk=1 nk/summationdisplay i:yi=kxi ˆσ2=1 n−KK/summationdisplay k=1/summationdisplay i:yi=k(xi−ˆµk)2(4.20) wherenis the total number of training observations, and nkis the number of training observations in the kth class. The estimate for µkis simply the average of all the training observations from the kth class, while ˆσ2can be seen as a weighted average of the sample variances for each of the K classes. Sometimes we have knowledge of the class membership probabili- tiesπ1,...,πK, which can be used directly. In the absence of any additional information, LDA estimates πkusing the proportion of the training obser- vations that belong to the kth class. In other words, ˆπk=nk/n. (4.21) TheLDAclassifierplugstheestimatesgivenin( 4.20)and(4.21)into(4.18), and assigns an observation X=xto the class for which ˆδk(x)=x·ˆµk ˆσ2−ˆµ2 k 2ˆσ2+ log(ˆ πk) (4.22) is largest. The word linearin the classifier’s name stems from the fact that the discriminant functions ˆδk(x)in (4.22) are linear functions of x(asdiscriminant functionopposed to a more complex function of x). The right-hand panel of Figure 4.4displays a histogram of a random sample of 20observations from each class. To implement LDA, we began byestimating πk,µk,andσ2using(4.20)and(4.21).Wethencomputedthe decision boundary, shown as a black solid line, that results from assigning an observation to the class for which ( 4.22) is largest. All points to the left of this line will be assigned to the green class, while points to the right of this line are assigned to the purple class. In this case, since n1=n2= 20 , we have ˆπ1=ˆπ2. As a result, the decision boundary corresponds to the midpoint between the sample means for the two classes, (ˆµ1+ˆµ2)/2. The figure indicates that the LDA decision boundary is slightly to the left of the optimal Bayes decision boundary, which instead equals (µ1+µ2)/2= 0. How well does the LDA classifier perform on this data? Since this is simulateddata,wecangeneratealargenumberoftestobservationsinorder to compute the Bayes error rate and the LDA test error rate. These are 10.6% and11.1%, respectively. In other words, the LDA classifier’s error rate is only 0.5% above the smallest", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 185, "start_word": 59200, "end_word": 59600, "chunk_words": 400}}, "ISLP_website::c000186": {"text": "the midpoint between the sample means for the two classes, (ˆµ1+ˆµ2)/2. The figure indicates that the LDA decision boundary is slightly to the left of the optimal Bayes decision boundary, which instead equals (µ1+µ2)/2= 0. How well does the LDA classifier perform on this data? Since this is simulateddata,wecangeneratealargenumberoftestobservationsinorder to compute the Bayes error rate and the LDA test error rate. These are 10.6% and11.1%, respectively. In other words, the LDA classifier’s error rate is only 0.5% above the smallest possible error rate! This indicates that LDA is performing pretty well on this data set. To reiterate, the LDA classifier results from assuming that the obser- vations within each class come from a normal distribution with a class- specific mean and a common variance σ2, and plugging estimates for these parameters into the Bayes classifier. In Section 4.4.3, we will consider a less stringent set of assumptions, by allowing the observations in the kth class to have a class-specific variance, σ2 k. 150 4. Classification x1x1x2x2FIGURE 4.5. Two multivariate Gaussian density functions are shown, with p=2.Left:The two predictors are uncorrelated. Right:The two variables have a correlation of 0.7. 4.4.2 Linear Discriminant Analysis for p>1 We now extend the LDA classifier to the case of multiple predictors. To do this, we will assume that X=(X1,X2,...,X p)is drawn from a multi- variate Gaussian (or multivariate normal) distribution, with a class-specificmultivariate Gaussianmeanvectorandacommoncovariancematrix.Webeginwithabriefreview of this distribution. ThemultivariateGaussiandistributionassumesthateachindividualpre- dictorfollowsaone-dimensionalnormaldistribution,asin( 4.16),withsome correlation between each pair of predictors. Two examples of multivariate Gaussian distributions with p=2 are shown in Figure 4.5. The height of the surface at any particular point represents the probability that both X1 andX2fall in a small region around that point. In either panel, if the sur- faceiscutalongthe X1axisoralongthe X2axis,theresultingcross-section will have the shape of a one-dimensional normal distribution. The left-hand panel of Figure 4.5illustrates an example in which Var (X1)=Var(X2)and Cor(X1,X2)=0 ; this surface has a characteristic bell shape . However, the bell shape will be distorted if the predictors are correlated or have unequal variances, as is illustrated in the right-hand panel of Figure 4.5. In this situation, the base of the bell will have an elliptical, rather than circular, shape. To indicate that a p-dimensional random variable Xhas a multi- variate Gaussian distribution, we write X∼N(µ,Σ). HereE(X)=µis the mean of X(a vector with pcomponents), and Cov (X)= Σis the p×pcovariance matrix of X. Formally, the multivariate Gaussian density is defined as", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 186, "start_word": 59520, "end_word": 59920, "chunk_words": 400}}, "ISLP_website::c000187": {"text": "shape will be distorted if the predictors are correlated or have unequal variances, as is illustrated in the right-hand panel of Figure 4.5. In this situation, the base of the bell will have an elliptical, rather than circular, shape. To indicate that a p-dimensional random variable Xhas a multi- variate Gaussian distribution, we write X∼N(µ,Σ). HereE(X)=µis the mean of X(a vector with pcomponents), and Cov (X)= Σis the p×pcovariance matrix of X. Formally, the multivariate Gaussian density is defined as f(x)=1 (2π)p/2|Σ|1/2exp/parenleftbigg −1 2(x−µ)TΣ−1(x−µ)/parenrightbigg . (4.23) In the case of p> 1predictors, the LDA classifier assumes that the observations in the kth class are drawn from a multivariate Gaussian dis- tribution N(µk,Σ), whereµkis a class-specific mean vector, and Σis a covariance matrix that is common to all Kclasses. Plugging the density function for the kth class, fk(X=x), into (4.15) and performing a little bit of algebra reveals that the Bayes classifier assigns an observation X=x 4.4 Generative Models for Classification 151 −4 −2 0 2 4−4 −2 0 2 4−4 −2 0 2 4−4 −2 0 2 4X1X1 X2X2 FIGURE 4.6. An example with three classes. The observations from each class are drawn from a multivariate Gaussian distribution with p=2, with a class-spe- cific mean vector and a common covariance matrix. Left:Ellipses that contain 95% of the probability for each of the three classes are shown. The dashed lines are the Bayes decision boundaries. Right:20observations were generated from each class, and the corresponding LDA decision boundaries are indicated using solid black lines. The Bayes decision boundaries are once again shown as dashed lines. to the class for which δk(x)=xTΣ−1µk−1 2µT kΣ−1µk+ log πk (4.24) is largest. This is the vector/matrix version of ( 4.18). An example is shown in the left-hand panel of Figure 4.6. Three equally- sized Gaussian classes are shown with class-specific mean vectors and a common covariance matrix. The three ellipses represent regions that con- tain95% of the probability for each of the three classes. The dashed lines are the Bayes decision boundaries. In other words, they represent the set of values xfor which δk(x)=δ/lscript(x); i.e. xTΣ−1µk−1 2µT kΣ−1µk=xTΣ−1µl−1 2µT lΣ−1µl (4.25) fork/negationslash=l. (Thelogπkterm from ( 4.24) has disappeared because each of the three classes has the same number of training observations; i.e. πkis the same for each class.) Note that there are three lines representing the Bayes decision boundaries because there are three pairs of classes", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 187, "start_word": 59840, "end_word": 60240, "chunk_words": 400}}, "ISLP_website::c000188": {"text": "the probability for each of the three classes. The dashed lines are the Bayes decision boundaries. In other words, they represent the set of values xfor which δk(x)=δ/lscript(x); i.e. xTΣ−1µk−1 2µT kΣ−1µk=xTΣ−1µl−1 2µT lΣ−1µl (4.25) fork/negationslash=l. (Thelogπkterm from ( 4.24) has disappeared because each of the three classes has the same number of training observations; i.e. πkis the same for each class.) Note that there are three lines representing the Bayes decision boundaries because there are three pairs of classes among the three classes. That is, one Bayes decision boundary separates class 1 from class 2, one separates class 1 from class 3, and one separates class 2 from class 3. These three Bayes decision boundaries divide the predictor space into three regions. The Bayes classifier will classify an observation according to the region in which it is located. Once again, we need to estimate the unknown parameters µ1,...,µ K, π1,...,πK, andΣ; the formulas are similar to those used in the one- dimensional case, given in ( 4.20). To assign a new observation X=x, LDA plugs these estimates into ( 4.24) to obtain quantities ˆδk(x), and clas- sifies to the class for which ˆδk(x)is largest. Note that in ( 4.24)δk(x)is a linear function of x; that is, the LDA decision rule depends on xonly 152 4. Classification True default status No Yes Total Predicted No9644 252 9896 default status Yes23 81 104 Total9667 333 10000 TABLE 4.4. A confusion matrix compares the LDA predictions to the true default statuses for the 10,000training observations in the Default data set. Elementsonthediagonalofthematrixrepresentindividualswhosedefaultstatuses were correctly predicted, while off-diagonal elements represent individuals that were misclassified. LDA made incorrect predictions for 23individuals who did not default and for 252individuals who did default. through a linear combination of its elements. As previously discussed, this is the reason for the word linearin LDA. In the right-hand panel of Figure 4.6,20observations drawn from each of the three classes are displayed, and the resulting LDA decision boundaries are shown as solid black lines. Overall, the LDA decision boundaries are pretty close to the Bayes decision boundaries, shown again as dashed lines. ThetesterrorratesfortheBayesandLDAclassifiersare 0.0746and0.0770, respectively. This indicates that LDA is performing well on this data. We can perform LDA on the Defaultdata in order to predict whether or not an individual will default on the basis of credit card balance and student status.4The LDA model fit to the 10,000training samples results", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 188, "start_word": 60160, "end_word": 60560, "chunk_words": 400}}, "ISLP_website::c000189": {"text": "displayed, and the resulting LDA decision boundaries are shown as solid black lines. Overall, the LDA decision boundaries are pretty close to the Bayes decision boundaries, shown again as dashed lines. ThetesterrorratesfortheBayesandLDAclassifiersare 0.0746and0.0770, respectively. This indicates that LDA is performing well on this data. We can perform LDA on the Defaultdata in order to predict whether or not an individual will default on the basis of credit card balance and student status.4The LDA model fit to the 10,000training samples results in atrainingerror rate of 2.75%. This sounds like a low error rate, but two caveats must be noted. • First of all, training error rates will usually be lower than test error rates, which are the real quantity of interest. In other words, we might expect this classifier to perform worse if we use it to predict whether or not a new set of individuals will default. The reason is that we specifically adjust the parameters of our model to do well on the training data. The higher the ratio of parameters pto number of samples n, the more we expect this overfitting to play a role. Foroverfittingthese data we don’t expect this to be a problem, since p=2and n= 10,000. • Second, since only 3.33% of the individuals in the training sample defaulted, a simple but useless classifier that always predicts that an individual will not default, regardless of his or her credit card balance and student status, will result in an error rate of 3.33%. In other words, the trivial nullclassifier will achieve an error rate thatnullis only a bit higher than the LDA training set error rate. In practice, a binary classifier such as this one can make two types of errors: it can incorrectly assign an individual who defaults to the no default category, or it can incorrectly assign an individual who does not default to 4The careful reader will notice that student status is qualitative — thus, the normality assumption made by LDA is clearly violated in this example! However, LDA is often remarkably robust to model violations, as this example shows. Naive Bayes, discussed in Section4.4.4, provides an alternative to LDA that does not assume normally distributed predictors. 4.4 Generative Models for Classification 153 thedefaultcategory. It is often of interest to determine which of these two types of errors are being made. A confusion matrix , shown for the Defaultconfusion matrixdata in Table 4.4,", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 189, "start_word": 60480, "end_word": 60880, "chunk_words": 400}}, "ISLP_website::c000190": {"text": "— thus, the normality assumption made by LDA is clearly violated in this example! However, LDA is often remarkably robust to model violations, as this example shows. Naive Bayes, discussed in Section4.4.4, provides an alternative to LDA that does not assume normally distributed predictors. 4.4 Generative Models for Classification 153 thedefaultcategory. It is often of interest to determine which of these two types of errors are being made. A confusion matrix , shown for the Defaultconfusion matrixdata in Table 4.4, is a convenient way to display this information. The table reveals that LDA predicted that a total of 104people would default. Of these people, 81actually defaulted and 23did not. Hence only 23out of9,667of the individuals who did not default were incorrectly labeled. This looks like a pretty low error rate! However, of the 333individuals who defaulted, 252(or75.7%) were missed by LDA. So while the overall error rate is low, the error rate among individuals who defaulted is very high. From the perspective of a credit card company that is trying to identify high-risk individuals, an error rate of 252/333 = 75 .7% among individuals who default may well be unacceptable. Class-specific performance is also important in medicine and biology, where the terms sensitivity andspecificity characterize the performance ofsensitivity specificitya classifier or screening test. In this case the sensitivity is the percent- age of true defaulters that are identified; it equals 24.3%. The specificity is the percentage of non-defaulters that are correctly identified; it equals (1−23/9667) = 99 .8%. Why does LDA do such a poor job of classifying the customers who de- fault? In other words, why does it have such low sensitivity? As we have seen, LDA is trying to approximate the Bayes classifier, which has the low- esttotalerror rate out of all classifiers. That is, the Bayes classifier will yield the smallest possible total number of misclassified observations, re- gardlessoftheclassfromwhichtheerrorsstem.Somemisclassificationswill result from incorrectly assigning a customer who does not default to the default class, and others will result from incorrectly assigning a customer who defaults to the non-default class. In contrast, a credit card company might particularly wish to avoid incorrectly classifying an individual who will default, whereas incorrectly classifying an individual who will not de- fault, though still to be avoided, is less problematic. We will now see that it is possible to modify LDA in order to develop a classifier that better meets the credit card", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 190, "start_word": 60800, "end_word": 61200, "chunk_words": 400}}, "ISLP_website::c000191": {"text": "not default to the default class, and others will result from incorrectly assigning a customer who defaults to the non-default class. In contrast, a credit card company might particularly wish to avoid incorrectly classifying an individual who will default, whereas incorrectly classifying an individual who will not de- fault, though still to be avoided, is less problematic. We will now see that it is possible to modify LDA in order to develop a classifier that better meets the credit card company’s needs. The Bayes classifier works by assigning an observation to the class for which the posterior probability pk(X)is greatest. In the two-class case, this amounts to assigning an observation to the defaultclass if Pr(default =Yes|X=x)>0.5. (4.26) Thus, the Bayes classifier, and by extension LDA, uses a threshold of 50% for the posterior probability of default in order to assign an observation to thedefaultclass. However, if we are concerned about incorrectly pre- dicting the default status for individuals who default, then we can consider lowering this threshold. For instance, we might label any customer with a posterior probability of default above 20% to the defaultclass. In other words, instead of assigning an observation to the defaultclass if ( 4.26) holds, we could instead assign an observation to this class if Pr(default =Yes|X=x)>0.2. (4.27) TheerrorratesthatresultfromtakingthisapproachareshowninTable 4.5. Now LDA predicts that 430individuals will default. Of the 333individuals who default, LDA correctly predicts all but 138, or41.4%. This is a vast 154 4. Classification True default status No Yes Total Predicted No9432 138 9570 default status Yes235 195 430 Total9667 333 10000 TABLE 4.5. A confusion matrix compares the LDA predictions to the true default statuses for the 10,000training observations in the Default data set, using a modified threshold value that predicts default for any individuals whose posterior default probability exceeds 20%. 0.00.10.20.30.40.50.0 0.2 0.4 0.6ThresholdError RateFIGURE 4.7.For theDefaultdata set, error rates are shown as a function ofthe threshold value for the posterior probability that is used to perform the assign-ment. The black solid line displays the overall error rate. The blue dashed linerepresents the fraction of defaulting customers that are incorrectly classified, andthe orange dotted line indicates the fraction of errors among the non-defaultingcustomers.improvement over the error rate of75.7% that resulted from using thethreshold of50%. However, this improvement comes at a cost: now235individuals who do not default are incorrectly classified. As a result, theoverallerrorratehasincreasedslightlyto3.73%.Butacreditcardcompanymayconsiderthis slightincreasein thetotalerror ratetobe asmallprice topay for more accurate", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 191, "start_word": 61120, "end_word": 61520, "chunk_words": 400}}, "ISLP_website::c000192": {"text": "probability that is used to perform the assign-ment. The black solid line displays the overall error rate. The blue dashed linerepresents the fraction of defaulting customers that are incorrectly classified, andthe orange dotted line indicates the fraction of errors among the non-defaultingcustomers.improvement over the error rate of75.7% that resulted from using thethreshold of50%. However, this improvement comes at a cost: now235individuals who do not default are incorrectly classified. As a result, theoverallerrorratehasincreasedslightlyto3.73%.Butacreditcardcompanymayconsiderthis slightincreasein thetotalerror ratetobe asmallprice topay for more accurate identification of individuals who do indeed default.Figure4.7illustratesthetrade-offthatresultsfrommodifyingthethresh-old value for the posterior probability of default. Various error rates areshown as a function of the threshold value. Using a threshold of0.5, as in(4.26), minimizes the overall error rate, shown as a black solid line. Thisis to be expected, since the Bayes classifier uses a threshold of0.5and isknown to have the lowest overall error rate. But when a threshold of0.5isused, the error rate among the individuals who default is quite high (bluedashed line). As the threshold is reduced, the error rate among individualswho default decreases steadily, but the error rate among the individualswho do not default increases. How can we decide which threshold value isbest? Such a decision must be based ondomain knowledge, such as detailedinformation about the costs associated with default.TheROC curveis a popular graphic for simultaneously displaying theROC curvetwo types of errors for all possible thresholds. The name “ROC” is historic,and comes from communications theory. It is an acronym forreceiver op-erating characteristics. Figure4.8displays the ROC curve for the LDAclassifier on the training data. The overall performance of a classifier, sum- 4.4 Generative Models for Classification 155ROC Curve False positive rateTrue positive rate0.0 0.2 0.4 0.6 0.8 1.00.0 0.2 0.4 0.6 0.8 1.0FIGURE 4.8. A ROC curve for the LDA classifier on the Default data. It traces out two types of error as we vary the threshold value for the posterior probability of default. The actual thresholds are not shown. The true positive rate is the sensitivity: the fraction of defaulters that are correctly identified, using a given threshold value. The false positive rate is 1-specificity: the fraction of non-defaulters that we classify incorrectly as defaulters, using that same threshold value. The ideal ROC curve hugs the top left corner, indicating a high true positive rate and a low false positive rate. The dotted line represents the “no information” classifier; this is what we would expect if student status and credit card", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 192, "start_word": 61440, "end_word": 61840, "chunk_words": 400}}, "ISLP_website::c000193": {"text": "positive rate is the sensitivity: the fraction of defaulters that are correctly identified, using a given threshold value. The false positive rate is 1-specificity: the fraction of non-defaulters that we classify incorrectly as defaulters, using that same threshold value. The ideal ROC curve hugs the top left corner, indicating a high true positive rate and a low false positive rate. The dotted line represents the “no information” classifier; this is what we would expect if student status and credit card balance are not associated with probability of default. marized over all possible thresholds, is given by the area under the (ROC) curve(AUC). AnidealROCcurvewillhugthetopleftcorner,sothelargerarea under the (ROC) curvethe AUC the better the classifier. For this data the AUC is 0.95, which is close to the maximum of 1.0, so would be considered very good. We expect a classifier that performs no better than chance to have an AUC of 0.5 (when evaluated on an independent test set not used in model training). ROC curves are useful for comparing different classifiers, since they take into account all possible thresholds. It turns out that the ROC curve for the logistic regression model of Section 4.3.4fit to these data is virtually indistinguishable from this one for the LDA model, so we do not display it here. As we have seen above, varying the classifier threshold changes its true positive and false positive rate. These are also called the sensitivity and onesensitivityminus the specificity of our classifier. Since there is an almost bewilderingspecificityarray of terms used in this context, we now give a summary. Table 4.6 shows the possible results when applying a classifier (or diagnostic test) to a population. To make the connection with the epidemiology literature, we think of “+” as the “disease” that we are trying to detect, and “ −” as the “non-disease” state. To make the connection to the classical hypothesis testing literature, we think of “ −” as the null hypothesis and “+” as the 156 4. Classification True class −or Null +or Non-null Total Predicted −or Null True Neg. (TN) False Neg. (FN) N∗ class +or Non-null False Pos. (FP) True Pos. (TP) P∗ Total N P TABLE 4.6. Possible results when applying a classifier or diagnostic test to a population. Name Definition Synonyms False Pos. rate FP/NType I error, 1 −Specificity True Pos. rate TP/P1−Type II error, power, sensitivity, recall Pos. Pred. value TP/P∗Precision, 1 −false discovery", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 193, "start_word": 61760, "end_word": 62160, "chunk_words": 400}}, "ISLP_website::c000194": {"text": "null hypothesis and “+” as the 156 4. Classification True class −or Null +or Non-null Total Predicted −or Null True Neg. (TN) False Neg. (FN) N∗ class +or Non-null False Pos. (FP) True Pos. (TP) P∗ Total N P TABLE 4.6. Possible results when applying a classifier or diagnostic test to a population. Name Definition Synonyms False Pos. rate FP/NType I error, 1 −Specificity True Pos. rate TP/P1−Type II error, power, sensitivity, recall Pos. Pred. value TP/P∗Precision, 1 −false discovery proportion Neg. Pred. value TN/N∗ TABLE 4.7. Importantmeasuresforclassificationanddiagnostictesting,derived from quantities in Table 4.6. alternative (non-null) hypothesis. In the context of the Defaultdata, “+” indicates an individual who defaults, and “ −” indicates one who does not. Table4.7listsmanyofthepopularperformancemeasuresthatareusedin this context. The denominators for the false positive and true positive rates aretheactualpopulationcountsineachclass.Incontrast,thedenominators for the positive predictive value and the negative predictive value are the total predicted counts for each class. 4.4.3 Quadratic Discriminant Analysis As we have discussed, LDA assumes that the observations within each class are drawn from a multivariate Gaussian distribution with a class-specific mean vector and a covariance matrix that is common to all Kclasses. Quadratic discriminant analysis (QDA) provides an alternative approach.quadratic discriminant analysisLike LDA, the QDA classifier results from assuming that the observations from each class are drawn from a Gaussian distribution, and plugging es- timates for the parameters into Bayes’ theorem in order to perform pre- diction. However, unlike LDA, QDA assumes that each class has its own covariance matrix. That is, it assumes that an observation from the kth class is of the form X∼N(µk,Σk), whereΣkis a covariance matrix for thekth class. Under this assumption, the Bayes classifier assigns an obser- vationX=xto the class for which δk(x)=−1 2(x−µk)TΣ−1 k(x−µk)−1 2log|Σk|+ logπk =−1 2xTΣ−1 kx+xTΣ−1 kµk−1 2µT kΣ−1 kµk−1 2log|Σk|+ logπk (4.28) is largest. So the QDA classifier involves plugging estimates for Σk,µk, andπkinto (4.28), and then assigning an observation X=xto the class for which this quantity is largest. Unlike in ( 4.24), the quantity xappears as aquadratic function in ( 4.28). This is where QDA gets its name. Why does it matter whether or not we assume that the Kclasses share a common covariance matrix? In other words, why would one prefer LDA to 4.4 Generative Models for Classification 157 −4 −2 0 2 4−4 −3 −2 −1 0 1 2−4 −2 0 2 4−4 −3 −2 −1 0 1 2X1X1 X2X2 FIGURE 4.9. Left:The", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 194, "start_word": 62080, "end_word": 62480, "chunk_words": 400}}, "ISLP_website::c000195": {"text": "quantity is largest. Unlike in ( 4.24), the quantity xappears as aquadratic function in ( 4.28). This is where QDA gets its name. Why does it matter whether or not we assume that the Kclasses share a common covariance matrix? In other words, why would one prefer LDA to 4.4 Generative Models for Classification 157 −4 −2 0 2 4−4 −3 −2 −1 0 1 2−4 −2 0 2 4−4 −3 −2 −1 0 1 2X1X1 X2X2 FIGURE 4.9. Left:The Bayes (purple dashed), LDA (black dotted), and QDA (green solid) decision boundaries for a two-class problem with Σ1=Σ2. The shading indicates the QDA decision rule. Since the Bayes decision boundary is linear, it is more accurately approximated by LDA than by QDA. Right:Details are as given in the left-hand panel, except that Σ1/negationslash=Σ2. Since the Bayes decision boundary is non-linear, it is more accurately approximated by QDA than by LDA. QDA, or vice-versa? The answer lies in the bias-variance trade-off. When there are ppredictors, then estimating a covariance matrix requires esti- matingp(p+1)/2parameters. QDA estimates a separate covariance matrix for each class, for a total of Kp(p+1)/2parameters. With 50 predictors this is some multiple of 1,275, which is a lot of parameters. By instead assum- ing that the Kclasses share a common covariance matrix, the LDA model becomes linear in x, which means there are Kplinear coefficients to esti- mate. Consequently, LDA is a much less flexible classifier than QDA, and so has substantially lower variance. This can potentially lead to improved prediction performance. But there is a trade-off: if LDA’s assumption that theKclasses share a common covariance matrix is badly off, then LDA can suffer from high bias. Roughly speaking, LDA tends to be a better bet than QDA if there are relatively few training observations and so reducing variance is crucial. In contrast, QDA is recommended if the training set is very large, so that the variance of the classifier is not a major concern, or if the assumption of a common covariance matrix for the Kclasses is clearly untenable. Figure4.9illustratestheperformancesofLDAandQDAintwoscenarios. In the left-hand panel, the two Gaussian classes have a common correla- tion of0.7between X1andX2. As a result, the Bayes decision boundary is linear and is accurately approximated by the LDA decision boundary. The QDA decision boundary is inferior, because it suffers from higher vari- ance without a corresponding decrease in bias. In contrast, the right-hand panel displays", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 195, "start_word": 62400, "end_word": 62800, "chunk_words": 400}}, "ISLP_website::c000196": {"text": "classifier is not a major concern, or if the assumption of a common covariance matrix for the Kclasses is clearly untenable. Figure4.9illustratestheperformancesofLDAandQDAintwoscenarios. In the left-hand panel, the two Gaussian classes have a common correla- tion of0.7between X1andX2. As a result, the Bayes decision boundary is linear and is accurately approximated by the LDA decision boundary. The QDA decision boundary is inferior, because it suffers from higher vari- ance without a corresponding decrease in bias. In contrast, the right-hand panel displays a situation in which the orange class has a correlation of 0.7 between the variables and the blue class has a correlation of −0.7. Now the Bayes decision boundary is quadratic, and so QDA more accurately approximates this boundary than does LDA. 158 4. Classification 4.4.4 Naive Bayes In previous sections, we used Bayes’ theorem ( 4.15) to develop the LDA and QDA classifiers. Here, we use Bayes’ theorem to motivate the popular naive Bayes classifier.naive BayesRecall that Bayes’ theorem ( 4.15) provides an expression for the pos- terior probability pk(x) = Pr( Y=k|X=x)in terms of π1,...,πKand f1(x),...,f K(x).Touse( 4.15)inpractice,weneedestimatesfor π1,...,πK andf1(x),...,f K(x). As we saw in previous sections, estimating the prior probabilities π1,...,πKis typically straightforward: for instance, we can estimate ˆπkas the proportion of training observations belonging to the kth class, for k=1,...,K . However, estimating f1(x),...,f K(x)is more subtle. Recall that fk(x) is thep-dimensional density function for an observation in the kth class, fork=1,...,K . In general, estimating a p-dimensional density function is challenging. In LDA, we make a very strong assumption that greatly sim- plifies the task: we assume that fkis the density function for a multivariate normal random variable with class-specific mean µk, and shared covariance matrixΣ. By contrast, in QDA, we assume that fkis the density function for a multivariate normal random variable with class-specific mean µk, and class-specific covariance matrix Σk. By making these very strong assump- tions, we are able to replace the very challenging problem of estimating K p-dimensional density functions with the much simpler problem of estimat- ingKp-dimensional mean vectors and one (in the case of LDA) or K(in the case of QDA) (p×p)-dimensional covariance matrices. The naive Bayes classifier takes a different tack for estimating f1(x),..., fK(x). Instead of assuming that these functions belong to a particular family of distributions (e.g. multivariate normal), we instead make a single assumption: Within the kth class, the ppredictors are independent. Stated mathematically, this", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 196, "start_word": 62720, "end_word": 63120, "chunk_words": 400}}, "ISLP_website::c000197": {"text": "very challenging problem of estimating K p-dimensional density functions with the much simpler problem of estimat- ingKp-dimensional mean vectors and one (in the case of LDA) or K(in the case of QDA) (p×p)-dimensional covariance matrices. The naive Bayes classifier takes a different tack for estimating f1(x),..., fK(x). Instead of assuming that these functions belong to a particular family of distributions (e.g. multivariate normal), we instead make a single assumption: Within the kth class, the ppredictors are independent. Stated mathematically, this assumption means that for k=1,...,K , fk(x)=fk1(x1)×fk2(x2)×···×fkp(xp), (4.29) wherefkjis the density function of the jth predictor among observations in thekth class. Why is this assumption so powerful? Essentially, estimating a p-dimen- sional density function is challenging because we must consider not only themarginal distribution of each predictor — that is, the distribution ofmarginal distributioneach predictor on its own — but also the joint distribution of the predictors joint distribution— that is, the association between the different predictors. In the case of a multivariate normal distribution, the association between the different predictors is summarized by the off-diagonal elements of the covariance matrix. However, in general, this association can be very hard to charac- terize, and exceedingly challenging to estimate. But by assuming that the pcovariates are independent within each class, we completely eliminate the need to worry about the association between the ppredictors, because we have simply assumed that there is noassociation between the predictors! Do we really believe the naive Bayes assumption that the pcovariates are independent within each class? In most settings, we do not. But even though this modeling assumption is made for convenience, it often leads to 4.4 Generative Models for Classification 159 prettydecentresults, especially in settings where nis not large enough rela- tive topfor us to effectively estimate the joint distribution of the predictors within each class. In fact, since estimating a joint distribution requires such a huge amount of data, naive Bayes is a good choice in a wide range of set- tings. Essentially, the naive Bayes assumption introduces some bias, but reduces variance, leading to a classifier that works quite well in practice as a result of the bias-variance trade-off. Once we have made the naive Bayes assumption, we can plug ( 4.29) into (4.15) to obtain an expression for the posterior probability, Pr(Y=k|X=x)=πk×fk1(x1)×fk2(x2)×···×fkp(xp)/summationtextK l=1πl×fl1(x1)×fl2(x2)×···×flp(xp)(4.30) fork=1,...,K . To estimate the one-dimensional density function fkjusing training data x1j,...,x nj, we have a few options. •", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 197, "start_word": 63040, "end_word": 63440, "chunk_words": 400}}, "ISLP_website::c000198": {"text": "choice in a wide range of set- tings. Essentially, the naive Bayes assumption introduces some bias, but reduces variance, leading to a classifier that works quite well in practice as a result of the bias-variance trade-off. Once we have made the naive Bayes assumption, we can plug ( 4.29) into (4.15) to obtain an expression for the posterior probability, Pr(Y=k|X=x)=πk×fk1(x1)×fk2(x2)×···×fkp(xp)/summationtextK l=1πl×fl1(x1)×fl2(x2)×···×flp(xp)(4.30) fork=1,...,K . To estimate the one-dimensional density function fkjusing training data x1j,...,x nj, we have a few options. • IfXjisquantitative,thenwecanassumethat Xj|Y=k∼N(µjk,σ2 jk). In other words, we assume that within each class, the jth predictor is drawn from a (univariate) normal distribution. While this may sound a bit like QDA, there is one key difference, in that here we are assum- ing that the predictors are independent; this amounts to QDA with an additional assumption that the class-specific covariance matrix is diagonal. • IfXjis quantitative, then another option is to use a non-parametric estimate for fkj. A very simple way to do this is by making a his- togram for the observations of the jth predictor within each class. Then we can estimate fkj(xj)as the fraction of the training obser- vations in the kth class that belong to the same histogram bin as xj. Alternatively, we can use a kernel density estimator , which iskernel density estimatoressentially a smoothed version of a histogram. • IfXjis qualitative, then we can simply count the proportion of train- ing observations for the jth predictor corresponding to each class. For instance, suppose that Xj∈{1,2,3}, and we have 100observations in thekth class. Suppose that the jth predictor takes on values of 1, 2, and3in 32, 55, and 13 of those observations, respectively. Then we can estimate fkjas ˆfkj(xj)=  0.32 ifxj=1 0.55 ifxj=2 0.13 ifxj=3. We now consider the naive Bayes classifier in a toy example with p=3 predictors and K=2 classes. The first two predictors are quantitative, and the third predictor is qualitative with three levels. Suppose further thatˆπ1=ˆπ2=0.5. The estimated density functions ˆfkjfork=1,2 andj=1,2,3are displayed in Figure 4.10. Now suppose that we wish to classify a new observation, x∗= (0 .4,1.5,1)T. It turns out that in this 160 4. Classification Density estimates for class k=1 ˆf11ˆf12ˆf13 −4 −2 0 2 4 Frequency−2 0 2 4123Density estimates for class k=2 ˆf21ˆf22ˆf23 −4 −2 0 2 4 Frequency−2 0 2 4123FIGURE 4.10. In the toy example in Section 4.4.4, we generate data with p=3 predictors", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 198, "start_word": 63360, "end_word": 63760, "chunk_words": 400}}, "ISLP_website::c000199": {"text": "three levels. Suppose further thatˆπ1=ˆπ2=0.5. The estimated density functions ˆfkjfork=1,2 andj=1,2,3are displayed in Figure 4.10. Now suppose that we wish to classify a new observation, x∗= (0 .4,1.5,1)T. It turns out that in this 160 4. Classification Density estimates for class k=1 ˆf11ˆf12ˆf13 −4 −2 0 2 4 Frequency−2 0 2 4123Density estimates for class k=2 ˆf21ˆf22ˆf23 −4 −2 0 2 4 Frequency−2 0 2 4123FIGURE 4.10. In the toy example in Section 4.4.4, we generate data with p=3 predictors and K=2classes. The first two predictors are quantitative, and the third predictor is qualitative with three levels. In each class, the estimated density for each of the three predictors is displayed. If the prior probabilities for the two classes are equal, then the observation x∗= (0.4,1.5,1)Thas a94.4%posterior probability of belonging to the first class. True default status No Yes Total Predicted No9621 244 9865 default status Yes46 89 135 Total9667 333 10000 TABLE 4.8. Comparison of the naive Bayes predictions to the true default status for the 10,000training observations in the Default data set, when we predict default for any observation for which P(Y=default|X=x)>0.5. example, ˆf11(0.4) = 0.368,ˆf12(1.5) = 0.484,ˆf13(1) = 0.226, andˆf21(0.4) = 0.030,ˆf22(1.5) = 0.130,ˆf23(1) = 0.616.Pluggingtheseestimatesinto( 4.30) results in posterior probability estimates of Pr(Y=1|X=x∗)=0.944and Pr(Y=2|X=x∗)=0.056. Table4.8providestheconfusionmatrixresultingfromapplyingthenaive Bayes classifier to the Defaultdata set, where we predict a default if the posterior probability of a default — that is, P(Y=default|X=x)— ex- ceeds0.5. Comparing this to the results for LDA in Table 4.4, our findings are mixed. While LDA has a slightly lower overall error rate, naive Bayes 4.5 A Comparison of Classification Methods 161 True default status No Yes Total Predicted No9339 130 9469 default status Yes328 203 531 Total9667 333 10000 TABLE 4.9. Comparison of the naive Bayes predictions to the true default status for the 10,000training observations in the Default data set, when we predict default for any observation for which P(Y=default|X=x)>0.2. correctly predicts a higher fraction of the true defaulters. In this implemen- tation of naive Bayes, we have assumed that each quantitative predictor is drawn from a Gaussian distribution (and, of course, that within each class, each predictor is independent). Just as with LDA, we can easily adjust the probability threshold for predicting a default. For example, Table 4.9provides the confusion matrix resulting from predicting a default if P(Y=default|X=x)>0.2. Again, the results are mixed relative to LDA with the same threshold (Table 4.5). NaiveBayeshasahighererrorrate,butcorrectlypredictsalmosttwo-thirds of", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 199, "start_word": 63680, "end_word": 64080, "chunk_words": 400}}, "ISLP_website::c000200": {"text": "of the true defaulters. In this implemen- tation of naive Bayes, we have assumed that each quantitative predictor is drawn from a Gaussian distribution (and, of course, that within each class, each predictor is independent). Just as with LDA, we can easily adjust the probability threshold for predicting a default. For example, Table 4.9provides the confusion matrix resulting from predicting a default if P(Y=default|X=x)>0.2. Again, the results are mixed relative to LDA with the same threshold (Table 4.5). NaiveBayeshasahighererrorrate,butcorrectlypredictsalmosttwo-thirds of the true defaults. In this example, it should not be too surprising that naive Bayes does not convincingly outperform LDA: this data set has n= 10,000andp=2, and so the reduction in variance resulting from the naive Bayes assumption is not necessarily worthwhile. We expect to see a greater pay-off to using naive Bayes relative to LDA or QDA in instances where pis larger or nis smaller, so that reducing the variance is very important. 4.5 A Comparison of Classification Methods 4.5.1 An Analytical Comparison Wenowperforman analytical (ormathematical)comparisonofLDA,QDA, naive Bayes, and logistic regression. We consider these approaches in a setting with Kclasses, so that we assign an observation to the class that maximizes Pr(Y=k|X=x). Equivalently, we can set Kas thebaseline class and assign an observation to the class that maximizes log/parenleftbiggPr(Y=k|X=x) Pr(Y=K|X=x)/parenrightbigg (4.31) fork=1,...,K. Examining the specific form of ( 4.31) for each method provides a clear understanding of their similarities and differences. First, for LDA, we can make use of Bayes’ theorem ( 4.15) as well as the assumption that the predictors within each class are drawn from a multivariate normal density ( 4.23) with class-specific mean and shared co- 162 4. Classification variance matrix in order to show that log/parenleftbiggPr(Y=k|X=x) Pr(Y=K|X=x)/parenrightbigg = log/parenleftbiggπkfk(x) πKfK(x)/parenrightbigg = log/parenleftBigg πkexp/parenleftbig −1 2(x−µk)TΣ−1(x−µk)/parenrightbig πKexp/parenleftbig −1 2(x−µK)TΣ−1(x−µK)/parenrightbig/parenrightBigg = log/parenleftbiggπk πK/parenrightbigg −1 2(x−µk)TΣ−1(x−µk) +1 2(x−µK)TΣ−1(x−µK) = log/parenleftbiggπk πK/parenrightbigg −1 2(µk+µK)TΣ−1(µk−µK) +xTΣ−1(µk−µK) =ak+p/summationdisplay j=1bkjxj, (4.32) whereak= log/parenleftBig πk πK/parenrightBig −1 2(µk+µK)TΣ−1(µk−µK)andbkjis thejth component of Σ−1(µk−µK). Hence LDA, like logistic regression, assumes that the log odds of the posterior probabilities is linear in x. Using similar calculations, in the QDA setting ( 4.31) becomes log/parenleftbiggPr(Y=k|X=x) Pr(Y=K|X=x)/parenrightbigg =ak+p/summationdisplay j=1bkjxj+p/summationdisplay j=1p/summationdisplay l=1ckjlxjxl,(4.33) whereak,bkj, andckjlare functions of πk,πK,µk,µK,ΣkandΣK. Again, as the name suggests, QDA assumes that the log odds of the posterior probabilities is quadratic in x. Finally, we examine ( 4.31) in the naive Bayes setting. Recall that in this setting, fk(x)is modeled as a product of pone-dimensional functions", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 200, "start_word": 64000, "end_word": 64400, "chunk_words": 400}}, "ISLP_website::c000201": {"text": "LDA, like logistic regression, assumes that the log odds of the posterior probabilities is linear in x. Using similar calculations, in the QDA setting ( 4.31) becomes log/parenleftbiggPr(Y=k|X=x) Pr(Y=K|X=x)/parenrightbigg =ak+p/summationdisplay j=1bkjxj+p/summationdisplay j=1p/summationdisplay l=1ckjlxjxl,(4.33) whereak,bkj, andckjlare functions of πk,πK,µk,µK,ΣkandΣK. Again, as the name suggests, QDA assumes that the log odds of the posterior probabilities is quadratic in x. Finally, we examine ( 4.31) in the naive Bayes setting. Recall that in this setting, fk(x)is modeled as a product of pone-dimensional functions fkj(xj)forj=1,...,p . Hence, log/parenleftbiggPr(Y=k|X=x) Pr(Y=K|X=x)/parenrightbigg = log/parenleftbiggπkfk(x) πKfK(x)/parenrightbigg = log/parenleftBigg πk/producttextp j=1fkj(xj) πK/producttextp j=1fKj(xj)/parenrightBigg = log/parenleftbiggπk πK/parenrightbigg +p/summationdisplay j=1log/parenleftbiggfkj(xj) fKj(xj)/parenrightbigg =ak+p/summationdisplay j=1gkj(xj), (4.34) whereak= log/parenleftBig πk πK/parenrightBig andgkj(xj) = log/parenleftBig fkj(xj) fKj(xj)/parenrightBig . Hence, the right-hand side of (4.34) takes the form of a generalized additive model , a topic that is discussed further in Chapter 7. 4.5 A Comparison of Classification Methods 163 Inspection of ( 4.32), (4.33), and (4.34) yields the following observations about LDA, QDA, and naive Bayes: • LDA is a special case of QDA with ckjl=0 for allj=1,...,p , l=1,...,p , andk=1,...,K . (Of course, this is not surprising, since LDAissimplyarestrictedversionofQDAwith Σ1=···=ΣK=Σ.) • Anyclassifierwithalineardecisionboundaryisaspecialcaseofnaive Bayes with gkj(xj)= bkjxj. In particular, this means that LDA is a special case of naive Bayes! This is not at all obvious from the descriptions of LDA and naive Bayes earlier in this chapter, since each method makes very different assumptions: LDA assumes that the features are normally distributed with a common within-class covariance matrix, and naive Bayes instead assumes independence of the features. • If we model fkj(xj)in the naive Bayes classifier using a one-dimensio- nal Gaussian distribution N(µkj,σ2 j), then we end up with gkj(xj)= bkjxjwherebkj=(µkj−µKj)/σ2 j.Inthiscase,naiveBayesisactually a special case of LDA with Σrestricted to be a diagonal matrix with jth diagonal element equal to σ2 j. • Neither QDA nor naive Bayes is a special case of the other. Naive Bayes can produce a more flexible fit, since any choice can be made forgkj(xj). However, it is restricted to a purely additive fit, in the sense that in ( 4.34), a function of xjisaddedto a function of xl, for j/negationslash=l; however, these terms are never multiplied. By contrast, QDA includes multiplicative terms of the form ckjlxjxl. Therefore, QDA has the potential to be more accurate in settings where interactions amongthepredictorsareimportantindiscriminatingbetweenclasses. None of these methods uniformly dominates the others: in any setting, the choice of method will depend", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 201, "start_word": 64320, "end_word": 64720, "chunk_words": 400}}, "ISLP_website::c000202": {"text": "since any choice can be made forgkj(xj). However, it is restricted to a purely additive fit, in the sense that in ( 4.34), a function of xjisaddedto a function of xl, for j/negationslash=l; however, these terms are never multiplied. By contrast, QDA includes multiplicative terms of the form ckjlxjxl. Therefore, QDA has the potential to be more accurate in settings where interactions amongthepredictorsareimportantindiscriminatingbetweenclasses. None of these methods uniformly dominates the others: in any setting, the choice of method will depend on the true distribution of the predictors in each of the Kclasses, as well as other considerations, such as the values of nandp. The latter ties into the bias-variance trade-off. How does logistic regression tie into this story? Recall from ( 4.12) that multinomial logistic regression takes the form log/parenleftbiggPr(Y=k|X=x) Pr(Y=K|X=x)/parenrightbigg =βk0+p/summationdisplay j=1βkjxj. This is identical to the linear form of LDA ( 4.32): in both cases, log/parenleftBig Pr(Y=k|X=x) Pr(Y=K|X=x)/parenrightBig is a linear function of the predictors. In LDA, the co- efficients in this linear function are functions of estimates for πk,πK,µk, µK, andΣobtained by assuming that X1,...,X pfollow a normal distri- bution within each class. By contrast, in logistic regression, the coefficients are chosen to maximize the likelihood function ( 4.5). Thus, we expect LDA to outperform logistic regression when the normality assumption (approxi- mately) holds, and we expect logistic regression to perform better when it does not. 164 4. Classification We close with a brief discussion of K-nearest neighbors (KNN), intro- duced in Chapter 2. Recall that KNN takes a completely different approach from the classifiers seen in this chapter. In order to make a prediction for an observation X=x, the training observations that are closest to xare identified. Then Xis assigned to the class to which the plurality of these observations belong. Hence KNN is a completely non-parametric approach: no assumptions are made about the shape of the decision boundary. We make the following observations about KNN: • Because KNN is completely non-parametric, we can expect this ap- proach to dominate LDA and logistic regression when the decision boundary is highly non-linear, provided that nis very large and pis small. • In order to provide accurate classification, KNN requires a lotof ob- servationsrelativetothenumberofpredictors—thatis, nmuchlarger thanp. This has to do with the fact that KNN is non-parametric, and thus tends to reduce the bias while incurring a lot of variance. • In settings where the decision boundary is", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 202, "start_word": 64640, "end_word": 65040, "chunk_words": 400}}, "ISLP_website::c000203": {"text": "• Because KNN is completely non-parametric, we can expect this ap- proach to dominate LDA and logistic regression when the decision boundary is highly non-linear, provided that nis very large and pis small. • In order to provide accurate classification, KNN requires a lotof ob- servationsrelativetothenumberofpredictors—thatis, nmuchlarger thanp. This has to do with the fact that KNN is non-parametric, and thus tends to reduce the bias while incurring a lot of variance. • In settings where the decision boundary is non-linear but nis only modest, or pis not very small, then QDA may be preferred to KNN. This is because QDA can provide a non-linear decision boundary while taking advantage of a parametric form, which means that it requires a smaller sample size for accurate classification, relative to KNN. • Unlike logistic regression, KNN does not tell us which predictors are important: we don’t get a table of coefficients as in Table 4.3. 4.5.2 An Empirical Comparison We now compare the empirical (practical) performance of logistic regres- sion, LDA, QDA, naive Bayes, and KNN. We generated data from six dif- ferent scenarios, each of which involves a binary (two-class) classification problem. In three of the scenarios, the Bayes decision boundary is linear, and in the remaining scenarios it is non-linear. For each scenario, we pro- duced100random training data sets. On each of these training sets, we fit each method to the data and computed the resulting test error rate on a large test set. Results for the linear scenarios are shown in Figure 4.11, and the results for the non-linear scenarios are in Figure 4.12. The KNN method requires selection of K, the number of neighbors (not to be con- fused with the number of classes in earlier sections of this chapter). We performed KNN with two values of K:K=1, and a value of Kthat was chosen automatically using an approach called cross-validation , which we discuss further in Chapter 5. We applied naive Bayes assuming univariate Gaussian densities for the features within each class (and, of course — since this is the key characteristic of naive Bayes — assuming independence of the features). In each of the six scenarios, there were p=2 quantitative predictors. The scenarios were as follows: 4.5 A Comparison of Classification Methods 165KNN−1KNN−CVLDALogisticNBayesQDASCENARIO 10.25 0.30 0.35 0.40 0.45 KNN−1KNN−CVLDALogisticNBayesQDASCENARIO 20.15 0.20 0.25 0.30 KNN−1KNN−CVLDALogisticNBayesQDASCENARIO 30.20 0.25 0.30 0.35 0.40 0.45 0.50FIGURE 4.11. Boxplots of the test", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 203, "start_word": 64960, "end_word": 65360, "chunk_words": 400}}, "ISLP_website::c000204": {"text": "5. We applied naive Bayes assuming univariate Gaussian densities for the features within each class (and, of course — since this is the key characteristic of naive Bayes — assuming independence of the features). In each of the six scenarios, there were p=2 quantitative predictors. The scenarios were as follows: 4.5 A Comparison of Classification Methods 165KNN−1KNN−CVLDALogisticNBayesQDASCENARIO 10.25 0.30 0.35 0.40 0.45 KNN−1KNN−CVLDALogisticNBayesQDASCENARIO 20.15 0.20 0.25 0.30 KNN−1KNN−CVLDALogisticNBayesQDASCENARIO 30.20 0.25 0.30 0.35 0.40 0.45 0.50FIGURE 4.11. Boxplots of the test error rates for each of the linear scenarios described in the main text. Scenario 1: There were 20training observations in each of two classes. The observations within each class were uncorrelated random normal variables withadifferentmeanineachclass.Theleft-handpanelofFigure 4.11shows that LDA performed well in this setting, as one would expect since this is the model assumed by LDA. Logistic regression also performed quite well, sinceitassumesalineardecisionboundary.KNNperformedpoorlybecause itpaidapriceintermsofvariancethatwasnotoffsetbyareductioninbias. QDA also performed worse than LDA, since it fit a more flexible classifier than necessary. The performance of naive Bayes was slightly better than QDA, because the naive Bayes assumption of independent predictors is correct. Scenario 2: Details are as in Scenario 1, except that within each class, the two predictors had a correlation of −0.5. The center panel of Figure 4.11 indicates that the performance of most methods is similar to the previ- ous scenario. The notable exception is naive Bayes, which performs very poorly here, since the naive Bayes assumption of independent predictors is violated. Scenario 3: As in the previous scenario, there is substantial negative cor- relation between the predictors within each class. However, this time we generated X1andX2fromthe t-distribution ,with50observationsperclass.t- distribution Thet-distribution has a similar shape to the normal distribution, but it has a tendency to yield more extreme points—that is, more points that are far from the mean. In this setting, the decision boundary was still linear, and so fit into the logistic regression framework. The set-up violated the assumptions of LDA, since the observations were not drawn from a normal distribution. The right-hand panel of Figure 4.11shows that logistic regres- sion outperformed LDA, though both methods were superior to the other approaches. In particular, the QDA results deteriorated considerably as a consequence of non-normality. Naive Bayes performed very poorly because the independence assumption is violated. Scenario 4: The data were generated from a normal distribution, with a correlation of 0.5between the predictors in the first class, and correlation of −0.5betweenthepredictorsinthesecondclass.Thissetupcorrespondedto the", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 204, "start_word": 65280, "end_word": 65680, "chunk_words": 400}}, "ISLP_website::c000205": {"text": "since the observations were not drawn from a normal distribution. The right-hand panel of Figure 4.11shows that logistic regres- sion outperformed LDA, though both methods were superior to the other approaches. In particular, the QDA results deteriorated considerably as a consequence of non-normality. Naive Bayes performed very poorly because the independence assumption is violated. Scenario 4: The data were generated from a normal distribution, with a correlation of 0.5between the predictors in the first class, and correlation of −0.5betweenthepredictorsinthesecondclass.Thissetupcorrespondedto the QDA assumption, and resulted in quadratic decision boundaries. The left-hand panel of Figure 4.12shows that QDA outperformed all of the 166 4. ClassificationKNN−1KNN−CVLDALogisticNBayesQDASCENARIO 40.300.350.40 KNN−1KNN−CVLDALogisticNBayesQDASCENARIO 50.18 0.20 0.22 0.24 0.26 0.28 0.30 0.32 KNN−1KNN−CVLDALogisticNBayesQDASCENARIO 60.15 0.20 0.25 0.30 0.35 0.40 0.45FIGURE 4.12. Boxplots of the test error rates for each of the non-linear scenarios described in the main text. other approaches. The naive Bayes assumption of independent predictors is violated, so naive Bayes performs poorly. Scenario 5: The data were generated from a normal distribution with un- correlated predictors. Then the responses were sampled from the logistic function applied to a complicated non-linear function of the predictors. The center panel of Figure 4.12shows that both QDA and naive Bayes gave slightly better results than the linear methods, while the much more flexi- ble KNN-CV method gave the best results. But KNN with K=1gave the worstresultsoutofallmethods.Thishighlightsthefactthatevenwhenthe data exhibits a complex non-linear relationship, a non-parametric method such as KNN can still give poor results if the level of smoothness is not chosen correctly. Scenario 6: The observations were generated from a normal distribution with a different diagonal covariance matrix for each class. However, the sample size was verysmall: just n=6in each class. Naive Bayes performed very well, because its assumptions are met. LDA and logistic regression performed poorly because the true decision boundary is non-linear, due to the unequal covariance matrices. QDA performed a bit worse than naive Bayes, because given the very small sample size, the former incurred too much variance in estimating the correlation between the predictors within each class. KNN’s performance also suffered due to the very small sample size. These six examples illustrate that no one method will dominate the oth- ers in every situation. When the true decision boundaries are linear, then theLDAandlogisticregressionapproacheswilltendtoperformwell.When the boundaries are moderately non-linear, QDA or naive Bayes may give better results. Finally, for much more complicated decision boundaries, a non-parametric approach such", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 205, "start_word": 65600, "end_word": 66000, "chunk_words": 400}}, "ISLP_website::c000206": {"text": "very small sample size, the former incurred too much variance in estimating the correlation between the predictors within each class. KNN’s performance also suffered due to the very small sample size. These six examples illustrate that no one method will dominate the oth- ers in every situation. When the true decision boundaries are linear, then theLDAandlogisticregressionapproacheswilltendtoperformwell.When the boundaries are moderately non-linear, QDA or naive Bayes may give better results. Finally, for much more complicated decision boundaries, a non-parametric approach such as KNN can be superior. But the level of smoothness for a non-parametric approach must be chosen carefully. In the next chapter we examine a number of approaches for choosing the correct level of smoothness and, in general, for selecting the best overall method. Finally,recallfromChapter 3thatintheregressionsettingwecanaccom- modate a non-linear relationship between the predictors and the response by performing regression using transformations of the predictors. A similar approach could be taken in the classification setting. For instance, we could 4.6 Generalized Linear Models 167 Coefficient Std. error t-statistic p-value Intercept 73.60 5.13 14.34 0.00 workingday 1.27 1.78 0.71 0.48 temp 157.21 10.26 15.32 0.00 weathersit[cloudy/misty] -12.89 1.96 -6.56 0.00 weathersit[light rain/snow] -66.49 2.97 -22.43 0.00 weathersit[heavy rain/snow] -109.75 76.67 -1.43 0.15 TABLE 4.10. Results for a least squares linear model fit to predict bikersin theBikeshare data. The predictors mnthandhrare omitted from this table due to space constraints, and can be seen in Figure 4.13. For the qualitative variable weathersit , the baseline level corresponds to clear skies. create a more flexible version of logistic regression by including X2,X3, and even X4as predictors. This may or may not improve logistic regres- sion’s performance, depending on whether the increase in variance due to the added flexibility is offset by a sufficiently large reduction in bias. We could do the same for LDA. If we added all possible quadratic terms and cross-products to LDA, the form of the model would be the same as the QDA model, although the parameter estimates would be different. This device allows us to move somewhere between an LDA and a QDA model. 4.6 Generalized Linear Models In Chapter 3, we assumed that the response Yis quantitative, and ex- plored the use of least squares linear regression to predict Y. Thus far in this chapter, we have instead assumed that Yis qualitative. However, we may sometimes be faced with situations in which Yis neither qualitative nor quantitative, and so", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 206, "start_word": 65920, "end_word": 66320, "chunk_words": 400}}, "ISLP_website::c000207": {"text": "the QDA model, although the parameter estimates would be different. This device allows us to move somewhere between an LDA and a QDA model. 4.6 Generalized Linear Models In Chapter 3, we assumed that the response Yis quantitative, and ex- plored the use of least squares linear regression to predict Y. Thus far in this chapter, we have instead assumed that Yis qualitative. However, we may sometimes be faced with situations in which Yis neither qualitative nor quantitative, and so neither linear regression from Chapter 3nor the classification approaches covered in this chapter is applicable. As a concrete example, we consider the Bikeshare data set. The response isbikers, the number of hourly users of a bike sharing program in Wash- ington, DC. This response value is neither qualitative nor quantitative: instead, it takes on non-negative integer values, or counts. We will considercountspredicting bikersusing the covariates mnth(month of the year), hr(hour of the day, from 0 to 23), workingday (an indicator variable that equals 1if it is neither a weekend nor a holiday), temp(the normalized temperature, in Celsius), and weathersit (a qualitative variable that takes on one of four possible values: clear; misty or cloudy; light rain or light snow; or heavy rain or heavy snow.) In the analyses that follow, we will treat mnth,hr, andweathersit as qualitative variables. 4.6.1 Linear Regression on the Bikeshare Data To begin, we consider predicting bikersusing linear regression. The results are shown in Table 4.10. We see, for example, that a progression of weather from clear to cloudy results in, on average, 12.89fewer bikers per hour; however, if the weather progresses further to rain or snow, then this further results in 53.60fewer bikers per hour. Figure 4.13displays the coefficients associated with mnth 168 4. Classification FIGURE 4.13. A least squares linear regression model was fit to predict bikers in theBikeshare data set. Left:The coefficients associated with the month of the year. Bike usage is highest in the spring and fall, and lowest in the winter. Right: The coefficients associated with the hour of the day. Bike usage is highest during peak commute times, and lowest overnight. and the coefficients associated with hr. We see that bike usage is highest in the spring and fall, and lowest during the winter months. Furthermore, bike usage is greatest around rush hour (9 AM and 6 PM), and lowest overnight. Thus, at first glance, fitting a linear regression model", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 207, "start_word": 66240, "end_word": 66640, "chunk_words": 400}}, "ISLP_website::c000208": {"text": "in the spring and fall, and lowest in the winter. Right: The coefficients associated with the hour of the day. Bike usage is highest during peak commute times, and lowest overnight. and the coefficients associated with hr. We see that bike usage is highest in the spring and fall, and lowest during the winter months. Furthermore, bike usage is greatest around rush hour (9 AM and 6 PM), and lowest overnight. Thus, at first glance, fitting a linear regression model to the Bikeshare data set seems to provide reasonable and intuitive results. But upon more careful inspection, some issues become apparent. For example, 9.6% of the fitted values in the Bikeshare data set are negative: that is, the linear regression model predicts a negative number of users during 9.6% of the hours in the data set. This calls into question our ability to perform meaningful predictions on the data, and it also raises concerns about the accuracy of the coefficient estimates, confidence intervals, and other outputs of the regression model. Furthermore, it is reasonable to suspect that when the expected value ofbikersis small, the variance of bikersshould be small as well. For instance, at 2 AM during a heavy December snow storm, we expect that extremely few people will use a bike, and moreover that there should be little variance associated with the number of users during those conditions. This is borne out in the data: between 1 AM and 4 AM, in December, January, and February, when it is raining, there are 5.05users, on average, with a standard deviation of 3.73. By contrast, between 7 AM and 10 AM, in April, May, and June, when skies are clear, there are 243.59users, on average,withastandarddeviationof 131.7.Themean-variancerelationship is displayed in the left-hand panel of Figure 4.14. This is a major violation of the assumptions of a linear model, which state that Y=/summationtextp j=1Xjβj+/epsilon1, where/epsilon1is a mean-zero error term with variance σ2that isconstant, and not a function of the covariates. Therefore, the heteroscedasticity of the data calls into question the suitability of a linear regression model. Finally, the response bikersis integer-valued. But under a linear model, Y=β0+/summationtextp j=1Xjβj+/epsilon1, where/epsilon1is a continuous-valued error term. This means that in a linear model, the response Yis necessarily continuous- valued (quantitative). Thus, the integer nature of the response bikerssug- gests that a linear regression model is not entirely satisfactory for this data set./uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF /uni25CF /uni25CF/uni25CF/uni25CF/uni25CF /uni25CF /uni25CF−40", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 208, "start_word": 66560, "end_word": 66960, "chunk_words": 400}}, "ISLP_website::c000209": {"text": "and not a function of the covariates. Therefore, the heteroscedasticity of the data calls into question the suitability of a linear regression model. Finally, the response bikersis integer-valued. But under a linear model, Y=β0+/summationtextp j=1Xjβj+/epsilon1, where/epsilon1is a continuous-valued error term. This means that in a linear model, the response Yis necessarily continuous- valued (quantitative). Thus, the integer nature of the response bikerssug- gests that a linear regression model is not entirely satisfactory for this data set./uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF /uni25CF /uni25CF/uni25CF/uni25CF/uni25CF /uni25CF /uni25CF−40 −20 0 20 MonthCoefficient JF M A MJJAS O N D/uni25CF /uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF /uni25CF /uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF /uni25CF /uni25CF /uni25CF /uni25CF /uni25CF /uni25CF 51 0 1 5 2 0−100 0 50 100 200 HourCoefficient 4.6 Generalized Linear Models 169 5 10 15 200 100 200 300 400 500 600HourNumber of Bikers5 10 15 200123456HourLog(Number of Bikers)FIGURE 4.14. Left:On theBikeshare dataset, the number of bikers is dis- played on the y-axis, and the hour of the day is displayed on the x-axis. Jitter was applied for ease of visualization. For the most part, as the mean number of bikers increases, so does the variance in the number of bikers. A smoothing spline fit is shown in green. Right:The log of the number of bikers is now displayed on they-axis. Some of the problems that arise when fitting a linear regression model to theBikeshare data can be overcome by transforming the response; for instance, we can fit the model log(Y)=p/summationdisplay j=1Xjβj+/epsilon1. Transforming the response avoids the possibility of negative predictions, and it overcomes much of the heteroscedasticity in the untransformed data, as is shown in the right-hand panel of Figure 4.14. However, it is not quite a satisfactory solution, since predictions and inference are made in terms of the log of the response, rather than the response. This leads to challenges in interpretation, e.g. “a one-unit increase in Xjis associated with an increase in the mean of the log of Yby an amount βj”. Furthermore, a log transformation of the response cannot be applied in settings where the response can take on a value of 0. Thus, while fitting a linear model to a transformation of the response may be an adequate approach for some count-valued data sets, it often leaves something to be desired. We will see in the next section that a Poisson regression model provides a much more natural and elegant approach for this task. 4.6.2 Poisson Regression on the Bikeshare Data", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 209, "start_word": 66880, "end_word": 67280, "chunk_words": 400}}, "ISLP_website::c000210": {"text": "a log transformation of the response cannot be applied in settings where the response can take on a value of 0. Thus, while fitting a linear model to a transformation of the response may be an adequate approach for some count-valued data sets, it often leaves something to be desired. We will see in the next section that a Poisson regression model provides a much more natural and elegant approach for this task. 4.6.2 Poisson Regression on the Bikeshare Data Toovercometheinadequaciesoflinearregressionforanalyzingthe Bikeshare data set, we will make use of an alternative approach, called Poisson regression . Before we can talk about Poisson regression, we must first in-Poisson regressiontroduce the Poisson distribution . Poisson distributionSuppose that a random variable Ytakes on nonnegative integer values, i.e.Y∈{0,1,2,...}. IfYfollows the Poisson distribution, then Pr(Y=k)=e−λλk k!fork=0,1,2,.... (4.35) 170 4. Classification Here,λ>0is the expected value of Y, i.e.E(Y). It turns out that λalso equals the variance of Y, i.e.λ= E( Y) = Var( Y). This means that if Y follows the Poisson distribution, then the larger the mean of Y, the larger its variance. (In ( 4.35), the notation k!, pronounced “k factorial”, is defined ask!=k×(k−1)×(k−2)×...×3×2×1.) The Poisson distribution is typically used to model counts; this is a nat- ural choice for a number of reasons, including the fact that counts, like the Poisson distribution, take on nonnegative integer values. To see how we might use the Poisson distribution in practice, let Ydenote the num- ber of users of the bike sharing program during a particular hour of the day, under a particular set of weather conditions, and during a particu- lar month of the year. We might model Yas a Poisson distribution with meanE(Y)= λ=5. This means that the probability of no users dur- ing this particular hour is Pr(Y= 0) =e−550 0!=e−5=0.0067 (where 0! = 1 by convention). The probability that there is exactly one user isPr(Y= 1) =e−551 1!=5e−5=0.034, the probability of two users is Pr(Y= 2) =e−552 2!=0.084, and so on. Of course, in reality, we expect the mean number of users of the bike sharing program, λ= E( Y), to vary as a function of the hour of the day, the month of the year, the weather conditions, and so forth. So rather than modeling the number of bikers, Y, as a Poisson distribution with a fixed mean value like λ=5, we would like to allow the mean to vary as", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 210, "start_word": 67200, "end_word": 67600, "chunk_words": 400}}, "ISLP_website::c000211": {"text": "users is Pr(Y= 2) =e−552 2!=0.084, and so on. Of course, in reality, we expect the mean number of users of the bike sharing program, λ= E( Y), to vary as a function of the hour of the day, the month of the year, the weather conditions, and so forth. So rather than modeling the number of bikers, Y, as a Poisson distribution with a fixed mean value like λ=5, we would like to allow the mean to vary as a function of the covariates. In particular, we consider the following model for the mean λ= E( Y), which we now write as λ(X1,...,X p)to emphasize that it is a function of the covariates X1,...,X p: log(λ(X1,...,X p)) = β0+β1X1+···+βpXp (4.36) or equivalently λ(X1,...,X p)=eβ0+β1X1+···+βpXp. (4.37) Here,β0,β1,...,βpare parameters to be estimated. Together, ( 4.35) and (4.36) define the Poisson regression model. Notice that in ( 4.36), we take thelogofλ(X1,...,X p)to be linear in X1,...,X p, rather than having λ(X1,...,X p)itselfbelinearin X1,...,X p;thisensuresthat λ(X1,...,X p) takes on nonnegative values for all values of the covariates. To estimate the coefficients β0,β1,...,βp, we use the same maximum likelihood approach that we adopted for logistic regression in Section 4.3.2. Specifically, given nindependent observations from the Poisson regression model, the likelihood takes the form /lscript(β0,β1,...,βp)=n/productdisplay i=1e−λ(xi)λ(xi)yi yi!, (4.38) whereλ(xi)= eβ0+β1xi1+···+βpxip, due to ( 4.37). We estimate the coef- ficients that maximize the likelihood /lscript(β0,β1,...,βp), i.e. that make the observed data as likely as possible. We now fit a Poisson regression model to the Bikeshare data set. The results are shown in Table 4.11and Figure 4.15. Qualitatively, the results are similar to those from linear regression in Section 4.6.1. We again see that bike usage is highest in the spring and fall and during rush hour, 4.6 Generalized Linear Models 171 Coefficient Std. error z-statistic p-value Intercept 4.12 0.01 683.96 0.00 workingday 0.01 0.00 7.5 0.00 temp 0.79 0.01 68.43 0.00 weathersit[cloudy/misty] -0.08 0.00 -34.53 0.00 weathersit[light rain/snow] -0.58 0.00 -141.91 0.00 weathersit[heavy rain/snow] -0.93 0.17 -5.55 0.00 TABLE 4.11. Results for a Poisson regression model fit to predict bikersin theBikeshare data. The predictors mnthandhrare omitted from this table due to space constraints, and can be seen in Figure 4.15. For the qualitative variable weathersit , the baseline corresponds to clear skies. FIGURE 4.15. A Poisson regression model was fit to predict bikersin the Bikeshare data set. Left:The coefficients associated with the month of the year.", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 211, "start_word": 67520, "end_word": 67920, "chunk_words": 400}}, "ISLP_website::c000212": {"text": "weathersit[light rain/snow] -0.58 0.00 -141.91 0.00 weathersit[heavy rain/snow] -0.93 0.17 -5.55 0.00 TABLE 4.11. Results for a Poisson regression model fit to predict bikersin theBikeshare data. The predictors mnthandhrare omitted from this table due to space constraints, and can be seen in Figure 4.15. For the qualitative variable weathersit , the baseline corresponds to clear skies. FIGURE 4.15. A Poisson regression model was fit to predict bikersin the Bikeshare data set. Left:The coefficients associated with the month of the year. Bike usage is highest in the spring and fall, and lowest in the winter. Right:The coefficients associated with the hour of the day. Bike usage is highest during peak commute times, and lowest overnight. and lowest during the winter and in the early morning hours. Moreover, bike usage increases as the temperature increases, and decreases as the weather worsens. Interestingly, the coefficient associated with workingday isstatisticallysignificantunderthePoissonregressionmodel,butnotunder the linear regression model. Some important distinctions between the Poisson regression model and the linear regression model are as follows: •Interpretation: To interpret the coefficients in the Poisson regression model, we must pay close attention to ( 4.37), which states that an increase in Xjby one unit is associated with a change in E(Y)=λ by a factor of exp(βj). For example, a change in weather from clear to cloudy skies is associated with a change in mean bike usage by a factor of exp(−0.08) = 0 .923, i.e. on average, only 92.3% as many people will use bikes when it is cloudy relative to when it is clear. If the weather worsens further and it begins to rain, then the mean bike usage will further change by a factor of exp(−0.5) = 0 .607, i.e. on average only 60.7% as many people will use bikes when it is rainy relative to when it is cloudy./uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF /uni25CF/uni25CF/uni25CF/uni25CF /uni25CF /uni25CF−0.6−0.4−0.2 0.0 0.2 MonthCoefficient JF M A MJJAS O N D/uni25CF /uni25CF /uni25CF /uni25CF /uni25CF/uni25CF/uni25CF/uni25CF/uni25CF /uni25CF /uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF /uni25CF /uni25CF /uni25CF /uni25CF /uni25CF 51 0 1 5 2 0−2 −10 1 HourCoefficient 172 4. Classification •Mean-variance relationship: As mentioned earlier, under the Poisson model,λ= E( Y) = Var( Y). Thus, by modeling bike usage with a Poisson regression, we implicitly assume that mean bike usage in a given hour equals the variance of bike usage during that hour. By contrast, under a linear regression model, the variance of bike usage always takes on a constant value. Recall from", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 212, "start_word": 67840, "end_word": 68240, "chunk_words": 400}}, "ISLP_website::c000213": {"text": "/uni25CF /uni25CF /uni25CF /uni25CF /uni25CF 51 0 1 5 2 0−2 −10 1 HourCoefficient 172 4. Classification •Mean-variance relationship: As mentioned earlier, under the Poisson model,λ= E( Y) = Var( Y). Thus, by modeling bike usage with a Poisson regression, we implicitly assume that mean bike usage in a given hour equals the variance of bike usage during that hour. By contrast, under a linear regression model, the variance of bike usage always takes on a constant value. Recall from Figure 4.14that in the Bikeshare data, when biking conditions are favorable, both the mean andthe variance in bike usage are much higher than when conditions are unfavorable. Thus, the Poisson regression model is able to handle the mean-variance relationship seen in the Bikeshare data in a way that the linear regression model is not.5 overdispersion •nonnegative fitted values: There are no negative predictions using the Poisson regression model. This is because the Poisson model itself only allows for nonnegative values; see ( 4.35). By contrast, when we fit a linear regression model to the Bikeshare data set, almost 10% of the predictions were negative. 4.6.3 Generalized Linear Models in Greater Generality We have now discussed three types of regression models: linear, logistic and Poisson. These approaches share some common characteristics: 1. Each approach uses predictors X1,...,X pto predict a response Y. We assume that, conditional on X1,...,X p,Ybelongs to a certain family of distributions. Forlinear regression, wetypicallyassume that Yfollows a Gaussian or normal distribution. For logistic regression, weassumethat YfollowsaBernoullidistribution.Finally,forPoisson regression, we assume that Yfollows a Poisson distribution. 2. Each approach models the mean of Yas a function of the predictors. In linear regression, the mean of Ytakes the form E(Y|X1,...,X p)=β0+β1X1+···+βpXp, (4.39) i.e. it is a linear function of the predictors. For logistic regression, the mean instead takes the form E(Y|X1,...,X p) = Pr( Y=1|X1,...,X p) =eβ0+β1X1+···+βpXp 1+eβ0+β1X1+···+βpXp, (4.40) while for Poisson regression it takes the form E(Y|X1,...,X p)=λ(X1,...,X p)=eβ0+β1X1+···+βpXp.(4.41) Equations ( 4.39)–(4.41) can be expressed using a link function ,η, whichlink function 5In fact, the variance in the Bikeshare data appears to be much higher than the mean, a situation referred to as overdispersion . This causes the Z-values to be inflated in Table 4.11. A more careful analysis should account for this overdispersion to obtain more accurate Z-values, and there are a variety of methods for doing this. But they are beyond the scope of this book. 4.7", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 213, "start_word": 68160, "end_word": 68560, "chunk_words": 400}}, "ISLP_website::c000214": {"text": "Equations ( 4.39)–(4.41) can be expressed using a link function ,η, whichlink function 5In fact, the variance in the Bikeshare data appears to be much higher than the mean, a situation referred to as overdispersion . This causes the Z-values to be inflated in Table 4.11. A more careful analysis should account for this overdispersion to obtain more accurate Z-values, and there are a variety of methods for doing this. But they are beyond the scope of this book. 4.7 Lab: Logistic Regression, LDA, QDA, and KNN 173 applies a transformation to E(Y|X1,...,X p)so that the transformed mean is a linear function of the predictors. That is, η(E(Y|X1,...,X p)) = β0+β1X1+···+βpXp. (4.42) The link functions for linear, logistic and Poisson regression are η(µ)=µ, η(µ) = log( µ/(1−µ)), andη(µ) = log( µ), respectively. The Gaussian, Bernoulli and Poisson distributions are all members of a wider class of distributions, known as the exponential family . Other well-exponential familyknown members of this family are the exponential distribution, the Gamma exponential Gammadistribution, and the negative binomial distribution. In general, we can per- negative binomialform a regression by modeling the response Yas coming from a particular member of the exponential family, and then transforming the mean of the response so that the transformed mean is a linear function of the predictors via (4.42). Any regression approach that follows this very general recipe is knownas a generalized linear model (GLM). Thus,linear regression, logisticgeneralized linear modelregression, and Poisson regression are three examples of GLMs. Other ex- amples not covered here include Gamma regression andnegative binomial regression . 4.7 Lab: Logistic Regression, LDA, QDA, and KNN 4.7.1 The Stock Market Data In this lab we will examine the Smarket data, which is part of the ISLP library. This data set consists of percentage returns for the S&P 500 stock index over 1,250 days, from the beginning of 2001 until the end of 2005. For each date, we have recorded the percentage returns for each of the five previous trading days, Lag1through Lag5. We have also recorded Volume (the number of shares traded on the previous day, in billions), Today(the percentage return on the date in question) and Direction (whether the market was UporDownon this date). We start by importing our libraries at this top level; these are all imports we have seen in previous labs. In[1]: import numpy as np import pandas as pd from matplotlib.pyplot import subplots", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 214, "start_word": 68480, "end_word": 68880, "chunk_words": 400}}, "ISLP_website::c000215": {"text": "recorded the percentage returns for each of the five previous trading days, Lag1through Lag5. We have also recorded Volume (the number of shares traded on the previous day, in billions), Today(the percentage return on the date in question) and Direction (whether the market was UporDownon this date). We start by importing our libraries at this top level; these are all imports we have seen in previous labs. In[1]: import numpy as np import pandas as pd from matplotlib.pyplot import subplots import statsmodels.api as sm from ISLP import load_data from ISLP.models import (ModelSpec as MS, summarize) We also collect together the new imports needed for this lab. In[2]: from ISLP import confusion_table from ISLP.models import contrast from sklearn.discriminant_analysis import \\ (LinearDiscriminantAnalysis as LDA, QuadraticDiscriminantAnalysis as QDA) from sklearn.naive_bayes import GaussianNB from sklearn.neighbors import KNeighborsClassifier from sklearn.preprocessing import StandardScaler 174 4. Classificationfrom sklearn.model_selection import train_test_splitfrom sklearn.linear_model import LogisticRegressionNow we are ready to load theSmarketdata.In[3]:Smarket = load_data('Smarket')SmarketThis gives a truncated listing of the data, which we do not show here. Wecan see what the variable names are.In[4]:Smarket.columnsOut[4]:Index(['Year','Lag1','Lag2','Lag3','Lag4','Lag5','Volume','Today','Direction'],dtype='object')We compute the correlation matrix using thecorr()method for data.corr()frames, which produces a matrix that contains all of the pairwise corre-lations among the variables. (We suppress the output here.) Thepandaslibrary does not report a correlation for theDirectionvariable because itis qualitative.In[5]:Smarket.corr()As one would expect, the correlations between the lagged return variablesand today’s return are close to zero. The only substantial correlation isbetweenYearandVolume. By plotting the data we see thatVolumeis in-creasing over time. In other words, the average number of shares tradeddaily increased from 2001 to 2005.In[6]:Smarket.plot(y='Volume');4.7.2 Logistic RegressionNext, we will fit a logistic regression model in order to predictDirectionusingLag1throughLag5andVolume. Thesm.GLM()function fitsgener-sm.GLM()alized linear models, a class of models that includes logistic regression.generalizedlinear modelAlternatively, the functionsm.Logit()fits a logistic regression model di-rectly. The syntax ofsm.GLM()is similar to that ofsm.OLS(), except thatwe must pass in the argumentfamily=sm.families.Binomial()in order totellstatsmodelsto run a logistic regression rather than some other type ofgeneralized linear model.In[7]:allvars = Smarket.columns.drop(['Today','Direction','Year'])design = MS(allvars)X=d e s i g n . f i t _ t r a n s f o r m ( S m a r k e t )y=S m a r k e t . D i r e c t i o n= ='Up'glm = sm.GLM(y,X,family=sm.families.Binomial())results = glm.fit()summarize(results) 4.7 Lab: Logistic Regression, LDA, QDA, and KNN 175Out[7]:coef std err z P>|z|intercept -0.1260 0.241 -0.523 0.601Lag1 -0.0731 0.050 -1.457 0.145Lag2 -0.0423 0.050 -0.845 0.398Lag3 0.0111 0.050 0.222 0.824Lag4", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 215, "start_word": 68800, "end_word": 69200, "chunk_words": 400}}, "ISLP_website::c000216": {"text": "= MS(allvars)X=d e s i g n . f i t _ t r a n s f o r m ( S m a r k e t )y=S m a r k e t . D i r e c t i o n= ='Up'glm = sm.GLM(y,X,family=sm.families.Binomial())results = glm.fit()summarize(results) 4.7 Lab: Logistic Regression, LDA, QDA, and KNN 175Out[7]:coef std err z P>|z|intercept -0.1260 0.241 -0.523 0.601Lag1 -0.0731 0.050 -1.457 0.145Lag2 -0.0423 0.050 -0.845 0.398Lag3 0.0111 0.050 0.222 0.824Lag4 0.0094 0.050 0.187 0.851Lag5 0.0103 0.050 0.208 0.835Volume 0.1354 0.158 0.855 0.392The smallestp-value here is associated withLag1. The negative coefficientforthispredictorsuggeststhatifthemarkethadapositivereturnyesterday,then it is less likely to go up today. However, at a value of 0.15, thep-valueis still relatively large, and so there is no clear evidence of a real associationbetweenLag1andDirection.We use theparamsattribute ofresultsin order to access just the coeffi-cients for this fitted model.In[8]:results.paramsOut[8]:intercept -0.126000Lag1 -0.073074Lag2 -0.042301Lag30.011085Lag40.009359Lag50.010313Volume 0.135441dtype: float64Likewise we can use thepvaluesattribute to access thep-values for thecoefficients (not shown).In[9]:results.pvaluesThepredict()method ofresultscan be used to predict the probabilitythat the market will go up, given values of the predictors. This methodreturns predictions on the probability scale. If no data set is supplied tothepredict()function, then the probabilities are computed for the train-ing data that was used to fit the logistic regression model. As with linearregression, one can pass an optionalexogargument consistent with a designmatrix if desired. Here we have printed only the first ten probabilities.In[10]:probs = results.predict()probs[:10]Out[10]:array([0.5070841, 0.4814679, 0.4811388, 0.5152223, 0.5107812,0.5069565, 0.4926509, 0.5092292, 0.5176135, 0.4888378])In order to make a prediction as to whether the market will go up ordown on a particular day, we must convert these predicted probabilitiesinto class labels,UporDown. The following two commands create a vectorof class predictions based on whether the predicted probability of a marketincrease is greater than or less than 0.5.In[11]:labels = np.array(['Down']*1250)labels[probs>0.5] =\"Up\" 176 4. ClassificationTheconfusion_table()function from theISLPpackage summarizes theseconfusion_table()predictions, showing how many observations were correctly or incorrectlyclassified. Our function, which is adapted from a similar function in themodulesklearn.metrics, transposes the resulting matrix and includes rowand column labels. Theconfusion_table()function takes as first argumentthe predicted labels, and second argument the true labels.In[12]:confusion_table(labels, Smarket.Direction)Out[12]:Truth Down UpPredictedDown 145 141Up 457 507The diagonal elements of the confusion matrix indicate correct predictions,while the off-diagonals represent incorrect predictions. Hence our modelcorrectly predicted that the market would go up on 507 days and thatit would go down on 145 days, for a total of 507 + 145 = 652 correctpredictions. Thenp.mean()function can be used to compute", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 216, "start_word": 69120, "end_word": 69520, "chunk_words": 400}}, "ISLP_website::c000217": {"text": "transposes the resulting matrix and includes rowand column labels. Theconfusion_table()function takes as first argumentthe predicted labels, and second argument the true labels.In[12]:confusion_table(labels, Smarket.Direction)Out[12]:Truth Down UpPredictedDown 145 141Up 457 507The diagonal elements of the confusion matrix indicate correct predictions,while the off-diagonals represent incorrect predictions. Hence our modelcorrectly predicted that the market would go up on 507 days and thatit would go down on 145 days, for a total of 507 + 145 = 652 correctpredictions. Thenp.mean()function can be used to compute the fraction ofdays for which the prediction was correct. In this case, logistic regressioncorrectly predicted the movement of the market 52.2% of the time.In[13]:(507+145)/1250, np.mean(labels == Smarket.Direction)Out[13]:(0.5216, 0.5216)At first glance, it appears that the logistic regression model is workinga little better than random guessing. However, this result is misleadingbecause we trained and tested the model on the same set of 1,250 obser-vations. In other words,100−52.2 = 47.8%is thetrainingerror rate. Aswe have seen previously, the training error rate is often overly optimistic— it tends to underestimate the test error rate. In order to better assessthe accuracy of the logistic regression model in this setting, we can fit themodel using part of the data, and then examine how well it predicts theheld outdata. This will yield a more realistic error rate, in the sense that inpractice we will be interested in our model’s performance not on the datathat we used to fit the model, but rather on days in the future for whichthe market’s movements are unknown.To implement this strategy, we first create a Boolean vector correspond-ing to the observations from 2001 through 2004. We then use this vectorto create a held out data set of observations from 2005.In[14]:train = (Smarket.Year < 2005)Smarket_train = Smarket.loc[train]Smarket_test = Smarket.loc[∼train]Smarket_test.shapeOut[14]:(252, 9)The objecttrainis a vector of 1,250 elements, corresponding to theobservations in our data set. The elements of the vector that correspondto observations that occurred before 2005 are set toTrue, whereas thosethat correspond to observations in 2005 are set toFalse. Hencetrainis abooleanarray, since its elements areTrueandFalse. Boolean arrays can beused to obtain a subset of the rows or columns of a data frame using the 4.7 Lab: Logistic Regression, LDA, QDA, and KNN 177locmethod. For instance, the commandSmarket.loc[train]would pickout a submatrix of the stock market data set, corresponding only to thedates before 2005, since those are the ones for which the elements oftrainareTrue. The∼symbol can be used to negate all of the elements of aBoolean vector.", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 217, "start_word": 69440, "end_word": 69840, "chunk_words": 400}}, "ISLP_website::c000218": {"text": "2005 are set toFalse. Hencetrainis abooleanarray, since its elements areTrueandFalse. Boolean arrays can beused to obtain a subset of the rows or columns of a data frame using the 4.7 Lab: Logistic Regression, LDA, QDA, and KNN 177locmethod. For instance, the commandSmarket.loc[train]would pickout a submatrix of the stock market data set, corresponding only to thedates before 2005, since those are the ones for which the elements oftrainareTrue. The∼symbol can be used to negate all of the elements of aBoolean vector. That is,∼trainis a vector similar totrain, except thatthe elements that areTrueintrainget swapped toFalsein∼train, andvice versa. Therefore,Smarket.loc[∼train]yields a subset of the rows ofthe data frame of the stock market data containing only the observationsfor whichtrainisFalse. The output above indicates that there are 252such observations.We now fit a logistic regression model using only the subset of the ob-servations that correspond to dates before 2005. We then obtain predictedprobabilities of the stock market going up for each of the days in our testset — that is, for the days in 2005.In[15]:X_train, X_test = X.loc[train], X.loc[∼train]y_train, y_test = y.loc[train], y.loc[∼train]glm_train = sm.GLM(y_train,X_train,family=sm.families.Binomial())results = glm_train.fit()probs = results.predict(exog=X_test)Notice that we have trained and tested our model on two completelyseparate data sets: training was performed using only the dates before2005, and testing was performed using only the dates in 2005.Finally, we compare the predictions for 2005 to the actual movements ofthe market over that time period. We will first store the test and traininglabels (recally_testis binary).In[16]:D=S m a r k e t . D i r e c t i o nL_train, L_test = D.loc[train], D.loc[∼train]Nowwethresholdthefittedprobabilityat50%toformourpredictedlabels.In[17]:labels = np.array(['Down']*252)labels[probs>0.5] ='Up'confusion_table(labels, L_test)Out[17]:Truth Down UpPredictedDown 77 97Up 34 44The test accuracy is about 48% while the error rate is about 52%In[18]:np.mean(labels == L_test), np.mean(labels != L_test)Out[18]:(0.4802, 0.5198)The!=notation meansnot equal to, and so the last command computes!=the test set error rate. The results are rather disappointing: the test errorrate is 52%, which is worse than random guessing! Of course this resultis not all that surprising, given that one would not generally expect to beable to use previous days’ returns to predict future market performance.(After all, if it were possible to do so, then the authors of this book wouldbe out striking it rich rather than writing a statistics textbook.) 178 4. ClassificationWe recall that the logistic regression model had very underwhelmingp-values associated with all of the predictors, and that the smallestp-value,though not very small, corresponded toLag1. Perhaps by removing thevariables that", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 218, "start_word": 69760, "end_word": 70160, "chunk_words": 400}}, "ISLP_website::c000219": {"text": "not all that surprising, given that one would not generally expect to beable to use previous days’ returns to predict future market performance.(After all, if it were possible to do so, then the authors of this book wouldbe out striking it rich rather than writing a statistics textbook.) 178 4. ClassificationWe recall that the logistic regression model had very underwhelmingp-values associated with all of the predictors, and that the smallestp-value,though not very small, corresponded toLag1. Perhaps by removing thevariables that appear not to be helpful in predictingDirection, we canobtain a more effective model. After all, using predictors that have norelationship with the response tends to cause a deterioration in the testerror rate (since such predictors cause an increase in variance without acorresponding decrease in bias), and so removing such predictors may inturn yield an improvement. Below we refit the logistic regression using justLag1andLag2, which seemed to have the highest predictive power in theoriginal logistic regression model.In[19]:model = MS(['Lag1','Lag2']).fit(Smarket)X=m o d e l . t r a n s f o r m ( S m a r k e t )X_train, X_test = X.loc[train], X.loc[∼train]glm_train = sm.GLM(y_train,X_train,family=sm.families.Binomial())results = glm_train.fit()probs = results.predict(exog=X_test)labels = np.array(['Down']*252)labels[probs>0.5] ='Up'confusion_table(labels, L_test)Out[19]:Truth Down UpPredictedDown 35 35Up 76 106Let’s evaluate the overall accuracy as well as the accuracy within thedays when logistic regression predicts an increase.In[20]:(35+106)/252,106/(106+76)Out[20]:(0.5595, 0.5824)Now the results appear to be a little better: 56% of the daily movementshave been correctly predicted. It is worth noting that in this case, a muchsimpler strategy of predicting that the market will increase every day willalso be correct 56% of the time! Hence, in terms of overall error rate, thelogistic regression method is no better than the naive approach. However,the confusion matrix shows that on days when logistic regression predictsan increase in the market, it has a 58% accuracy rate. This suggests apossible trading strategy of buying on days when the model predicts an in-creasing market, and avoiding trades on days when a decrease is predicted.Of course one would need to investigate more carefully whether this smallimprovement was real or just due to random chance.Suppose that we want to predict the returns associated with particularvalues ofLag1andLag2. In particular, we want to predictDirectionon aday whenLag1andLag2equal1.2and1.1, respectively, and on a day whenthey equal1.5and−0.8. We do this using thepredict()function.In[21]:newdata = pd.DataFrame({'Lag1':[1.2, 1.5],'Lag2':[1.1, -0.8]}); 4.7 Lab: Logistic Regression, LDA, QDA, and KNN 179 newX = model.transform(newdata) results.predict(newX) Out[21]: 00 . 4 7 9 1", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 219, "start_word": 70080, "end_word": 70480, "chunk_words": 400}}, "ISLP_website::c000220": {"text": "days when a decrease is predicted.Of course one would need to investigate more carefully whether this smallimprovement was real or just due to random chance.Suppose that we want to predict the returns associated with particularvalues ofLag1andLag2. In particular, we want to predictDirectionon aday whenLag1andLag2equal1.2and1.1, respectively, and on a day whenthey equal1.5and−0.8. We do this using thepredict()function.In[21]:newdata = pd.DataFrame({'Lag1':[1.2, 1.5],'Lag2':[1.1, -0.8]}); 4.7 Lab: Logistic Regression, LDA, QDA, and KNN 179 newX = model.transform(newdata) results.predict(newX) Out[21]: 00 . 4 7 9 1 10 . 4 9 6 1 dtype: float64 4.7.3 Linear Discriminant Analysis We begin by performing LDA on the Smarket data, using the function LinearDiscriminantAnalysis() , which we have abbreviated LDA(). We fitLinear Discriminant Analysis()the model using only the observations before 2005. In[22]: lda = LDA(store_covariance=True) Since the LDAestimator automatically adds an intercept, we should re- movethecolumncorrespondingtotheinterceptinboth X_trainandX_test. We can also directly use the labels rather than the Boolean vectors y_train. In[23]: X_train, X_test = [M.drop(columns=[ 'intercept' ]) for M in [X_train, X_test]] lda.fit(X_train, L_train) Out[23]: LinearDiscriminantAnalysis(store_covariance=True) Here we have used the list comprehensions introduced in Section 3.6.4. Looking at our first line above, we see that the right-hand side is a list of length two. This is because the code for M in [X_train, X_test] iterates over a list of length two. While here we loop over a list, the list comprehen- sion method works when looping over any iterable object. We then apply thedrop()method to each element in the iteration, collecting the result.drop()in a list. The left-hand side tells Pythonto unpack this list of length two, assigning its elements to the variables X_trainandX_test. Of course, this overwrites the previous values of X_trainandX_test. Having fit the model, we can extract the means in the two classes with themeans_attribute. These are the average of each predictor within each class, and are used by LDA as estimates of µk. These suggest that there is a tendency for the previous 2 days’ returns to be negative on days when the market increases, and a tendency for the previous days’ returns to be positive on days when the market declines. In[24]: lda.means_ Out[24]: array([[ 0.04, 0.03], [-0.04, -0.03]]) Theestimated prior probabilities are stored in the priors_attribute.The package sklearntypicallyusesthistrailing _todenoteaquantityestimated when using the fit()method. We can be sure of which entry corresponds to which label by looking at the classes_ attribute. In[25]: lda.classes_ Out[25]: array([ 'Down','Up'], dtype= '<U4') 180 4. Classification The LDA output", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 220, "start_word": 70400, "end_word": 70800, "chunk_words": 400}}, "ISLP_website::c000221": {"text": "returns to be negative on days when the market increases, and a tendency for the previous days’ returns to be positive on days when the market declines. In[24]: lda.means_ Out[24]: array([[ 0.04, 0.03], [-0.04, -0.03]]) Theestimated prior probabilities are stored in the priors_attribute.The package sklearntypicallyusesthistrailing _todenoteaquantityestimated when using the fit()method. We can be sure of which entry corresponds to which label by looking at the classes_ attribute. In[25]: lda.classes_ Out[25]: array([ 'Down','Up'], dtype= '<U4') 180 4. Classification The LDA output indicates that ˆπDown=0.492andˆπUp=0.508. In[26]: lda.priors_ Out[26]: array([0.492, 0.508]) The linear discriminant vectors can be found in the scalings_ attribute: In[27]: lda.scalings_ Out[27]: array([[-0.642], [-0.513]]) These values provide the linear combination of Lag1andLag2that are used to form the LDA decision rule. In other words, these are the multipliers of the elements of X=xin (4.24). If−0.64×Lag1−0.51×Lag2is large, then the LDA classifier will predict a market increase, and if it is small, then the LDA classifier will predict a market decline. In[28]: lda_pred = lda.predict(X_test) As we observed in our comparison of classification methods (Section 4.5), the LDA and logistic regression predictions are almost identical. In[29]: confusion_table(lda_pred, L_test) Out[29]: Truth Down Up Predicted Down 35 35 Up 76 106 We can also estimate the probability of each class for each point in a training set. Applying a 50% threshold to the posterior probabilities of be- ing in class one allows us to recreate the predictions contained in lda_pred . In[30]: lda_prob = lda.predict_proba(X_test) np.all( np.where(lda_prob[:,1] >= 0.5, 'Up','Down')= =l d a _ p r e d ) Out[30]: True Above, we used the np.where() function that creates an array with valuenp.where()'Up'for indices where the second column of lda_prob (the estimated poste- rior probability of 'Up') is greater than 0.5. For problems with more than two classes the labels are chosen as the class whose posterior probability is highest: In[31]: np.all( [lda.classes_[i] for i in np.argmax(lda_prob, 1)] == lda_pred ) Out[31]: True If we wanted to use a posterior probability threshold other than 50% in order to make predictions, then we could easily do so. For instance, suppose thatwewishtopredictamarketdecreaseonlyifweareverycertainthatthe 4.7 Lab: Logistic Regression, LDA, QDA, and KNN 181 market will indeed decrease on that day — say, if the posterior probability is at least 90%. We know that the first column of lda_prob corresponds to the label Downafter having checked the classes_ attribute, hence we use the column index 0 rather than 1 as", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 221, "start_word": 70720, "end_word": 71120, "chunk_words": 400}}, "ISLP_website::c000222": {"text": "wanted to use a posterior probability threshold other than 50% in order to make predictions, then we could easily do so. For instance, suppose thatwewishtopredictamarketdecreaseonlyifweareverycertainthatthe 4.7 Lab: Logistic Regression, LDA, QDA, and KNN 181 market will indeed decrease on that day — say, if the posterior probability is at least 90%. We know that the first column of lda_prob corresponds to the label Downafter having checked the classes_ attribute, hence we use the column index 0 rather than 1 as we did above. In[32]: np.sum(lda_prob[:,0] > 0.9) Out[32]: 0 No days in 2005 meet that threshold! In fact, the greatest posterior prob- ability of decrease in all of 2005 was 52.02%. TheLDAclassifieraboveisthefirstclassifierfromthe sklearnlibrary.We willuseseveralotherobjectsfromthislibrary.Theobjectsfollowacommon structure that simplifies tasks such as cross-validation, which we will see in Chapter 5. Specifically, the methods first create a generic classifier without referring to any data. This classifier is then fit to data with the fit() method and predictions are always produced with the predict() method. This pattern of first instantiating the classifier, followed by fitting it, and then producing predictions is an explicit design choice of sklearn. This uniformity makes it possible to cleanly copy the classifier so that it can be fit on different data; e.g. different training sets arising in cross-validation. This standard pattern also allows for a predictable formation of workflows. 4.7.4 Quadratic Discriminant Analysis We will now fit a QDA model to the Smarketdata. QDA is implemented viaQuadraticDiscriminantAnalysis() in thesklearnpackage, which we ab-Quadratic Discriminant Analysis()breviate to QDA(). The syntax is very similar to LDA(). In[33]: qda = QDA(store_covariance=True) qda.fit(X_train, L_train) Out[33]: QuadraticDiscriminantAnalysis(store_covariance=True) TheQDA()function will again compute means_andpriors_. In[34]: qda.means_, qda.priors_ Out[34]: (array([[ 0.04279022, 0.03389409], [-0.03954635, -0.03132544]]), array([0.49198397, 0.50801603])) TheQDA()classifier will estimate one covariance per class. Here is the estimated covariance in the first class: In[35]: qda.covariance_[0] Out[35]: array([[ 1.50662277, -0.03924806], [-0.03924806, 1.53559498]]) The output contains the group means. But it does not contain the coef- ficients of the linear discriminants, because the QDA classifier involves a quadratic, rather than a linear, function of the predictors. The predict() function works in exactly the same fashion as for LDA. 182 4. ClassificationIn[36]:qda_pred = qda.predict(X_test)confusion_table(qda_pred, L_test)Out[36]:Truth Down UpPredictedDown 30 20Up 81 121Interestingly, the QDA predictions are accurate almost 60% of the time,even though the 2005 data was not used to fit the model.In[37]:np.mean(qda_pred == L_test)Out[37]:0.599This level of accuracy is quite impressive for stock market data, whichis known to be quite hard to model", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 222, "start_word": 71040, "end_word": 71440, "chunk_words": 400}}, "ISLP_website::c000223": {"text": "because the QDA classifier involves a quadratic, rather than a linear, function of the predictors. The predict() function works in exactly the same fashion as for LDA. 182 4. ClassificationIn[36]:qda_pred = qda.predict(X_test)confusion_table(qda_pred, L_test)Out[36]:Truth Down UpPredictedDown 30 20Up 81 121Interestingly, the QDA predictions are accurate almost 60% of the time,even though the 2005 data was not used to fit the model.In[37]:np.mean(qda_pred == L_test)Out[37]:0.599This level of accuracy is quite impressive for stock market data, whichis known to be quite hard to model accurately. This suggests that thequadratic form assumed by QDA may capture the true relationship moreaccurately than the linear forms assumed by LDA and logistic regression.However, we recommend evaluating this method’s performance on a largertest set before betting that this approach will consistently beat the market!4.7.5 Naive BayesNext, we fit a naive Bayes model to theSmarketdata. The syntax is similarto that ofLDA()andQDA(). By default, this implementationGaussianNB()ofGaussianNB()the naive Bayes classifier models each quantitative feature using a Gaussiandistribution. However, a kernel density method can also be used to estimatethe distributions.In[38]:NB = GaussianNB()NB.fit(X_train, L_train)Out[38]:GaussianNB()The classes are stored asclasses_.In[39]:NB.classes_Out[39]:array(['Down','Up'], dtype='<U4')The class prior probabilities are stored in theclass_prior_attribute.In[40]:NB.class_prior_Out[40]:array([0.49, 0.51])The parameters of the features can be found in thetheta_andvar_attributes. The number of rows is equal to the number of classes, while thenumber of columns is equal to the number of features. We see below thatthe mean for featureLag1in theDownclass is 0.043.In[41]:NB.theta_Out[41]:array([[ 0.043, 0.034],[-0.040, -0.031]]) 4.7 Lab: Logistic Regression, LDA, QDA, and KNN 183 Its variance is 1.503. In[42]: NB.var_ Out[42]: array([[1.503, 1.532], [1.514, 1.487]]) How do we know the names of these attributes? We use NB?(or?NB). We can easily verify the mean computation: In[43]: X_train[L_train == 'Down'].mean() Out[43]: Lag1 0.042790 Lag2 0.033894 dtype: float64 Similarly for the variance: In[44]: X_train[L_train == 'Down'].var(ddof=0) Out[44]: Lag1 1.503554 Lag2 1.532467 dtype: float64 TheGaussianNB() function calculates variances using the 1/nformula.6 SinceNB()is a classifier in the sklearnlibrary, making predictions uses the same syntax as for LDA()andQDA()above. In[45]: nb_labels = NB.predict(X_test) confusion_table(nb_labels, L_test) Out[45]: Truth Down Up Predicted Down 29 20 Up 82 121 Naive Bayes performs well on these data, with accurate predictions over 59% of the time. This is slightly worse than QDA, but much better than LDA. As forLDA, thepredict_proba() method estimates the probability that each observation belongs to a particular class. In[46]: NB.predict_proba(X_test)[:5] Out[46]: array([[0.4873, 0.5127], [0.4762, 0.5238], [0.4653, 0.5347], [0.4748, 0.5252], [0.4902, 0.5098]]) 4.7.6 K-Nearest Neighbors WewillnowperformKNNusingthe KNeighborsClassifier() function.ThisKNeighbors Classifier() 6There are two formulas for computing the sample", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 223, "start_word": 71360, "end_word": 71760, "chunk_words": 400}}, "ISLP_website::c000224": {"text": "Out[45]: Truth Down Up Predicted Down 29 20 Up 82 121 Naive Bayes performs well on these data, with accurate predictions over 59% of the time. This is slightly worse than QDA, but much better than LDA. As forLDA, thepredict_proba() method estimates the probability that each observation belongs to a particular class. In[46]: NB.predict_proba(X_test)[:5] Out[46]: array([[0.4873, 0.5127], [0.4762, 0.5238], [0.4653, 0.5347], [0.4748, 0.5252], [0.4902, 0.5098]]) 4.7.6 K-Nearest Neighbors WewillnowperformKNNusingthe KNeighborsClassifier() function.ThisKNeighbors Classifier() 6There are two formulas for computing the sample variance of nobservations x1,...,x n:1 n/summationtextn i=1(xi−¯x)2and1 n−1/summationtextn i=1(xi−¯x)2where¯xis the sample mean. In most cases the distinction is not important. 184 4. Classificationfunction works similarly to the other model-fitting functions that we haveencountered thus far.As is the case for LDA and QDA, we fit the classifier using thefitmethod.Newpredictionsareformedusingthepredictmethodoftheobjectreturned byfit().In[47]:knn1 = KNeighborsClassifier(n_neighbors=1)knn1.fit(X_train, L_train)knn1_pred = knn1.predict(X_test)confusion_table(knn1_pred, L_test)Out[47]:Truth Down UpPredictedDown 43 58Up 68 83The results usingK=1are not very good, since only50%of the observa-tions are correctly predicted. Of course, it may be thatK=1results in anoverly-flexible fit to the data.In[48]:(83+43)/252, np.mean(knn1_pred == L_test)Out[48]:(0.5, 0.5)We repeat the analysis below usingK=3.In[49]:knn3 = KNeighborsClassifier(n_neighbors=3)knn3_pred = knn3.fit(X_train, L_train).predict(X_test)np.mean(knn3_pred == L_test)Out[49]:0.532The results have improved slightly. But increasingKfurther provides nofurther improvements. It appears that for these data, and this train/testsplit, QDA gives the best results of the methods that we have examined sofar.KNNdoesnotperformwellontheSmarketdata,butitoftendoesprovideimpressive results. As an example we will apply the KNN approach to theCaravandata set, which is part of theISLPlibrary. This data set includes 85predictors that measure demographic characteristics for 5,822 individuals.The response variable isPurchase, which indicates whether or not a givenindividual purchases a caravan insurance policy. In this data set, only 6%of people purchased caravan insurance.In[50]:Caravan = load_data('Caravan')Purchase = Caravan.PurchasePurchase.value_counts()Out[50]:No 5474Yes 348Name: Purchase, dtype: int64The methodvalue_counts()takes apd.Seriesorpd.DataFrameand re-turns apd.Serieswith the corresponding counts for each unique element.In this casePurchasehas onlyYesandNovalues and returns how manyvalues of each there are. 4.7 Lab: Logistic Regression, LDA, QDA, and KNN 185In[51]:348 / 5822Out[51]:0.0598Our features will include all columns exceptPurchase.In[52]:feature_df = Caravan.drop(columns=['Purchase'])Because the KNN classifier predicts the class of a given test observa-tion by identifying the observations that are nearest to it, the scale ofthe variables matters. Any variables that are on a large scale will have amuch larger effect on thedistancebetween the observations, and hence onthe KNN classifier, than variables that are on a small scale. For instance,imagine a data set that contains two variables,salaryandage(measuredin dollars and years, respectively). As far as KNN is concerned, a differenceof 1,000 USD in salary is enormous compared", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 224, "start_word": 71680, "end_word": 72080, "chunk_words": 400}}, "ISLP_website::c000225": {"text": "predicts the class of a given test observa-tion by identifying the observations that are nearest to it, the scale ofthe variables matters. Any variables that are on a large scale will have amuch larger effect on thedistancebetween the observations, and hence onthe KNN classifier, than variables that are on a small scale. For instance,imagine a data set that contains two variables,salaryandage(measuredin dollars and years, respectively). As far as KNN is concerned, a differenceof 1,000 USD in salary is enormous compared to a difference of 50 years inage. Consequently,salarywill drive the KNN classification results, andagewill have almost no effect. This is contrary to our intuition that a salarydifference of 1,000 USD is quite small compared to an age difference of 50years. Furthermore, the importance of scale to the KNN classifier leads toanother issue: if we measuredsalaryin Japanese yen, or if we measuredagein minutes, then we’d get quite different classification results from what weget if these two variables are measured in dollars and years.A good way to handle this problem is tostandardizethe data so that allstandardizevariables are given a mean of zero and a standard deviation of one. Thenall variables will be on a comparable scale. This is accomplished using theStandardScaler()transformation.StandardScaler()In[53]:scaler = StandardScaler(with_mean=True,with_std=True,copy=True)The argumentwith_meanindicates whether or not we should subtract themean, whilewith_stdindicates whether or not we should scale the columnsto have standard deviation of 1 or not. Finally, the argumentcopy=Truein-dicates that we will always copy data, rather than trying to do calculationsin place where possible.This transformation can be fit and then applied to arbitrary data. In thefirst line below, the parameters for the scaling are computed and storedinscaler, while the second line actually constructs the standardized set offeatures.In[54]:scaler.fit(feature_df)X_std = scaler.transform(feature_df)Now every column offeature_stdbelow has a standard deviation of oneand a mean of zero.In[55]:feature_std = pd.DataFrame(X_std,columns=feature_df.columns);feature_std.std()Out[55]:MOSTYPE 1.000086MAANTHUI 1.000086 186 4. Classification MGEMOMV 1.000086 MGEMLEEF 1.000086 MOSHOOFD 1.000086 ... AZEILPL 1.000086 APLEZIER 1.000086 AFIETS 1.000086 AINBOED 1.000086 ABYSTAND 1.000086 Length: 85, dtype: float64 Notice that the standard deviations are not quite 1here; this is again due to some procedures using the 1/nconvention for variances (in this case scaler() ), while others use 1/(n−1)(thestd()method). See the footnote.std()on page183. In this case it does not matter, as long as the variables are all on the same scale. Usingthefunction train_test_split() wenowsplittheobservationsintotrain_test_ split() a test set, containing 1000 observations, and a training set containing the remaining observations. The argument random_state=0 ensures that we get the same split each", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 225, "start_word": 72000, "end_word": 72400, "chunk_words": 400}}, "ISLP_website::c000226": {"text": "that the standard deviations are not quite 1here; this is again due to some procedures using the 1/nconvention for variances (in this case scaler() ), while others use 1/(n−1)(thestd()method). See the footnote.std()on page183. In this case it does not matter, as long as the variables are all on the same scale. Usingthefunction train_test_split() wenowsplittheobservationsintotrain_test_ split() a test set, containing 1000 observations, and a training set containing the remaining observations. The argument random_state=0 ensures that we get the same split each time we rerun the code. In[56]: (X_train, X_test, y_train, y_test) = train_test_split(feature_std, Purchase, test_size=1000, random_state=0) ?train_test_split reveals that the non-keyword arguments can be lists, arrays,pandas dataframes etc that all have the same length ( shape[0] ) and hence are indexable . In this case they are the dataframe feature_std andindexablethe response variable Purchase . We fit a KNN model on the training data usingK=1, and evaluate its performance on the test data. In[57]: knn1 = KNeighborsClassifier(n_neighbors=1) knn1_pred = knn1.fit(X_train, y_train).predict(X_test) np.mean(y_test != knn1_pred), np.mean(y_test != \"No\") Out[57]: (0.111, 0.067) The KNN error rate on the 1,000 test observations is about 11%. At first glance, this may appear to be fairly good. However, since just over 6% of customers purchased insurance, we could get the error rate down to almost 6% by always predicting Noregardless of the values of the predictors! This is known as the null rate.null rateSuppose that there is some non-trivial cost to trying to sell insurance to a given individual. For instance, perhaps a salesperson must visit each potential customer. If the company tries to sell insurance to a random selection of customers, then the success rate will be only 6%, which may be far too low given the costs involved. Instead, the company would like to try to sell insurance only to customers who are likely to buy it. So the overall error rate is not of interest. Instead, the fraction of individuals that are correctly predicted to buy insurance is of interest. In[58]: confusion_table(knn1_pred, y_test) 4.7 Lab: Logistic Regression, LDA, QDA, and KNN 187 Out[58]: Truth No Yes Predicted No 880 58 Yes 53 9 It turns out that KNN with K=1does far better than random guessing among the customers that are predicted to buy insurance. Among 62 such customers, 9, or 14.5%, actually do purchase insurance. This is double the rate that one would obtain from random guessing. In[59]: 9/(53+9) Out[59]: 0.145 Tuning Parameters", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 226, "start_word": 72320, "end_word": 72720, "chunk_words": 400}}, "ISLP_website::c000227": {"text": "predicted to buy insurance is of interest. In[58]: confusion_table(knn1_pred, y_test) 4.7 Lab: Logistic Regression, LDA, QDA, and KNN 187 Out[58]: Truth No Yes Predicted No 880 58 Yes 53 9 It turns out that KNN with K=1does far better than random guessing among the customers that are predicted to buy insurance. Among 62 such customers, 9, or 14.5%, actually do purchase insurance. This is double the rate that one would obtain from random guessing. In[59]: 9/(53+9) Out[59]: 0.145 Tuning Parameters The number of neighbors in KNN is referred to as a tuning parameter , alsotuning parameterreferred to as a hyperparameter . We do not know a priori what value to hyper- parameteruse. It is therefore of interest to see how the classifier performs on test data as we vary these parameters. This can be achieved with a forloop, described in Section 2.3.8. Here we use a for loop to look at the accuracy of our classifier in the group predicted to purchase insurance as we vary the number of neighbors from 1 to 5: In[60]: for K in range(1,6): knn = KNeighborsClassifier(n_neighbors=K) knn_pred = knn.fit(X_train, y_train).predict(X_test) C=c o n f u s i o n _ t a b l e ( k n n _ p r e d ,y _ t e s t ) templ = ( 'K={0:d}: # predicted to rent: {1:>2},' + '# w h o d i d r e n t { 2 : d } , a c c u r a c y { 3 : . 1 % } ' ) pred = C.loc[ 'Yes'].sum() did_rent = C.loc[ 'Yes','Yes'] print(templ.format( K, pred, did_rent, did_rent / pred)) K=1:#p r e d i c t e dt or e n t :6 2 , #w h od i dr e n t9 ,a c c u r a c y1 4 . 5 % K=2:#p r e d i c t e dt or e n t :6 , #w h od i dr e n t1 ,a c c u r a c y1 6 . 7 % K=3:#p r e d i c t e dt or e n t :2 0 , #w h od i dr e n t3 ,a c c u r a c y1 5 . 0 % K=4:#p r e d i c t e dt or e n t :3 , #w h", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 227, "start_word": 72640, "end_word": 73040, "chunk_words": 400}}, "ISLP_website::c000228": {"text": "dt or e n t :6 , #w h od i dr e n t1 ,a c c u r a c y1 6 . 7 % K=3:#p r e d i c t e dt or e n t :2 0 , #w h od i dr e n t3 ,a c c u r a c y1 5 . 0 % K=4:#p r e d i c t e dt or e n t :3 , #w h od i dr e n t0 ,a c c u r a c y0 . 0 % K=5:#p r e d i c t e dt or e n t :7 , #w h od i dr e n t1 ,a c c u r a c y1 4 . 3 % We see some variability — the numbers for K=4are very different from the rest. Comparison to Logistic Regression As a comparison, we can also fit a logistic regression model to the data. This can also be done with sklearn, though by default it fits something like theridge regression version of logistic regression, which we introduce in Chapter 6. This can be modified by appropriately setting the argument Cbelow. Its default value is 1 but by setting it to a very large number, the algorithm converges to the same solution as the usual (unregularized) logistic regression estimator discussed above. 188 4. Classification Unlike the statsmodels package, sklearnfocuses less on inference and more on classification. Hence, the summary methods seen in statsmodels and our simplified version seen with summarize are not generally available for the classifiers in sklearn. In[61]: logit = LogisticRegression(C=1e10, solver= 'liblinear' ) logit.fit(X_train, y_train) logit_pred = logit.predict_proba(X_test) logit_labels = np.where(logit_pred[:,1] > 5, 'Yes','No') confusion_table(logit_labels, y_test) Out[61]: Truth No Yes Predicted No 933 67 Yes 0 0 We used the argument solver='liblinear' above to avoid a warning with the default solver which would indicate that the algorithm does not con- verge. If we use 0.5as the predicted probability cut-off for the classifier, then we have a problem: none of the test observations are predicted to purchase insurance. However, we are not required to use a cut-off of 0.5. If we instead predict a purchase any time the predicted probability of purchase exceeds 0.25, we get much better results: we predict that 29 people will purchase insurance, and we are correct for about 31% of these people. This is", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 228, "start_word": 72960, "end_word": 73360, "chunk_words": 400}}, "ISLP_website::c000229": {"text": "not con- verge. If we use 0.5as the predicted probability cut-off for the classifier, then we have a problem: none of the test observations are predicted to purchase insurance. However, we are not required to use a cut-off of 0.5. If we instead predict a purchase any time the predicted probability of purchase exceeds 0.25, we get much better results: we predict that 29 people will purchase insurance, and we are correct for about 31% of these people. This is almost five times better than random guessing! In[62]: logit_labels = np.where(logit_pred[:,1]>0.25, 'Yes','No') confusion_table(logit_labels, y_test) Out[62]: Truth No Yes Predicted No 913 58 Yes 20 9 In[63]: 9/(20+9) Out[63]: 0.310 4.7.7 Linear and Poisson Regression on the Bikeshare Data Here we fit linear and Poisson regression models to the Bikeshare data, as described in Section 4.6. The response bikersmeasures the number of bike rentals per hour in Washington, DC in the period 2010–2012. In[64]: Bike = load_data( 'Bikeshare' ) Let’s have a peek at the dimensions and names of the variables in this dataframe. In[65]: Bike.shape, Bike.columns 4.7 Lab: Logistic Regression, LDA, QDA, and KNN 189 Out[65]: ((8645, 15), Index([ 'season' ,'mnth','day','hr','holiday' ,'weekday' , 'workingday' ,'weathersit' ,'temp','atemp' ,'hum', 'windspeed' ,'casual' ,'registered' ,'bikers' ], dtype='object' )) Linear Regression We begin by fitting a linear regression model to the data. In[66]: X=M S ( [ 'mnth', 'hr', 'workingday' , 'temp', 'weathersit' ]).fit_transform(Bike) Y=B i k e [ 'bikers' ] M_lm = sm.OLS(Y, X).fit() summarize(M_lm) Out[66]: coef std err t P>|t| intercept -68.6317 5.307 -12.932 0.000 mnth[Feb] 6.8452 4.287 1.597 0.110 mnth[March] 16.5514 4.301 3.848 0.000 mnth[April] 41.4249 4.972 8.331 0.000 mnth[May] 72.5571 5.641 12.862 0.000 mnth[June] 67.8187 6.544 10.364 0.000 mnth[July] 45.3245 7.081 6.401 0.000 mnth[Aug] 53.2430 6.640 8.019 0.000 mnth[Sept] 66.6783 5.925 11.254 0.000 mnth[Oct] 75.8343 4.950 15.319 0.000 mnth[Nov] 60.3100 4.610 13.083 0.000 mnth[Dec] 46.4577 4.271 10.878 0.000 hr[1] -14.5793 5.699 -2.558 0.011 hr[2] -21.5791 5.733 -3.764 0.000 hr[3] -31.1408 5.778 -5.389 0.000 ..... ....... ..... ..... ..... There are 24 levels in hrand 40 rows in all, so we have truncated the summary. In M_lm, the first levels hr[0]andmnth[Jan] are treated as the baseline values, and so no coefficient estimates are provided for them: im- plicitly,theircoefficientestimatesarezero,andallotherlevelsaremeasured relative to these baselines. For example, the Feb coefficient of 6.845signi- fies that, holding all other variables constant, there are on average about 7 more riders in February than in January. Similarly there are", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 229, "start_word": 73280, "end_word": 73680, "chunk_words": 400}}, "ISLP_website::c000230": {"text": "-5.389 0.000 ..... ....... ..... ..... ..... There are 24 levels in hrand 40 rows in all, so we have truncated the summary. In M_lm, the first levels hr[0]andmnth[Jan] are treated as the baseline values, and so no coefficient estimates are provided for them: im- plicitly,theircoefficientestimatesarezero,andallotherlevelsaremeasured relative to these baselines. For example, the Feb coefficient of 6.845signi- fies that, holding all other variables constant, there are on average about 7 more riders in February than in January. Similarly there are about 16.5 more riders in March than in January. The results seen in Section 4.6.1used a slightly different coding of the variables hrandmnth, as follows: In[67]: hr_encode = contrast( 'hr','sum') mnth_encode = contrast( 'mnth','sum') Refitting again: In[68]: X2 = MS([mnth_encode, hr_encode, 'workingday' , 'temp', 190 4. Classification 'weathersit' ]).fit_transform(Bike) M2_lm = sm.OLS(Y, X2).fit() S2 = summarize(M2_lm) S2 Out[68]: coef std err t P>|t| intercept 73.5974 5.132 14.340 0.000 mnth[Jan] -46.0871 4.085 -11.281 0.000 mnth[Feb] -39.2419 3.539 -11.088 0.000 mnth[March] -29.5357 3.155 -9.361 0.000 mnth[April] -4.6622 2.741 -1.701 0.089 mnth[May] 26.4700 2.851 9.285 0.000 mnth[June] 21.7317 3.465 6.272 0.000 mnth[July] -0.7626 3.908 -0.195 0.845 mnth[Aug] 7.1560 3.535 2.024 0.043 mnth[Sept] 20.5912 3.046 6.761 0.000 mnth[Oct] 29.7472 2.700 11.019 0.000 mnth[Nov] 14.2229 2.860 4.972 0.000 hr[0] -96.1420 3.955 -24.307 0.000 hr[1] -110.7213 3.966 -27.916 0.000 hr[2] -117.7212 4.016 -29.310 0.000 ..... ....... ..... ...... ..... What is the difference between the two codings? In M2_lm, a coefficient esti- mate is reported for all but level 23ofhrand level Decofmnth. Importantly, inM2_lm, the (unreported) coefficient estimate for the last level of mnthis not zero: instead, it equals the negative of the sum of the coefficient esti- mates for all of the other levels. Similarly, in M2_lm, the coefficient estimate for the last level of hris the negative of the sum of the coefficient estimates for all of the other levels. This means that the coefficients of hrandmnth inM2_lmwill always sum to zero, and can be interpreted as the difference from the mean level. For example, the coefficient for January of −46.087 indicates that, holding all other variables constant, there are typically 46 fewer riders in January relative to the yearly average. It is important to realize that the choice of coding really does not matter, provided that we interpret the model output correctly in light of the coding used. For example, we see that the predictions from the linear model are the same regardless", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 230, "start_word": 73600, "end_word": 74000, "chunk_words": 400}}, "ISLP_website::c000231": {"text": "be interpreted as the difference from the mean level. For example, the coefficient for January of −46.087 indicates that, holding all other variables constant, there are typically 46 fewer riders in January relative to the yearly average. It is important to realize that the choice of coding really does not matter, provided that we interpret the model output correctly in light of the coding used. For example, we see that the predictions from the linear model are the same regardless of coding: In[69]: np.sum((M_lm.fittedvalues - M2_lm.fittedvalues)**2) Out[69]: 1.53e-20 The sum of squared differences is zero. We can also see this using the np.allclose() function:np.allclose() In[70]: np.allclose(M_lm.fittedvalues, M2_lm.fittedvalues) Out[70]: True To reproduce the left-hand side of Figure 4.13we must first obtain the coefficient estimates associated with mnth. The coefficients for January through November can be obtained directly from the M2_lmobject. The coefficient for December must be explicitly computed as the negative sum of all the other months. We first extract all the coefficients for month from the coefficients of M2_lm. 4.7 Lab: Logistic Regression, LDA, QDA, and KNN 191 In[71]: coef_month = S2[S2.index.str.contains( 'mnth')]['coef'] coef_month Out[71]: mnth[Jan] -46.0871 mnth[Feb] -39.2419 mnth[March] -29.5357 mnth[April] -4.6622 mnth[May] 26.4700 mnth[June] 21.7317 mnth[July] -0.7626 mnth[Aug] 7.1560 mnth[Sept] 20.5912 mnth[Oct] 29.7472 mnth[Nov] 14.2229 Name: coef, dtype: float64 Next, we append Decas the negative of the sum of all other months. In[72]: months = Bike[ 'mnth'].dtype.categories coef_month = pd.concat([ coef_month, pd.Series([-coef_month.sum()], index=[ 'mnth[Dec]' ]) ]) coef_month Out[72]: mnth[Jan] -46.0871 mnth[Feb] -39.2419 mnth[March] -29.5357 mnth[April] -4.6622 mnth[May] 26.4700 mnth[June] 21.7317 mnth[July] -0.7626 mnth[Aug] 7.1560 mnth[Sept] 20.5912 mnth[Oct] 29.7472 mnth[Nov] 14.2229 mnth[Dec] 0.3705 Name: coef, dtype: float64 Finally, to make the plot neater, we’ll just use the first letter of each month, which is the 6th entry of each of the labels in the index. In[73]: fig_month, ax_month = subplots(figsize=(8,8)) x_month = np.arange(coef_month.shape[0]) ax_month.plot(x_month, coef_month, marker= 'o',m s = 1 0 ) ax_month.set_xticks(x_month) ax_month.set_xticklabels([l[5] for l in coef_month.index], fontsize =20) ax_month.set_xlabel( 'Month' ,f o n t s i z e = 2 0 ) ax_month.set_ylabel( 'Coefficient' ,f o n t s i z e = 2 0 ) ; Reproducing the right-hand plot in Figure 4.13follows a similar process. In[74]: coef_hr = S2[S2.index.str.contains( 'hr')]['coef'] coef_hr = coef_hr.reindex([ 'hr[{0}]' .format(h) for h in range(23)]) coef_hr = pd.concat([coef_hr, 192 4. Classification pd.Series([-coef_hr.sum()], index=[ 'hr[23]' ]) ]) We now make the hour plot. In[75]: fig_hr, ax_hr = subplots(figsize=(8,8)) x_hr = np.arange(coef_hr.shape[0]) ax_hr.plot(x_hr,", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 231, "start_word": 73920, "end_word": 74320, "chunk_words": 400}}, "ISLP_website::c000232": {"text": "=20) ax_month.set_xlabel( 'Month' ,f o n t s i z e = 2 0 ) ax_month.set_ylabel( 'Coefficient' ,f o n t s i z e = 2 0 ) ; Reproducing the right-hand plot in Figure 4.13follows a similar process. In[74]: coef_hr = S2[S2.index.str.contains( 'hr')]['coef'] coef_hr = coef_hr.reindex([ 'hr[{0}]' .format(h) for h in range(23)]) coef_hr = pd.concat([coef_hr, 192 4. Classification pd.Series([-coef_hr.sum()], index=[ 'hr[23]' ]) ]) We now make the hour plot. In[75]: fig_hr, ax_hr = subplots(figsize=(8,8)) x_hr = np.arange(coef_hr.shape[0]) ax_hr.plot(x_hr, coef_hr, marker= 'o',m s = 1 0 ) ax_hr.set_xticks(x_hr[::2]) ax_hr.set_xticklabels(range(24)[::2], fontsize=20) ax_hr.set_xlabel( 'Hour',f o n t s i z e = 2 0 ) ax_hr.set_ylabel( 'Coefficient' ,f o n t s i z e = 2 0 ) ; Poisson Regression Now we fit instead a Poisson regression model to the Bikeshare data. Very little changes, except that we now use the function sm.GLM() with the Pois- son family specified: In[76]: M_pois = sm.GLM(Y, X2, family=sm.families.Poisson()).fit() We can plot the coefficients associated with mnthandhr, in order to reproduce Figure 4.15. We first complete these coefficients as before. In[77]: S_pois = summarize(M_pois) coef_month = S_pois[S_pois.index.str.contains( 'mnth')]['coef'] coef_month = pd.concat([coef_month, pd.Series([-coef_month.sum()], index=[ 'mnth[Dec]' ])]) coef_hr = S_pois[S_pois.index.str.contains( 'hr')]['coef'] coef_hr = pd.concat([coef_hr, pd.Series([-coef_hr.sum()], index=[ 'hr[23]' ])]) The plotting is as before. In[78]: fig_pois, (ax_month, ax_hr) = subplots(1, 2, figsize=(16,8)) ax_month.plot(x_month, coef_month, marker= 'o',m s = 1 0 ) ax_month.set_xticks(x_month) ax_month.set_xticklabels([l[5] for l in coef_month.index], fontsize =20) ax_month.set_xlabel( 'Month' ,f o n t s i z e = 2 0 ) ax_month.set_ylabel( 'Coefficient' ,f o n t s i z e = 2 0 ) ax_hr.plot(x_hr, coef_hr, marker= 'o',m s = 1 0 ) ax_hr.set_xticklabels(range(24)[::2], fontsize=20) ax_hr.set_xlabel( 'Hour',f o n t s i z e = 2 0 ) ax_hr.set_ylabel( 'Coefficient' ,f o n t s i z e = 2 0 ) ; Wecomparethefittedvaluesofthetwomodels.Thefittedvaluesarestored in thefittedvalues attribute returned by the fit()method for both the linear regression and the Poisson fits. The linear predictors are stored as the attribute lin_pred . In[79]: fig, ax = subplots(figsize=(8, 8)) ax.scatter(M2_lm.fittedvalues, M_pois.fittedvalues, s=20) ax.set_xlabel( 'Linear Regression Fit' ,f o n t s i z e = 2 0 ) 4.8 Exercises 193 ax.set_ylabel( 'Poisson Regression Fit' ,f o n t s i z e = 2 0 ) ax.axline([0,0], c= 'black' ,l i n e w i d t h = 3 , linestyle= '--',s l o p e = 1 ) ; The predictions from the", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 232, "start_word": 74240, "end_word": 74640, "chunk_words": 400}}, "ISLP_website::c000233": {"text": "are stored as the attribute lin_pred . In[79]: fig, ax = subplots(figsize=(8, 8)) ax.scatter(M2_lm.fittedvalues, M_pois.fittedvalues, s=20) ax.set_xlabel( 'Linear Regression Fit' ,f o n t s i z e = 2 0 ) 4.8 Exercises 193 ax.set_ylabel( 'Poisson Regression Fit' ,f o n t s i z e = 2 0 ) ax.axline([0,0], c= 'black' ,l i n e w i d t h = 3 , linestyle= '--',s l o p e = 1 ) ; The predictions from the Poisson regression model are correlated with those from the linear model; however, the former are non-negative. As a result the Poisson regression predictions tend to be larger than those from the linear model for either very low or very high levels of ridership. In this section, we fit Poisson regression models using the sm.GLM() func- tion with the argument family=sm.families.Poisson() . Earlier in this lab we used the sm.GLM() function with family=sm.families.Binomial() to per- form logistic regression. Other choices for the familyargument can be used to fit other types of GLMs. For instance, family=sm.families.Gamma() fits a Gamma regression model. 4.8 Exercises Conceptual 1. Using a little bit of algebra, prove that ( 4.2) is equivalent to ( 4.3). In other words, the logistic function representation and logit represen- tation for the logistic regression model are equivalent. 2. It was stated in the text that classifying an observation to the class for which ( 4.17) is largest is equivalent to classifying an observation to the class for which ( 4.18) is largest. Prove that this is the case. In other words, under the assumption that the observations in the kth class are drawn from a N(µk,σ2)distribution, the Bayes classifier assignsanobservationtotheclassforwhichthediscriminantfunction is maximized. 3. This problem relates to the QDA model, in which the observations within each class are drawn from a normal distribution with a class- specific mean vector and a class specific covariance matrix. We con- sider the simple case where p=1; i.e. there is only one feature. Suppose that we have Kclasses, and that if an observation belongs to thekth class then Xcomes from a one-dimensional normal dis- tribution, X∼N(µk,σ2 k). Recall that the density function for the one-dimensional normal distribution is given in ( 4.16). Prove that in this case, the Bayes classifier is notlinear. Argue that it is in fact quadratic. Hint: For this problem, you should follow the arguments laid out in Section4.4.1, but without making", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 233, "start_word": 74560, "end_word": 74960, "chunk_words": 400}}, "ISLP_website::c000234": {"text": "where p=1; i.e. there is only one feature. Suppose that we have Kclasses, and that if an observation belongs to thekth class then Xcomes from a one-dimensional normal dis- tribution, X∼N(µk,σ2 k). Recall that the density function for the one-dimensional normal distribution is given in ( 4.16). Prove that in this case, the Bayes classifier is notlinear. Argue that it is in fact quadratic. Hint: For this problem, you should follow the arguments laid out in Section4.4.1, but without making the assumption that σ2 1=···=σ2 K. 4. When the number of features pis large, there tends to be a deteri- oration in the performance of KNN and other localapproaches that perform prediction using only observations that are nearthe test ob- servation for which a prediction must be made. This phenomenon is known as thecurse of dimensionality, and it ties into the fact thatcurse of di-mensionalitynon-parametric approaches often perform poorly whenpis large. Wewill now investigate this curse. 194 4. Classification(a) Suppose that we have a set of observations, each with measure-ments onp=1feature,X. We assume thatXis uniformly(evenly) distributed on[0,1]. Associated with each observationis a response value. Suppose that we wish to predict a test obser-vation’s response using only observations that are within 10% ofthe range ofXclosest to that test observation. For instance, inordertopredicttheresponseforatestobservationwithX=0.6,we will use observations in the range[0.55,0.65]. On average,what fraction of the available observations will we use to makethe prediction?(b) Now suppose that we have a set of observations, each withmeasurements onp=2features,X1andX2. We assume that(X1,X2)are uniformly distributed on[0,1]×[0,1]. We wish topredictatestobservation’sresponseusingonlyobservationsthatare within 10% of the range ofX1andwithin 10% of the rangeofX2closest to that test observation. For instance, in order topredict the response for a test observation withX1=0.6andX2=0.35, we will use observations in the range[0.55,0.65]forX1and in the range[0.3,0.4]forX2. On average, what fractionof the available observations will we use to make the prediction?(c) Now suppose that we have a set of observations onp= 100fea-tures. Again the observations are uniformly distributed on eachfeature, and again each feature ranges in value from 0 to 1. Wewish to predict a test observation’s response using observationswithin the 10% of each feature’s range that is closest to that testobservation. What fraction of the available observations will weuse to make the prediction?(d) Using your answers to parts (a)–(c), argue that a drawback ofKNN whenpis large is that there are very few training obser-vations “near” any given test observation.(e) Now suppose that we wish to make a prediction for", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 234, "start_word": 74880, "end_word": 75280, "chunk_words": 400}}, "ISLP_website::c000235": {"text": "and again each feature ranges in value from 0 to 1. Wewish to predict a test observation’s response using observationswithin the 10% of each feature’s range that is closest to that testobservation. What fraction of the available observations will weuse to make the prediction?(d) Using your answers to parts (a)–(c), argue that a drawback ofKNN whenpis large is that there are very few training obser-vations “near” any given test observation.(e) Now suppose that we wish to make a prediction for a test obser-vation by creating ap-dimensional hypercube centered aroundthe test observation that contains, on average, 10% of the train-ingobservations.Forp=1,2,and100,whatisthelengthofeachside of the hypercube? Comment on your answer.Note: A hypercube is a generalization of a cube to an arbitrarynumber of dimensions. Whenp=1, a hypercube is simply a linesegment, whenp=2it is a square, and whenp= 100it is a100-dimensional cube.5. We now examine the differences between LDA and QDA.(a) If the Bayes decision boundary is linear, do we expect LDA orQDA to perform better on the training set? On the test set?(b) If the Bayes decision boundary is non-linear, do we expect LDAor QDA to perform better on the training set? On the test set? 4.8 Exercises 195(c) In general, as the sample sizenincreases, do we expect the testprediction accuracy of QDA relative to LDA to improve, decline,or be unchanged? Why?(d) True or False: Even if the Bayes decision boundary for a givenproblem is linear, we will probably achieve a superior test er-ror rate using QDA rather than LDA because QDA is flexibleenough to model a linear decision boundary. Justify your an-swer.6. Suppose we collect data for a group of students in a statistics classwith variablesX1=hours studied,X2=undergrad GPA, andY=receive an A. We fit a logistic regression and produce estimatedcoefficient,ˆβ0=−6,ˆβ1=0.05,ˆβ2=1.(a) Estimate the probability that a student who studies for40h andhas an undergrad GPA of3.5gets an A in the class.(b) How many hours would the student in part (a) need to study tohave a 50% chance of getting an A in the class?7. Suppose that we wish to predict whether a given stock will issue adividend this year (“Yes” or “No”) based onX, last year’s percentprofit.Weexaminealargenumberofcompaniesanddiscoverthatthemean value ofXfor companies that issued a dividend was¯X= 10,while the mean for those that didn’t was¯X=0. In addition, thevariance ofXfor these two sets of companies wasˆσ2= 36. Finally,80% of companies issued dividends. Assuming thatXfollows a nor-mal distribution, predict the probability that a company will issuea dividend this year given that", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 235, "start_word": 75200, "end_word": 75600, "chunk_words": 400}}, "ISLP_website::c000236": {"text": "of getting an A in the class?7. Suppose that we wish to predict whether a given stock will issue adividend this year (“Yes” or “No”) based onX, last year’s percentprofit.Weexaminealargenumberofcompaniesanddiscoverthatthemean value ofXfor companies that issued a dividend was¯X= 10,while the mean for those that didn’t was¯X=0. In addition, thevariance ofXfor these two sets of companies wasˆσ2= 36. Finally,80% of companies issued dividends. Assuming thatXfollows a nor-mal distribution, predict the probability that a company will issuea dividend this year given that its percentage profit wasX=4lastyear.Hint: Recall that the density function for a normal random variableisf(x)=1√2πσ2e−(x−µ)2/2σ2. You will need to use Bayes’ theorem.8. Suppose that we take a data set, divide it into equally-sized trainingand test sets, and then try out two different classification procedures.First we use logistic regression and get an error rate of 20% on thetraining data and 30% on the test data. Next we use 1-nearest neigh-bors (i.e.K=1) and get an average error rate (averaged over bothtestand training data sets) of 18%. Based on these results, whichmethod should we prefer to use for classification of new observations?Why?9. This problem has to do withodds.(a) On average, what fraction of people with an odds of 0.37 ofdefaulting on their credit card payment will in fact default?(b) Suppose that an individual has a 16% chance of defaulting onher credit card payment. What are the odds that she will de-fault? 196 4. Classification 10. Equation 4.32derived an expression for log/parenleftBig Pr(Y=k|X=x) Pr(Y=K|X=x)/parenrightBig in the setting where p>1, so that the mean for the kth class, µk, is ap- dimensional vector, and the shared covariance Σis ap×pmatrix. However, in the setting with p=1,(4.32) takes a simpler form, since the means µ1,...,µ Kand the variance σ2are scalars. In this simpler setting, repeat the calculation in ( 4.32), and provide expressions for akandbkjin terms of πk,πK,µk,µK, andσ2. 11. Workoutthedetailedformsof ak,bkj,andbkjlin(4.33).Youranswer should involve πk,πK,µk,µK,Σk, andΣK. 12. Suppose that you wish to classify an observation X∈Rintoapples andoranges. You fit a logistic regression model and find that /hatwiderPr(Y=orange |X=x)=exp( ˆβ0+ˆβ1x) 1 + exp( ˆβ0+ˆβ1x). Your friend fits a logistic regression model to the same data using the softmaxformulation in ( 4.13), and finds that /hatwiderPr(Y=orange |X=x)= exp(ˆαorange 0+ˆαorange 1x) exp(ˆαorange 0+ˆαorange 1x) + exp(ˆ αapple 0+ˆαapple 1x). (a) What is the log odds of orangeversusapplein your model? (b) What is the log odds of orangeversusapplein your friend’s model? (c) Suppose that in your model, ˆβ0=2 andˆβ1=−1. What are the", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 236, "start_word": 75520, "end_word": 75920, "chunk_words": 400}}, "ISLP_website::c000237": {"text": "fit a logistic regression model and find that /hatwiderPr(Y=orange |X=x)=exp( ˆβ0+ˆβ1x) 1 + exp( ˆβ0+ˆβ1x). Your friend fits a logistic regression model to the same data using the softmaxformulation in ( 4.13), and finds that /hatwiderPr(Y=orange |X=x)= exp(ˆαorange 0+ˆαorange 1x) exp(ˆαorange 0+ˆαorange 1x) + exp(ˆ αapple 0+ˆαapple 1x). (a) What is the log odds of orangeversusapplein your model? (b) What is the log odds of orangeversusapplein your friend’s model? (c) Suppose that in your model, ˆβ0=2 andˆβ1=−1. What are the coefficient estimates in your friend’s model? Be as specific as possible. (d) Now suppose that you and your friend fit the same two models on a different data set. This time, your friend gets the coefficient estimates ˆαorange 0=1.2,ˆαorange 1=−2,ˆαorange 0=3,ˆαorange 1= 0.6. What are the coefficient estimates in your model? (e) Finally, suppose you apply both models from (d) to a data set with 2,000 test observations. What fraction of the time do you expect the predicted class labels from your model to agree with those from your friend’s model? Explain your answer. Applied 13. This question should be answered using the Weeklydata set, which is part of the ISLPpackage. This data is similar in nature to the Smarketdata from this chapter’s lab, except that it contains 1,089 weekly returns for 21 years, from the beginning of 1990 to the end of 2010. (a) Produce some numerical and graphical summaries of the Weekly data. Do there appear to be any patterns? 4.8 Exercises 197(b) Use the full data set to perform a logistic regression withDirectionas the response and the five lag variables plusVolumeas predictors. Use the summary function to print the results. Doany of the predictors appear to be statistically significant? If so,which ones?(c) Compute the confusion matrix and overall fraction of correctpredictions. Explain what the confusion matrix is telling youabout the types of mistakes made by logistic regression.(d) Nowfitthelogisticregressionmodelusingatrainingdataperiodfrom 1990 to 2008, withLag2as the only predictor. Compute theconfusion matrix and the overall fraction of correct predictionsfor the held out data (that is, the data from 2009 and 2010).(e) Repeat (d) using LDA.(f) Repeat (d) using QDA.(g) Repeat (d) using KNN withK=1.(h) Repeat (d) using naive Bayes.(i) Which of these methods appears to provide the best results onthis data?(j) Experiment with different combinations of predictors, includ-ing possible transformations and interactions, for each of themethods. Report the variables, method, and associated confu-sion matrix that appears to provide the best results", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 237, "start_word": 75840, "end_word": 76240, "chunk_words": 400}}, "ISLP_website::c000238": {"text": "matrix and the overall fraction of correct predictionsfor the held out data (that is, the data from 2009 and 2010).(e) Repeat (d) using LDA.(f) Repeat (d) using QDA.(g) Repeat (d) using KNN withK=1.(h) Repeat (d) using naive Bayes.(i) Which of these methods appears to provide the best results onthis data?(j) Experiment with different combinations of predictors, includ-ing possible transformations and interactions, for each of themethods. Report the variables, method, and associated confu-sion matrix that appears to provide the best results on the heldout data. Note that you should also experiment with values forKin the KNN classifier.14. In this problem, you will develop a model to predict whether a givencar gets high or low gas mileage based on theAutodata set.(a) Create a binary variable,mpg01, that contains a 1 ifmpgcontainsa value above its median, and a 0 ifmpgcontains a value belowits median. You can compute the median using themedian()method of the data frame. Note you may find it helpful to adda columnmpg01to the data frame by assignment. Assuming youhave stored the data frame asAuto, this can be done as follows:Auto['mpg01']=m p g 0 1(b) Explore the data graphically in order to investigate the associ-ation betweenmpg01and the other features. Which of the otherfeatures seem most likely to be useful in predictingmpg01? Scat-terplots and boxplots may be useful tools to answer this ques-tion. Describe your findings.(c) Split the data into a training set and a test set.(d) Perform LDA on the training data in order to predictmpg01using the variables that seemed most associated withmpg01in(b). What is the test error of the model obtained? 198 4. Classification(e) Perform QDA on the training data in order to predictmpg01using the variables that seemed most associated withmpg01in(b). What is the test error of the model obtained?(f) Perform logistic regression on the training data in order to pre-dictmpg01using the variables that seemed most associated withmpg01in (b). What is the test error of the model obtained?(g) Perform naive Bayes on the training data in order to predictmpg01usingthevariablesthatseemedmostassociatedwithmpg01in (b). What is the test error of the model obtained?(h) Perform KNN on the training data, with several values ofK, inorder to predictmpg01. Use only the variables that seemed mostassociated withmpg01in (b). What test errors do you obtain?Which value ofKseems to perform the best on this data set?15. This problem involves writing functions.(a) Write a function,Power(), that prints out the result of raising2to the3rd power. In other words, your function should compute23and print", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 238, "start_word": 76160, "end_word": 76560, "chunk_words": 400}}, "ISLP_website::c000239": {"text": "the training data in order to predictmpg01usingthevariablesthatseemedmostassociatedwithmpg01in (b). What is the test error of the model obtained?(h) Perform KNN on the training data, with several values ofK, inorder to predictmpg01. Use only the variables that seemed mostassociated withmpg01in (b). What test errors do you obtain?Which value ofKseems to perform the best on this data set?15. This problem involves writing functions.(a) Write a function,Power(), that prints out the result of raising2to the3rd power. In other words, your function should compute23and print out the results.Hint: Recall thatx**araisesxto the powera. Use theprint()function to display the result.(b) Create a new function,Power2(), that allows you to passanytwo numbers,xanda, and prints out the value ofx**a. You cando this by beginning your function with the linedef Power2(x, a):Youshouldbeabletocallyourfunctionbyentering,forinstance,Power2(3, 8)onthecommandline.Thisshouldoutputthevalueof38,namely,6,561.(c) Using thePower2()function that you just wrote, compute103,817, and1313.(d) Now create a new function,Power3(), that actuallyreturnstheresultx**aas aPythonobject, rather than simply printing itto the screen. That is, if you store the valuex**ain an objectcalledresultwithin your function, then you can simplyreturnreturnthis result, using the following line:return resultNote that the line above should be the last line in your function,and it should be indented 4 spaces.(e) Now using thePower3()function, create a plot off(x)=x2.Thex-axis should display a range of integers from1to10, andthey-axis should displayx2. Label the axes appropriately, anduse an appropriate title for the figure. Consider displaying eitherthex-axis, they-axis, or both on the log-scale. You can do thisby using theax.set_xscale()andax.set_yscale()methods of.set_xscale().set_yscale()the axes you are plotting to. 4.8 Exercises 199(f) Create a function,PlotPower(), that allows you to create a plotofxagainstx**afor a fixedaand a sequence of values ofx. Forinstance, if you callPlotPower(np.arange(1, 11), 3)then a plot should be created with anx-axis taking on values1,2,...,10, and ay-axis taking on values13,23,...,103.16. Using theBostondata set, fit classification models in order to predictwhether a given suburb has a crime rate above or below the median.Explorelogisticregression,LDA,naiveBayes,andKNNmodelsusingvarious subsets of the predictors. Describe your findings.Hint: You will have to create the response variable yourself, using thevariables that are contained in theBostondata set. 5 Resampling Methods Resampling methods are an indispensable tool in modern statistics. They involverepeatedlydrawingsamplesfromatrainingsetandrefittingamodel of interest on each sample in order to obtain additional information about thefittedmodel.Forexample,inordertoestimatethevariabilityofalinear regression fit, we can repeatedly draw different samples from the training data, fit a linear regression to each new sample, and then examine the extent to which the resulting fits differ. Such an approach may allow us to obtain information that would not be available from fitting the model only once using the", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 239, "start_word": 76480, "end_word": 76880, "chunk_words": 400}}, "ISLP_website::c000240": {"text": "5 Resampling Methods Resampling methods are an indispensable tool in modern statistics. They involverepeatedlydrawingsamplesfromatrainingsetandrefittingamodel of interest on each sample in order to obtain additional information about thefittedmodel.Forexample,inordertoestimatethevariabilityofalinear regression fit, we can repeatedly draw different samples from the training data, fit a linear regression to each new sample, and then examine the extent to which the resulting fits differ. Such an approach may allow us to obtain information that would not be available from fitting the model only once using the original training sample. Resampling approaches can be computationally expensive, because they involve fitting the same statistical method multiple times using different subsets of the training data. However, due to recent advances in computing power, the computational requirements of resampling methods generally are not prohibitive. In this chapter, we discuss two of the most commonly usedresamplingmethods, cross-validation andthebootstrap .Bothmethods are important tools in the practical application of many statistical learning procedures. For example, cross-validation can be used to estimate the test errorassociatedwithagivenstatisticallearningmethodinordertoevaluate its performance, or to select the appropriate level of flexibility. The process ofevaluatingamodel’sperformanceisknownas model assessment ,whereasmodel assessmenttheprocess of selecting theproper levelof flexibilityfora model is knownas model selection . The bootstrap is used in several contexts, most commonlymodel selectionto provide a measure of accuracy of a parameter estimate or of a given statistical learning method. © Springer Nature Switzerland AG 2023 G. James et al., An Introduction to Statistical Learning , Springer Texts in Statistics, https://doi.org/10.1007/978-3-031-38747-0_5 201 202 5. Resampling Methods 5.1 Cross-Validation In Chapter 2we discuss the distinction between the test error rate and the trainingerrorrate .Thetesterroristheaverageerrorthatresultsfromusing astatisticallearningmethodtopredicttheresponseonanewobservation— that is, a measurement that was not used in training the method. Given a data set, the use of a particular statistical learning method is warranted if it results in a low test error. The test error can be easily calculated if a designated test set is available. Unfortunately, this is usually not the case. In contrast, the training error can be easily calculated by applying the statistical learning method to the observations used in its training. But as we saw in Chapter 2, the training error rate often is quite different from the test error rate, and in particular the former can dramatically underestimate the latter. In the absence of a very large designated test set that can be used to directly estimate the test error rate, a number of techniques can be used to estimate this quantity using the", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 240, "start_word": 76800, "end_word": 77200, "chunk_words": 400}}, "ISLP_website::c000241": {"text": "be easily calculated by applying the statistical learning method to the observations used in its training. But as we saw in Chapter 2, the training error rate often is quite different from the test error rate, and in particular the former can dramatically underestimate the latter. In the absence of a very large designated test set that can be used to directly estimate the test error rate, a number of techniques can be used to estimate this quantity using the available training data. Some methods make a mathematical adjustment to the training error rate in order to estimate the test error rate. Such approaches are discussed in Chapter 6. In this section, we instead consider a class of methods that estimate the test error rate by holding out a subset of the training observations from the fitting process, and then applying the statistical learning method to those held out observations. In Sections 5.1.1–5.1.4, for simplicity we assume that we are interested in performing regression with a quantitative response. In Section 5.1.5we consider the case of classification with a qualitative response. As we will see, the key concepts remain the same regardless of whether the response is quantitative or qualitative. 5.1.1 The Validation Set Approach Suppose that we would like to estimate the test error associated with fit- ting a particular statistical learning method on a set of observations. The validation set approach , displayed in Figure 5.1, is a very simple strategyvalidation set approachfor this task. It involves randomly dividing the available set of observa- tions into two parts, a training set and avalidation set orhold-out set . Thevalidation set hold-out setmodel is fit on the training set, and the fitted model is used to predict the responsesfortheobservationsinthevalidationset.Theresultingvalidation set error rate—typically assessed using MSE in the case of a quantitative response—provides an estimate of the test error rate. Weillustratethevalidationsetapproachonthe Autodataset.Recallfrom Chapter 3that there appears to be a non-linear relationship between mpg andhorsepower , and that a model that predicts mpgusinghorsepower and horsepower2gives better results than a model that uses only a linear term. It is natural to wonder whether a cubic or higher-order fit might provide even better results. We answer this question in Chapter 3by looking at the p-values associated with a cubic term and higher-order polynomial terms in a linear regression. But we could also answer this question using the validation method. We randomly split the 392observations into", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 241, "start_word": 77120, "end_word": 77520, "chunk_words": 400}}, "ISLP_website::c000242": {"text": "mpg andhorsepower , and that a model that predicts mpgusinghorsepower and horsepower2gives better results than a model that uses only a linear term. It is natural to wonder whether a cubic or higher-order fit might provide even better results. We answer this question in Chapter 3by looking at the p-values associated with a cubic term and higher-order polynomial terms in a linear regression. But we could also answer this question using the validation method. We randomly split the 392observations into two 5.1 Cross-Validation 203/g3/g1/g4/g1/g5/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g2/g1/g6/g1/g1/g4/g4/g1/g1/g3/g5/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g7/g3/g1FIGURE 5.1. A schematic display of the validation set approach. A set of n observations are randomly split into a training set (shown in blue, containing observations 7, 22, and 13, among others) and a validation set (shown in beige, and containing observation 91, among others). The statistical learning method is fit on the training set, and its performance is evaluated on the validation set. sets, a training set containing 196of the data points, and a validation set containing the remaining 196observations. The validation set error rates that result from fitting various regression models on the training sample and evaluating their performance on the validation sample, using MSE as a measure of validation set error, are shown in the left-hand panel of Figure5.2. The validation set MSE for the quadratic fit is considerably smallerthanforthelinearfit.However,thevalidationsetMSEforthecubic fit is actually slightly larger than for the quadratic fit. This implies that including a cubic term in the regression does not lead to better prediction than simply using a quadratic term. Recall that in order to create the left-hand panel of Figure 5.2, we ran- domly divided the data set into two parts, a training set and a validation set. If we repeat the process of randomly splitting the sample set into two parts, we will get a somewhat different estimate for the test MSE. As an illustration, the right-hand panel of Figure 5.2displays ten different vali- dation set MSE curves from the Autodata set, produced using ten different random splits of the observations into training and validation sets. All ten curves indicate that the model with a quadratic term has a dramatically smaller validation set MSE than the model with only a linear term. Fur- thermore, all ten curves indicate that there is not much benefit in including cubic or higher-order polynomial terms in the model. But it is worth noting that each of the ten curves results in a different", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 242, "start_word": 77440, "end_word": 77840, "chunk_words": 400}}, "ISLP_website::c000243": {"text": "the Autodata set, produced using ten different random splits of the observations into training and validation sets. All ten curves indicate that the model with a quadratic term has a dramatically smaller validation set MSE than the model with only a linear term. Fur- thermore, all ten curves indicate that there is not much benefit in including cubic or higher-order polynomial terms in the model. But it is worth noting that each of the ten curves results in a different test MSE estimate for each of the ten regression models considered. And there is no consensus among the curves as to which model results in the smallest validation set MSE. Based on the variability among these curves, all that we can conclude with any confidence is that the linear fit is not adequate for this data. The validation set approach is conceptually simple and is easy to imple- ment. But it has two potential drawbacks: 1. As is shown in the right-hand panel of Figure 5.2, the validation esti- mate of the test error rate can be highly variable, depending on pre- cisely which observations are included in the training set and which observations are included in the validation set. 2. In the validation approach, only a subset of the observations—those that are included in the training set rather than in the validation set—are used to fit the model. Since statistical methods tend to per- form worse when trained on fewer observations, this suggests that the 204 5. Resampling Methods 2 4 6 8 1016 18 20 22 24 26 28Degree of PolynomialMean Squared Error2 4 6 8 1016 18 20 22 24 26 28Degree of PolynomialMean Squared ErrorFIGURE 5.2. The validation set approach was used on the Autodata set in order to estimate the test error that results from predicting mpgusing polynomial functions of horsepower .Left:Validation error estimates for a single split into training and validation data sets. Right:The validation method was repeated ten times, each time using a different random split of the observations into a training set and a validation set. This illustrates the variability in the estimated test MSE that results from this approach. validation set error rate may tend to overestimate the test error rate for the model fit on the entire data set. In the coming subsections, we will present cross-validation , a refinement of the validation set approach that addresses these two issues.", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 243, "start_word": 77760, "end_word": 78160, "chunk_words": 400}}, "ISLP_website::c000244": {"text": "validation method was repeated ten times, each time using a different random split of the observations into a training set and a validation set. This illustrates the variability in the estimated test MSE that results from this approach. validation set error rate may tend to overestimate the test error rate for the model fit on the entire data set. In the coming subsections, we will present cross-validation , a refinement of the validation set approach that addresses these two issues. 5.1.2 Leave-One-Out Cross-Validation Leave-one-out cross-validation (LOOCV)iscloselyrelatedtothevalidationleave-one- out cross- validationset approach of Section 5.1.1, but it attempts to address that method’s drawbacks. Like the validation set approach, LOOCV involves splitting the set of observations into two parts. However, instead of creating two subsets of comparable size, a single observation (x1,y1)is used for the validation set, and the remaining observations {(x2,y2),...,(xn,yn)}make up the training set. The statistical learning method is fit on the n−1training observations, and a prediction ˆy1is made for the excluded observation, usingitsvalue x1.Since(x1,y1)wasnotusedinthefittingprocess, MSE 1= (y1−ˆy1)2provides an approximately unbiased estimate for the test error. But even though MSE 1is unbiased for the test error, it is a poor estimate because it is highly variable, since it is based upon a single observation (x1,y1). We can repeat the procedure by selecting (x2,y2)for the validation data, training the statistical learning procedure on the n−1observations {(x1,y1),(x3,y3),...,(xn,yn)},andcomputing MSE 2=(y2−ˆy2)2.Repeat- ing this approach ntimes produces nsquared errors, MSE 1,..., MSE n. The LOOCV estimate for the test MSE is the average of these ntest error estimates: CV (n)=1 nn/summationdisplay i=1MSE i. (5.1) 5.1 Cross-Validation 205/g4/g1/g5/g1/g6/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g2/g1/g4/g1/g5/g1/g6/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g2/g1/g4/g1/g5/g1/g6/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g2/g1/g4/g1/g5/g1/g6/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g2/g1/g4/g1/g5/g1/g6/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g2/g1/g3/g1/g3/g1/g3/g1FIGURE 5.3. A schematic display of LOOCV. A set of ndata points is repeat- edly split into a training set (shown in blue) containing all but one observation, and a validation set that contains only that observation (shown in beige). The test error is then estimated by averaging the nresulting MSEs. The first training set contains all but observation 1, the second training set contains all but observation 2, and so forth. A schematic of the LOOCV approach is illustrated in Figure 5.3. LOOCV has a couple of major advantages over the validation set ap- proach. First, it has far less bias. In LOOCV, we repeatedly fit the sta- tistical learning method using training sets that contain n−1observa- tions, almost as many as are in the entire data set. This is in contrast to the validation set approach, in which", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 244, "start_word": 78080, "end_word": 78480, "chunk_words": 400}}, "ISLP_website::c000245": {"text": "the second training set contains all but observation 2, and so forth. A schematic of the LOOCV approach is illustrated in Figure 5.3. LOOCV has a couple of major advantages over the validation set ap- proach. First, it has far less bias. In LOOCV, we repeatedly fit the sta- tistical learning method using training sets that contain n−1observa- tions, almost as many as are in the entire data set. This is in contrast to the validation set approach, in which the training set is typically around half the size of the original data set. Consequently, the LOOCV approach tends not to overestimate the test error rate as much as the validation set approach does. Second, in contrast to the validation approach which will yield different results when applied repeatedly due to randomness in the training/validation set splits, performing LOOCV multiple times will always yield the same results: there is no randomness in the training/vali- dation set splits. We used LOOCV on the Autodata set in order to obtain an estimate of the test set MSE that results from fitting a linear regression model to predictmpgusingpolynomialfunctionsof horsepower .Theresultsareshown in the left-hand panel of Figure 5.4. LOOCV has the potential to be expensive to implement, since the model has to be fit ntimes. This can be very time consuming if nis large, and if each individual model is slow to fit. With least squares linear or polynomial regression, an amazing shortcut makes the cost of LOOCV the same as that of a single model fit! The following formula holds: CV (n)=1 nn/summationdisplay i=1/parenleftbiggyi−ˆyi 1−hi/parenrightbigg2 , (5.2) 206 5. Resampling Methods 2 4 6 8 1016 18 20 22 24 26 28LOOCV Degree of PolynomialMean Squared Error2 4 6 8 1016 18 20 22 24 26 2810−fold CV Degree of PolynomialMean Squared ErrorFIGURE 5.4. Cross-validation was used on the Autodata set in order to estimate the test error that results from predicting mpgusing polynomial functions ofhorsepower .Left:The LOOCV error curve. Right:10-fold CV was run nine separate times, each with a different random split of the data into ten parts. The figure shows the nine slightly different CV error curves. whereˆyiis theith fitted value from the original least squares fit, and hiis the leverage defined in ( 3.37) on page 105.1This is like the ordinary MSE, except the ith residual is divided by 1−hi. The leverage lies between 1/n and1, and reflects the amount", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 245, "start_word": 78400, "end_word": 78800, "chunk_words": 400}}, "ISLP_website::c000246": {"text": "polynomial functions ofhorsepower .Left:The LOOCV error curve. Right:10-fold CV was run nine separate times, each with a different random split of the data into ten parts. The figure shows the nine slightly different CV error curves. whereˆyiis theith fitted value from the original least squares fit, and hiis the leverage defined in ( 3.37) on page 105.1This is like the ordinary MSE, except the ith residual is divided by 1−hi. The leverage lies between 1/n and1, and reflects the amount that an observation influences its own fit. Hence the residuals for high-leverage points are inflated in this formula by exactly the right amount for this equality to hold. LOOCV is a very general method, and can be used with any kind of predictive modeling. For example we could use it with logistic regression or linear discriminant analysis, or any of the methods discussed in later chapters. The magic formula ( 5.2) does not hold in general, in which case the model has to be refit ntimes. 5.1.3k-Fold Cross-Validation An alternative to LOOCV is k-fold CV . This approach involves randomlyk-fold CVdividing the set of observations into kgroups, or folds, of approximately equal size. The first fold is treated as a validation set, and the method is fit on the remaining k−1folds. The mean squared error, MSE 1, is then computed on the observations in the held-out fold. This procedure is repeated ktimes; each time, a different group of observations is treated as a validation set. This process results in kestimates of the test error, MSE 1,MSE 2,...,MSE k. Thek-fold CV estimate is computed by averaging these values, CV (k)=1 kk/summationdisplay i=1MSE i. (5.3) Figure5.5illustrates the k-fold CV approach. 1In the case of multiple linear regression, the leverage takes a slightly more compli- cated form than ( 3.37), but (5.2) still holds. 5.1 Cross-Validation 207/g4/g1/g5/g1/g6/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g2/g1/g4/g4/g1/g10/g9/g1/g8/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g7/g10/g1/g4/g4/g1/g10/g9/g1/g8/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g7/g10/g1/g4/g4/g1/g10/g9/g1/g8/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g7/g10/g1/g4/g4/g1/g10/g9/g1/g8/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g7/g10/g1/g4/g4/g1/g10/g9/g1/g8/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g7/g10/g1/g4/g4/g1/g10/g9/g1/g8/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g7/g10/g1FIGURE 5.5. A schematic display of 5-fold CV. A set of nobservations is randomly split into five non-overlapping groups. Each of these fifths acts as a validation set (shown in beige), and the remainder as a training set (shown in blue). The test error is estimated by averaging the five resulting MSE estimates. It is not hard to see that LOOCV is a special case of k-fold CV in which k is set to equal n. In practice, one typically performs k-fold CV using k=5 ork= 10 . What is the advantage of using k=5 ork= 10", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 246, "start_word": 78720, "end_word": 79120, "chunk_words": 400}}, "ISLP_website::c000247": {"text": "non-overlapping groups. Each of these fifths acts as a validation set (shown in beige), and the remainder as a training set (shown in blue). The test error is estimated by averaging the five resulting MSE estimates. It is not hard to see that LOOCV is a special case of k-fold CV in which k is set to equal n. In practice, one typically performs k-fold CV using k=5 ork= 10 . What is the advantage of using k=5 ork= 10 rather than k=n? The most obvious advantage is computational. LOOCV requires fitting the statistical learning method ntimes. This has the potential to be computationally expensive (except for linear models fit by least squares, in which case formula ( 5.2) can be used). But cross-validation is a very general approach that can be applied to almost any statistical learning method. Some statistical learning methods have computationally intensive fitting procedures, and so performing LOOCV may pose computational problems, especially if nis extremely large. In contrast, performing 10-fold CV requires fitting the learning procedure only ten times, which may be much more feasible. As we see in Section 5.1.4, there also can be other non-computational advantages to performing 5-fold or10-fold CV, which involve the bias-variance trade-off. The right-hand panel of Figure 5.4displays nine different 10-fold CV estimates for the Autodata set, each resulting from a different random split of the observations into ten folds. As we can see from the figure, there is some variability in the CV estimates as a result of the variability in how the observations are divided into ten folds. But this variability is typically much lower than the variability in the test error estimates that results from the validation set approach (right-hand panel of Figure 5.2). When we examine real data, we do not know the truetest MSE, and so it is difficult to determine the accuracy of the cross-validation estimate. However, if we examine simulated data, then we can compute the true test MSE, and can thereby evaluate the accuracy of our cross-validation results. In Figure 5.6, we plot the cross-validation estimates and true test error rates that result from applying smoothing splines to the simulated data sets illustrated in Figures 2.9–2.11of Chapter 2. The true test MSE is displayed in blue. The black dashed and orange solid lines respectively show the estimated LOOCV and 10-fold CV estimates. In all three plots, the two cross-validation estimates are", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 247, "start_word": 79040, "end_word": 79440, "chunk_words": 400}}, "ISLP_website::c000248": {"text": "we can compute the true test MSE, and can thereby evaluate the accuracy of our cross-validation results. In Figure 5.6, we plot the cross-validation estimates and true test error rates that result from applying smoothing splines to the simulated data sets illustrated in Figures 2.9–2.11of Chapter 2. The true test MSE is displayed in blue. The black dashed and orange solid lines respectively show the estimated LOOCV and 10-fold CV estimates. In all three plots, the two cross-validation estimates are very similar. In the right-hand panel 208 5. Resampling Methods 25 10 200.0 0.5 1.0 1.5 2.0 2.5 3.0FlexibilityMean Squared Error25 10 200.0 0.5 1.0 1.5 2.02.5 3.0 FlexibilityMean Squared Error25 10 2005101520 FlexibilityMean Squared ErrorFIGURE 5.6. True and estimated test MSE for the simulated data sets in Figures2.9(left),2.10(center), and2.11(right). The true test MSE is shown in blue, the LOOCV estimate is shown as a black dashed line, and the 10-fold CV estimate is shown in orange. The crosses indicate the minimum of each of the MSE curves. of Figure 5.6, the true test MSE and the cross-validation curves are almost identical. In the center panel of Figure 5.6, the two sets of curves are similar at the lower degrees of flexibility, while the CV curves overestimate the test setMSEforhigherdegreesofflexibility.Intheleft-handpanelofFigure 5.6, the CV curves have the correct general shape, but they underestimate the true test MSE. When we perform cross-validation, our goal might be to determine how well a given statistical learning procedure can be expected to perform on independent data; in this case, the actual estimate of the test MSE is of interest. But at other times we are interested only in the location of theminimum point in the estimated test MSE curve . This is because we might be performing cross-validation on a number of statistical learning methods, or on a single method using different levels of flexibility, in order toidentifythemethodthatresultsinthelowesttesterror.Forthispurpose, the location of the minimum point in the estimated test MSE curve is important, but the actual value of the estimated test MSE is not. We find in Figure 5.6that despite the fact that they sometimes underestimate the true test MSE, all of the CV curves come close to identifying the correct levelofflexibility—thatis,theflexibilitylevelcorrespondingtothesmallest test MSE. 5.1.4 Bias-Variance Trade-Off for k-Fold Cross-Validation We mentioned in Section 5.1.3thatk-fold CV with k<n has a compu- tational advantage to LOOCV. But putting computational issues aside, a less obvious but potentially more", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 248, "start_word": 79360, "end_word": 79760, "chunk_words": 400}}, "ISLP_website::c000249": {"text": "the estimated test MSE curve is important, but the actual value of the estimated test MSE is not. We find in Figure 5.6that despite the fact that they sometimes underestimate the true test MSE, all of the CV curves come close to identifying the correct levelofflexibility—thatis,theflexibilitylevelcorrespondingtothesmallest test MSE. 5.1.4 Bias-Variance Trade-Off for k-Fold Cross-Validation We mentioned in Section 5.1.3thatk-fold CV with k<n has a compu- tational advantage to LOOCV. But putting computational issues aside, a less obvious but potentially more important advantage of k-fold CV is that it often gives more accurate estimates of the test error rate than does LOOCV. This has to do with a bias-variance trade-off. It was mentioned in Section 5.1.1that the validation set approach can lead to overestimates of the test error rate, since in this approach the training set used to fit the statistical learning method contains only half the observations of the entire data set. Using this logic, it is not hard to see 5.1 Cross-Validation 209 that LOOCV will give approximately unbiased estimates of the test error, since each training set contains n−1observations, which is almost as many as the number of observations in the full data set. And performing k-fold CV for, say, k=5 ork= 10 will lead to an intermediate level of bias, since each training set contains approximately (k−1)n/kobservations— fewer than in the LOOCV approach, but substantially more than in the validation set approach. Therefore, from the perspective of bias reduction, it is clear that LOOCV is to be preferred to k-fold CV. However, we know that bias is not the only source for concern in an esti- mating procedure; we must also consider the procedure’s variance. It turns outthatLOOCV hashigher variancethan does k-foldCVwith k<n .Why is this the case? When we perform LOOCV, we are in effect averaging the outputs of nfitted models, each of which is trained on an almost identical set of observations; therefore, these outputs are highly (positively) corre- lated with each other. In contrast, when we perform k-fold CV with k<n , we are averaging the outputs of kfitted models that are somewhat less correlated with each other, since the overlap between the training sets in each model is smaller. Since the mean of many highly correlated quantities has higher variance than does the mean of many quantities that are not as highly correlated, the test error estimate resulting from LOOCV tends to have", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 249, "start_word": 79680, "end_word": 80080, "chunk_words": 400}}, "ISLP_website::c000250": {"text": "are highly (positively) corre- lated with each other. In contrast, when we perform k-fold CV with k<n , we are averaging the outputs of kfitted models that are somewhat less correlated with each other, since the overlap between the training sets in each model is smaller. Since the mean of many highly correlated quantities has higher variance than does the mean of many quantities that are not as highly correlated, the test error estimate resulting from LOOCV tends to have higher variance than does the test error estimate resulting from k-fold CV. To summarize, there is a bias-variance trade-off associated with the choice of kink-fold cross-validation. Typically, given these considerations, one performs k-fold cross-validation using k=5ork= 10 , as these values have been shown empirically to yield test error rate estimates that suffer neither from excessively high bias nor from very high variance. 5.1.5 Cross-Validation on Classification Problems In this chapter so far, we have illustrated the use of cross-validation in the regression setting where the outcome Yis quantitative, and so have used MSE to quantify test error. But cross-validation can also be a very useful approach in the classification setting when Yis qualitative. In this setting, cross-validation works just as described earlier in this chapter, except that rather than using MSE to quantify test error, we instead use the number of misclassified observations. For instance, in the classification setting, the LOOCV error rate takes the form CV (n)=1 nn/summationdisplay i=1Err i, (5.4) whereErr i=I(yi/negationslash=ˆyi). Thek-fold CV error rate and validation set error rates are defined analogously. As an example, we fit various logistic regression models on the two- dimensional classification data displayed in Figure 2.13. In the top-left panelofFigure 5.7,theblacksolidlineshowstheestimateddecisionbound- ary resulting from fitting a standard logistic regression model to this data set. Since this is simulated data, we can compute the truetest error rate, which takes a value of 0.201and so is substantially larger than the Bayes 210 5. Resampling MethodsDegree=1ooooooooooo oooo oo ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo ooooooooo ooooooooooooooooooooooo oooooooooooo oooooooooooooooooooooooooooooooooooooooooooooooooooooooooo ooooooDegree=2ooooooooooo oooo oo ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo ooooooooo ooooooooooooooooooooooo oooooooooooo oooooooooooooooooooooooooooooooooooooooooooooooooooooooooo oooooo Degree=3ooooooooooo oooo oo ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo ooooooooo ooooooooooooooooooooooo oooooooooooo oooooooooooooooooooooooooooooooooooooooooooooooooooooooooo ooooooDegree=4ooooooooooo oooo oo ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo ooooooooo ooooooooooooooooooooooo oooooooooooo oooooooooooooooooooooooooooooooooooooooooooooooooooooooooo oooooo FIGURE 5.7. Logistic regression fits on the two-dimensional classification data displayed in Figure 2.13. The Bayes decision boundary is represented using a purple dashed line. Estimated decision boundaries from linear, quadratic, cubic and quartic (degrees 1–4) logistic regressions are displayed in black. The test", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 250, "start_word": 80000, "end_word": 80400, "chunk_words": 400}}, "ISLP_website::c000251": {"text": "5. Resampling MethodsDegree=1ooooooooooo oooo oo ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo ooooooooo ooooooooooooooooooooooo oooooooooooo oooooooooooooooooooooooooooooooooooooooooooooooooooooooooo ooooooDegree=2ooooooooooo oooo oo ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo ooooooooo ooooooooooooooooooooooo oooooooooooo oooooooooooooooooooooooooooooooooooooooooooooooooooooooooo oooooo Degree=3ooooooooooo oooo oo ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo ooooooooo ooooooooooooooooooooooo oooooooooooo oooooooooooooooooooooooooooooooooooooooooooooooooooooooooo ooooooDegree=4ooooooooooo oooo oo ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo ooooooooo ooooooooooooooooooooooo oooooooooooo oooooooooooooooooooooooooooooooooooooooooooooooooooooooooo oooooo FIGURE 5.7. Logistic regression fits on the two-dimensional classification data displayed in Figure 2.13. The Bayes decision boundary is represented using a purple dashed line. Estimated decision boundaries from linear, quadratic, cubic and quartic (degrees 1–4) logistic regressions are displayed in black. The test error rates for the four logistic regression fits are respectively 0.201,0.197,0.160, and 0.162, while the Bayes error rate is 0.133. error rate of 0.133. Clearly logistic regression does not have enough flexi- bility to model the Bayes decision boundary in this setting. We can easily extend logistic regression to obtain a non-linear decision boundary by using polynomial functions of the predictors, as we did in the regression setting in Section3.3.2. For example, we can fit a quadratic logistic regression model, given by log/parenleftbiggp 1−p/parenrightbigg =β0+β1X1+β2X2 1+β3X2+β4X2 2. (5.5) The top-right panel of Figure 5.7displays the resulting decision boundary, whichisnowcurved.However,thetesterrorratehasimprovedonlyslightly, to0.197. A much larger improvement is apparent in the bottom-left panel 5.1 Cross-Validation 211 2 4 6 8 100.12 0.14 0.16 0.18 0.20Order of Polynomials UsedError Rate0.01 0.02 0.05 0.10 0.20 0.50 1.000.12 0.14 0.16 0.18 0.201/KError RateFIGURE 5.8. Test error (brown), training error (blue), and 10-fold CV error (black) on the two-dimensional classification data displayed in Figure 5.7.Left: Logistic regression using polynomial functions of the predictors. The order of the polynomials used is displayed on the x-axis.Right:The KNN classifier with different values of K, the number of neighbors used in the KNN classifier. of Figure 5.7, in which we have fit a logistic regression model involving cubic polynomials of the predictors. Now the test error rate has decreased to0.160. Going to a quartic polynomial (bottom-right) slightly increases the test error. In practice, for real data, the Bayes decision boundary and the test er- ror rates are unknown. So how might we decide between the four logistic regression models displayed in Figure 5.7? We can use cross-validation in order to make this decision. The left-hand panel of Figure 5.8displays in black the 10-fold CV error rates that result from fitting ten logistic regres- sion models to the data, using polynomial functions of the predictors up to tenth order. The true test errors are shown in brown, and the training errors are", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 251, "start_word": 80320, "end_word": 80720, "chunk_words": 400}}, "ISLP_website::c000252": {"text": "the test er- ror rates are unknown. So how might we decide between the four logistic regression models displayed in Figure 5.7? We can use cross-validation in order to make this decision. The left-hand panel of Figure 5.8displays in black the 10-fold CV error rates that result from fitting ten logistic regres- sion models to the data, using polynomial functions of the predictors up to tenth order. The true test errors are shown in brown, and the training errors are shown in blue. As we have seen previously, the training error tends to decrease as the flexibility of the fit increases. (The figure indicates that though the training error rate doesn’t quite decrease monotonically, it tends to decrease on the whole as the model complexity increases.) In contrast, the test error displays a characteristic U-shape. The 10-fold CV error rate provides a pretty good approximation to the test error rate. While it somewhat underestimates the error rate, it reaches a minimum when fourth-order polynomials are used, which is very close to the min- imum of the test curve, which occurs when third-order polynomials are used. In fact, using fourth-order polynomials would likely lead to good test set performance, as the true test error rate is approximately the same for third, fourth, fifth, and sixth-order polynomials. The right-hand panel of Figure 5.8displays the same three curves us- ing the KNN approach for classification, as a function of the value of K (which in this context indicates the number of neighbors used in the KNN classifier, rather than the number of CV folds used). Again the training error rate declines as the method becomes more flexible, and so we see that the training error rate cannot be used to select the optimal value for K. Though the cross-validation error curve slightly underestimates the test error rate, it takes on a minimum very close to the best value for K. 212 5. Resampling Methods 5.2 The Bootstrap Thebootstrap is a widely applicable and extremely powerful statistical toolbootstrapthat can be used to quantify the uncertainty associated with a given esti- mator or statistical learning method. As a simple example, the bootstrap can be used to estimate the standard errors of the coefficients from a linear regression fit. In the specific case of linear regression, this is not particularly useful, since we saw in Chapter 3that standard statistical software such as Routputs such standard errors", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 252, "start_word": 80640, "end_word": 81040, "chunk_words": 400}}, "ISLP_website::c000253": {"text": "Methods 5.2 The Bootstrap Thebootstrap is a widely applicable and extremely powerful statistical toolbootstrapthat can be used to quantify the uncertainty associated with a given esti- mator or statistical learning method. As a simple example, the bootstrap can be used to estimate the standard errors of the coefficients from a linear regression fit. In the specific case of linear regression, this is not particularly useful, since we saw in Chapter 3that standard statistical software such as Routputs such standard errors automatically. However, the power of the bootstrap lies in the fact that it can be easily applied to a wide range of statistical learning methods, including some for which a measure of vari- ability is otherwise difficult to obtain and is not automatically output by statistical software. In this section we illustrate the bootstrap on a toy example in which we wish to determine the best investment allocation under a simple model. In Section 5.3we explore the use of the bootstrap to assess the variability associated with the regression coefficients in a linear model fit. Suppose that we wish to invest a fixed sum of money in two financial assets that yield returns of XandY, respectively, where XandYare random quantities. We will invest a fraction αof our money in X, and will invest the remaining 1−αinY. Since there is variability associated with the returns on these two assets, we wish to choose αto minimize the total risk, or variance, of our investment. In other words, we want to minimize Var(αX+ (1 −α)Y). One can show that the value that minimizes the risk is given by α=σ2 Y−σXY σ2 X+σ2 Y−2σXY, (5.6) whereσ2 X= Var( X),σ2 Y= Var( Y), andσXY= Cov( X,Y). Inreality,thequantities σ2 X,σ2 Y,andσXYareunknown.Wecancompute estimates for these quantities, ˆσ2 X,ˆσ2 Y, andˆσXY, using a data set that contains past measurements for XandY. We can then estimate the value ofαthat minimizes the variance of our investment using ˆα=ˆσ2 Y−ˆσXY ˆσ2 X+ˆσ2 Y−2ˆσXY. (5.7) Figure5.9illustrates this approach for estimating αon a simulated data set. In each panel, we simulated 100pairs of returns for the investments XandY. We used these returns to estimate σ2 X,σ2 Y, andσXY, which we then substituted into ( 5.7) in order to obtain estimates for α. The value of ˆαresulting from each simulated data set ranges from 0.532to0.657. It is natural to wish to quantify the accuracy of our estimate of α.T o estimate the standard deviation", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 253, "start_word": 80960, "end_word": 81360, "chunk_words": 400}}, "ISLP_website::c000254": {"text": "X+ˆσ2 Y−2ˆσXY. (5.7) Figure5.9illustrates this approach for estimating αon a simulated data set. In each panel, we simulated 100pairs of returns for the investments XandY. We used these returns to estimate σ2 X,σ2 Y, andσXY, which we then substituted into ( 5.7) in order to obtain estimates for α. The value of ˆαresulting from each simulated data set ranges from 0.532to0.657. It is natural to wish to quantify the accuracy of our estimate of α.T o estimate the standard deviation of ˆα, we repeated the process of simu- lating100paired observations of XandY, and estimating αusing (5.7), 1,000 times. We thereby obtained 1,000 estimates for α, which we can call ˆα1,ˆα2,..., ˆα1,000. The left-hand panel of Figure 5.10displays a histogram of the resulting estimates. For these simulations the parameters were set to σ2 X=1,σ2 Y=1.25, andσXY=0.5, and so we know that the true value of αis0.6. We indicated this value using a solid vertical line on the histogram. 5.2 The Bootstrap 213 −2 −1 0 1 2−2 −1 0 1 2XY −2 −1 0 1 2−2 −1 0 1 2XY −3 −2 −1 0 1 2−3 −2 −1 0 1 2XY −2 −1 0 1 2 3−3 −2 −1 0 1 2XYFIGURE 5.9. Each panel displays 100 simulated returns for investments XandY. From left to right and top to bottom, the resulting estimates for α are0.576,0.532,0.657, and0.651. The mean over all 1,000 estimates for αis ¯α=1 10001000/summationdisplay r=1ˆαr=0.5996 , very close to α=0.6, and the standard deviation of the estimates is /radicaltp/radicalvertex/radicalvertex/radicalbt1 1000 −11000/summationdisplay r=1(ˆαr−¯α)2=0.083. This gives us a very good idea of the accuracy of ˆα:SE(ˆα)≈0.083. So roughly speaking, for a random sample from the population, we would expectˆαto differ from αby approximately 0.08, on average. In practice, however, the procedure for estimating SE(ˆα)outlined above cannot be applied, because for real data we cannot generate new samples from the original population. However, the bootstrap approach allows us to use a computer to emulate the process of obtaining new sample sets, so that we can estimate the variability of ˆαwithout generating additional samples. Rather than repeatedly obtaining independent data sets from the population, we instead obtain distinct data sets by repeatedly sampling observations from the original data set . This approach is illustrated in Figure 5.11on a simple data set, which we callZ, that contains only n=3 observations. We randomly select n observations from the data set in order to produce", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 254, "start_word": 81280, "end_word": 81680, "chunk_words": 400}}, "ISLP_website::c000255": {"text": "computer to emulate the process of obtaining new sample sets, so that we can estimate the variability of ˆαwithout generating additional samples. Rather than repeatedly obtaining independent data sets from the population, we instead obtain distinct data sets by repeatedly sampling observations from the original data set . This approach is illustrated in Figure 5.11on a simple data set, which we callZ, that contains only n=3 observations. We randomly select n observations from the data set in order to produce a bootstrap data set, 214 5. Resampling Methods 0.4 0.5 0.6 0.7 0.8 0.90 50 100 150 2000.3 0.4 0.5 0.6 0.7 0.8 0.90 50 100 150 200TrueBootstrap0.3 0.4 0.5 0.6 0.7 0.8 0.9αα αFIGURE 5.10. Left:A histogram of the estimates of αobtained by generating 1,000 simulated data sets from the true population. Center:A histogram of the estimates of αobtained from 1,000 bootstrap samples from a single data set. Right:The estimates of αdisplayed in the left and center panels are shown as boxplots. In each panel, the pink line indicates the true value of α. Z∗1. The sampling is performed with replacement , which means that thewith replacementsame observation can occur more than once in the bootstrap data set. In this example, Z∗1contains the third observation twice, the first observation once,andnoinstancesofthesecondobservation.Notethatifanobservation is contained in Z∗1, then both its XandYvalues are included. We can use Z∗1to produce a new bootstrap estimate for α, which we call ˆα∗1. This procedureisrepeated Btimesforsomelargevalueof B,inordertoproduce Bdifferent bootstrap data sets, Z∗1,Z∗2,...,Z∗B, andBcorresponding α estimates, ˆα∗1,ˆα∗2,..., ˆα∗B. We can compute the standard error of these bootstrap estimates using the formula SEB(ˆα)=/radicaltp/radicalvertex/radicalvertex/radicalbt1 B−1B/summationdisplay r=1/parenleftBigg ˆα∗r−1 BB/summationdisplay r/prime=1ˆα∗r/prime/parenrightBigg2 . (5.8) This serves as an estimate of the standard error of ˆαestimated from the original data set. The bootstrap approach is illustrated in the center panel of Figure 5.10, which displays a histogram of 1,000 bootstrap estimates of α, each com- puted using a distinct bootstrap data set. This panel was constructed on the basis of a single data set, and hence could be created using real data. Note that the histogram looks very similar to the left-hand panel, which displays the idealized histogram of the estimates of αobtained by generat- ing 1,000 simulated data sets from the true population. In particular the bootstrap estimate SE(ˆα)from (5.8) is0.087, very close to the estimate of 0.083obtained using 1,000 simulated data sets. The right-hand panel dis- plays the information in the center", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 255, "start_word": 81600, "end_word": 82000, "chunk_words": 400}}, "ISLP_website::c000256": {"text": "was constructed on the basis of a single data set, and hence could be created using real data. Note that the histogram looks very similar to the left-hand panel, which displays the idealized histogram of the estimates of αobtained by generat- ing 1,000 simulated data sets from the true population. In particular the bootstrap estimate SE(ˆα)from (5.8) is0.087, very close to the estimate of 0.083obtained using 1,000 simulated data sets. The right-hand panel dis- plays the information in the center and left panels in a different way, via boxplots of the estimates for αobtained by generating 1,000 simulated data sets from the true population and using the bootstrap approach. Again, the boxplots have similar spreads, indicating that the bootstrap approach can be used to effectively estimate the variability associated with ˆα. 5.3 Lab: Cross-Validation and the Bootstrap 215 2.8 5.3 3 1.1 2.1 2 2.4 4.3 1 Y X Obs 2.8 5.3 3 2.4 4.3 1 2.8 5.3 3 Y X Obs 2.4 4.3 1 2.8 5.3 3 1.1 2.1 2 Y X Obs 2.4 4.3 1 1.1 2.1 2 1.1 2.1 2 Y X Obs Original Data (Z) 1*Z2*ZZ*B1*ˆ 2*ˆˆ*B/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1FIGURE 5.11.A graphical illustration of the bootstrap approach on a smallsample containingn=3observations. Each bootstrap data set containsnobser-vations, sampled with replacement from the original data set. Each bootstrap dataset is used to obtain an estimate ofα.5.3 Lab: Cross-Validation and the BootstrapIn this lab, we explore the resampling techniques covered in this chap-ter. Some of the commands in this lab may take a while to run on yourcomputer.We again begin by placing most of our imports at this top level.In[1]:import numpy as npimport statsmodels.api as smfrom ISLP import load_datafrom ISLP.models import (ModelSpec as MS,summarize,poly)from sklearn.model_selection import train_test_splitThere are several new imports needed for this lab.In[2]:from functools import partialfrom sklearn.model_selection import \\(cross_validate,KFold,ShuffleSplit)from sklearn.base import clonefrom ISLP.models import sklearn_sm\u0001\u0001\u0001 216 5. Resampling Methods5.3.1 The Validation Set ApproachWe explore the use of the validation set approach in order to estimate thetest error rates that result from fitting various linear models on theAutodata set.We use the functiontrain_test_split()to split the data into trainingtrain_test_split()and validation sets. As there are 392 observations, we split into two equalsets of size 196 using the argumenttest_size=196. It is generally a goodidea to set a random seed when performing operations like this that containan element of randomness, so that the results obtained can be reproducedprecisely at a later time. We set the random", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 256, "start_word": 81920, "end_word": 82320, "chunk_words": 400}}, "ISLP_website::c000257": {"text": "approach in order to estimate thetest error rates that result from fitting various linear models on theAutodata set.We use the functiontrain_test_split()to split the data into trainingtrain_test_split()and validation sets. As there are 392 observations, we split into two equalsets of size 196 using the argumenttest_size=196. It is generally a goodidea to set a random seed when performing operations like this that containan element of randomness, so that the results obtained can be reproducedprecisely at a later time. We set the random seed of the splitter with theargumentrandom_state=0.In[3]:Auto = load_data('Auto')Auto_train, Auto_valid = train_test_split(Auto,test_size=196,random_state=0)Now we can fit a linear regression using only the observations corre-sponding to the training setAuto_train.In[4]:hp_mm = MS(['horsepower'])X_train = hp_mm.fit_transform(Auto_train)y_train = Auto_train['mpg']model = sm.OLS(y_train, X_train)results = model.fit()Wenowusethepredict()methodofresultsevaluatedonthemodelma-trix for this model created using the validation data set. We also calculatethe validation MSE of our model.In[5]:X_valid = hp_mm.transform(Auto_valid)y_valid = Auto_valid['mpg']valid_pred = results.predict(X_valid)np.mean((y_valid - valid_pred)**2)Out[5]:23.6166Hence our estimate for the validation MSE of the linear regression fit is23.62.We can also estimate the validation error for higher-degree polynomialregressions. We first provide a functionevalMSE()that takes a model stringas well as a training and test set and returns the MSE on the test set.In[6]:def evalMSE(terms,response,train,test):mm = MS(terms)X_train = mm.fit_transform(train)y_train = train[response]X_test = mm.transform(test)y_test = test[response] 5.3 Lab: Cross-Validation and the Bootstrap 217results = sm.OLS(y_train, X_train).fit()test_pred = results.predict(X_test)return np.mean((y_test - test_pred)**2)Let’s use this function to estimate the validation MSE using linear,quadratic and cubic fits. We use theenumerate()function here, which givesenumerate()both the values and indices of objects as one iterates over a for loop.In[7]:MSE = np.zeros(3)for idx, degree in enumerate(range(1, 4)):MSE[idx] = evalMSE([poly('horsepower',d e g r e e ) ] ,'mpg',Auto_train,Auto_valid)MSEOut[7]:array([23.62, 18.76, 18.80])These error rates are23.62,18.76, and18.80, respectively. If we choose adifferent training/validation split instead, then we can expect somewhatdifferent errors on the validation set.In[8]:Auto_train, Auto_valid = train_test_split(Auto,test_size=196,random_state=3)MSE = np.zeros(3)for idx, degree in enumerate(range(1, 4)):MSE[idx] = evalMSE([poly('horsepower',d e g r e e ) ] ,'mpg',Auto_train,Auto_valid)MSEOut[8]:array([20.76, 16.95, 16.97])Using this split of the observations into a training set and a validationset, we find that the validation set error rates for the models with linear,quadratic, and cubic terms are20.76,16.95, and16.97, respectively.These results are consistent with our previous findings: a model thatpredictsmpgusing a quadratic function ofhorsepowerperforms better thana model that involves only a linear function ofhorsepower, and there is noevidence of an improvement in using a cubic function ofhorsepower.5.3.2 Cross-ValidationIn theory, the cross-validation estimate can be computed for any general-ized linear model. In practice, however, the simplest way to cross-validatein Python is to", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 257, "start_word": 82240, "end_word": 82640, "chunk_words": 400}}, "ISLP_website::c000258": {"text": "we find that the validation set error rates for the models with linear,quadratic, and cubic terms are20.76,16.95, and16.97, respectively.These results are consistent with our previous findings: a model thatpredictsmpgusing a quadratic function ofhorsepowerperforms better thana model that involves only a linear function ofhorsepower, and there is noevidence of an improvement in using a cubic function ofhorsepower.5.3.2 Cross-ValidationIn theory, the cross-validation estimate can be computed for any general-ized linear model. In practice, however, the simplest way to cross-validatein Python is to usesklearn, which has a different interface or API thanstatsmodels, the code we have been using to fit GLMs.Thisisaproblemwhichoftenconfrontsdatascientists:“Ihaveafunctionto do taskA, and need to feed it into something that performs taskB, sothat I can computeB(A(D)), whereDis my data.” WhenAandBdon’tnaturally speak to each other, this requires the use of awrapper. In theISLPwrapper 218 5. Resampling Methods package, we provide a wrapper, sklearn_sm() , that enables us to easily usesklearn_sm()the cross-validation tools of sklearnwith models fit by statsmodels . Theclass sklearn_sm() hasasitsfirstargumentamodelfrom statsmodels . Itcantaketwoadditional optionalarguments: model_str whichcanbeused to specify a formula, and model_args which should be a dictionary of addi- tional arguments used when fitting the model. For example, to fit a logistic regression model we have to specify a familyargument. This is passed as model_args={'family':sm.families.Binomial()} . Here is our wrapper in action: In[9]: hp_model = sklearn_sm(sm.OLS, MS(['horsepower' ])) X, Y = Auto.drop(columns=[ 'mpg']), Auto[ 'mpg'] cv_results = cross_validate(hp_model, X, Y, cv=Auto.shape[0]) cv_err = np.mean(cv_results[ 'test_score' ]) cv_err Out[9]: 24.2315 The arguments to cross_validate() are as follows: an object with the ap- propriate fit(),predict() ,andscore()methods,anarrayoffeatures Xand aresponse Y.Wealsoincludedanadditionalargument cvtocross_validate() ; specifyinganinteger Kresultsin K-foldcross-validation.Wehaveprovided a value corresponding to the total number of observations, which results in leave-one-out cross-validation (LOOCV). The cross_validate() func-cross_ validate() tion produces a dictionary with several components; we simply want the cross-validated test score here (MSE), which is estimated to be 24.23. We can repeat this procedure for increasingly complex polynomial fits. To automate the process, we again use a for loop which iteratively fits polynomial regressions of degree 1 to 5, computes the associated cross- validation error, and stores it in the ith element of the vector cv_error . The variable din the for loop corresponds to the degree of the polynomial. We begin by initializing the vector. This command may take a couple of seconds to run. In[10]: cv_error = np.zeros(5) H=n p . a r r a y ( A u t o [ 'horsepower' ]) M=s", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 258, "start_word": 82560, "end_word": 82960, "chunk_words": 400}}, "ISLP_website::c000259": {"text": "for loop which iteratively fits polynomial regressions of degree 1 to 5, computes the associated cross- validation error, and stores it in the ith element of the vector cv_error . The variable din the for loop corresponds to the degree of the polynomial. We begin by initializing the vector. This command may take a couple of seconds to run. In[10]: cv_error = np.zeros(5) H=n p . a r r a y ( A u t o [ 'horsepower' ]) M=s k l e a r n _ s m ( s m . O L S ) for i, d in enumerate(range(1,6)): X=n p . p o w e r . o u t e r ( H ,n p . a r a n g e ( d + 1 ) ) M_CV = cross_validate(M, X, Y, cv=Auto.shape[0]) cv_error[i] = np.mean(M_CV[ 'test_score' ]) cv_error Out[10]: array([24.2315, 19.2482, 19.3350, 19.4244, 19.0332]) As in Figure 5.4, we see a sharp drop in the estimated test MSE between the linear and quadratic fits, but then no clear improvement from using higher-degree polynomials. 5.3 Lab: Cross-Validation and the Bootstrap 219 Above we introduced the outer() method of the np.power() function..outer() np.power()Theouter()method is applied to an operation that has two arguments, such as add(),min(), orpower(). It has two arrays as arguments, and then forms a larger array where the operation is applied to each pair of elements of the two arrays. In[11]: A=n p . a r r a y ( [ 3 ,5 ,9 ] ) B=n p . a r r a y ( [ 2 ,4 ] ) np.add.outer(A, B) Out[11]: array([[ 5, 7], [7 , 9 ] , [11, 13]]) In the CV example above, we used K=n, but of course we can also use K<n. The code is very similar to the above (and is significantly faster). Here we use KFold()to partition the data into K= 10random groups. WeKFold()userandom_state to set a random seed and initialize a vector cv_error in which we will store the CV errors corresponding to the polynomial fits of degrees one to five. In[12]: cv_error = np.zeros(5) cv = KFold(n_splits=10, shuffle=True, random_state=0) #u s es a m es p l i t sf o re a c hd e g r e e for i, d in enumerate(range(1,6)): X=n p . p o w e r . o u t e r ( H ,n", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 259, "start_word": 82880, "end_word": 83280, "chunk_words": 400}}, "ISLP_website::c000260": {"text": "to set a random seed and initialize a vector cv_error in which we will store the CV errors corresponding to the polynomial fits of degrees one to five. In[12]: cv_error = np.zeros(5) cv = KFold(n_splits=10, shuffle=True, random_state=0) #u s es a m es p l i t sf o re a c hd e g r e e for i, d in enumerate(range(1,6)): X=n p . p o w e r . o u t e r ( H ,n p . a r a n g e ( d + 1 ) ) M_CV = cross_validate(M, X, Y, cv=cv) cv_error[i] = np.mean(M_CV[ 'test_score' ]) cv_error Out[12]: array([24.2077, 19.1853, 19.2763, 19.4785, 19.1372]) Notice that the computation time is much shorter than that of LOOCV. (In principle, the computation time for LOOCV for a least squares linear model should be faster than for K-fold CV, due to the availability of the formula ( 5.2) for LOOCV; however, the generic cross_validate() function does not make use of this formula.) We still see little evidence that using cubic or higher-degree polynomial terms leads to a lower test error than simply using a quadratic fit. Thecross_validate() function is flexible and can take different splitting mechanisms as an argument. For instance, one can use the ShuffleSplit()Shuffle Split() funtion to implement the validation set approach just as easily as K-fold cross-validation. In[13]: validation = ShuffleSplit(n_splits=1, test_size=196, random_state=0) results = cross_validate(hp_model, Auto.drop([ 'mpg'], axis=1), Auto['mpg'], cv=validation); results[ 'test_score' ] 220 5. Resampling Methods Out[13]: array([23.6166]) Onecanestimatethevariabilityinthetesterrorbyrunningthefollowing: In[14]: validation = ShuffleSplit(n_splits=10, test_size=196, random_state=0) results = cross_validate(hp_model, Auto.drop([ 'mpg'], axis=1), Auto['mpg'], cv=validation) results[ 'test_score' ].mean(), results[ 'test_score' ].std() Out[14]: (23.8022, 1.4218) Note that this standard deviation is not a valid estimate of the sam- pling variability of the mean test score or the individual scores, since the randomly-selected training samples overlap and hence introduce correla- tions. But it does give an idea of the Monte Carlo variation incurred by picking different random folds. 5.3.3 The Bootstrap We illustrate the use of the bootstrap in the simple example of Section 5.2, as well as on an example involving estimating the accuracy of the linear regression model on the Autodata set. Estimating the Accuracy of a Statistic of Interest One of the great advantages of the bootstrap approach is that it can be applied in almost all situations. No complicated mathematical calculations are required. While there are several implementations of the", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 260, "start_word": 83200, "end_word": 83600, "chunk_words": 400}}, "ISLP_website::c000261": {"text": "picking different random folds. 5.3.3 The Bootstrap We illustrate the use of the bootstrap in the simple example of Section 5.2, as well as on an example involving estimating the accuracy of the linear regression model on the Autodata set. Estimating the Accuracy of a Statistic of Interest One of the great advantages of the bootstrap approach is that it can be applied in almost all situations. No complicated mathematical calculations are required. While there are several implementations of the bootstrap in Python,itsuseforestimatingstandarderrorissimpleenoughthatwewrite our own function below for the case when our data is stored in a dataframe. Toillustratethebootstrap,westartwithasimpleexample.The Portfolio data set in the ISLPpackage is described in Section 5.2. The goal is to es- timate the sampling variance of the parameter αgiven in formula ( 5.7). We will create a function alpha_func() , which takes as input a dataframe D assumed to have columns XandY, as well as a vector idxindicating which observations should be used to estimate α. The function then outputs the estimate for αbased on the selected observations. In[15]: Portfolio = load_data( 'Portfolio' ) def alpha_func(D, idx): cov_ = np.cov(D[[ 'X','Y']].loc[idx], rowvar=False) return ((cov_[1,1] - cov_[0,1]) / (cov_[0,0]+cov_[1,1]-2*cov_[0,1])) This function returns an estimate for αbased on applying the minimum varianceformula( 5.7)totheobservationsindexedbytheargument idx.For instance, the following command estimates αusing all 100 observations. In[16]: alpha_func(Portfolio, range(100)) 5.3 Lab: Cross-Validation and the Bootstrap 221Out[16]:0.5758Next we randomly select 100 observations fromrange(100), with replace-ment. This is equivalent to constructing a new bootstrap data set andrecomputingˆαbased on the new data set.In[17]:rng = np.random.default_rng(0)alpha_func(Portfolio,rng.choice(100,100,replace=True))Out[17]:0.6074This process can be generalized to create a simple functionboot_SE()forcomputing the bootstrap standard error for arbitrary functions that takeonly a data frame as an argument.In[18]:def boot_SE(func,D,n=None,B=1000,seed=0):rng = np.random.default_rng(seed)first_, second_ = 0, 0n=no rD . s h a p e [ 0 ]for _ in range(B):idx = rng.choice(D.index,n,replace=True)value = func(D, idx)first_ += valuesecond_ += value**2return np.sqrt(second_ / B - (first_ / B)**2)Notice the use of_as a loop variable infor _ in range(B). This is oftenused if the value of the counter is unimportant and simply makes sure theloop is executedBtimes.Let’s use our function to evaluate the accuracy of our estimate ofαusingB=1,000bootstrap replications.In[19]:alpha_SE = boot_SE(alpha_func,Portfolio,B=1000,seed=0)alpha_SEOut[19]:0.0912The final output shows that the bootstrap estimate forSE(ˆα)is0.0912.Estimating the Accuracy of a Linear Regression ModelThe bootstrap approach can be used to assess the variability of the coef-ficient estimates and predictions from a statistical learning method. Herewe use the bootstrap approach in order to assess the variability of", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 261, "start_word": 83520, "end_word": 83920, "chunk_words": 400}}, "ISLP_website::c000262": {"text": "range(B). This is oftenused if the value of the counter is unimportant and simply makes sure theloop is executedBtimes.Let’s use our function to evaluate the accuracy of our estimate ofαusingB=1,000bootstrap replications.In[19]:alpha_SE = boot_SE(alpha_func,Portfolio,B=1000,seed=0)alpha_SEOut[19]:0.0912The final output shows that the bootstrap estimate forSE(ˆα)is0.0912.Estimating the Accuracy of a Linear Regression ModelThe bootstrap approach can be used to assess the variability of the coef-ficient estimates and predictions from a statistical learning method. Herewe use the bootstrap approach in order to assess the variability of the 222 5. Resampling Methods estimates for β0andβ1, the intercept and slope terms for the linear regres- sion model that uses horsepower to predict mpgin theAutodata set. We will compare the estimates obtained using the bootstrap to those obtained using the formulas for SE(ˆβ0)andSE(ˆβ1)described in Section 3.1.2. To use our boot_SE() function, we must write a function (its first argu- ment) that takes a data frame Dand indices idxas its only arguments. But here we want to bootstrap a specific regression model, specified by a model formula and data. We show how to do this in a few simple steps. We start by writing a generic function boot_OLS() for bootstrapping a regression model that takes a formula to define the corresponding regres- sion. We use the clone()function to make a copy of the formula that canclone()be refit to the new dataframe. This means that any derived features such as those defined by poly()(which we will see shortly), will be re-fit on the resampled data frame. In[20]: def boot_OLS(model_matrix, response, D, idx): D_ = D.loc[idx] Y_ = D_[response] X_ = clone(model_matrix).fit_transform(D_) return sm.OLS(Y_, X_).fit().params Thisisnotquitewhatisneededasthefirstargumentto boot_SE() .Thefirst two arguments which specify the model will not change in the bootstrap process, and we would like to freezethem. The function partial() from thepartial()functools module does precisely this: it takes a function as an argument, and freezes some of its arguments, starting from the left. We use it to freeze the first two model-formula arguments of boot_OLS() . In[21]: hp_func = partial(boot_OLS, MS([ 'horsepower' ]),'mpg') Typing hp_func? will show that it has two arguments Dandidx— it is a version of boot_OLS() with the first two arguments frozen — and hence is ideal as the first argument for boot_SE() . Thehp_func() function can now be used in order to create bootstrap estimates for the intercept and slope terms by randomly sampling from among the observations with replacement. We first demonstrate its utility on 10 bootstrap", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 262, "start_word": 83840, "end_word": 84240, "chunk_words": 400}}, "ISLP_website::c000263": {"text": "arguments of boot_OLS() . In[21]: hp_func = partial(boot_OLS, MS([ 'horsepower' ]),'mpg') Typing hp_func? will show that it has two arguments Dandidx— it is a version of boot_OLS() with the first two arguments frozen — and hence is ideal as the first argument for boot_SE() . Thehp_func() function can now be used in order to create bootstrap estimates for the intercept and slope terms by randomly sampling from among the observations with replacement. We first demonstrate its utility on 10 bootstrap samples. In[22]: rng = np.random.default_rng(0) np.array([hp_func(Auto, rng.choice(392, 392, replace=True)) for _ in range(10)]) Out[22]: array([[39.8806, -0.1568], [38.733 , -0.147 ], [38.3173, -0.1444], [39.9145, -0.1578], [39.4335, -0.1507], [40.3663, -0.1591], [39.6233, -0.1545], [39.0581, -0.1495], [38.6669, -0.1452], [39.6428, -0.1556]]) 5.3 Lab: Cross-Validation and the Bootstrap 223 Next, we use the boot_SE() function to compute the standard errors of 1,000 bootstrap estimates for the intercept and slope terms. In[23]: hp_se = boot_SE(hp_func, Auto, B=1000, seed=10) hp_se Out[23]: intercept 0.8488 horsepower 0.0074 dtype: float64 This indicates that the bootstrap estimate for SE(ˆβ0)is 0.85, and that the bootstrap estimate for SE(ˆβ1)is 0.0074. As discussed in Section 3.1.2, standard formulas can be used to compute the standard errors for the regression coefficients in a linear model. These can be obtained using the summarize() function from ISLP.sm. In[24]: hp_model.fit(Auto, Auto[ 'mpg']) model_se = summarize(hp_model.results_)[ 'std err' ] model_se Out[24]: intercept 0.717 horsepower 0.006 Name: std err, dtype: float64 The standard error estimates for ˆβ0andˆβ1obtained using the formulas from Section 3.1.2are 0.717 for the intercept and 0.006 for the slope. Inter- estingly, these are somewhat different from the estimates obtained using the bootstrap. Does this indicate a problem with the bootstrap? In fact, it suggests the opposite. Recall that the standard formulas given in Equa- tion3.8on page75rely on certain assumptions. For example, they depend on the unknown parameter σ2, the noise variance. We then estimate σ2 using the RSS. Now although the formula for the standard errors do not rely on the linear model being correct, the estimate for σ2does. We see in Figure3.8on page 99that there is a non-linear relationship in the data, and so the residuals from a linear fit will be inflated, and so will ˆσ2. Sec- ondly, the standard formulas assume (somewhat unrealistically) that the xiare fixed, and all the variability comes from the variation in the errors /epsilon1i. The bootstrap approach does not rely on any of these assumptions, and so it is likely", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 263, "start_word": 84160, "end_word": 84560, "chunk_words": 400}}, "ISLP_website::c000264": {"text": "rely on the linear model being correct, the estimate for σ2does. We see in Figure3.8on page 99that there is a non-linear relationship in the data, and so the residuals from a linear fit will be inflated, and so will ˆσ2. Sec- ondly, the standard formulas assume (somewhat unrealistically) that the xiare fixed, and all the variability comes from the variation in the errors /epsilon1i. The bootstrap approach does not rely on any of these assumptions, and so it is likely giving a more accurate estimate of the standard errors of ˆβ0 andˆβ1than the results from sm.OLS. Below we compute the bootstrap standard error estimates and the stan- dardlinearregressionestimatesthatresultfromfittingthequadraticmodel to the data. Since this model provides a good fit to the data (Figure 3.8), there is now a better correspondence between the bootstrap estimates and the standard estimates of SE(ˆβ0),SE(ˆβ1)andSE(ˆβ2). In[25]: quad_model = MS([poly( 'horsepower' ,2 ,r a w = T r u e ) ] ) quad_func = partial(boot_OLS, quad_model, 'mpg') boot_SE(quad_func, Auto, B=1000) 224 5. Resampling Methods Out[25]: intercept 2.067840 poly(horsepower, 2, raw=True)[0] 0.033019 poly(horsepower, 2, raw=True)[1] 0.000120 dtype: float64 We compare the results to the standard errors computed using sm.OLS() . In[26]: M=s m . O L S ( A u t o [ 'mpg'], quad_model.fit_transform(Auto)) summarize(M.fit())[ 'std err' ] Out[26]: intercept 1.800 poly(horsepower, 2, raw=True)[0] 0.031 poly(horsepower, 2, raw=True)[1] 0.000 Name: std err, dtype: float64 5.4 Exercises Conceptual 1. Using basic statistical properties of the variance, as well as single- variable calculus, derive ( 5.6). In other words, prove that αgiven by (5.6) does indeed minimize Var(αX+ (1−α)Y). 2. We will now derive the probability that a given observation is part of a bootstrap sample. Suppose that we obtain a bootstrap sample from a set of nobservations. (a) What is the probability that the first bootstrap observation is notthejth observation from the original sample? Justify your answer. (b) What is the probability that the second bootstrap observation isnotthejth observation from the original sample? (c) Argue that the probability that the jth observation is notin the bootstrap sample is (1−1/n)n. (d) When n=5, what is the probability that the jth observation is in the bootstrap sample? (e) When n= 100, what is the probability that the jth observation is in the bootstrap sample? (f) When n= 10,000, what is the probability that the jth observa- tion is in the bootstrap sample? (g) Create a plot that displays, for", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 264, "start_word": 84480, "end_word": 84880, "chunk_words": 400}}, "ISLP_website::c000265": {"text": "isnotthejth observation from the original sample? (c) Argue that the probability that the jth observation is notin the bootstrap sample is (1−1/n)n. (d) When n=5, what is the probability that the jth observation is in the bootstrap sample? (e) When n= 100, what is the probability that the jth observation is in the bootstrap sample? (f) When n= 10,000, what is the probability that the jth observa- tion is in the bootstrap sample? (g) Create a plot that displays, for each integer value of nfrom1 to100,000, the probability that the jth observation is in the bootstrap sample. Comment on what you observe. (h) We will now investigate numerically the probability that a boot- strap sample of size n= 100contains the jth observation. Here j=4. We first create an array storewith values that will subse- quently be overwritten using the function np.empty() . We thennp.empty() 5.4 Exercises 225 repeatedly create bootstrap samples, and each time we record whetherornotthefifthobservationiscontainedinthebootstrap sample. rng = np.random.default_rng(10) store = np.empty(10000) for i in range(10000): store[i] = np.sum(rng.choice(100, replace=True) == 4) >0 np.mean(store) Comment on the results obtained. 3. We now review k-fold cross-validation. (a) Explain how k-fold cross-validation is implemented. (b) What are the advantages and disadvantages of k-fold cross- validation relative to: i. The validation set approach? ii. LOOCV? 4. Suppose that we use some statistical learning method to make a pre- diction for the response Yfor a particular value of the predictor X. Carefully describe how we might estimate the standard deviation of our prediction. Applied 5. In Chapter 4, we used logistic regression to predict the probability of defaultusingincomeandbalanceon theDefaultdata set. We will now estimate the test error of this logistic regression model using the validation set approach. Do not forget to set a random seed before beginning your analysis. (a) Fit a logistic regression model that uses incomeandbalanceto predict default. (b) Using the validation set approach, estimate the test error of this model. In order to do this, you must perform the following steps: i. Split the sample set into a training set and a validation set. ii. Fit a multiple logistic regression model using only the train- ing observations. iii. Obtain a prediction of default status for each individual in the validation set by computing the posterior probability of default for that individual, and classifying the individual to thedefaultcategory if the posterior probability is greater than 0.5. iv. Compute the validation", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 265, "start_word": 84800, "end_word": 85200, "chunk_words": 400}}, "ISLP_website::c000266": {"text": "model. In order to do this, you must perform the following steps: i. Split the sample set into a training set and a validation set. ii. Fit a multiple logistic regression model using only the train- ing observations. iii. Obtain a prediction of default status for each individual in the validation set by computing the posterior probability of default for that individual, and classifying the individual to thedefaultcategory if the posterior probability is greater than 0.5. iv. Compute the validation set error, which is the fraction of the observations in the validation set that are misclassified. (c) Repeat the process in (b) three times, using three different splits of the observations into a training set and a validation set. Com- ment on the results obtained. 226 5. Resampling Methods (d) Now consider a logistic regression model that predicts the prob- ability of defaultusingincome,balance, and a dummy variable forstudent. Estimate the test error for this model using the val- idation set approach. Comment on whether or not including a dummy variable for studentleads to a reduction in the test error rate. 6. We continue to consider the use of a logistic regression model to predict the probability of defaultusingincomeandbalanceon the Defaultdata set. In particular, we will now compute estimates for the standard errors of the incomeandbalancelogistic regression coeffi- cients in two different ways: (1) using the bootstrap, and (2) using the standard formula for computing the standard errors in the sm.GLM() function. Do not forget to set a random seed before beginning your analysis. (a) Using the summarize() andsm.GLM() functions, determine the estimated standard errors for the coefficients associated with incomeandbalancein a multiple logistic regression model that uses both predictors. (b) Writeafunction, boot_fn() ,thattakesasinputthe Defaultdata set as well as an index of the observations, and that outputs the coefficient estimates for incomeandbalancein the multiple logistic regression model. (c) Following the bootstrap example in the lab, use your boot_fn() function to estimate the standard errors of the logistic regression coefficients for incomeandbalance. (d) Comment on the estimated standard errors obtained using the sm.GLM() function and using the bootstrap. 7. InSections 5.1.2and5.1.3,wesawthatthe cross_validate() function can be used in order to compute the LOOCV test error estimate. Alternatively, one could compute those quantities using just sm.GLM() and the predict() method of the fitted model within a for loop. You will now take this approach in order to compute the LOOCV error for a simple", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 266, "start_word": 85120, "end_word": 85520, "chunk_words": 400}}, "ISLP_website::c000267": {"text": "the standard errors of the logistic regression coefficients for incomeandbalance. (d) Comment on the estimated standard errors obtained using the sm.GLM() function and using the bootstrap. 7. InSections 5.1.2and5.1.3,wesawthatthe cross_validate() function can be used in order to compute the LOOCV test error estimate. Alternatively, one could compute those quantities using just sm.GLM() and the predict() method of the fitted model within a for loop. You will now take this approach in order to compute the LOOCV error for a simple logistic regression model on the Weeklydata set. Recall that in the context of classification problems, the LOOCV error is given in ( 5.4). (a) Fitalogisticregressionmodelthatpredicts Direction usingLag1 andLag2. (b) Fitalogisticregressionmodelthatpredicts Direction usingLag1 andLag2using all but the first observation . (c) Usethe model from (b) to predict the direction of the first obser- vation. You can do this by predicting that the first observation will go up if P(Direction = \"Up\" |Lag1,Lag2)>0.5. Was this observation correctly classified? (d) Write a for loop from i=1toi=n, wherenis the number of observations in the data set, that performs each of the following steps: 5.4 Exercises 227i. Fit a logistic regression model using all but theith obser-vation to predictDirectionusingLag1andLag2.ii. Compute the posterior probability of the market moving upfor theith observation.iii. Usetheposteriorprobabilityfortheithobservationinorderto predict whether or not the market moves up.iv. Determine whether or not an error was made in predictingthe direction for theith observation. If an error was made,then indicate this as a1, and otherwise indicate it as a0.(e) Take the average of thennumbers obtained in (d)iv in order toobtain the LOOCV estimate for the test error. Comment on theresults.8. We will now perform cross-validation on a simulated data set.(a) Generate a simulated data set as follows:rng = np.random.default_rng(1)x=r n g . n o r m a l ( s i z e = 1 0 0 )y=x-2*x * * 2+r n g . n o r m a l ( s i z e = 1 0 0 )In this data set, what isnand what isp? Write out the modelused to generate the data in equation form.(b) Createa scatterplot ofXagainstY.Commenton what youfind.(c) Set a random seed, and then compute the LOOCV errors thatresult from fitting the following four models using least squares:i.Y=β0+β1X+/epsilon1ii.Y=β0+β1X+β2X2+/epsilon1iii.Y=β0+β1X+β2X2+β3X3+/epsilon1iv.Y=β0+β1X+β2X2+β3X3+β4X4+/epsilon1.Note you may find it helpful to use thedata.frame()functionto create a single data set containing bothXandY.(d) Repeat (c) using another random seed, and report your results.Are your results the same as what you got", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 267, "start_word": 85440, "end_word": 85840, "chunk_words": 400}}, "ISLP_website::c000268": {"text": "1 0 0 )In this data set, what isnand what isp? Write out the modelused to generate the data in equation form.(b) Createa scatterplot ofXagainstY.Commenton what youfind.(c) Set a random seed, and then compute the LOOCV errors thatresult from fitting the following four models using least squares:i.Y=β0+β1X+/epsilon1ii.Y=β0+β1X+β2X2+/epsilon1iii.Y=β0+β1X+β2X2+β3X3+/epsilon1iv.Y=β0+β1X+β2X2+β3X3+β4X4+/epsilon1.Note you may find it helpful to use thedata.frame()functionto create a single data set containing bothXandY.(d) Repeat (c) using another random seed, and report your results.Are your results the same as what you got in (c)? Why?(e) Which of the models in (c) had the smallest LOOCV error? Isthis what you expected? Explain your answer.(f) Comment on the statistical significance of the coefficient esti-mates that results from fitting each of the models in (c) usingleast squares. Do these results agree with the conclusions drawnbased on the cross-validation results?9. We will now consider theBostonhousing data set, from theISLPlibrary.(a) Based on this data set, provide an estimate for the populationmean ofmedv. Call this estimateˆµ. 228 5. Resampling Methods (b) Provide an estimate of the standard error of ˆµ. Interpret this result. Hint: We can compute the standard error of the sample mean by dividing the sample standard deviation by the square root of the number of observations. (c) Now estimate the standard error of ˆµusing the bootstrap. How does this compare to your answer from (b)? (d) Based on your bootstrap estimate from (c), provide a 95% con- fidence interval for the mean of medv. Compare it to the results obtained by using Boston['medv'].std() and the two standard error rule ( 3.9). Hint: You can approximate a 95% confidence interval using the formula[ˆµ−2SE(ˆ µ),ˆµ+ 2SE(ˆ µ)]. (e) Basedonthisdataset,provideanestimate, ˆµmed,forthemedian value of medvin the population. (f) Wenowwouldliketoestimatethestandarderrorof ˆµmed.Unfor- tunately, there is no simple formula for computing the standard error of the median. Instead, estimate the standard error of the median using the bootstrap. Comment on your findings. (g) Based on this data set, provide an estimate for the tenth per- centile of medvin Boston census tracts. Call this quantity ˆµ0.1. (You can use the np.percentile() function.)np. percentile() (h) Use the bootstrap to estimate the standard error of ˆµ0.1. Com- ment on your findings. 6 Linear Model Selection and Regularization In the regression setting, the standard linear model Y=β0+β1X1+···+βpXp+/epsilon1 (6.1) is commonly used to describe the relationship between a response Yand a set of variables X1,X2,...,X p. We have seen in Chapter 3that one typically fits this model", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 268, "start_word": 85760, "end_word": 86160, "chunk_words": 400}}, "ISLP_website::c000269": {"text": "the tenth per- centile of medvin Boston census tracts. Call this quantity ˆµ0.1. (You can use the np.percentile() function.)np. percentile() (h) Use the bootstrap to estimate the standard error of ˆµ0.1. Com- ment on your findings. 6 Linear Model Selection and Regularization In the regression setting, the standard linear model Y=β0+β1X1+···+βpXp+/epsilon1 (6.1) is commonly used to describe the relationship between a response Yand a set of variables X1,X2,...,X p. We have seen in Chapter 3that one typically fits this model using least squares. In the chapters that follow, we consider some approaches for extending the linear model framework. In Chapter 7we generalize ( 6.1) in order to accommodate non-linear, but still additive, relationships, while in Chap- ters8and10we consider even more general non-linear models. However, the linear model has distinct advantages in terms of inference and, on real- world problems, is often surprisingly competitive in relation to non-linear methods. Hence, before moving to the non-linear world, we discuss in this chaptersomewaysinwhichthesimplelinearmodelcanbeimproved,byre- placing plain least squares fitting with some alternative fitting procedures. Why might we want to use another fitting procedure instead of least squares? As we will see, alternative fitting procedures can yield better pre- diction accuracy andmodel interpretability . •Prediction Accuracy : Provided that the true relationship between the response and the predictors is approximately linear, the least squares estimates will have low bias. If n/greatermuchp—that is, if n, the number of observations,ismuchlargerthan p,thenumberofvariables—thenthe least squares estimates tend to also have low variance, and hence will perform well on test observations. However, if nis not much larger thanp, then there can be a lot of variability in the least squares fit, resulting in overfitting and consequently poor predictions on future observationsnotusedinmodeltraining.Andif p>n ,thenthereisno longer a unique least squares coefficient estimate: there are infinitely © Springer Nature Switzerland AG 2023 G. James et al., An Introduction to Statistical Learning , Springer Texts in Statistics, https://doi.org/10.1007/978-3-031-38747-0_6 229 230 6. Linear Model Selection and Regularization many solutions. Each of these least squares solutions gives zero error on the training data, but typically very poor test set performance due to extremely high variance.1Byconstraining orshrinking the estimated coefficients, we can often substantially reduce the variance at the cost of a negligible increase in bias. This can lead to substantial improvements in the accuracy with which we can predict the response for observations not used in model training. •Model Interpretability : It is often the case", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 269, "start_word": 86080, "end_word": 86480, "chunk_words": 400}}, "ISLP_website::c000270": {"text": "and Regularization many solutions. Each of these least squares solutions gives zero error on the training data, but typically very poor test set performance due to extremely high variance.1Byconstraining orshrinking the estimated coefficients, we can often substantially reduce the variance at the cost of a negligible increase in bias. This can lead to substantial improvements in the accuracy with which we can predict the response for observations not used in model training. •Model Interpretability : It is often the case that some or many of the variables used in a multiple regression model are in fact not associ- ated with the response. Including such irrelevant variables leads to unnecessary complexity in the resulting model. By removing these variables—that is, by setting the corresponding coefficient estimates to zero—we can obtain a model that is more easily interpreted. Now least squares is extremely unlikely to yield any coefficient estimates that are exactly zero. In this chapter, we see some approaches for au- tomatically performing feature selection orvariable selection —that is,feature selection variable selectionfor excluding irrelevant variables from a multiple regression model. There are many alternatives, both classical and modern, to using least squares to fit ( 6.1). In this chapter, we discuss three important classes of methods. •Subset Selection . This approach involves identifying a subset of the p predictors that we believe to be related to the response. We then fit a model using least squares on the reduced set of variables. •Shrinkage . This approach involves fitting a model involving all ppre- dictors.However,theestimatedcoefficientsareshrunkentowardszero relative to the least squares estimates. This shrinkage (also known as regularization )hastheeffectofreducingvariance.Dependingonwhat type of shrinkage is performed, some of the coefficients may be esti- mated to be exactly zero. Hence, shrinkage methods can also perform variable selection. •Dimension Reduction . This approach involves projecting theppredic- tors into an M-dimensional subspace, where M<p . This is achieved by computing Mdifferent linear combinations , orprojections , of the variables. Then these Mprojections are used as predictors to fit a linear regression model by least squares. In the following sections we describe each of these approaches in greater de- tail, along with their advantages and disadvantages. Although this chapter describes extensions and modifications to the linear model for regression seen in Chapter 3, the same concepts apply to other methods, such as the classification models seen in Chapter 4. 1Whenp/greatermuchn, the least squares solution that has the smallest sum", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 270, "start_word": 86400, "end_word": 86800, "chunk_words": 400}}, "ISLP_website::c000271": {"text": "variables. Then these Mprojections are used as predictors to fit a linear regression model by least squares. In the following sections we describe each of these approaches in greater de- tail, along with their advantages and disadvantages. Although this chapter describes extensions and modifications to the linear model for regression seen in Chapter 3, the same concepts apply to other methods, such as the classification models seen in Chapter 4. 1Whenp/greatermuchn, the least squares solution that has the smallest sum of squared coeffi- cients can sometimes perform quite well. See Section 10.8for a more detailed discussion. 6.1 Subset Selection 231 6.1 Subset Selection In this section we consider some methods for selecting subsets of predictors. These include best subset and stepwise model selection procedures. 6.1.1 Best Subset Selection To perform best subset selection , we fit a separate least squares regressionbest subset selectionforeachpossiblecombinationofthe ppredictors.Thatis,wefitall pmodels that contain exactly one predictor, all/parenleftbigp 2/parenrightbig =p(p−1)/2models that contain exactly two predictors, and so forth. We then look at all of the resulting models, with the goal of identifying the one that is best. The problem of selecting the best model from among the 2ppossibilities considered by best subset selection is not trivial. This is usually broken up into two stages, as described in Algorithm 6.1. Algorithm 6.1 Best subset selection 1. LetM0denote the null model , which contains no predictors. This model simply predicts the sample mean for each observation. 2. Fork=1,2,...p : (a) Fit all/parenleftbigp k/parenrightbig models that contain exactly kpredictors. (b) Pick the best among these/parenleftbigp k/parenrightbig models, and call it Mk. Herebest is defined as having the smallest RSS, or equivalently largest R2. 3. Select a single best model from among M0,...,Mpusing using the prediction error on a validation set, Cp(AIC), BIC, or adjusted R2. Or use the cross-validation method. In Algorithm 6.1, Step 2 identifies the best model (on the training data) for each subset size, in order to reduce the problem from one of 2ppossible models to one of p+1possible models. In Figure 6.1, these models form the lower frontier depicted in red. Now in order to select a single best model, we must simply choose among thesep+1options. This task must be performed with care, because the RSS of these p+1models decreases monotonically, and the R2increases monotonically, as the number of features included in the models increases. Therefore, if we use these statistics to select the best model,", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 271, "start_word": 86720, "end_word": 87120, "chunk_words": 400}}, "ISLP_website::c000272": {"text": "reduce the problem from one of 2ppossible models to one of p+1possible models. In Figure 6.1, these models form the lower frontier depicted in red. Now in order to select a single best model, we must simply choose among thesep+1options. This task must be performed with care, because the RSS of these p+1models decreases monotonically, and the R2increases monotonically, as the number of features included in the models increases. Therefore, if we use these statistics to select the best model, then we will always end up with a model involving all of the variables. The problem is that a low RSS or a high R2indicates a model with a low training error, whereas we wish to choose a model that has a low testerror. (As shown in Chapter 2in Figures 2.9–2.11, training error tends to be quite a bit smaller than test error, and a low training error by no means guarantees a low test error.) Therefore, in Step 3, weuse the error on a validationset, Cp, BIC, or adjusted R2in order to select among M0,M1,...,Mp. If cross-validation is used to select the best model, then Step 2 is repeated on each training fold, and the validation errors are averaged to select the best value of k. 232 6. Linear Model Selection and Regularization 2 4 6 8 102e+07 4e+07 6e+07 8e+07Number of PredictorsResidual Sum of Squares2 4 6 8 100.0 0.2 0.4 0.6 0.8 1.0Number of PredictorsR2 FIGURE 6.1. For each possible model containing a subset of the ten predictors in theCreditdata set, the RSS and R2are displayed. The red frontier tracks the bestmodel for a given number of predictors, according to RSS and R2. Though the data set contains only ten predictors, the x-axis ranges from 1to11, since one of the variables is categorical and takes on three values, leading to the creation of two dummy variables. Then the model Mkfit on the full training set is delivered for the chosen k. These approaches are discussed in Section 6.1.3. An application of best subset selection is shown in Figure 6.1. Each plotted point corresponds to a least squares regression model fit using a different subset of the 10 predictors in the Creditdata set, discussed in Chapter 3. Here the variable regionis a three-level qualitative variable, and so is represented by two dummy variables, which are selected sepa- rately in this case. Hence, there are a total of 11", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 272, "start_word": 87040, "end_word": 87440, "chunk_words": 400}}, "ISLP_website::c000273": {"text": "for the chosen k. These approaches are discussed in Section 6.1.3. An application of best subset selection is shown in Figure 6.1. Each plotted point corresponds to a least squares regression model fit using a different subset of the 10 predictors in the Creditdata set, discussed in Chapter 3. Here the variable regionis a three-level qualitative variable, and so is represented by two dummy variables, which are selected sepa- rately in this case. Hence, there are a total of 11 possible variables which can be included in the model. We have plotted the RSS and R2statistics for each model, as a function of the number of variables. The red curves connect the best models for each model size, according to RSS or R2. The figure shows that, as expected, these quantities improve as the number of variablesincreases;however,fromthethree-variablemodelon,thereislittle improvement in RSS and R2as a result of including additional predictors. Although we have presented best subset selection here for least squares regression, the same ideas apply to other types of models, such as logistic regression. In the case of logistic regression, instead of ordering models by RSS in Step 2 of Algorithm 6.1, we instead use the deviance, a measuredeviancethat plays the role of RSS for a broader class of models. The deviance is negative two times the maximized log-likelihood; the smaller the deviance, the better the fit. While best subset selection is a simple and conceptually appealing ap- proach, it suffers from computational limitations. The number of possible models that must be considered grows rapidly as pincreases. In general, there are 2pmodels that involve subsets of ppredictors. So if p= 10 , then there are approximately 1,000 possible models to be considered, and if p= 20 ,thenthereareoveronemillionpossibilities!Consequently,bestsub- setselectionbecomescomputationallyinfeasibleforvaluesof pgreaterthan 6.1 Subset Selection 233 Algorithm 6.2 Forward stepwise selection 1. LetM0denote the nullmodel, which contains no predictors. 2. Fork=0,...,p −1: (a) Consider all p−kmodels that augment the predictors in Mk with one additional predictor. (b) Choose the bestamong these p−kmodels, and call it Mk+1. Herebestis defined as having smallest RSS or highest R2. 3. Select a single best model from among M0,...,Mpusing the pre- diction error on a validation set, Cp(AIC), BIC, or adjusted R2. Or use the cross-validation method. around40, even with extremely fast modern computers. There are compu- tational shortcuts—so called branch-and-bound techniques—for eliminat- ing some choices, but these have their limitations as pgets large. They also only work for", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 273, "start_word": 87360, "end_word": 87760, "chunk_words": 400}}, "ISLP_website::c000274": {"text": "additional predictor. (b) Choose the bestamong these p−kmodels, and call it Mk+1. Herebestis defined as having smallest RSS or highest R2. 3. Select a single best model from among M0,...,Mpusing the pre- diction error on a validation set, Cp(AIC), BIC, or adjusted R2. Or use the cross-validation method. around40, even with extremely fast modern computers. There are compu- tational shortcuts—so called branch-and-bound techniques—for eliminat- ing some choices, but these have their limitations as pgets large. They also only work for least squares linear regression. We present computationally efficient alternatives to best subset selection next. 6.1.2 Stepwise Selection For computational reasons, best subset selection cannot be applied with very large p. Best subset selection may also suffer from statistical problems whenpislarge.Thelargerthesearchspace,thehigherthechanceoffinding models that look good on the training data, even though they might not have any predictive power on future data. Thus an enormous search space can lead to overfitting and high variance of the coefficient estimates. For both of these reasons, stepwise methods, which explore a far more restricted set of models, are attractive alternatives to best subset selection. Forward Stepwise Selection Forward stepwise selection is a computationally efficient alternative to bestforward stepwise selectionsubset selection. While the best subset selection procedure considers all 2ppossible models containing subsets of the ppredictors, forward step- wise considers a much smaller set of models. Forward stepwise selection begins with a model containing no predictors, and then adds predictors to the model, one-at-a-time, until all of the predictors are in the model. In particular, at each step the variable that gives the greatest additional improvement to the fit is added to the model. More formally, the forward stepwise selection procedure is given in Algorithm 6.2. Unlike best subset selection, which involved fitting 2pmodels, forward stepwise selection involves fitting one null model, along with p−kmodels in thekth iteration, for k=0,...,p −1. This amounts to a total of 1+/summationtextp−1 k=0(p−k)=1 + p(p+1)/2models. This is a substantial difference: when 234 6. Linear Model Selection and Regularization # Variables Best subset Forward stepwise One rating rating Two rating,income rating,income Three rating,income,student rating ,income,student Four cards,income rating,income, student,limit student,limit TABLE 6.1. The first four selected models for best subset selection and forward stepwise selection on the Creditdata set. The first three models are identical but the fourth models differ. p= 20 , best subset selection requires fitting 1,048,576models, whereas forward stepwise selection requires fitting only 211models.2 In Step 2(b) of", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 274, "start_word": 87680, "end_word": 88080, "chunk_words": 400}}, "ISLP_website::c000275": {"text": "when 234 6. Linear Model Selection and Regularization # Variables Best subset Forward stepwise One rating rating Two rating,income rating,income Three rating,income,student rating ,income,student Four cards,income rating,income, student,limit student,limit TABLE 6.1. The first four selected models for best subset selection and forward stepwise selection on the Creditdata set. The first three models are identical but the fourth models differ. p= 20 , best subset selection requires fitting 1,048,576models, whereas forward stepwise selection requires fitting only 211models.2 In Step 2(b) of Algorithm 6.2, we must identify the bestmodel from among those p−kthat augment Mkwith one additional predictor. We can do this by simply choosing the model with the lowest RSS or the highest R2. However, in Step 3, we must identify the best model among a set of models with different numbers of variables. This is more challenging, and is discussed in Section 6.1.3. Forward stepwise selection’s computational advantage over best subset selection is clear. Though forward stepwise tends to do well in practice, it is not guaranteed to find the best possible model out of all 2pmod- els containing subsets of the ppredictors. For instance, suppose that in a given data set with p=3predictors, the best possible one-variable model contains X1, and the best possible two-variable model instead contains X2 andX3. Then forward stepwise selection will fail to select the best possible two-variable model, because M1will contain X1, soM2must also contain X1together with one additional variable. Table6.1, which shows the first four selected models for best subset and forward stepwise selection on the Creditdata set, illustrates this phe- nomenon. Both best subset selection and forward stepwise selection choose ratingfor the best one-variable model and then include incomeandstudent for the two- and three-variable models. However, best subset selection re- placesratingbycardsin the four-variable model, while forward stepwise selection must maintain ratingin its four-variable model. In this example, Figure6.1indicates that there is not much difference between the three- and four-variable models in terms of RSS, so either of the four-variable models will likely be adequate. Forward stepwise selection can be applied even in the high-dimensional setting where n<p ; however, in this case, it is possible to construct sub- modelsM0,...,Mn−1only, since each submodel is fit using least squares, which will not yield a unique solution if p≥n. Backward Stepwise Selection Like forward stepwise selection, backward stepwise selection provides anbackward stepwise selection 2Though forward stepwise selection considers p(p+ 1)/2+1 models, it performs a guidedsearch", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 275, "start_word": 88000, "end_word": 88400, "chunk_words": 400}}, "ISLP_website::c000276": {"text": "of RSS, so either of the four-variable models will likely be adequate. Forward stepwise selection can be applied even in the high-dimensional setting where n<p ; however, in this case, it is possible to construct sub- modelsM0,...,Mn−1only, since each submodel is fit using least squares, which will not yield a unique solution if p≥n. Backward Stepwise Selection Like forward stepwise selection, backward stepwise selection provides anbackward stepwise selection 2Though forward stepwise selection considers p(p+ 1)/2+1 models, it performs a guidedsearch over model space, and so the effective model space considered contains substantially more than p(p+ 1)/2+1 models. 6.1 Subset Selection 235 efficient alternative to best subset selection. However, unlike forward step- wise selection, it begins with the full least squares model containing all p predictors, and then iteratively removes the least useful predictor, one-at- a-time. Details are given in Algorithm 6.3. Algorithm 6.3 Backward stepwise selection 1. LetMpdenote the fullmodel, which contains all ppredictors. 2. Fork=p, p−1,...,1: (a) Consider all kmodels that contain all but one of the predictors inMk, for a total of k−1predictors. (b) Choose the bestamong these kmodels, and call it Mk−1. Here bestis defined as having smallest RSS or highest R2. 3. Select a single best model from among M0,...,Mpusing the pre- diction error on a validation set, Cp(AIC), BIC, or adjusted R2. Or use the cross-validation method. Likeforwardstepwiseselection,thebackwardselectionapproachsearches through only 1+p(p+1)/2models, and so can be applied in settings where pis too large to apply best subset selection.3Also like forward stepwise selection, backward stepwise selection is not guaranteed to yield the best model containing a subset of the ppredictors. Backward selection requires that the number of samples nis larger than the number of variables p(so that the full model can be fit). In contrast, forward stepwise can be used even when n<p , and so is the only viable subset method when pis very large. Hybrid Approaches The best subset, forward stepwise, and backward stepwise selection ap- proaches generally give similar but not identical models. As another al- ternative, hybrid versions of forward and backward stepwise selection are available, in which variables are added to the model sequentially, in analogy to forward selection. However, after adding each new variable, the method may also remove any variables that no longer provide an improvement in the model fit. Such an approach attempts to more closely mimic best sub- set selection while retaining the computational advantages of forward and", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 276, "start_word": 88320, "end_word": 88720, "chunk_words": 400}}, "ISLP_website::c000277": {"text": "ap- proaches generally give similar but not identical models. As another al- ternative, hybrid versions of forward and backward stepwise selection are available, in which variables are added to the model sequentially, in analogy to forward selection. However, after adding each new variable, the method may also remove any variables that no longer provide an improvement in the model fit. Such an approach attempts to more closely mimic best sub- set selection while retaining the computational advantages of forward and backward stepwise selection. 6.1.3 Choosing the Optimal Model Best subset selection, forward selection, and backward selection result in the creation of a set of models, each of which contains a subset of the p 3Likeforwardstepwiseselection, backwardstepwiseselection performs a guidedsearch over model space, and so effectively considers substantially more than 1+p(p+ 1)/2 models. 236 6. Linear Model Selection and Regularization predictors. To apply these methods, we need a way to determine which of these models is best. As we discussed in Section 6.1.1, the model containing all of the predictors will always have the smallest RSS and the largest R2, since these quantities are related to the training error. Instead, we wish to choose a model with a low test error. As is evident here, and as we show in Chapter 2, the training error can be a poor estimate of the test error. Therefore, RSS and R2are not suitable for selecting the best model among a collection of models with different numbers of predictors. In order to select the best model with respect to test error, we need to estimate this test error. There are two common approaches: 1. We can indirectly estimate test error by making an adjustment to the training error to account for the bias due to overfitting. 2. We can directlyestimate the test error, using either a validation set approach or a cross-validation approach, as discussed in Chapter 5. We consider both of these approaches below. Cp, AIC, BIC, and Adjusted R2 We show in Chapter 2that the training set MSE is generally an under- estimate of the test MSE. (Recall that MSE = RSS /n.) This is because when we fit a model to the training data using least squares, we specifi- cally estimate the regression coefficients such that the training RSS (but not the test RSS) is as small as possible. In particular, the training error will decrease as more variables are included in", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 277, "start_word": 88640, "end_word": 89040, "chunk_words": 400}}, "ISLP_website::c000278": {"text": "Cp, AIC, BIC, and Adjusted R2 We show in Chapter 2that the training set MSE is generally an under- estimate of the test MSE. (Recall that MSE = RSS /n.) This is because when we fit a model to the training data using least squares, we specifi- cally estimate the regression coefficients such that the training RSS (but not the test RSS) is as small as possible. In particular, the training error will decrease as more variables are included in the model, but the test error may not. Therefore, training set RSS and training set R2cannot be used to select from among a set of models with different numbers of variables. However, a number of techniques for adjusting the training error for the modelsizeareavailable.Theseapproachescanbeusedtoselectamongaset of models with different numbers of variables. We now consider four such approaches: Cp,Akaike information criterion (AIC),Bayesian informationCp Akaike information criterioncriterion (BIC),and adjusted R2.Figure6.2displaysCp,BIC,andadjusted Bayesian information criterion adjusted R2R2for the best model of each size produced by best subset selection on the Creditdata set. For a fitted least squares model containing dpredictors, the Cpestimate of test MSE is computed using the equation Cp=1 n/parenleftbig RSS + 2 dˆσ2/parenrightbig , (6.2) whereˆσ2is an estimate of the variance of the error /epsilon1associated with each response measurement in ( 6.1).4Typically ˆσ2is estimated using the full model containing all predictors. Essentially, the Cpstatistic adds a penalty of2dˆσ2to the training RSS in order to adjust for the fact that the training error tends to underestimate the test error. Clearly, the penalty increases as the number of predictors in the model increases; this is intended to adjust 4Mallow’s Cpis sometimes defined as C/prime p= RSS /ˆσ2+2d−n. This is equivalent to the definition given above in the sense that Cp=1 nˆσ2(C/prime p+n), and so the model with smallest Cpalso has smallest C/prime p. 6.1 Subset Selection 237 2 4 6 8 1010000 15000 20000 25000 30000Number of PredictorsCp 2 4 6 8 1010000 15000 20000 25000 30000Number of PredictorsBIC 2 4 6 8 100.86 0.88 0.90 0.92 0.94 0.96Number of PredictorsAdjusted R2 FIGURE 6.2. Cp, BIC, and adjusted R2are shown for the best models of each size for the Creditdata set (the lower frontier in Figure 6.1).Cpand BIC are estimates of test MSE. In the middle plot we see that the BIC estimate of test error shows an increase after four variables are selected. The other two plots are rather flat after four", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 278, "start_word": 88960, "end_word": 89360, "chunk_words": 400}}, "ISLP_website::c000279": {"text": "15000 20000 25000 30000Number of PredictorsBIC 2 4 6 8 100.86 0.88 0.90 0.92 0.94 0.96Number of PredictorsAdjusted R2 FIGURE 6.2. Cp, BIC, and adjusted R2are shown for the best models of each size for the Creditdata set (the lower frontier in Figure 6.1).Cpand BIC are estimates of test MSE. In the middle plot we see that the BIC estimate of test error shows an increase after four variables are selected. The other two plots are rather flat after four variables are included. for the corresponding decrease in training RSS. Though it is beyond the scope of this book, one can show that if ˆσ2is an unbiased estimate of σ2in (6.2), thenCpis an unbiased estimate of test MSE. As a consequence, the Cpstatistic tends to take on a small value for models with a low test error, so when determining which of a set of models is best, we choose the model with the lowest Cpvalue. In Figure 6.2,Cpselects the six-variable model containing the predictors income,limit,rating,cards,ageandstudent. The AIC criterion is defined for a large class of models fit by maximum likelihood. In the case of the model ( 6.1) with Gaussian errors, maximum likelihood and least squares are the same thing. In this case AIC is given by AIC =1 n/parenleftbig RSS + 2 dˆσ2/parenrightbig , where, for simplicity, we have omitted irrelevant constants.5Hence for least squares models, Cpand AIC are proportional to each other, and so only Cpis displayed in Figure 6.2. BIC is derived from a Bayesian point of view, but ends up looking similar toCp(and AIC) as well. For the least squares model with dpredictors, the BIC is, up to irrelevant constants, given by BIC=1 n/parenleftbig RSS + log( n)dˆσ2/parenrightbig . (6.3) LikeCp, the BIC will tend to take on a small value for a model with a low test error, and so generally we select the model that has the lowest BIC value. Notice that BIC replaces the 2dˆσ2used byCpwith alog(n)dˆσ2 term, where nis the number of observations. Since logn>2for anyn>7, 5There are two formulas for AIC for least squares regression. The formula that we provide here requires an expression for σ2, which we obtain using the full model con- taining all predictors. The second formula is appropriate when σ2is unknown and we do not want to explicitly estimate it; that formula has a log(RSS)term instead of an RSS term. Detailed derivations of these two formulas", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 279, "start_word": 89280, "end_word": 89680, "chunk_words": 400}}, "ISLP_website::c000280": {"text": "replaces the 2dˆσ2used byCpwith alog(n)dˆσ2 term, where nis the number of observations. Since logn>2for anyn>7, 5There are two formulas for AIC for least squares regression. The formula that we provide here requires an expression for σ2, which we obtain using the full model con- taining all predictors. The second formula is appropriate when σ2is unknown and we do not want to explicitly estimate it; that formula has a log(RSS)term instead of an RSS term. Detailed derivations of these two formulas are outside of the scope of this book. 238 6. Linear Model Selection and Regularization the BIC statistic generally places a heavier penalty on models with many variables, and hence results in the selection of smaller models than Cp. In Figure 6.2, we see that this is indeed the case for the Creditdata set; BIC chooses a model that contains only the four predictors income,limit, cards, andstudent. In this case the curves are very flat and so there does not appear to be much difference in accuracy between the four-variable and six-variable models. Theadjusted R2statisticisanotherpopularapproachforselectingamong a set of models that contain different numbers of variables. Recall from Chapter 3that the usual R2is defined as 1−RSS/TSS, where TSS =/summationtext(yi−y)2is thetotal sum of squares for the response. Since RSS always decreases as more variables are added to the model, the R2always increases as more variables are added. For a least squares model with dvariables, the adjusted R2statistic is calculated as Adjusted R2=1−RSS/(n−d−1) TSS/(n−1). (6.4) UnlikeCp, AIC, and BIC, for which a smallvalue indicates a model with a low test error, a largevalue of adjusted R2indicates a model with a small test error. Maximizing the adjusted R2is equivalent to minimizing RSS n−d−1.WhileRSSalwaysdecreasesasthenumberofvariablesinthemodel increases,RSS n−d−1may increase or decrease, due to the presence of din the denominator. The intuition behind the adjusted R2is that once all of the correct variableshavebeenincludedinthemodel,addingadditional noisevariables will lead to only a very small decrease in RSS. Since adding noise variables leads to an increase in d, such variables will lead to an increase inRSS n−d−1, and consequently a decrease in the adjusted R2. Therefore, in theory, the model with the largest adjusted R2will have only correct variables and no noise variables. Unlike the R2statistic, the adjusted R2statistic pays a pricefor the inclusion of unnecessary variables in the model. Figure 6.2 displays the adjusted R2for theCreditdata set. Using this statistic results in the selection of a model that contains seven variables,", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 280, "start_word": 89600, "end_word": 90000, "chunk_words": 400}}, "ISLP_website::c000281": {"text": "leads to an increase in d, such variables will lead to an increase inRSS n−d−1, and consequently a decrease in the adjusted R2. Therefore, in theory, the model with the largest adjusted R2will have only correct variables and no noise variables. Unlike the R2statistic, the adjusted R2statistic pays a pricefor the inclusion of unnecessary variables in the model. Figure 6.2 displays the adjusted R2for theCreditdata set. Using this statistic results in the selection of a model that contains seven variables, adding ownto the model selected by Cpand AIC. Cp, AIC, and BIC all have rigorous theoretical justifications that are beyond the scope of this book. These justifications rely on asymptotic ar- guments (scenarios where the sample size nis very large). Despite its pop- ularity, and even though it is quite intuitive, the adjusted R2is not as well motivated in statistical theory as AIC, BIC, and Cp. All of these measures are simple to use and compute. Here we have presented their formulas in the case of a linear model fit using least squares; however, AIC and BIC can also be defined for more general types of models. Validation and Cross-Validation As an alternative to the approaches just discussed, we can directly esti- mate the test error using the validation set and cross-validation methods discussed in Chapter 5. We can compute the validation set error or the cross-validation error for each model under consideration, and then select 6.1 Subset Selection 239 2 4 6 8 10100 120 140 160 180 200 220Number of PredictorsSquare Root of BIC2 4 6 8 10100 120 140 160 180 200 220Number of PredictorsValidation Set Error2 4 6 8 10100 120 140 160 180 200 220Number of PredictorsCross−Validation ErrorFIGURE 6.3. For theCreditdata set, three quantities are displayed for the best model containing dpredictors, for dranging from 1to11. The overall best model, based on each of these quantities, is shown as a blue cross. Left:Square root of BIC. Center:Validation set errors. Right:Cross-validation errors. the model for which the resulting estimated test error is smallest. This pro- cedure has an advantage relative to AIC, BIC, Cp, and adjusted R2, in that it provides a direct estimate of the test error, and makes fewer assumptions about the true underlying model. It can also be used in a wider range of model selection tasks, even in cases where it is hard to pinpoint the model degrees of freedom (e.g. the", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 281, "start_word": 89920, "end_word": 90320, "chunk_words": 400}}, "ISLP_website::c000282": {"text": "BIC. Center:Validation set errors. Right:Cross-validation errors. the model for which the resulting estimated test error is smallest. This pro- cedure has an advantage relative to AIC, BIC, Cp, and adjusted R2, in that it provides a direct estimate of the test error, and makes fewer assumptions about the true underlying model. It can also be used in a wider range of model selection tasks, even in cases where it is hard to pinpoint the model degrees of freedom (e.g. the number of predictors in the model) or hard to estimate the error variance σ2. Note that when cross-validation is used, the sequence of models Mkin Algorithms 6.1–6.3is determined separately for each training fold, and the validation errors are averaged over all folds for each model size k. This means, for example with best-subset regression, thatMk, the best subset of size k, can differ across the folds. Once the best size kis chosen, we find the best model of that size on the full data set. In the past, performing cross-validation was computationally prohibitive for many problems with large pand/or large n, and so AIC, BIC, Cp, and adjusted R2were more attractive approaches for choosing among a set of models. However, nowadays with fast computers, the computations required to perform cross-validation are hardly ever an issue. Thus, cross- validation is a very attractive approach for selecting from among a number of models under consideration. Figure6.3displays, as a function of d, the BIC, validation set errors, and cross-validation errors on the Creditdata, for the best d-variable model. The validation errors were calculated by randomly selecting three-quarters of the observations as the training set, and the remainder as the valida- tion set. The cross-validation errors were computed using k= 10 folds. In this case, the validation and cross-validation methods both result in a six-variable model. However, all three approaches suggest that the four-, five-, and six-variable models are roughly equivalent in terms of their test errors. In fact, the estimated test error curves displayed in the center and right- handpanelsofFigure 6.3arequiteflat.Whileathree-variablemodelclearly haslowerestimated test error than a two-variablemodel, the estimated test errors of the 3- to 11-variable models are quite similar. Furthermore, if we 240 6. Linear Model Selection and Regularization repeated the validation set approach using a different split of the data into a training set and a validation set, or if we repeated cross-validation using a different set of cross-validation folds, then", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 282, "start_word": 90240, "end_word": 90640, "chunk_words": 400}}, "ISLP_website::c000283": {"text": "their test errors. In fact, the estimated test error curves displayed in the center and right- handpanelsofFigure 6.3arequiteflat.Whileathree-variablemodelclearly haslowerestimated test error than a two-variablemodel, the estimated test errors of the 3- to 11-variable models are quite similar. Furthermore, if we 240 6. Linear Model Selection and Regularization repeated the validation set approach using a different split of the data into a training set and a validation set, or if we repeated cross-validation using a different set of cross-validation folds, then the precise model with the lowest estimated test error would surely change. In this setting, we can select a model using the one-standard-error rule . We first calculate theone- standard- error rulestandard error of the estimated test MSE for each model size, and then select the smallest model for which the estimated test error is within one standard error of the lowest point on the curve. The rationale here is that if a set of models appear to be more or less equally good, then we might as well choose the simplest model—that is, the model with the smallest number of predictors. In this case, applying the one-standard-error rule to the validation set or cross-validation approach leads to selection of the three-variable model. 6.2 Shrinkage Methods The subset selection methods described in Section 6.1involve using least squares to fit a linear model that contains a subset of the predictors. As an alternative, we can fit a model containing all ppredictors using a technique thatconstrains orregularizes the coefficient estimates, or equivalently, that shrinksthe coefficient estimates towards zero. It may not be immediately obvious why such a constraint should improve the fit, but it turns out that shrinking the coefficient estimates can significantly reduce their variance. The two best-known techniques for shrinking the regression coefficients towards zero are ridge regression and thelasso. 6.2.1 Ridge Regression Recall from Chapter 3that the least squares fitting procedure estimates β0,β1,...,βpusing the values that minimize RSS =n/summationdisplay i=1 yi−β0−p/summationdisplay j=1βjxij 2 . Ridge regression is very similar to least squares, except that the coefficientsridge regressionare estimated by minimizing a slightly different quantity. In particular, the ridge regression coefficient estimates ˆβRare the values that minimize n/summationdisplay i=1 yi−β0−p/summationdisplay j=1βjxij 2 +λp/summationdisplay j=1β2 j= RSS + λp/summationdisplay j=1β2 j, (6.5) whereλ≥0is atuning parameter , to be determined separately. Equa-tuning parametertion6.5trades off two different criteria. As with least squares, ridge regres- sion seeks coefficient estimates that fit the data well,", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 283, "start_word": 90560, "end_word": 90960, "chunk_words": 400}}, "ISLP_website::c000284": {"text": "i=1 yi−β0−p/summationdisplay j=1βjxij 2 . Ridge regression is very similar to least squares, except that the coefficientsridge regressionare estimated by minimizing a slightly different quantity. In particular, the ridge regression coefficient estimates ˆβRare the values that minimize n/summationdisplay i=1 yi−β0−p/summationdisplay j=1βjxij 2 +λp/summationdisplay j=1β2 j= RSS + λp/summationdisplay j=1β2 j, (6.5) whereλ≥0is atuning parameter , to be determined separately. Equa-tuning parametertion6.5trades off two different criteria. As with least squares, ridge regres- sion seeks coefficient estimates that fit the data well, by making the RSS small. However, the second term, λ/summationtext jβ2 j, called a shrinkage penalty , isshrinkage penaltysmall when β1,...,βpare close to zero, and so it has the effect of shrinking the estimates of βjtowards zero. The tuning parameter λserves to control 6.2 Shrinkage Methods 241 1e−02 1e+00 1e+02 1e+04−300 −100 0 100 200 300 400Standardized CoefficientsIncomeLimitRatingStudent 0.0 0.2 0.4 0.6 0.8 1.0−300 −100 0 100 200 300 400Standardized Coefficientsλ/bardblˆβRλ/bardbl2//bardblˆβ/bardbl2FIGURE 6.4. The standardized ridge regression coefficients are displayed for theCreditdata set, as a function of λand/bardblˆβR λ/bardbl2//bardblˆβ/bardbl2. the relative impact of these two terms on the regression coefficient esti- mates. When λ=0, the penalty term has no effect, and ridge regression will produce the least squares estimates. However, as λ→∞, the impact of the shrinkage penalty grows, and the ridge regression coefficient estimates will approach zero. Unlike least squares, which generates only one set of co- efficient estimates, ridge regression will produce a different set of coefficient estimates, ˆβR λ, for each value of λ. Selecting a good value for λis critical; we defer this discussion to Section 6.2.3, where we use cross-validation. Note that in ( 6.5), the shrinkage penalty is applied to β1,...,βp, but not to the intercept β0. We want to shrink the estimated association of each variable with the response; however, we do not want to shrink the intercept, which is simply a measure of the mean value of the response whenxi1=xi2=...=xip=0. If we assume that the variables—that is, the columns of the data matrix X—have been centered to have mean zero before ridge regression is performed, then the estimated intercept will take the form ˆβ0=¯y=/summationtextn i=1yi/n. An Application to the Credit Data In Figure 6.4, the ridge regression coefficient estimates for the Creditdata set are displayed. In the left-hand panel, each curve corresponds to the ridge regression coefficient estimate for one of the ten variables, plotted as a function of λ. For example, the", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 284, "start_word": 90880, "end_word": 91280, "chunk_words": 400}}, "ISLP_website::c000285": {"text": "that the variables—that is, the columns of the data matrix X—have been centered to have mean zero before ridge regression is performed, then the estimated intercept will take the form ˆβ0=¯y=/summationtextn i=1yi/n. An Application to the Credit Data In Figure 6.4, the ridge regression coefficient estimates for the Creditdata set are displayed. In the left-hand panel, each curve corresponds to the ridge regression coefficient estimate for one of the ten variables, plotted as a function of λ. For example, the black solid line represents the ridge regression estimate for the incomecoefficient, as λis varied. At the extreme left-hand side of the plot, λis essentially zero, and so the corresponding ridge coefficient estimates are the same as the usual least squares esti- mates. But as λincreases, the ridge coefficient estimates shrink towards zero. When λis extremely large, then all of the ridge coefficient estimates are basically zero; this corresponds to the null model that contains no pre- dictors. In this plot, the income,limit,rating, andstudentvariables are displayed in distinct colors, since these variables tend to have by far the largest coefficient estimates. While the ridge coefficient estimates tend to decrease in aggregate as λincreases, individual coefficients, such as rating andincome, may occasionally increase as λincreases. 242 6. Linear Model Selection and Regularization The right-hand panel of Figure 6.4displays the same ridge coefficient estimates as the left-hand panel, but instead of displaying λon thex-axis, we now display /bardblˆβR λ/bardbl2//bardblˆβ/bardbl2, where ˆβdenotes the vector of least squares coefficient estimates. The notation /bardblβ/bardbl2denotes the /lscript2norm(pronounced/lscript2norm “ell 2”) of a vector, and is defined as /bardblβ/bardbl2=/radicalBig/summationtextp j=1βj2. It measures the distance of βfrom zero. As λincreases, the /lscript2norm of ˆβR λwillalways decrease, and so will /bardblˆβR λ/bardbl2//bardblˆβ/bardbl2. The latter quantity ranges from 1 (when λ=0, in which case the ridge regression coefficient estimate is the same as the least squares estimate, and so their /lscript2norms are the same) to 0 (whenλ=∞, in which case the ridge regression coefficient estimate is a vector of zeros, with /lscript2norm equal to zero). Therefore, we can think of the x-axis in the right-hand panel of Figure 6.4as the amount that the ridge regression coefficient estimates have been shrunken towards zero; a small value indicates that they have been shrunken very close to zero. The standard least squares coefficient estimates discussed in Chapter 3 arescale equivariant : multiplying Xjby a constant csimply leads to ascale equivariantscaling of the least squares coefficient", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 285, "start_word": 91200, "end_word": 91600, "chunk_words": 400}}, "ISLP_website::c000286": {"text": "regression coefficient estimate is a vector of zeros, with /lscript2norm equal to zero). Therefore, we can think of the x-axis in the right-hand panel of Figure 6.4as the amount that the ridge regression coefficient estimates have been shrunken towards zero; a small value indicates that they have been shrunken very close to zero. The standard least squares coefficient estimates discussed in Chapter 3 arescale equivariant : multiplying Xjby a constant csimply leads to ascale equivariantscaling of the least squares coefficient estimates by a factor of 1/c. In other words, regardless of how the jth predictor is scaled, Xjˆβjwill remain the same. In contrast, the ridge regression coefficient estimates can change sub- stantially when multiplying a given predictor by a constant. For instance, consider the incomevariable, which is measured in dollars. One could rea- sonably have measured income in thousands of dollars, which would result inareductionintheobservedvaluesof incomebyafactorof1,000.Nowdue to the sum of squared coefficients term in the ridge regression formulation (6.5), such a change in scale will not simply cause the ridge regression co- efficient estimate for incometo change by a factor of 1,000. In other words, XjˆβR j,λwill depend not only on the value of λ, but also on the scaling of the jth predictor. In fact, the value of XjˆβR j,λmay even depend on the scaling of theotherpredictors! Therefore, it is best to apply ridge regression after standardizing the predictors , using the formula ˜xij=xij/radicalBig 1 n/summationtextn i=1(xij−xj)2, (6.6) so that they are all on the same scale. In ( 6.6), the denominator is the estimated standard deviation of the jth predictor. Consequently, all of the standardized predictors will have a standard deviation of one. As a re- sult the final fit will not depend on the scale on which the predictors are measured. In Figure 6.4, they-axis displays the standardized ridge regres- sion coefficient estimates—that is, the coefficient estimates that result from performing ridge regression using standardized predictors. Why Does Ridge Regression Improve Over Least Squares? Ridgeregression’sadvantageoverleastsquaresisrootedinthe bias-variance trade-off. Asλincreases, the flexibility of the ridge regression fit decreases, leading to decreased variance but increased bias. This is illustrated in the left-hand panel of Figure 6.5, using a simulated data set containing p= 45 predictors and n= 50 observations. The green curve in the left-hand panel 6.2 Shrinkage Methods 243 1e−01 1e+01 1e+030 10 20 30 40 50 60Mean Squared Error0.0 0.2 0.4 0.6 0.8 1.00 10 20 30 40", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 286, "start_word": 91520, "end_word": 91920, "chunk_words": 400}}, "ISLP_website::c000287": {"text": "Does Ridge Regression Improve Over Least Squares? Ridgeregression’sadvantageoverleastsquaresisrootedinthe bias-variance trade-off. Asλincreases, the flexibility of the ridge regression fit decreases, leading to decreased variance but increased bias. This is illustrated in the left-hand panel of Figure 6.5, using a simulated data set containing p= 45 predictors and n= 50 observations. The green curve in the left-hand panel 6.2 Shrinkage Methods 243 1e−01 1e+01 1e+030 10 20 30 40 50 60Mean Squared Error0.0 0.2 0.4 0.6 0.8 1.00 10 20 30 40 50 60Mean Squared Errorλ/bardblˆβRλ/bardbl2//bardblˆβ/bardbl2FIGURE 6.5. Squared bias (black), variance (green), and test mean squared error (purple) for the ridge regression predictions on a simulated data set, as a function of λand/bardblˆβR λ/bardbl2//bardblˆβ/bardbl2. The horizontal dashed lines indicate the minimum possible MSE. The purple crosses indicate the ridge regression models for which the MSE is smallest. of Figure 6.5displays the variance of the ridge regression predictions as a function of λ. At the least squares coefficient estimates, which correspond to ridge regression with λ=0, the variance is high but there is no bias. But asλincreases, the shrinkage of the ridge coefficient estimates leads to a substantial reduction in the variance of the predictions, at the expense of a slight increase in bias. Recall that the test mean squared error (MSE), plot- ted in purple, is closely related to the variance plus the squared bias. For values of λup to about 10, the variance decreases rapidly, with very little increase in bias, plotted in black. Consequently, the MSE drops consider- ably asλincreases from 0to10. Beyond this point, the decrease in variance due to increasing λslows, and the shrinkage on the coefficients causes them to be significantly underestimated, resulting in a large increase in the bias. The minimum MSE is achieved at approximately λ= 30 . Interestingly, because of its high variance, the MSE associated with the least squares fit, when λ=0, is almost as high as that of the null model for which all coefficient estimates are zero, when λ=∞. However, for an intermediate value ofλ, the MSE is considerably lower. The right-hand panel of Figure 6.5displays the same curves as the left- hand panel, this time plotted against the /lscript2norm of the ridge regression coefficient estimates divided by the /lscript2norm of the least squares estimates. Now as we move from left to right, the fits become more flexible, and so the bias decreases and the variance increases. In general, in situations", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 287, "start_word": 91840, "end_word": 92240, "chunk_words": 400}}, "ISLP_website::c000288": {"text": "which all coefficient estimates are zero, when λ=∞. However, for an intermediate value ofλ, the MSE is considerably lower. The right-hand panel of Figure 6.5displays the same curves as the left- hand panel, this time plotted against the /lscript2norm of the ridge regression coefficient estimates divided by the /lscript2norm of the least squares estimates. Now as we move from left to right, the fits become more flexible, and so the bias decreases and the variance increases. In general, in situations where the relationship between the response and the predictors is close to linear, the least squares estimates will have low bias but may have high variance. This means that a small change in the training data can cause a large change in the least squares coefficient estimates. In particular, when the number of variables pis almost as large as the number of observations n, as in the example in Figure 6.5, the least squares estimates will be extremely variable. And if p>n , then the least squares estimates do not even have a unique solution, whereas ridge regression can still perform well by trading off a small increase in bias for a 244 6. Linear Model Selection and Regularization large decrease in variance. Hence, ridge regression works best in situations where the least squares estimates have high variance. Ridge regression also has substantial computational advantages over best subset selection, which requires searching through 2pmodels. As we dis- cussed previously, even for moderate values of p, such a search can be computationally infeasible. In contrast, for any fixed value of λ, ridge re- gression only fits a single model, and the model-fitting procedure can be performed quite quickly. In fact, one can show that the computations re- quired to solve ( 6.5),simultaneously for all values of λ, are almost identical to those for fitting a model using least squares. 6.2.2 The Lasso Ridge regression does have one obvious disadvantage. Unlike best subset, forward stepwise, and backward stepwise selection, which will generally select models that involve just a subset of the variables, ridge regression will include all ppredictors in the final model. The penalty λ/summationtextβ2 jin (6.5) willshrinkallofthecoefficientstowardszero,butitwillnotsetanyofthem exactly to zero (unless λ=∞). This may not be a problem for prediction accuracy, but it can create a challenge in model interpretation in settings in which the number of variables pis quite large. For example, in the Credit data set, it appears that", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 288, "start_word": 92160, "end_word": 92560, "chunk_words": 400}}, "ISLP_website::c000289": {"text": "subset, forward stepwise, and backward stepwise selection, which will generally select models that involve just a subset of the variables, ridge regression will include all ppredictors in the final model. The penalty λ/summationtextβ2 jin (6.5) willshrinkallofthecoefficientstowardszero,butitwillnotsetanyofthem exactly to zero (unless λ=∞). This may not be a problem for prediction accuracy, but it can create a challenge in model interpretation in settings in which the number of variables pis quite large. For example, in the Credit data set, it appears that the most important variables are income,limit, rating, andstudent. So we might wish to build a model including just these predictors. However, ridge regression will always generate a model involving all ten predictors. Increasing the value of λwill tend to reduce the magnitudes of the coefficients, but will not result in exclusion of any of the variables. Thelassois a relatively recent alternative to ridge regression that over-lassocomes this disadvantage. The lasso coefficients, ˆβL λ, minimize the quantity n/summationdisplay i=1 yi−β0−p/summationdisplay j=1βjxij 2 +λp/summationdisplay j=1|βj|= RSS + λp/summationdisplay j=1|βj|. (6.7) Comparing ( 6.7) to (6.5), we see that the lasso and ridge regression have similar formulations. The only difference is that the β2 jterm in the ridge regression penalty ( 6.5) has been replaced by |βj|in the lasso penalty ( 6.7). In statistical parlance, the lasso uses an /lscript1(pronounced “ell 1”) penalty instead of an /lscript2penalty. The /lscript1norm of a coefficient vector βis given by /bardblβ/bardbl1=/summationtext|βj|. As with ridge regression, the lasso shrinks the coefficient estimates to- wards zero. However, in the case of the lasso, the /lscript1penalty has the effect of forcing some of the coefficient estimates to be exactly equal to zero when thetuningparameter λissufficientlylarge.Hence,muchlikebestsubsetse- lection, the lasso performs variable selection . As a result, models generated from the lasso are generally much easier to interpret than those produced by ridge regression. We say that the lasso yields sparsemodels—that is,sparse models that involve only a subset of the variables. As in ridge regression, selecting a good value of λfor the lasso is critical; we defer this discussion to Section 6.2.3, where we use cross-validation. 6.2 Shrinkage Methods 245 20 50 100 200 500 2000 5000−200 0 100 200 300 400Standardized Coefficients0.0 0.2 0.4 0.6 0.8 1.0−300 −100 0 100 200 300 400Standardized CoefficientsIncomeLimitRatingStudentλ/bardblˆβLλ/bardbl1//bardblˆβ/bardbl1FIGURE 6.6. The standardized lasso coefficients on the Creditdata set are shown as a function of λand/bardblˆβL λ/bardbl1//bardblˆβ/bardbl1. As an example, consider the coefficient plots in Figure 6.6,", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 289, "start_word": 92480, "end_word": 92880, "chunk_words": 400}}, "ISLP_website::c000290": {"text": "in ridge regression, selecting a good value of λfor the lasso is critical; we defer this discussion to Section 6.2.3, where we use cross-validation. 6.2 Shrinkage Methods 245 20 50 100 200 500 2000 5000−200 0 100 200 300 400Standardized Coefficients0.0 0.2 0.4 0.6 0.8 1.0−300 −100 0 100 200 300 400Standardized CoefficientsIncomeLimitRatingStudentλ/bardblˆβLλ/bardbl1//bardblˆβ/bardbl1FIGURE 6.6. The standardized lasso coefficients on the Creditdata set are shown as a function of λand/bardblˆβL λ/bardbl1//bardblˆβ/bardbl1. As an example, consider the coefficient plots in Figure 6.6, which are gen- erated from applying the lasso to the Creditdata set. When λ=0, then the lasso simply gives the least squares fit, and when λbecomes sufficiently large, the lasso gives the null model in which all coefficient estimates equal zero. However, in between these two extremes, the ridge regression and lasso models are quite different from each other. Moving from left to right in the right-hand panel of Figure 6.6, we observe that at first the lasso re- sults in a model that contains only the ratingpredictor. Then studentand limitenter the model almost simultaneously, shortly followed by income. Eventually, the remaining variables enter the model. Hence, depending on the value of λ, the lasso can produce a model involving any number of vari- ables. In contrast, ridge regression will always include all of the variables in the model, although the magnitude of the coefficient estimates will depend onλ. Another Formulation for Ridge Regression and the Lasso One can show that the lasso and ridge regression coefficient estimates solve the problems minimize β  n/summationdisplay i=1 yi−β0−p/summationdisplay j=1βjxij 2  subject top/summationdisplay j=1|βj|≤s (6.8) and minimize β  n/summationdisplay i=1 yi−β0−p/summationdisplay j=1βjxij 2  subject top/summationdisplay j=1β2 j≤s, (6.9) respectively. In other words, for every value of λ, there is some ssuch that the Equations ( 6.7) and (6.8) will give the same lasso coefficient estimates. Similarly, for every value of λthere is a corresponding ssuch that Equa- tions(6.5)and(6.9)willgivethesameridgeregressioncoefficientestimates. 246 6. Linear Model Selection and Regularization Whenp=2, then (6.8) indicates that the lasso coefficient estimates have the smallest RSS out of all points that lie within the diamond defined by |β1|+|β2|≤s. Similarly, the ridge regression estimates have the smallest RSS out of all points that lie within the circle defined by β2 1+β2 2≤s. Wecanthinkof( 6.8)asfollows.Whenweperformthelassowearetrying to find the set of coefficient estimates that lead to the smallest RSS, subject to the constraint that there is a budgetsfor how large/summationtextp", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 290, "start_word": 92800, "end_word": 93200, "chunk_words": 400}}, "ISLP_website::c000291": {"text": "6. Linear Model Selection and Regularization Whenp=2, then (6.8) indicates that the lasso coefficient estimates have the smallest RSS out of all points that lie within the diamond defined by |β1|+|β2|≤s. Similarly, the ridge regression estimates have the smallest RSS out of all points that lie within the circle defined by β2 1+β2 2≤s. Wecanthinkof( 6.8)asfollows.Whenweperformthelassowearetrying to find the set of coefficient estimates that lead to the smallest RSS, subject to the constraint that there is a budgetsfor how large/summationtextp j=1|βj|can be. Whensis extremely large, then this budget is not very restrictive, and so the coefficient estimates can be large. In fact, if sis large enough that the least squares solution falls within the budget, then ( 6.8) will simply yield the least squares solution. In contrast, if sis small, then/summationtextp j=1|βj|must be small in order to avoid violating the budget. Similarly, ( 6.9) indicates that when we perform ridge regression, we seek a set of coefficient estimates such that the RSS is as small as possible, subject to the requirement that/summationtextp j=1β2 jnot exceed the budget s. The formulations ( 6.8) and (6.9) reveal a close connection between the lasso, ridge regression, and best subset selection. Consider the problem minimize β  n/summationdisplay i=1 yi−β0−p/summationdisplay j=1βjxij 2  subject top/summationdisplay j=1I(βj/negationslash= 0) ≤s. (6.10) HereI(βj/negationslash= 0) isanindicatorvariable:ittakesonavalueof1if βj/negationslash=0,and equals zero otherwise. Then ( 6.10) amounts to finding a set of coefficient estimates such that RSS is as small as possible, subject to the constraint that no more than scoefficients can be nonzero. The problem ( 6.10) is equivalent to best subset selection. Unfortunately, solving ( 6.10) is com- putationally infeasible when pis large, since it requires considering all/parenleftbigp s/parenrightbig models containing spredictors. Therefore, we can interpret ridge regression and the lasso as computationally feasible alternatives to best subset selec- tion that replace the intractable form of the budget in ( 6.10) with forms that are much easier to solve. Of course, the lasso is much more closely related to best subset selection, since the lasso performs feature selection forssufficiently small in ( 6.8), while ridge regression does not. The Variable Selection Property of the Lasso Why is it that the lasso, unlike ridge regression, results in coefficient esti- mates that are exactly equal to zero? The formulations ( 6.8) and (6.9) can be used to shed light on the issue. Figure 6.7illustrates the situation. The least squares solution is", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 291, "start_word": 93120, "end_word": 93520, "chunk_words": 400}}, "ISLP_website::c000292": {"text": "Of course, the lasso is much more closely related to best subset selection, since the lasso performs feature selection forssufficiently small in ( 6.8), while ridge regression does not. The Variable Selection Property of the Lasso Why is it that the lasso, unlike ridge regression, results in coefficient esti- mates that are exactly equal to zero? The formulations ( 6.8) and (6.9) can be used to shed light on the issue. Figure 6.7illustrates the situation. The least squares solution is marked as ˆβ, while the blue diamond and circle represent the lasso and ridge regression constraints in ( 6.8) and (6.9), re- spectively. If sis sufficiently large, then the constraint regions will contain ˆβ, and so the ridge regression and lasso estimates will be the same as the least squares estimates. (Such a large value of scorresponds to λ=0 in (6.5) and (6.7).) However, in Figure 6.7the least squares estimates lie out- side of the diamond and the circle, and so the least squares estimates are not the same as the lasso and ridge regression estimates. Each of the ellipses centered around ˆβrepresents a contour: this meanscontourthat all of the points on a particular ellipse have the same RSS value. As 6.2 Shrinkage Methods 247 FIGURE 6.7. Contours of the error and constraint functions for the lasso (left)and ridge regression (right). The solid blue areas are the constraint regions, |β1|+|β2|≤sandβ2 1+β2 2≤s, while the red ellipses are the contours of the RSS. the ellipses expand away from the least squares coefficient estimates, the RSS increases. Equations ( 6.8) and (6.9) indicate that the lasso and ridge regression coefficient estimates are given by the first point at which an ellipse contacts the constraint region. Since ridge regression has a circular constraintwithnosharppoints,thisintersectionwillnotgenerallyoccuron an axis, and so the ridge regression coefficient estimates will be exclusively non-zero. However, the lasso constraint has cornersat each of the axes, and so the ellipse will often intersect the constraint region at an axis. When this occurs, one of the coefficients will equal zero. In higher dimensions, many of the coefficient estimates may equal zero simultaneously. In Figure 6.7, the intersection occurs at β1=0, and so the resulting model will only include β2. In Figure 6.7, we considered the simple case of p=2. When p=3, then the constraint region for ridge regression becomes a sphere, and the constraint region for the lasso becomes a polyhedron. When p>3, the", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 292, "start_word": 93440, "end_word": 93840, "chunk_words": 400}}, "ISLP_website::c000293": {"text": "the constraint region at an axis. When this occurs, one of the coefficients will equal zero. In higher dimensions, many of the coefficient estimates may equal zero simultaneously. In Figure 6.7, the intersection occurs at β1=0, and so the resulting model will only include β2. In Figure 6.7, we considered the simple case of p=2. When p=3, then the constraint region for ridge regression becomes a sphere, and the constraint region for the lasso becomes a polyhedron. When p>3, the constraint for ridge regression becomes a hypersphere, and the constraint for the lasso becomes a polytope. However, the key ideas depicted in Fig- ure6.7still hold. In particular, the lasso leads to feature selection when p>2due to the sharp corners of the polyhedron or polytope. Comparing the Lasso and Ridge Regression It is clear that the lasso has a major advantage over ridge regression, in that it produces simpler and more interpretable models that involve only a subset of the predictors. However, which method leads to better prediction accuracy? Figure 6.8displays the variance, squared bias, and test MSE of the lasso applied to the same simulated data as in Figure 6.5. Clearly the lasso leads to qualitatively similar behavior to ridge regression, in that as λ increases, the variance decreases and the bias increases. In the right-hand 248 6. Linear Model Selection and Regularization 0.02 0.10 0.50 2.00 10.00 50.000 10 20 30 40 50 60Mean Squared Error0.0 0.2 0.4 0.6 0.8 1.00 10 20 30 40 50 60R2 on Training DataMean Squared ErrorλFIGURE 6.8. Left:Plots of squared bias (black), variance (green), and test MSE (purple) for the lasso on a simulated data set. Right:Comparison of squared bias, variance, and test MSE between lasso (solid) and ridge (dotted). Both are plotted against their R2on the training data, as a common form of indexing. The crosses in both plots indicate the lasso model for which the MSE is smallest. panel of Figure 6.8, the dotted lines represent the ridge regression fits. Here we plot both against their R2on the training data. This is another useful way to index models, and can be used to compare models with different types of regularization, as is the case here. In this example, the lasso and ridge regression result in almost identical biases. However, the variance of ridge regression is slightly lower than the variance of the lasso. Consequently,theminimumMSEofridgeregressionisslightlysmallerthan that of the lasso. However, the data", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 293, "start_word": 93760, "end_word": 94160, "chunk_words": 400}}, "ISLP_website::c000294": {"text": "6.8, the dotted lines represent the ridge regression fits. Here we plot both against their R2on the training data. This is another useful way to index models, and can be used to compare models with different types of regularization, as is the case here. In this example, the lasso and ridge regression result in almost identical biases. However, the variance of ridge regression is slightly lower than the variance of the lasso. Consequently,theminimumMSEofridgeregressionisslightlysmallerthan that of the lasso. However, the data in Figure 6.8were generated in such a way that all 45 predictorswererelatedtotheresponse—thatis,noneofthetruecoefficients β1,...,β45equaled zero. The lasso implicitly assumes that a number of the coefficients truly equal zero. Consequently, it is not surprising that ridge regression outperforms the lasso in terms of prediction error in this setting. Figure6.9illustrates a similar situation, except that now the response is a function of only 2 out of 45predictors. Now the lasso tends to outperform ridge regression in terms of bias, variance, and MSE. These two examples illustrate that neither ridge regression nor the lasso will universally dominate the other. In general, one might expect the lasso to perform better in a setting where a relatively small number of predictors have substantial coefficients, and the remaining predictors have coefficients that are very small or that equal zero. Ridge regression will perform better when the response is a function of many predictors, all with coefficients of roughly equal size. However, the number of predictors that is related to the response is never known a priori for real data sets. A technique such as cross-validation can be used in order to determine which approach is better on a particular data set. As with ridge regression, when the least squares estimates have exces- sively high variance, the lasso solution can yield a reduction in variance at the expense of a small increase in bias, and consequently can gener- ate more accurate predictions. Unlike ridge regression, the lasso performs variable selection, and hence results in models that are easier to interpret. 6.2 Shrinkage Methods 249 0.02 0.10 0.50 2.00 10.00 50.000 20 40 60 80 100Mean Squared Error0.4 0.5 0.6 0.7 0.8 0.9 1.00 20 40 60 80 100R2 on Training DataMean Squared ErrorλFIGURE 6.9. Left:Plots of squared bias (black), variance (green), and test MSE (purple) for the lasso. The simulated data is similar to that in Figure 6.8, except that now only two predictors are related to the", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 294, "start_word": 94080, "end_word": 94480, "chunk_words": 400}}, "ISLP_website::c000295": {"text": "variable selection, and hence results in models that are easier to interpret. 6.2 Shrinkage Methods 249 0.02 0.10 0.50 2.00 10.00 50.000 20 40 60 80 100Mean Squared Error0.4 0.5 0.6 0.7 0.8 0.9 1.00 20 40 60 80 100R2 on Training DataMean Squared ErrorλFIGURE 6.9. Left:Plots of squared bias (black), variance (green), and test MSE (purple) for the lasso. The simulated data is similar to that in Figure 6.8, except that now only two predictors are related to the response. Right:Comparison of squared bias, variance, and test MSE between lasso (solid) and ridge (dotted). Both are plotted against their R2on the training data, as a common form of indexing. The crosses in both plots indicate the lasso model for which the MSE is smallest. Thereareveryefficientalgorithmsforfittingbothridgeandlassomodels; in both cases the entire coefficient paths can be computed with about the same amount of work as a single least squares fit. We will explore this further in the lab at the end of this chapter. A Simple Special Case for Ridge Regression and the Lasso In order to obtain a better intuition about the behavior of ridge regression and the lasso, consider a simple special case with n=p, andXa diag- onal matrix with 1’s on the diagonal and 0’s in all off-diagonal elements. To simplify the problem further, assume also that we are performing regres- sion without an intercept. With these assumptions, the usual least squares problem simplifies to finding β1,...,βpthat minimize p/summationdisplay j=1(yj−βj)2. (6.11) In this case, the least squares solution is given by ˆβj=yj. And in this setting, ridge regression amounts to finding β1,...,βpsuch that p/summationdisplay j=1(yj−βj)2+λp/summationdisplay j=1β2 j (6.12) is minimized, and the lasso amounts to finding the coefficients such that p/summationdisplay j=1(yj−βj)2+λp/summationdisplay j=1|βj| (6.13) 250 6. Linear Model Selection and Regularization −1.5 −0.5 0.0 0.5 1.0 1.5−1.5 −0.5 0.5 1.5Coefficient EstimateRidgeLeast Squares −1.5 −0.5 0.0 0.5 1.0 1.5−1.5 −0.5 0.5 1.5Coefficient EstimateLassoLeast Squares yjyjFIGURE 6.10. The ridge regression and lasso coefficient estimates for a simple setting with n=pandXa diagonal matrix with 1’s on the diagonal. Left:The ridge regression coefficient estimates are shrunken proportionally towards zero, relative to the least squares estimates. Right:The lasso coefficient estimates are soft-thresholded towards zero. is minimized. One can show that in this setting, the ridge regression esti- mates take the form ˆβR j=yj/(1 + λ), (6.14) and the lasso estimates take the form ˆβL j=  yj−λ/2ifyj>λ/2; yj+λ/2ifyj<−λ/2; 0 if|yj|≤λ/2.(6.15) Figure6.10displays the situation.", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 295, "start_word": 94400, "end_word": 94800, "chunk_words": 400}}, "ISLP_website::c000296": {"text": "and lasso coefficient estimates for a simple setting with n=pandXa diagonal matrix with 1’s on the diagonal. Left:The ridge regression coefficient estimates are shrunken proportionally towards zero, relative to the least squares estimates. Right:The lasso coefficient estimates are soft-thresholded towards zero. is minimized. One can show that in this setting, the ridge regression esti- mates take the form ˆβR j=yj/(1 + λ), (6.14) and the lasso estimates take the form ˆβL j=  yj−λ/2ifyj>λ/2; yj+λ/2ifyj<−λ/2; 0 if|yj|≤λ/2.(6.15) Figure6.10displays the situation. We can see that ridge regression and the lasso perform two very different types of shrinkage. In ridge regression, each least squares coefficient estimate is shrunken by the same proportion. In contrast, the lasso shrinks each least squares coefficient towards zero by a constant amount, λ/2; the least squares coefficients that are less than λ/2in absolute value are shrunken entirely to zero. The type of shrink- age performed by the lasso in this simple setting ( 6.15) is known as soft- thresholding . The fact that some lasso coefficients are shrunken entirely tosoft- thresholdingzero explains why the lasso performs feature selection. In the case of a more general data matrix X, the story is a little more complicated than what is depicted in Figure 6.10, but the main ideas still hold approximately: ridge regression more or less shrinks every dimension of the data by the same proportion, whereas the lasso more or less shrinks all coefficients toward zero by a similar amount, and sufficiently small co- efficients are shrunken all the way to zero. Bayesian Interpretation of Ridge Regression and the Lasso We now show that one can view ridge regression and the lasso through a Bayesian lens. A Bayesian viewpoint for regression assumes that the coefficient vector βhas some priordistribution, say p(β), where β= (β0,β1,...,βp)T. The likelihood of the data can be written as f(Y|X,β), 6.2 Shrinkage Methods 251 −3 −2 −1 0 1 2 30.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7−3 −2 −1 0 1 2 30.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7βjβj g(βj)g(βj) FIGURE 6.11. Left:Ridge regression is the posterior mode for βunder a Gaus- sian prior. Right:The lasso is the posterior mode for βunder a double-exponential prior. whereX=(X1,...,X p). Multiplying the prior distribution by the likeli- hood gives us (up to a proportionality constant) the posterior distribution ,posterior distributionwhich takes the form p(β|X,Y)∝f(Y|X,β)p(β|X)=f(Y|X,β)p(β), where the proportionality above follows from Bayes’ theorem, and the equality", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 296, "start_word": 94720, "end_word": 95120, "chunk_words": 400}}, "ISLP_website::c000297": {"text": "0.4 0.5 0.6 0.7−3 −2 −1 0 1 2 30.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7βjβj g(βj)g(βj) FIGURE 6.11. Left:Ridge regression is the posterior mode for βunder a Gaus- sian prior. Right:The lasso is the posterior mode for βunder a double-exponential prior. whereX=(X1,...,X p). Multiplying the prior distribution by the likeli- hood gives us (up to a proportionality constant) the posterior distribution ,posterior distributionwhich takes the form p(β|X,Y)∝f(Y|X,β)p(β|X)=f(Y|X,β)p(β), where the proportionality above follows from Bayes’ theorem, and the equality above follows from the assumption that Xis fixed. We assume the usual linear model, Y=β0+X1β1+···+Xpβp+/epsilon1, and suppose that the errors are independent and drawn from a normal dis- tribution. Furthermore, assume that p(β)=/producttextp j=1g(βj), for some density function g. It turns out that ridge regression and the lasso follow naturally from two special cases of g: • Ifgis a Gaussian distribution with mean zero and standard deviation a function of λ, then it follows that the posterior mode forβ—thatposterior modeis, the most likely value for β, given the data—is given by the ridge regression solution. (In fact, the ridge regression solution is also the posterior mean.) • Ifgis a double-exponential (Laplace) distribution with mean zero and scale parameter a function of λ, then it follows that the posterior mode for βis the lasso solution. (However, the lasso solution is not the posterior mean, and in fact, the posterior mean does not yield a sparse coefficient vector.) The Gaussian and double-exponential priors are displayed in Figure 6.11. Therefore, from a Bayesian viewpoint, ridge regression and the lasso follow directly from assuming the usual linear model with normal errors, together with a simple prior distribution for β. Notice that the lasso prior is steeply peaked at zero, while the Gaussian is flatter and fatter at zero. Hence, the lasso expects a priori that many of the coefficients are (exactly) zero, while ridge assumes the coefficients are randomly distributed about zero. 252 6. Linear Model Selection and Regularization 5e−03 5e−02 5e−01 5e+0025.0 25.2 25.4 25.6Cross−Validation Error5e−03 5e−02 5e−01 5e+00−300 −100 0 100 300Standardized CoefficientsλλFIGURE 6.12. Left:Cross-validation errors that result from applying ridge regression to the Creditdata set with various values of λ.Right:The coefficient estimates as a function of λ. The vertical dashed lines indicate the value of λ selected by cross-validation. 6.2.3 Selecting the Tuning Parameter Just as the subset selection approaches considered in Section 6.1require a method to determine which of the", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 297, "start_word": 95040, "end_word": 95440, "chunk_words": 400}}, "ISLP_website::c000298": {"text": "Linear Model Selection and Regularization 5e−03 5e−02 5e−01 5e+0025.0 25.2 25.4 25.6Cross−Validation Error5e−03 5e−02 5e−01 5e+00−300 −100 0 100 300Standardized CoefficientsλλFIGURE 6.12. Left:Cross-validation errors that result from applying ridge regression to the Creditdata set with various values of λ.Right:The coefficient estimates as a function of λ. The vertical dashed lines indicate the value of λ selected by cross-validation. 6.2.3 Selecting the Tuning Parameter Just as the subset selection approaches considered in Section 6.1require a method to determine which of the models under consideration is best, implementing ridge regression and the lasso requires a method for selecting a value for the tuning parameter λin (6.5) and (6.7), or equivalently, the value of the constraint sin (6.9) and (6.8). Cross-validation provides a sim- ple way to tackle this problem. We choose a grid of λvalues, and compute the cross-validation error for each value of λ, as described in Chapter 5.W e then select the tuning parameter value for which the cross-validation error is smallest. Finally, the model is re-fit using all of the available observations and the selected value of the tuning parameter. Figure6.12displays the choice of λthat results from performing leave- one-out cross-validation on the ridge regression fits from the Creditdata set. The dashed vertical lines indicate the selected value of λ. In this case the value is relatively small, indicating that the optimal fit only involves a smallamountofshrinkagerelativetotheleastsquaressolution.Inaddition, the dip is not very pronounced, so there is rather a wide range of values that would give a very similar error. In a case like this we might simply use the least squares solution. Figure6.13provides an illustration of ten-fold cross-validation applied to the lasso fits on the sparse simulated data from Figure 6.9. The left-hand panelofFigure 6.13displaysthecross-validationerror,whiletheright-hand panel displays the coefficient estimates. The vertical dashed lines indicate the point at which the cross-validation error is smallest. The two colored lines in the right-hand panel of Figure 6.13represent the two predictors that are related to the response, while the grey lines represent the unre- lated predictors; these are often referred to as signalandnoisevariables,signalrespectively. Not only has the lasso correctly given much larger coeffi- cient estimates to the two signal predictors, but also the minimum cross- validation error corresponds to a set of coefficient estimates for which only the signal variables are non-zero. Hence cross-validation together with the lasso has correctly identified the two signal variables in the model, even though this is", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 298, "start_word": 95360, "end_word": 95760, "chunk_words": 400}}, "ISLP_website::c000299": {"text": "are related to the response, while the grey lines represent the unre- lated predictors; these are often referred to as signalandnoisevariables,signalrespectively. Not only has the lasso correctly given much larger coeffi- cient estimates to the two signal predictors, but also the minimum cross- validation error corresponds to a set of coefficient estimates for which only the signal variables are non-zero. Hence cross-validation together with the lasso has correctly identified the two signal variables in the model, even though this is a challenging setting, with p= 45 variables and only n= 50 6.3 Dimension Reduction Methods 253 0.0 0.2 0.4 0.6 0.8 1.00 200 600 1000 1400Cross−Validation Error0.0 0.2 0.4 0.6 0.8 1.0−5 0 5 10 15Standardized Coefficients/bardblˆβLλ/bardbl1//bardblˆβ/bardbl1/bardblˆβLλ/bardbl1//bardblˆβ/bardbl1FIGURE 6.13. Left: Ten-fold cross-validation MSE for the lasso, applied to the sparse simulated data set from Figure 6.9.Right:The corresponding lasso coefficient estimates are displayed. The two signal variables are shown in color, and the noise variables are in gray. The vertical dashed lines indicate the lasso fit for which the cross-validation error is smallest. observations. In contrast, the least squares solution—displayed on the far right of the right-hand panel of Figure 6.13—assigns a large coefficient estimate to only one of the two signal variables. 6.3 Dimension Reduction Methods The methods that we have discussed so far in this chapter have controlled variance in two different ways, either by using a subset of the original vari- ables, or by shrinking their coefficients toward zero. All of these methods are defined using the original predictors, X1,X2,...,X p. We now explore a class of approaches that transform the predictors and then fit a least squares model using the transformed variables. We will refer to these tech- niques as dimension reduction methods.dimension reductionLetZ1,Z2,...,Z Mrepresent M<p linear combinations of our original linear combinationppredictors. That is, Zm=p/summationdisplay j=1φjmXj (6.16) for some constants φ1m,φ2m...,φpm,m=1,...,M . We can then fit the linear regression model yi=θ0+M/summationdisplay m=1θmzim+/epsilon1i,i=1, . . . , n, (6.17) using least squares. Note that in ( 6.17), the regression coefficients are given byθ0,θ1,...,θM.Iftheconstants φ1m,φ2m,...,φpmarechosenwisely,then such dimension reduction approaches can often outperform least squares regression. In other words, fitting ( 6.17) using least squares can lead to better results than fitting ( 6.1) using least squares. The term dimension reduction comes from the fact that this approach reduces the problem of estimating the p+1coefficients β0,β1,...,βpto the 254 6. Linear Model Selection and Regularization 102030405060700 5 10 15 20 25", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 299, "start_word": 95680, "end_word": 96080, "chunk_words": 400}}, "ISLP_website::c000300": {"text": "(6.17) using least squares. Note that in ( 6.17), the regression coefficients are given byθ0,θ1,...,θM.Iftheconstants φ1m,φ2m,...,φpmarechosenwisely,then such dimension reduction approaches can often outperform least squares regression. In other words, fitting ( 6.17) using least squares can lead to better results than fitting ( 6.1) using least squares. The term dimension reduction comes from the fact that this approach reduces the problem of estimating the p+1coefficients β0,β1,...,βpto the 254 6. Linear Model Selection and Regularization 102030405060700 5 10 15 20 25 30 35PopulationAd SpendingFIGURE 6.14. The population size ( pop) and ad spending ( ad) for100different cities are shown as purple circles. The green solid line indicates the first principal component, and the blue dashed line indicates the second principal component. simpler problem of estimating the M+1coefficients θ0,θ1,...,θM, where M<p . In other words, the dimension of the problem has been reduced fromp+1toM+1. Notice that from ( 6.16), M/summationdisplay m=1θmzim=M/summationdisplay m=1θmp/summationdisplay j=1φjmxij=p/summationdisplay j=1M/summationdisplay m=1θmφjmxij=p/summationdisplay j=1βjxij, where βj=M/summationdisplay m=1θmφjm. (6.18) Hence (6.17) can be thought of as a special case of the original linear regression model given by ( 6.1). Dimension reduction serves to constrain the estimated βjcoefficients, since now they must take the form ( 6.18). This constraint on the form of the coefficients has the potential to bias the coefficient estimates. However, in situations where pis large relative to n, selectingavalueof M/lessmuchpcansignificantlyreducethevarianceofthefitted coefficients. If M=p, and all the Zmare linearly independent, then ( 6.18) poses no constraints. In this case, no dimension reduction occurs, and so fitting (6.17) is equivalent to performing least squares on the original p predictors. All dimension reduction methods work in two steps. First, the trans- formed predictors Z1,Z2,...,Z Mare obtained. Second, the model is fit using these Mpredictors. However, the choice of Z1,Z2,...,Z M, or equiv- alently, the selection of the φjm’s, can be achieved in different ways. In this chapter,wewillconsidertwoapproachesforthistask: principal components andpartial least squares . 6.3.1 Principal Components Regression Principal components analysis (PCA) is a popular approach for derivingprincipal components analysis 6.3 Dimension Reduction Methods 255 a low-dimensional set of features from a large set of variables. PCA is discussed in greater detail as a tool for unsupervised learning in Chapter 12. Here we describe its use as a dimension reduction technique for regression. An Overview of Principal Components Analysis PCA is a technique for reducing the dimension of an n×pdata matrix X. Thefirst principal component direction of the data is that along", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 300, "start_word": 96000, "end_word": 96400, "chunk_words": 400}}, "ISLP_website::c000301": {"text": "is a popular approach for derivingprincipal components analysis 6.3 Dimension Reduction Methods 255 a low-dimensional set of features from a large set of variables. PCA is discussed in greater detail as a tool for unsupervised learning in Chapter 12. Here we describe its use as a dimension reduction technique for regression. An Overview of Principal Components Analysis PCA is a technique for reducing the dimension of an n×pdata matrix X. Thefirst principal component direction of the data is that along which the observations vary the most . For instance, consider Figure 6.14, which shows population size ( pop) in tens of thousands of people, and ad spending for a particular company ( ad) in thousands of dollars, for 100cities.6The green solid line represents the first principal component direction of the data. We can see by eye that this is the direction along which there is the greatest variability in the data. That is, if we projected the 100 observations onto this line (as shown in the left-hand panel of Figure 6.15), then the resulting projected observations would have the largest possible variance; projecting the observations onto any other line would yield projected observations with lower variance. Projecting a point onto a line simply involves finding the location on the line which is closest to the point. The first principal component is displayed graphically in Figure 6.14, but how can it be summarized mathematically? It is given by the formula Z1=0.839×(pop−pop)+0 .544×(ad−ad). (6.19) Hereφ11=0.839andφ21=0.544are the principal component loadings, which define the direction referred to above. In ( 6.19),pop indicates the mean of all popvalues in this data set, and adindicates the mean of all ad- vertisingspending. The idea is that out of everypossible linear combination ofpopandadsuch that φ2 11+φ2 21=1, this particular linear combination yields the highest variance: i.e. this is the linear combination for which Var(φ11×(pop−pop)+φ21×(ad−ad))is maximized. It is necessary to consider only linear combinations of the form φ2 11+φ2 21=1, since otherwise we could increase φ11andφ21arbitrarily in order to blow up the variance. In (6.19), the two loadings are both positive and have similar size, and so Z1is almost an averageof the two variables. Sincen= 100 ,popandadare vectors of length 100, and so is Z1in (6.19). For instance, zi1=0.839×(pop i−pop)+0 .544×(adi−ad). (6.20) The values of z11,...,z n1are known as the principal component scores , and can be seen in the right-hand panel of Figure 6.15. There is also another", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 301, "start_word": 96320, "end_word": 96720, "chunk_words": 400}}, "ISLP_website::c000302": {"text": "21=1, since otherwise we could increase φ11andφ21arbitrarily in order to blow up the variance. In (6.19), the two loadings are both positive and have similar size, and so Z1is almost an averageof the two variables. Sincen= 100 ,popandadare vectors of length 100, and so is Z1in (6.19). For instance, zi1=0.839×(pop i−pop)+0 .544×(adi−ad). (6.20) The values of z11,...,z n1are known as the principal component scores , and can be seen in the right-hand panel of Figure 6.15. There is also another interpretation of PCA: the first principal compo- nent vector defines the line that is as close as possible to the data. For instance, in Figure 6.14, the first principal component line minimizes the sum of the squared perpendicular distances between each point and the line. These distances are plotted as dashed line segments in the left-hand 6This dataset is distinct from the Advertising data discussed in Chapter 3. 256 6. Linear Model Selection and Regularization 20 30 40 505 10 15 20 25 30PopulationAd Spending−20 −10 0 10 20−10 −5 0 5 101st Principal Component2nd Principal ComponentFIGURE 6.15. A subset of the advertising data. The mean popandadbudgets are indicated with a blue circle. Left:The first principal component direction is shown in green. It is the dimension along which the data vary the most, and it also defines the line that is closest to all nof the observations. The distances from each observation to the principal component are represented using the black dashed line segments. The blue dot represents (pop,ad).Right:The left-hand panel has been rotated so that the first principal component direction coincides with the x-axis. panel of Figure 6.15, in which the crosses represent the projection of each point onto the first principal component line. The first principal component has been chosen so that the projected observations are as close as possible to the original observations. In the right-hand panel of Figure 6.15, the left-hand panel has been rotated so that the first principal component direction coincides with the x-axis. It is possible to show that the first principal component score for theith observation, given in ( 6.20), is the distance in the x-direction of the ith cross from zero. So for example, the point in the bottom-left corner of the left-hand panel of Figure 6.15has a large negative principal component score,zi1=−26.1, while the point in the top-right corner has a large positive score, zi1= 18 .7. These scores can", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 302, "start_word": 96640, "end_word": 97040, "chunk_words": 400}}, "ISLP_website::c000303": {"text": "that the first principal component direction coincides with the x-axis. It is possible to show that the first principal component score for theith observation, given in ( 6.20), is the distance in the x-direction of the ith cross from zero. So for example, the point in the bottom-left corner of the left-hand panel of Figure 6.15has a large negative principal component score,zi1=−26.1, while the point in the top-right corner has a large positive score, zi1= 18 .7. These scores can be computed directly using (6.20). We can think of the values of the principal component Z1as single- number summaries of the joint popandadbudgets for each location. In this example, if zi1=0.839×(pop i−pop)+0 .544×(adi−ad)<0, then this indicates a city with below-average population size and below- average ad spending. A positive score suggests the opposite. How well can a single number represent both popandad? In this case, Figure 6.14indicates thatpopandadhave approximately a linear relationship, and so we might expect that a single-number summary will work well. Figure 6.16displays zi1versus both popandad.7The plots show a strong relationship between the first principal component and the two features. In other words, the first principal component appears to capture most of the information contained in thepopandadpredictors. So far we have concentrated on the first principal component. In gen- eral, one can construct up to pdistinct principal components. The second 7The principal components were calculated after first standardizing both popandad, a common approach. Hence, the x-axes on Figures 6.15and6.16are not on the same scale. 6.3 Dimension Reduction Methods 257 −3 −2 −1 0 1 2 320 30 40 50 601st Principal ComponentPopulation−3 −2 −1 0 1 2 35 10 15 20 25 301st Principal ComponentAd SpendingFIGURE 6.16. Plots of the first principal component scores zi1versuspopand ad. The relationships are strong. principal component Z2is a linear combination of the variables that is un- correlated with Z1, and has largest variance subject to this constraint. The second principal component direction is illustrated as a dashed blue line in Figure6.14. It turns out that the zero correlation condition of Z1withZ2 is equivalent to the condition that the direction must be perpendicular , orperpen- dicular orthogonal , to the first principal component direction. The second principal orthogonal component is given by the formula Z2=0.544×(pop−pop)−0.839×(ad−ad). Since the advertising data has two predictors, the first two principal com- ponents contain all of the information that is in popandad. However, by construction, the first", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 303, "start_word": 96960, "end_word": 97360, "chunk_words": 400}}, "ISLP_website::c000304": {"text": "direction is illustrated as a dashed blue line in Figure6.14. It turns out that the zero correlation condition of Z1withZ2 is equivalent to the condition that the direction must be perpendicular , orperpen- dicular orthogonal , to the first principal component direction. The second principal orthogonal component is given by the formula Z2=0.544×(pop−pop)−0.839×(ad−ad). Since the advertising data has two predictors, the first two principal com- ponents contain all of the information that is in popandad. However, by construction, the first component will contain the most information. Con- sider, for example, the much larger variability of zi1(thex-axis) versus zi2(they-axis) in the right-hand panel of Figure 6.15. The fact that the second principal component scores are much closer to zero indicates that this component captures far less information. As another illustration, Fig- ure6.17displays zi2versuspopandad. There is little relationship between the second principal component and these two predictors, again suggesting that in this case, one only needs the first principal component in order to accurately represent the popandadbudgets. With two-dimensional data, such as in our advertising example, we can construct at most two principal components. However, if we had other predictors, such as population age, income level, education, and so forth, then additional components could be constructed. They would successively maximize variance, subject to the constraint of being uncorrelated with the preceding components. The Principal Components Regression Approach Theprincipal components regression (PCR) approach involves construct-principal components regressioning the first Mprincipal components, Z1,...,Z M, and then using these components as the predictors in a linear regression model that is fit us- ing least squares. The key idea is that often a small number of principal components suffice to explain most of the variability in the data, as well as the relationship with the response. In other words, we assume that the 258 6. Linear Model Selection and Regularization −1.0 −0.5 0.0 0.5 1.020 30 40 50 602nd Principal ComponentPopulation−1.0 −0.5 0.0 0.5 1.05 10 15 20 25 302nd Principal ComponentAd SpendingFIGURE 6.17. Plots of the second principal component scores zi2versuspop andad. The relationships are weak. 0 10 20 30 400 10 20 30 40 50 60 70Number of ComponentsMean Squared Error0 10 20 30 400 50 100 150Number of ComponentsMean Squared ErrorSquared BiasTest MSEVariance FIGURE 6.18. PCR was applied to two simulated data sets. In each panel, the horizontal dashed line represents the irreducible error. Left:Simulated data from Figure6.8.Right:Simulated data from Figure 6.9. directions", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 304, "start_word": 97280, "end_word": 97680, "chunk_words": 400}}, "ISLP_website::c000305": {"text": "15 20 25 302nd Principal ComponentAd SpendingFIGURE 6.17. Plots of the second principal component scores zi2versuspop andad. The relationships are weak. 0 10 20 30 400 10 20 30 40 50 60 70Number of ComponentsMean Squared Error0 10 20 30 400 50 100 150Number of ComponentsMean Squared ErrorSquared BiasTest MSEVariance FIGURE 6.18. PCR was applied to two simulated data sets. In each panel, the horizontal dashed line represents the irreducible error. Left:Simulated data from Figure6.8.Right:Simulated data from Figure 6.9. directions in which X1,...,X pshow the most variation are the directions that are associated with Y. While this assumption is not guaranteed to be true, it often turns out to be a reasonable enough approximation to give good results. If the assumption underlying PCR holds, then fitting a least squares model to Z1,...,Z Mwill lead to better results than fitting a least squares model to X1,...,X p, since most or all of the information in the data that relates to the response is contained in Z1,...,Z M, and by estimating only M/lessmuchpcoefficients we can mitigate overfitting. In the advertising data, the first principal component explains most of the variance in both popandad, so a principal component regression that uses this single variable to predict some response of interest, such as sales, will likely perform quite well. Figure6.18displays the PCR fits on the simulated data sets from Fig- ures6.8and6.9. Recall that both data sets were generated using n= 50 observations and p= 45 predictors. However, while the response in the first data set was a function of all the predictors, the response in the sec- ond data set was generated using only two of the predictors. The curves are plotted as a function of M, the number of principal components used as predictors in the regression model. As more principal components are used 6.3 Dimension Reduction Methods 259 0 10 20 30 400 10 20 30 40 50 60 70PCR Number of ComponentsMean Squared ErrorSquared BiasTest MSEVariance 0.0 0.2 0.4 0.6 0.8 1.00 10 20 30 40 50 60 70Ridge Regression and Lasso Shrinkage FactorMean Squared ErrorFIGURE 6.19. PCR, ridge regression, and the lasso were applied to a simu- lated data set in which the first five principal components of Xcontain all the information about the response Y. In each panel, the irreducible error Var(/epsilon1)is shown as a horizontal dashed line. Left:Results for PCR. Right:Results for lasso (solid) and ridge regression (dotted).", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 305, "start_word": 97600, "end_word": 98000, "chunk_words": 400}}, "ISLP_website::c000306": {"text": "ComponentsMean Squared ErrorSquared BiasTest MSEVariance 0.0 0.2 0.4 0.6 0.8 1.00 10 20 30 40 50 60 70Ridge Regression and Lasso Shrinkage FactorMean Squared ErrorFIGURE 6.19. PCR, ridge regression, and the lasso were applied to a simu- lated data set in which the first five principal components of Xcontain all the information about the response Y. In each panel, the irreducible error Var(/epsilon1)is shown as a horizontal dashed line. Left:Results for PCR. Right:Results for lasso (solid) and ridge regression (dotted). The x-axis displays the shrinkage factor of the coefficient estimates, defined as the /lscript2norm of the shrunken coefficient estimates divided by the /lscript2norm of the least squares estimate. in the regression model, the bias decreases, but the variance increases. This results in a typical U-shape for the mean squared error. When M=p= 45 , then PCR amounts simply to a least squares fit using all of the original predictors. The figure indicates that performing PCR with an appropriate choice of Mcan result in a substantial improvement over least squares, es- pecially in the left-hand panel. However, by examining the ridge regression and lasso results in Figures 6.5,6.8, and6.9, we see that PCR does not perform as well as the two shrinkage methods in this example. The relatively worse performance of PCR in Figure 6.18is a consequence of the fact that the data were generated in such a way that many princi- pal components are required in order to adequately model the response. In contrast, PCR will tend to do well in cases when the first few principal components are sufficient to capture most of the variation in the predictors as well as the relationship with the response. The left-hand panel of Fig- ure6.19illustrates the results from another simulated data set designed to be more favorable to PCR. Here the response was generated in such a way that it depends exclusively on the first five principal components. Now the bias drops to zero rapidly as M, the number of principal components used in PCR, increases. The mean squared error displays a clear minimum at M=5. The right-hand panel of Figure 6.19displays the results on these data using ridge regression and the lasso. All three methods offer a signif- icant improvement over least squares. However, PCR and ridge regression slightly outperform the lasso. We note that even though PCR provides a simple way to perform re- gression using M<p predictors, it is", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 306, "start_word": 97920, "end_word": 98320, "chunk_words": 400}}, "ISLP_website::c000307": {"text": "to zero rapidly as M, the number of principal components used in PCR, increases. The mean squared error displays a clear minimum at M=5. The right-hand panel of Figure 6.19displays the results on these data using ridge regression and the lasso. All three methods offer a signif- icant improvement over least squares. However, PCR and ridge regression slightly outperform the lasso. We note that even though PCR provides a simple way to perform re- gression using M<p predictors, it is nota feature selection method. This is because each of the Mprincipal components used in the regression is a linear combination of all pof theoriginalfeatures. For instance, in ( 6.19), Z1was a linear combination of both popandad. Therefore, while PCR of- ten performs quite well in many practical settings, it does not result in the 260 6. Linear Model Selection and Regularization 2 4 6 8 10−300 −100 0 100 200 300 400Number of ComponentsStandardized CoefficientsIncomeLimitRatingStudent 2 4 6 8 1020000 40000 60000 80000Number of ComponentsCross−Validation MSEFIGURE 6.20. Left:PCR standardized coefficient estimates on the Creditdata set for different values of M.Right:The ten-fold cross-validation MSE obtained using PCR, as a function of M. development of a model that relies upon a small set of the original features. In this sense, PCR is more closely related to ridge regression than to the lasso. In fact, one can show that PCR and ridge regression are very closely related. One can even think of ridge regression as a continuous version of PCR!8 In PCR, the number of principal components, M, is typically chosen by cross-validation. The results of applying PCR to the Creditdata set are shown in Figure 6.20; the right-hand panel displays the cross-validation er- rorsobtained,asafunctionof M.Onthesedata,thelowestcross-validation error occurs when there are M= 10 components; this corresponds to al- most no dimension reduction at all, since PCR with M= 11 is equivalent to simply performing least squares. When performing PCR, we generally recommend standardizing each pre- dictor, using ( 6.6), prior to generating the principal components. This stan- dardization ensures that all variables are on the same scale. In the absence of standardization, the high-variance variables will tend to play a larger role in the principal components obtained, and the scale on which the vari- ables are measured will ultimately have an effect on the final PCR model. However, if the variables are all measured in the same units (say, kilograms, or inches), then", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 307, "start_word": 98240, "end_word": 98640, "chunk_words": 400}}, "ISLP_website::c000308": {"text": "each pre- dictor, using ( 6.6), prior to generating the principal components. This stan- dardization ensures that all variables are on the same scale. In the absence of standardization, the high-variance variables will tend to play a larger role in the principal components obtained, and the scale on which the vari- ables are measured will ultimately have an effect on the final PCR model. However, if the variables are all measured in the same units (say, kilograms, or inches), then one might choose not to standardize them. 6.3.2 Partial Least Squares ThePCRapproachthatwejustdescribedinvolvesidentifyinglinearcombi- nations, or directions , that best represent the predictors X1,...,X p. These directions are identified in an unsupervised way, since the response Yis not used to help determine the principal component directions. That is, the response does not supervise the identification of the principal compo- nents. Consequently, PCR suffers from a drawback: there is no guarantee 8More details can be found in Section 3.5 of The Elements of Statistical Learning by Hastie, Tibshirani, and Friedman. 6.3 Dimension Reduction Methods 261 20304050605 10 15 20 25 30PopulationAd SpendingFIGURE 6.21. For the advertising data, the first PLS direction (solid line) and first PCR direction (dotted line) are shown. that the directions that best explain the predictors will also be the best directions to use for predicting the response. Unsupervised methods are discussed further in Chapter 12. We now present partial least squares (PLS), a supervised alternative topartial least squaresPCR.LikePCR,PLSisadimensionreductionmethod,whichfirstidentifies anewsetoffeatures Z1,...,Z Mthatarelinearcombinationsoftheoriginal features, and then fits a linear model via least squares using these Mnew features. But unlike PCR, PLS identifies these new features in a supervised way—that is, it makes use of the response Yin order to identify new features that not only approximate the old features well, but also that are related to the response . Roughly speaking, the PLS approach attempts to find directions that help explain both the response and the predictors. We now describe how the first PLS direction is computed. After stan- dardizing the ppredictors, PLS computes the first direction Z1by setting eachφj1in (6.16) equal to the coefficient from the simple linear regression ofYontoXj. One can show that this coefficient is proportional to the cor- relation between YandXj. Hence, in computing Z1=/summationtextp j=1φj1Xj, PLS places the highest weight on the variables that are most strongly related to the response. Figure6.21displays an example of PLS on a synthetic dataset with Sales in each of 100", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 308, "start_word": 98560, "end_word": 98960, "chunk_words": 400}}, "ISLP_website::c000309": {"text": "the first PLS direction is computed. After stan- dardizing the ppredictors, PLS computes the first direction Z1by setting eachφj1in (6.16) equal to the coefficient from the simple linear regression ofYontoXj. One can show that this coefficient is proportional to the cor- relation between YandXj. Hence, in computing Z1=/summationtextp j=1φj1Xj, PLS places the highest weight on the variables that are most strongly related to the response. Figure6.21displays an example of PLS on a synthetic dataset with Sales in each of 100 regions as the response, and two predictors; Population Size and Advertising Spending. The solid green line indicates the first PLS di- rection, while the dotted line shows the first principal component direction. PLS has chosen a direction that has less change in the addimension per unit change in the popdimension, relative to PCA. This suggests that pop is more highly correlated with the response than is ad. The PLS direction does not fit the predictors as closely as does PCA, but it does a better job explaining the response. To identify the second PLS direction we first adjusteach of the variables forZ1, by regressing each variable on Z1and taking residuals . These resid- uals can be interpreted as the remaining information that has not been explained by the first PLS direction. We then compute Z2using this or- 262 6. Linear Model Selection and Regularizationthogonalizeddata in exactly the same fashion asZ1was computed basedon the original data. This iterative approach can be repeatedMtimes toidentify multiple PLS componentsZ1,...,ZM. Finally, at the end of thisprocedure, we use least squares to fit a linear model to predictYusingZ1,...,ZMin exactly the same fashion as for PCR.As with PCR, the numberMof partial least squares directions used inPLS is a tuning parameter that is typically chosen by cross-validation. Wegenerally standardize the predictors and response before performing PLS.PLS is popular in the field of chemometrics, where many variables arisefrom digitized spectrometry signals. In practice it often performs no betterthan ridge regression or PCR. While the supervised dimension reductionof PLS can reduce bias, it also has the potential to increase variance, sothat the overall benefit of PLS relative to PCR is a wash.6.4 Considerations in High Dimensions6.4.1 High-Dimensional DataMost traditional statistical techniques for regression and classification areintended for thelow-dimensionalsetting in whichn, the number of ob-low-dimensionalservations, is much greater thanp, the number of features. This is due inpart to the fact that throughout most of the field’s history, the bulk of sci-entific", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 309, "start_word": 98880, "end_word": 99280, "chunk_words": 400}}, "ISLP_website::c000310": {"text": "regression or PCR. While the supervised dimension reductionof PLS can reduce bias, it also has the potential to increase variance, sothat the overall benefit of PLS relative to PCR is a wash.6.4 Considerations in High Dimensions6.4.1 High-Dimensional DataMost traditional statistical techniques for regression and classification areintended for thelow-dimensionalsetting in whichn, the number of ob-low-dimensionalservations, is much greater thanp, the number of features. This is due inpart to the fact that throughout most of the field’s history, the bulk of sci-entific problems requiring the use of statistics have been low-dimensional.For instance, consider the task of developing a model to predict a patient’sblood pressure on the basis of his or her age, sex, and body mass index(BMI). There are three predictors, or four if an intercept is included in themodel, and perhaps several thousand patients for whom blood pressureand age, sex, and BMI are available. Hencen/greatermuchp, and so the problem islow-dimensional. (By dimension here we are referring to the size ofp.)In the past 20 years, new technologies have changed the way that dataare collected in fields as diverse as finance, marketing, and medicine. It isnow commonplace to collect an almost unlimited number of feature mea-surements (pvery large). Whilepcan be extremely large, the number ofobservationsnis often limited due to cost, sample availability, or otherconsiderations. Two examples are as follows:1. Rather than predicting blood pressure on the basis of just age, sex,and BMI, one might also collect measurements for half a millionsin-gle nucleotide polymorphisms(SNPs; these are individual DNA mu-tations that are relatively common in the population) for inclusion inthe predictive model. Thenn≈200andp≈500,000.2. Amarketinganalystinterestedinunderstandingpeople’sonlineshop-ping patterns could treat as features all of the search terms enteredby users of a search engine. This is sometimes known as the “bag-of-words” model. The same researcher might have access to the searchhistories of only a few hundred or a few thousand search engine userswho have consented to share their information with the researcher.For a given user, each of thepsearch terms is scored present (0) or 6.4 Considerations in High Dimensions 263 absent (1), creating a large binary feature vector. Then n≈1,000 andpis much larger. Data sets containing more features than observations are often referred to ashigh-dimensional . Classical approaches such as least squares linearhigh- dimensionalregression are not appropriate in this setting. Many of the issues that arise in the analysis of high-dimensional data were discussed earlier in this book, since they apply also when n>p : these include the role", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 310, "start_word": 99200, "end_word": 99600, "chunk_words": 400}}, "ISLP_website::c000311": {"text": "is scored present (0) or 6.4 Considerations in High Dimensions 263 absent (1), creating a large binary feature vector. Then n≈1,000 andpis much larger. Data sets containing more features than observations are often referred to ashigh-dimensional . Classical approaches such as least squares linearhigh- dimensionalregression are not appropriate in this setting. Many of the issues that arise in the analysis of high-dimensional data were discussed earlier in this book, since they apply also when n>p : these include the role of the bias-variance trade-off and the danger of overfitting. Though these issues are always rele- vant, they can become particularly important when the number of features is very large relative to the number of observations. We have defined the high-dimensional setting as the case where the num- ber of features pis larger than the number of observations n. But the con- siderations that we will now discuss certainly also apply if pis slightly smaller than n, and are best always kept in mind when performing super- vised learning. 6.4.2 What Goes Wrong in High Dimensions? In order to illustrate the need for extra care and specialized techniques for regression and classification when p>n , we begin by examining what can go wrong if we apply a statistical technique not intended for the high- dimensional setting. For this purpose, we examine least squares regression. Butthesameconceptsapplytologisticregression,lineardiscriminantanal- ysis, and other classical statistical approaches. When the number of features pis as large as, or larger than, the number of observations n, least squares as described in Chapter 3cannot (or rather, should not ) be performed. The reason is simple: regardless of whether or not there truly is a relationship between the features and the response, least squares will yield a set of coefficient estimates that result in a perfect fit to the data, such that the residuals are zero. AnexampleisshowninFigure 6.22withp=1feature(plusanintercept) in two cases: when there are 20 observations, and when there are only two observations. When there are 20 observations, n>p and the least squaresregressionlinedoesnotperfectlyfitthedata;instead,theregression line seeks to approximate the 20 observations as well as possible. On the other hand, when there are only two observations, then regardless of the values of those observations, the regression line will fit the data exactly. This is problematic because this perfect fit will almost certainly lead to overfitting of the data. In other words, though it is possible to perfectly fit the training data in the", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 311, "start_word": 99520, "end_word": 99920, "chunk_words": 400}}, "ISLP_website::c000312": {"text": "two observations. When there are 20 observations, n>p and the least squaresregressionlinedoesnotperfectlyfitthedata;instead,theregression line seeks to approximate the 20 observations as well as possible. On the other hand, when there are only two observations, then regardless of the values of those observations, the regression line will fit the data exactly. This is problematic because this perfect fit will almost certainly lead to overfitting of the data. In other words, though it is possible to perfectly fit the training data in the high-dimensional setting, the resulting linear model will perform extremely poorly on an independent test set, and therefore does not constitute a useful model. In fact, we can see that this happened in Figure 6.22: the least squares line obtained in the right-hand panel will perform very poorly on a test set comprised of the observations in the left- hand panel. The problem is simple: when p>n orp≈n, a simple least squares regression line is too flexibleand hence overfits the data. Figure6.23further illustrates the risk of carelessly applying least squares when the number of features pis large. Data were simulated with n= 20 observations, and regression was performed with between 1and20features, 264 6. Linear Model Selection and Regularization −1.5 −1.0 −0.5 0.0 0.5 1.0−10 −5 0 5 10−1.5 −1.0 −0.5 0.0 0.5 1.0−10 −5 0 5 10XXYY FIGURE 6.22.Left:Least squares regression in the low-dimensional setting.Right:Least squares regression withn=2observations and two parameters to beestimated (an intercept and a coefficient). 5 10 150.2 0.4 0.6 0.8 1.0Number of VariablesR2 5 10 150.0 0.2 0.4 0.6 0.8Number of VariablesTraining MSE5 10 151 5 50 500Number of VariablesTest MSEFIGURE 6.23.On a simulated example withn= 20training observations,features that are completely unrelated to the outcome are added to the model.Left:TheR2increases to 1 as more features are included.Center:The trainingset MSE decreases to 0 as more features are included.Right:The test set MSEincreases as more features are included.each of which was completely unrelated to the response. As shown in thefigure,themodelR2increasesto1asthenumberoffeaturesincludedinthemodel increases, and correspondingly the training set MSE decreases to 0as the number of features increases,even though the features are completelyunrelated to the response. On the other hand, the MSE on anindependenttest setbecomes extremely large as the number of features included in themodel increases, because including the additional predictors leads to a vastincrease in the variance of the coefficient estimates. Looking at the testset MSE, it is clear that the best model contains at most a few variables.However, someone who carelessly", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 312, "start_word": 99840, "end_word": 100240, "chunk_words": 400}}, "ISLP_website::c000313": {"text": "increases, and correspondingly the training set MSE decreases to 0as the number of features increases,even though the features are completelyunrelated to the response. On the other hand, the MSE on anindependenttest setbecomes extremely large as the number of features included in themodel increases, because including the additional predictors leads to a vastincrease in the variance of the coefficient estimates. Looking at the testset MSE, it is clear that the best model contains at most a few variables.However, someone who carelessly examines only theR2or the training setMSE might erroneously conclude that the model with the greatest numberof variables is best. This indicates the importance of applying extra carewhen analyzing data sets with a large number of variables, and of alwaysevaluating model performance on an independent test set. 6.4 Considerations in High Dimensions 265 116 21012345128 51012345170 111012345p= 20p= 50p= 2000 Degrees of FreedomDegrees of FreedomDegrees of FreedomFIGURE 6.24. The lasso was performed with n= 100 observations and three values of p, the number of features. Of the pfeatures, 20 were associated with the response. The boxplots show the test MSEs that result using three different values of the tuning parameter λin (6.7). For ease of interpretation, rather than reporting λ, thedegrees of freedom are reported; for the lasso this turns out to be simply the number of estimated non-zero coefficients. When p= 20 , the lowest test MSE was obtained with the smallest amount of regularization. When p= 50 , the lowest test MSE was achieved when there is a substantial amount of regularization. When p=2,000the lasso performed poorly regardless of the amount of regularization, due to the fact that only 20 of the 2,000 features truly are associated with the outcome. InSection 6.1.3,wesawanumberofapproachesforadjustingthetraining set RSS or R2in order to account for the number of variables used to fit a least squares model. Unfortunately, the Cp, AIC, and BIC approaches are not appropriate in the high-dimensional setting, because estimating ˆσ2 is problematic. (For instance, the formula for ˆσ2from Chapter 3yields an estimate ˆσ2=0in this setting.) Similarly, problems arise in the application of adjusted R2in the high-dimensional setting, since one can easily obtain a model with an adjusted R2value of 1. Clearly, alternative approaches that are better-suited to the high-dimensional setting are required. 6.4.3 Regression in High Dimensions It turns out that many of the methods seen in this chapter for fitting less flexible least squares models, such as forward stepwise selection,", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 313, "start_word": 100160, "end_word": 100560, "chunk_words": 400}}, "ISLP_website::c000314": {"text": "problematic. (For instance, the formula for ˆσ2from Chapter 3yields an estimate ˆσ2=0in this setting.) Similarly, problems arise in the application of adjusted R2in the high-dimensional setting, since one can easily obtain a model with an adjusted R2value of 1. Clearly, alternative approaches that are better-suited to the high-dimensional setting are required. 6.4.3 Regression in High Dimensions It turns out that many of the methods seen in this chapter for fitting less flexible least squares models, such as forward stepwise selection, ridge regression, the lasso, and principal components regression, are particularly usefulforperformingregressioninthehigh-dimensionalsetting.Essentially, these approaches avoid overfitting by using a less flexible fitting approach than least squares. Figure6.24illustrates the performance of the lasso in a simple simulated example. There are p= 20 ,50, or2,000features, of which 20 are truly associated with the outcome. The lasso was performed on n= 100 training observations, and the mean squared error was evaluated on an independent test set. As the number of features increases, the test set error increases. Whenp= 20 , the lowest validation set error was achieved when λin 266 6. Linear Model Selection and Regularization (6.7) was small; however, when pwas larger then the lowest validation set error was achieved using a larger value of λ. In each boxplot, rather than reporting the values of λused, the degrees of freedom of the resulting lasso solution is displayed; this is simply the number of non-zero coefficient estimates in the lasso solution, and is a measure of the flexibility of the lasso fit. Figure 6.24highlights three important points: (1) regularization or shrinkage plays a key role in high-dimensional problems, (2) appropriate tuning parameter selection is crucial for good predictive performance, and (3) the test error tends to increase as the dimensionality of the problem (i.e. the number of features or predictors) increases, unless the additional features are truly associated with the response. The third point above is in fact a key principle in the analysis of high- dimensionaldata,whichisknownasthe curse of dimensionality .Onemightcurse of di- mensionalitythink that as the number of features used to fit a model increases, the quality of the fitted model will increase as well. However, comparing the left-hand and right-hand panels in Figure 6.24, we see that this is not necessarily the case: in this example, the test set MSE almost doubles as pincreases from 20 to 2,000. In general, adding additional signal features that are truly associated with the response will", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 314, "start_word": 100480, "end_word": 100880, "chunk_words": 400}}, "ISLP_website::c000315": {"text": "of high- dimensionaldata,whichisknownasthe curse of dimensionality .Onemightcurse of di- mensionalitythink that as the number of features used to fit a model increases, the quality of the fitted model will increase as well. However, comparing the left-hand and right-hand panels in Figure 6.24, we see that this is not necessarily the case: in this example, the test set MSE almost doubles as pincreases from 20 to 2,000. In general, adding additional signal features that are truly associated with the response will improve the fitted model , in the sense of leading to a reduction in test set error. However, adding noise features that are not truly associated with the response will lead to a deterioration in the fitted model, and consequently an increased test set error. This is because noise features increase the dimensionality of the problem, exacerbating the risk of overfitting (since noise features may be assigned nonzero coefficients due to chance associations with the response on the training set) without any potential upside in terms of improved test set error. Thus, we see that new technologies that allow for the collection of measurements for thousands or millions of features are a double-edged sword: they can lead to improved predictive models if these features are in fact relevant to the problem at hand, but will lead to worse results if the features are not relevant. Even if they are relevant, the variance incurred in fitting their coefficients may outweigh the reduction in bias that they bring. 6.4.4 Interpreting Results in High Dimensions When we perform the lasso, ridge regression, or other regression proce- dures in the high-dimensional setting, we must be quite cautious in the way that we report the results obtained. In Chapter 3, we learned about multi- collinearity , the concept that the variables in a regression might be corre- lated with each other. In the high-dimensional setting, the multicollinearity problem is extreme: any variable in the model can be written as a linear combination of all of the other variables in the model. Essentially, this means that we can never know exactly which variables (if any) truly are predictive of the outcome, and we can never identify the bestcoefficients for use in the regression. At most, we can hope to assign large regression coefficients to variables that are correlated with the variables that truly are predictive of the outcome. 6.5 Lab: Linear Models and Regularization Methods 267", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 315, "start_word": 100800, "end_word": 101200, "chunk_words": 400}}, "ISLP_website::c000316": {"text": "can be written as a linear combination of all of the other variables in the model. Essentially, this means that we can never know exactly which variables (if any) truly are predictive of the outcome, and we can never identify the bestcoefficients for use in the regression. At most, we can hope to assign large regression coefficients to variables that are correlated with the variables that truly are predictive of the outcome. 6.5 Lab: Linear Models and Regularization Methods 267 For instance, suppose that we are trying to predict blood pressure on the basis of half a million SNPs, and that forward stepwise selection indicates that 17 of those SNPs lead to a good predictive model on the training data. It would be incorrect to conclude that these 17 SNPs predict blood pressure more effectively than the other SNPs not included in the model. There are likely to be many sets of 17 SNPs that would predict blood pressure just as well as the selected model. If we were to obtain an independent data set and perform forward stepwise selection on that data set, we would likely obtain a model containing a different, and perhaps even non-overlapping, set of SNPs. This does not detract from the value of the model obtained— for instance, the model might turn out to be very effective in predicting blood pressure on an independent set of patients, and might be clinically useful for physicians. But we must be careful not to overstate the results obtained, and to make it clear that what we have identified is simply one of many possible models for predicting blood pressure, and that it must be further validated on independent data sets. Itisalsoimportanttobeparticularlycarefulinreportingerrorsandmea- sures of model fit in the high-dimensional setting. We have seen that when p>n , it is easy to obtain a useless model that has zero residuals. There- fore, one should neveruse sum of squared errors, p-values, R2statistics, or other traditional measures of model fit on the training data as evidence of a good model fit in the high-dimensional setting. For instance, as we saw in Figure 6.23, one can easily obtain a model with R2=1 whenp>n . Reporting this fact might mislead others into thinking that a statistically valid and useful model has been obtained, whereas in fact this provides absolutely no evidence of a compelling model. It is important to instead report results on an", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 316, "start_word": 101120, "end_word": 101520, "chunk_words": 400}}, "ISLP_website::c000317": {"text": "R2statistics, or other traditional measures of model fit on the training data as evidence of a good model fit in the high-dimensional setting. For instance, as we saw in Figure 6.23, one can easily obtain a model with R2=1 whenp>n . Reporting this fact might mislead others into thinking that a statistically valid and useful model has been obtained, whereas in fact this provides absolutely no evidence of a compelling model. It is important to instead report results on an independent test set, or cross-validation errors. For instance, the MSE or R2on an independent test set is a valid measure of model fit, but the MSE on the training set certainly is not. 6.5 Lab: Linear Models and Regularization Methods In this lab we implement many of the techniques discussed in this chapter. We import some of our libraries at this top level. In[1]: import numpy as np import pandas as pd from matplotlib.pyplot import subplots from statsmodels.api import OLS import sklearn.model_selection as skm import sklearn.linear_model as skl from sklearn.preprocessing import StandardScaler from ISLP import load_data from ISLP.models import ModelSpec as MS from functools import partial We again collect the new imports needed for this lab. In[2]: from sklearn.pipeline import Pipeline from sklearn.decomposition import PCA 268 6. Linear Model Selection and Regularization from sklearn.cross_decomposition import PLSRegression from ISLP.models import \\ (Stepwise, sklearn_selected, sklearn_selection_path) !pip install l0bnb from l0bnb import fit_path We have installed the package l0bnbon the fly. Note the escaped !pip install— this is run as a separate system command. 6.5.1 Subset Selection Methods Here we implement methods that reduce the number of parameters in a model by restricting the model to a subset of the input variables. Forward Selection We will apply the forward-selection approach to the Hittersdata. We wish to predict a baseball player’s Salaryon the basis of various statistics asso- ciated with performance in the previous year. First of all, we note that the Salaryvariable is missing for some of the players. The np.isnan() function can be used to identify the missing ob-np.isnan()servations. It returns an array of the same shape as the input vector, with aTruefor any elements that are missing, and a Falsefor non-missing el- ements. The sum()method can then be used to count all of the missingsum()elements. In[3]: Hitters = load_data( 'Hitters' ) np.isnan(Hitters[ 'Salary' ]).sum() Out[3]: 59 We see that Salaryis missing for 59 players. The dropna() method of data frames removes", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 317, "start_word": 101440, "end_word": 101840, "chunk_words": 400}}, "ISLP_website::c000318": {"text": "missing for some of the players. The np.isnan() function can be used to identify the missing ob-np.isnan()servations. It returns an array of the same shape as the input vector, with aTruefor any elements that are missing, and a Falsefor non-missing el- ements. The sum()method can then be used to count all of the missingsum()elements. In[3]: Hitters = load_data( 'Hitters' ) np.isnan(Hitters[ 'Salary' ]).sum() Out[3]: 59 We see that Salaryis missing for 59 players. The dropna() method of data frames removes all of the rows that have missing values in any variable (by default — see Hitters.dropna? ). In[4]: Hitters = Hitters.dropna(); Hitters.shape Out[4]: (263, 20) We first choose the best model using forward selection based on Cp(6.2). This score is not built in as a metric to sklearn. We therefore define a function to compute it ourselves, and use it as a scorer. By default, sklearn tries to maximize a score, hence our scoring function computes the negative Cpstatistic. In[5]: def nCp(sigma2, estimator, X, Y): \"Negative Cp statistic\" n, p = X.shape Yhat = estimator.predict(X) RSS = np.sum((Y - Yhat)**2) return -(RSS + 2 * p * sigma2) / n 6.5 Lab: Linear Models and Regularization Methods 269 We need to estimate the residual variance σ2, which is the first argument in our scoring function above. We will fit the biggest model, using all the variables, and estimate σ2based on its MSE. In[6]: design = MS(Hitters.columns.drop( 'Salary' )).fit(Hitters) Y=n p . a r r a y ( H i t t e r s [ 'Salary' ]) X=d e s i g n . t r a n s f o r m ( H i t t e r s ) sigma2 = OLS(Y,X).fit().scale The function sklearn_selected() expects a scorer with just three argu- ments — the last three in the definition of nCp()above. We use the function partial() first seen in Section 5.3.3to freeze the first argument with our estimate of σ2. In[7]: neg_Cp = partial(nCp, sigma2) We can now use neg_Cp() as a scorer for model selection. Along with a score we need to specify the search strategy. This is done through the object Stepwise() in theISLP.models package. The method Stepwise.first_peak() runs forward stepwise until any further additions to the model do not result in an improvement in the evaluation score. Similarly, the method Stepwise.fixed_steps() runs a fixed number of steps of stepwise search. In[8]: strategy =", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 318, "start_word": 101760, "end_word": 102160, "chunk_words": 400}}, "ISLP_website::c000319": {"text": "our estimate of σ2. In[7]: neg_Cp = partial(nCp, sigma2) We can now use neg_Cp() as a scorer for model selection. Along with a score we need to specify the search strategy. This is done through the object Stepwise() in theISLP.models package. The method Stepwise.first_peak() runs forward stepwise until any further additions to the model do not result in an improvement in the evaluation score. Similarly, the method Stepwise.fixed_steps() runs a fixed number of steps of stepwise search. In[8]: strategy = Stepwise.first_peak(design, direction= 'forward' , max_terms=len(design.terms)) We now fit a linear regression model with Salaryas outcome using for- ward selection. To do so, we use the function sklearn_selected() from thesklearn_ selected()ISLP.models package. This takes a model from statsmodels along with a search strategy and selects a model with its fitmethod. Without specify- ing ascoringargument, the score defaults to MSE, and so all 19 variables will be selected (output not shown). In[9]: hitters_MSE = sklearn_selected(OLS, strategy) hitters_MSE.fit(Hitters, Y) hitters_MSE.selected_state_ Usingneg_Cpresults in a smaller model, as expected, with just 10 vari- ables selected. In[10]: hitters_Cp = sklearn_selected(OLS, strategy, scoring=neg_Cp) hitters_Cp.fit(Hitters, Y) hitters_Cp.selected_state_ Out[10]: ('Assists' , 'AtBat' , 'CAtBat' , 'CRBI', 'CRuns' , 'CWalks' , 'Division' , 270 6. Linear Model Selection and Regularization'Hits','PutOuts','Walks')Choosing Among Models Using the Validation Set Approach andCross-ValidationAs an alternative to usingCp, we might try cross-validation to select amodel in forward selection. For this, we need a method that stores thefull path of models found in forward selection, and allows predictions foreach of these. This can be done with thesklearn_selection_path()estima-sklearn_selection_path()tor fromISLP.models. The functioncross_val_predict()fromISLP.modelscross_val_predict()computes the cross-validated predictions for each of the models along thepath, which we can use to evaluate the cross-validated MSE along the path.Here we define a strategy that fits the full forward selection path. Whilethere are various parameter choices forsklearn_selection_path(), we usethe defaults here, which selects the model at each step based on the biggestreduction in RSS.In[11]:strategy = Stepwise.fixed_steps(design,len(design.terms),direction='forward')full_path = sklearn_selection_path(OLS, strategy)We now fit the full forward-selection path on theHittersdata and com-pute the fitted values.In[12]:full_path.fit(Hitters, Y)Yhat_in = full_path.predict(Hitters)Yhat_in.shapeOut[12]:(263, 20)This gives us an array of fitted values — 20 steps in all, including thefitted mean for the null model — which we can use to evaluate in-sampleMSE. As expected, the in-sample MSE improves each step we take, indicat-ing we must use either the validation or cross-validation approach to selectthe number of steps. We fix the y-axis to range from 50,000 to 250,000to compare to the cross-validation and validation set", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 319, "start_word": 102080, "end_word": 102480, "chunk_words": 400}}, "ISLP_website::c000320": {"text": "on theHittersdata and com-pute the fitted values.In[12]:full_path.fit(Hitters, Y)Yhat_in = full_path.predict(Hitters)Yhat_in.shapeOut[12]:(263, 20)This gives us an array of fitted values — 20 steps in all, including thefitted mean for the null model — which we can use to evaluate in-sampleMSE. As expected, the in-sample MSE improves each step we take, indicat-ing we must use either the validation or cross-validation approach to selectthe number of steps. We fix the y-axis to range from 50,000 to 250,000to compare to the cross-validation and validation set MSE below, as wellas other methods such as ridge regression, lasso and principal componentsregression.In[13]:mse_fig, ax = subplots(figsize=(8,8))insample_mse = ((Yhat_in - Y[:,None])**2).mean(0)n_steps = insample_mse.shape[0]ax.plot(np.arange(n_steps),insample_mse,'k',#c o l o rb l a c klabel='In-sample')ax.set_ylabel('MSE',fontsize=20)ax.set_xlabel('# steps of forward stepwise',fontsize=20)ax.set_xticks(np.arange(n_steps)[::2])ax.legend() 6.5 Lab: Linear Models and Regularization Methods 271 ax.set_ylim([50000,250000]); Notice the expression NoneinY[:,None] above. This adds an axis (dimen- sion) to the one-dimensional array Y, which allows it to be recycled when subtracted from the two-dimensional Yhat_in. We are now ready to use cross-validation to estimate test error along the model path. We must use only the training observations to perform all aspects of model-fitting — including variable selection. Therefore, the determination of which model of a given size is best must be made using only the training observations in each training fold. This point is subtle but important. If the full data set is used to select the best subset at each step, then the validation set errors and cross-validation errors that we obtain will not be accurate estimates of the test error. We now compute the cross-validated predicted values using 5-fold cross- validation. In[14]: K=5 kfold = skm.KFold(K, random_state=0, shuffle=True) Yhat_cv = skm.cross_val_predict(full_path, Hitters, Y, cv=kfold) Yhat_cv.shape skm.KFold() skm.cross_ val_predict()Out[14]: (263, 20) The prediction matrix Yhat_cvis the same shape as Yhat_in; the difference is that the predictions in each row, corresponding to a particular sample index, were made from models fit on a training fold that did not include that row. At each model along the path, we compute the MSE in each of the cross- validation folds. These we will average to get the mean MSE, and can also use the individual values to compute a crude estimate of the standard error of the mean.9Hence we must know the test indices for each cross-validation split. This can be found by using the split()method of kfold. Because we fixed the random state above, whenever we split any array with the same number of", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 320, "start_word": 102400, "end_word": 102800, "chunk_words": 400}}, "ISLP_website::c000321": {"text": "model along the path, we compute the MSE in each of the cross- validation folds. These we will average to get the mean MSE, and can also use the individual values to compute a crude estimate of the standard error of the mean.9Hence we must know the test indices for each cross-validation split. This can be found by using the split()method of kfold. Because we fixed the random state above, whenever we split any array with the same number of rows as Ywe recover the same training and test indices, though we simply ignore the training indices below. In[15]: cv_mse = [] for train_idx, test_idx in kfold.split(Y): errors = (Yhat_cv[test_idx] - Y[test_idx,None])**2 cv_mse.append(errors.mean(0)) #c o l u m nm e a n s cv_mse = np.array(cv_mse).T cv_mse.shape Out[15]: (20, 5) 9The estimate is crude because the five error estimates are based on overlapping training sets, and hence are not independent. 272 6. Linear Model Selection and RegularizationWe now add the cross-validation error estimates to our MSE plot. Weincludethemeanerroracrossthefivefolds,andtheestimateofthestandarderror of the mean.In[16]:ax.errorbar(np.arange(n_steps),cv_mse.mean(1),cv_mse.std(1) / np.sqrt(K),label='Cross-validated',c='r')#c o l o rr e dax.set_ylim([50000,250000])ax.legend()mse_figTo repeat the above using the validation set approach, we simply changeourcvargument to a validation set: one random split of the data into atest and training. We choose a test size of 20%, similar to the size of eachtest set in 5-fold cross-validation.skm.ShuffleSplit()In[17]:validation = skm.ShuffleSplit(n_splits=1,test_size=0.2,random_state=0)for train_idx, test_idx in validation.split(Y):full_path.fit(Hitters.iloc[train_idx],Y[train_idx])Yhat_val = full_path.predict(Hitters.iloc[test_idx])errors = (Yhat_val - Y[test_idx,None])**2validation_mse = errors.mean(0)Asforthein-sampleMSEcase,thevalidationsetapproachdoesnotprovidestandard errors.In[18]:ax.plot(np.arange(n_steps),validation_mse,'b--',#c o l o rb l u e ,b r o k e nl i n elabel='Validation')ax.set_xticks(np.arange(n_steps)[::2])ax.set_ylim([50000,250000])ax.legend()mse_figBest Subset SelectionForward stepwise is agreedyselection procedure; at each step it augmentsthe current set by including one additional variable. We now apply bestsubset selection to theHittersdata, which for every subset size, searchesfor the best set of predictors.We will use a package calledl0bnbto perform best subset selection.Insteadofconstrainingthesubsettobeagivensize,thispackageproducesapath of solutions using the subset size as a penalty rather than a constraint.Although the distinction is subtle, the difference comes when we cross-validate.In[19]:D=d e s i g n . f i t _ t r a n s f o r m ( H i t t e r s )D=D . d r o p ('intercept',a x i s = 1 )X=n p . a s a r r a y ( D ) 6.5 Lab: Linear Models and Regularization Methods 273 Here we excluded the first column corresponding to the intercept, as l0bnb will fit the intercept separately. We can find", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 321, "start_word": 102720, "end_word": 103120, "chunk_words": 400}}, "ISLP_website::c000322": {"text": "e s i g n . f i t _ t r a n s f o r m ( H i t t e r s )D=D . d r o p ('intercept',a x i s = 1 )X=n p . a s a r r a y ( D ) 6.5 Lab: Linear Models and Regularization Methods 273 Here we excluded the first column corresponding to the intercept, as l0bnb will fit the intercept separately. We can find a path using the fit_path() function. In[20]: path = fit_path(X, Y, max_nonzeros=X.shape[1]) The function fit_path() returns a list whose values include the fitted coefficients as B, an intercept as B0, as well as a few other attributes related to the particular path algorithm used. Such details are beyond the scope of this book. In[21]: path[3] Out[21]: {'B':a r r a y ( [ 0 . ,3 . 2 5 4 8 4 4 ,0 . ,0 . ,0 . , 0. , 0. , 0. , 0. , 0. , 0. , 0.677753 , 0. , 0. , 0. , 0. , 0. , 0. , 0. ]), 'B0':- 3 8 . 9 8 2 1 6 7 3 9 5 5 5 4 9 4 , 'lambda_0' :0 . 0 1 1 4 1 6 2 4 8 0 2 7 4 5 0 1 9 4 , 'M':0 . 5 8 2 9 8 6 1 7 3 3 3 8 2 0 1 1 , 'Time_exceeded' :F a l s e } In the example above, we see that at the fourth step in the path, we have two nonzero coefficients in 'B', corresponding to the value 0.114for the penaltyparameter lambda_0 .Wecouldmakepredictionsusingthissequence of fits on a validation set as a function of lambda_0 , or with more work using cross-validation. 6.5.2 Ridge Regression and the Lasso We will use the sklearn.linear_model package (for which we use sklas shorthand below) to fit ridge and lasso regularized linear models on the Hitters data. We start with the model matrix X(without an intercept) that we computed in the previous section on best subset regression. Ridge Regression Wewillusethefunction skl.ElasticNet() tofitbothridgeandthelasso.Toskl.Elastic Net() fit apathof ridge regressions models, we use skl.ElasticNet.path() , which skl.Elastic Net.path()can fit both ridge and lasso, as well as a hybrid mixture; ridge regression corresponds to l1_ratio=0 . It is good practice to standardize the columns ofXin these applications,", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 322, "start_word": 103040, "end_word": 103440, "chunk_words": 400}}, "ISLP_website::c000323": {"text": "shorthand below) to fit ridge and lasso regularized linear models on the Hitters data. We start with the model matrix X(without an intercept) that we computed in the previous section on best subset regression. Ridge Regression Wewillusethefunction skl.ElasticNet() tofitbothridgeandthelasso.Toskl.Elastic Net() fit apathof ridge regressions models, we use skl.ElasticNet.path() , which skl.Elastic Net.path()can fit both ridge and lasso, as well as a hybrid mixture; ridge regression corresponds to l1_ratio=0 . It is good practice to standardize the columns ofXin these applications, if the variables are measured in different units. Sinceskl.ElasticNet() does no normalization, we have to take care of that ourselves. Since we standardize first, in order to find coefficient estimates on the original scale, we must unstandardize the coefficient estimates. The parameter λin (6.5) and (6.7) is called alphasinsklearn. In order to be consistent with the rest of this chapter, we use lambdasrather than alphas in what follows.10 10At the time of publication, ridge fits like the one in code chunk [22] issue unwarranted convergence warning messages; we expect these to disappear as this package matures. 274 6. Linear Model Selection and Regularization In[22]: Xs = X - X.mean(0)[None,:] X_scale = X.std(0) Xs = Xs / X_scale[None,:] lambdas = 10**np.linspace(8, -2, 100) / Y.std() soln_array = skl.ElasticNet.path(Xs, Y, l1_ratio=0., alphas=lambdas)[1] soln_array.shape Out[22]: (19, 100) Here we extract the array of coefficients corresponding to the solutions along the regularization path. By default the skl.ElasticNet.path method fits a path along an automatically selected range of λvalues, except for the case when l1_ratio=0 , which results in ridge regression (as is the case here).11So here we have chosen to implement the function over a grid of values ranging from λ= 108toλ= 10−2scaled by the standard deviation ofy, essentially covering the full range of scenarios from the null model containing only the intercept, to the least squares fit. Associated with each value of λis a vector of ridge regression coefficients, that can be accessed by a column of soln_array . In this case, soln_array is a19×100matrix, with 19 rows (one for each predictor) and 100 columns (one for each value of λ). We transpose this matrix and turn it into a data frame to facilitate viewing and plotting. In[23]: soln_path = pd.DataFrame(soln_array.T, columns=D.columns, index=-np.log(lambdas)) soln_path.index.name = 'negative log(lambda)' soln_path Out[23]: AtBat Hits HmRun Runs ... negative log(lambda) -12.310855 0.000800 0.000889 0.000695 0.000851 ... -12.078271 0.001010 0.001122 0.000878 0.001074 ... -11.845686 0.001274 0.001416 0.001107 0.001355", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 323, "start_word": 103360, "end_word": 103760, "chunk_words": 400}}, "ISLP_website::c000324": {"text": "by a column of soln_array . In this case, soln_array is a19×100matrix, with 19 rows (one for each predictor) and 100 columns (one for each value of λ). We transpose this matrix and turn it into a data frame to facilitate viewing and plotting. In[23]: soln_path = pd.DataFrame(soln_array.T, columns=D.columns, index=-np.log(lambdas)) soln_path.index.name = 'negative log(lambda)' soln_path Out[23]: AtBat Hits HmRun Runs ... negative log(lambda) -12.310855 0.000800 0.000889 0.000695 0.000851 ... -12.078271 0.001010 0.001122 0.000878 0.001074 ... -11.845686 0.001274 0.001416 0.001107 0.001355 ... -11.613102 0.001608 0.001787 0.001397 0.001710 ... -11.380518 0.002029 0.002255 0.001763 0.002158 ... ... ... ... ... ... ... 100 rows × 19 columns We plot the paths to get a sense of how the coefficients vary with λ.T o control the location of the legend we first set legendtoFalsein the plot method, adding it afterward with the legend() method of ax. In[24]: path_fig, ax = subplots(figsize=(8,8)) soln_path.plot(ax=ax, legend=False) ax.set_xlabel( '$-\\log(\\lambda)$' ,f o n t s i z e = 2 0 ) 11The reason is rather technical; for all models except ridge, we can find the smallest value of λfor which all coefficients are zero. For ridge this value is ∞. 6.5 Lab: Linear Models and Regularization Methods 275ax.set_ylabel('Standardized coefficients',f o n t s i z e = 2 0 )ax.legend(loc='upper left');(We have usedlatexformatting in the horizontal label, in order to formatthe Greekλappropriately.) We expect the coefficient estimates to be muchsmaller, in terms of/lscript2norm, when a large value ofλis used, as comparedto when a small value ofλis used. (Recall that the/lscript2norm is the squareroot of the sum of squared coefficient values.) We display the coefficientsat the40th step, whereλis 25.535.In[25]:beta_hat = soln_path.loc[soln_path.index[39]]lambdas[39], beta_hatOut[25]:(25.535,AtBat5.433750Hits6.223582HmRun4.585498Runs5.880855RBI6.195921Walks6.277975Years5.299767......Let’s compute the/lscript2norm of the standardized coefficients.In[26]:np.linalg.norm(beta_hat)Out[26]:24.17In contrast, here is the/lscript2norm whenλis 2.44e-01. Note the much larger/lscript2norm of the coefficients associated with this smaller value ofλ.In[27]:beta_hat = soln_path.loc[soln_path.index[59]]lambdas[59], np.linalg.norm(beta_hat)Out[27]:(0.2437, 160.4237)Above we normalizedXupfront, and fit the ridge model usingXs. ThePipeline()object insklearnprovides a clear way to separate feature nor-malization from the fitting of the ridge model itself.In[28]:ridge = skl.ElasticNet(alpha=lambdas[59], l1_ratio=0)scaler = StandardScaler(with_mean=True, with_std=True)pipe = Pipeline(steps=[('scaler',s c a l e r ) ,('ridge',r i d g e ) ] )pipe.fit(X, Y)We show that it gives the same/lscript2norm as in our previous fit on thestandardized data.In[29]:np.linalg.norm(ridge.coef_)Out[29]:160.4237Notice that the operationpipe.fit(X, Y)above has changed theridgeobject, and in particular has added attributes such ascoef_that were notthere before. 276 6. Linear Model Selection and RegularizationEstimating Test Error of Ridge RegressionChoosing ana priorivalue ofλfor ridge regression is", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 324, "start_word": 103680, "end_word": 104080, "chunk_words": 400}}, "ISLP_website::c000325": {"text": "the fitting of the ridge model itself.In[28]:ridge = skl.ElasticNet(alpha=lambdas[59], l1_ratio=0)scaler = StandardScaler(with_mean=True, with_std=True)pipe = Pipeline(steps=[('scaler',s c a l e r ) ,('ridge',r i d g e ) ] )pipe.fit(X, Y)We show that it gives the same/lscript2norm as in our previous fit on thestandardized data.In[29]:np.linalg.norm(ridge.coef_)Out[29]:160.4237Notice that the operationpipe.fit(X, Y)above has changed theridgeobject, and in particular has added attributes such ascoef_that were notthere before. 276 6. Linear Model Selection and RegularizationEstimating Test Error of Ridge RegressionChoosing ana priorivalue ofλfor ridge regression is difficult if not im-possible. We will want to use the validation method or cross-validation toselect the tuning parameter. The reader may not be surprised that thePipeline()approach can be used inskm.cross_validate()with either avalidation method (i.e.validation) ork-fold cross-validation.We fix the random state of the splitter so that the results obtained willbe reproducible.In[30]:validation = skm.ShuffleSplit(n_splits=1,test_size=0.5,random_state=0)ridge.alpha = 0.01results = skm.cross_validate(ridge,X,Y,scoring='neg_mean_squared_error',cv=validation)-results['test_score']Out[30]:array([134214.0])The test MSE is 1.342e+05. Note that if we had instead simply fit a modelwith just an intercept, we would have predicted each test observation usingthe mean of the training observations. We can get the same result by fittinga ridge regression model with averylarge value ofλ. Note that1e10means1010.In[31]:ridge.alpha = 1e10results = skm.cross_validate(ridge,X,Y,scoring='neg_mean_squared_error',cv=validation)-results['test_score']Out[31]:array([231788.32])Obviously choosingλ=0.01is arbitrary, so we will use cross-validation orthe validation-set approach to choose the tuning parameterλ. The objectGridSearchCV()allows exhaustive grid search to choose such a parameter.GridSearchCV()We first use the validation set method to chooseλ.In[32]:param_grid = {'ridge__alpha':l a m b d a s }grid = skm.GridSearchCV(pipe,param_grid,cv=validation,scoring='neg_mean_squared_error')grid.fit(X, Y)grid.best_params_['ridge__alpha']grid.best_estimator_Out[32]:Pipeline(steps=[('scaler',S t a n d a r d S c a l e r ( ) ) ,('ridge',E l a s t i c N e t ( a l p h a = 0 . 0 0 5 8 9 9 ,l 1 _ r a t i o = 0 ) ) ] ) 6.5 Lab: Linear Models and Regularization Methods 277 Alternatively, we can use 5-fold cross-validation. In[33]: grid = skm.GridSearchCV(pipe, param_grid, cv=kfold, scoring= 'neg_mean_squared_error' ) grid.fit(X, Y) grid.best_params_[ 'ridge__alpha' ] grid.best_estimator_ Recall we set up the kfoldobject for 5-fold cross-validation on page 271. We now plot the cross-validated MSE as a function of −log(λ), which has shrinkage decreasing from left to right. In[34]: ridge_fig, ax = subplots(figsize=(8,8)) ax.errorbar(-np.log(lambdas), -grid.cv_results_[ 'mean_test_score' ], yerr=grid.cv_results_[ 'std_test_score' ]/n p . s q r t ( K ) ) ax.set_ylim([50000,250000]) ax.set_xlabel( '$-\\log(\\lambda)$' ,f o n t s i z e = 2 0 ) ax.set_ylabel( 'Cross-validated MSE' ,f o n t s i z e = 2 0 ) ;", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 325, "start_word": 104000, "end_word": 104400, "chunk_words": 400}}, "ISLP_website::c000326": {"text": "the kfoldobject for 5-fold cross-validation on page 271. We now plot the cross-validated MSE as a function of −log(λ), which has shrinkage decreasing from left to right. In[34]: ridge_fig, ax = subplots(figsize=(8,8)) ax.errorbar(-np.log(lambdas), -grid.cv_results_[ 'mean_test_score' ], yerr=grid.cv_results_[ 'std_test_score' ]/n p . s q r t ( K ) ) ax.set_ylim([50000,250000]) ax.set_xlabel( '$-\\log(\\lambda)$' ,f o n t s i z e = 2 0 ) ax.set_ylabel( 'Cross-validated MSE' ,f o n t s i z e = 2 0 ) ; One can cross-validate different metrics to choose a parameter. The de- fault metric for skl.ElasticNet() is testR2. Let’s compare R2to MSE for cross-validation here. In[35]: grid_r2 = skm.GridSearchCV(pipe, param_grid, cv=kfold) grid_r2.fit(X, Y) Finally, let’s plot the results for cross-validated R2. In[36]: r2_fig, ax = subplots(figsize=(8,8)) ax.errorbar(-np.log(lambdas), grid_r2.cv_results_[ 'mean_test_score' ], yerr=grid_r2.cv_results_[ 'std_test_score' ]/n p . s q r t ( K ) ) ax.set_xlabel( '$-\\log(\\lambda)$' ,f o n t s i z e = 2 0 ) ax.set_ylabel( 'Cross-validated $R^2$' ,f o n t s i z e = 2 0 ) ; Fast Cross-Validation for Solution Paths The ridge, lasso, and elastic net can be efficiently fit along a sequence of λvalues, creating what is known as a solution path orregularization path . Hence there is specialized code to fit such paths, and to choose a suitable value ofλusing cross-validation. Even with identical splits the results will not agree exactlywith our gridabove because the standardization of each feature in gridis carried out on each fold, while in pipeCVbelow it is carried out only once. Nevertheless, the results are similar as the normalization is relatively stable across folds. In[37]: ridgeCV = skl.ElasticNetCV(alphas=lambdas, l1_ratio=0, cv=kfold) pipeCV = Pipeline(steps=[( 'scaler' ,s c a l e r ) , 278 6. Linear Model Selection and Regularization ('ridge' ,r i d g e C V ) ] ) pipeCV.fit(X, Y) Let’s produce a plot again of the cross-validation error to see that it is similar to using skm.GridSearchCV . In[38]: tuned_ridge = pipeCV.named_steps[ 'ridge' ] ridgeCV_fig, ax = subplots(figsize=(8,8)) ax.errorbar(-np.log(lambdas), tuned_ridge.mse_path_.mean(1), yerr=tuned_ridge.mse_path_.std(1) / np.sqrt(K)) ax.axvline(-np.log(tuned_ridge.alpha_), c= 'k',l s ='--') ax.set_ylim([50000,250000]) ax.set_xlabel( '$-\\log(\\lambda)$' ,f o n t s i z e = 2 0 ) ax.set_ylabel( 'Cross-validated MSE' ,f o n t s i z e = 2 0 ) ; We see that the value of λthat results in the smallest cross-validation error is 1.19e-02, available as the value tuned_ridge.alpha_ . What is the test", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 326, "start_word": 104320, "end_word": 104720, "chunk_words": 400}}, "ISLP_website::c000327": {"text": "to using skm.GridSearchCV . In[38]: tuned_ridge = pipeCV.named_steps[ 'ridge' ] ridgeCV_fig, ax = subplots(figsize=(8,8)) ax.errorbar(-np.log(lambdas), tuned_ridge.mse_path_.mean(1), yerr=tuned_ridge.mse_path_.std(1) / np.sqrt(K)) ax.axvline(-np.log(tuned_ridge.alpha_), c= 'k',l s ='--') ax.set_ylim([50000,250000]) ax.set_xlabel( '$-\\log(\\lambda)$' ,f o n t s i z e = 2 0 ) ax.set_ylabel( 'Cross-validated MSE' ,f o n t s i z e = 2 0 ) ; We see that the value of λthat results in the smallest cross-validation error is 1.19e-02, available as the value tuned_ridge.alpha_ . What is the test MSE associated with this value of λ? In[39]: np.min(tuned_ridge.mse_path_.mean(1)) Out[39]: 115526.71 This represents a further improvement over the test MSE that we got using λ=4. Finally, tuned_ridge.coef_ has the coefficients fit on the entire data set at this value of λ. In[40]: tuned_ridge.coef_ Out[40]: array([-222.80877051, 238.77246614, 3.21103754, -2.93050845, 3.64888723, 108.90953869, -50.81896152, -105.15731984, 122.00714801, 57.1859509 , 210.35170348, 118.05683748, -150.21959435, 30.36634231, -61.62459095, 77.73832472, 40.07350744, -25.02151514, -13.68429544]) As expected, none of the coefficients are zero—ridge regression does not perform variable selection! Evaluating Test Error of Cross-Validated Ridge Choosing λusing cross-validation provides a single regression estimator, similar to fitting a linear regression model as we saw in Chapter 3. It is therefore reasonable to estimate what its test error is. We run into a prob- lem here in that cross-validation will have touchedall of its data in choosing λ, hence we have no further data to estimate test error. A compromise is to do an initial split of the data into two disjoint sets: a training set and a test set. We then fit a cross-validation tuned ridge regression on the train- ing set, and evaluate its performance on the test set. We might call this cross-validation nested within the validation set approach. A priori there is no reason to use half of the data for each of the two sets in validation. Below, we use 75% for training and 25% for test, with the estimator being ridge regression tuned using 5-fold cross-validation. This can be achieved in code as follows: 6.5 Lab: Linear Models and Regularization Methods 279In[41]:outer_valid = skm.ShuffleSplit(n_splits=1,test_size=0.25,random_state=1)inner_cv = skm.KFold(n_splits=5,shuffle=True,random_state=2)ridgeCV = skl.ElasticNetCV(alphas=lambdas,l1_ratio=0,cv=inner_cv)pipeCV = Pipeline(steps=[('scaler',s c a l e r ) ,('ridge',r i d g e C V ) ] ) ;In[42]:results = skm.cross_validate(pipeCV,X,Y,cv=outer_valid,scoring='neg_mean_squared_error')-results['test_score']Out[42]:array([132393.84])The LassoWe saw that ridge regression with a wise choice ofλcan outperform leastsquares as well as the null model on theHittersdata set. We now askwhether the lasso can yield either a more accurate or a more interpretablemodel than ridge", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 327, "start_word": 104640, "end_word": 105040, "chunk_words": 400}}, "ISLP_website::c000328": {"text": "can be achieved in code as follows: 6.5 Lab: Linear Models and Regularization Methods 279In[41]:outer_valid = skm.ShuffleSplit(n_splits=1,test_size=0.25,random_state=1)inner_cv = skm.KFold(n_splits=5,shuffle=True,random_state=2)ridgeCV = skl.ElasticNetCV(alphas=lambdas,l1_ratio=0,cv=inner_cv)pipeCV = Pipeline(steps=[('scaler',s c a l e r ) ,('ridge',r i d g e C V ) ] ) ;In[42]:results = skm.cross_validate(pipeCV,X,Y,cv=outer_valid,scoring='neg_mean_squared_error')-results['test_score']Out[42]:array([132393.84])The LassoWe saw that ridge regression with a wise choice ofλcan outperform leastsquares as well as the null model on theHittersdata set. We now askwhether the lasso can yield either a more accurate or a more interpretablemodel than ridge regression. In order to fit a lasso model, we once againuse theElasticNetCV()function; however, this time we use the argumentl1_ratio=1. Other than that change, we proceed just as we did in fitting aridge model.In[43]:lassoCV = skl.ElasticNetCV(n_alphas=100,l1_ratio=1,cv=kfold)pipeCV = Pipeline(steps=[('scaler',s c a l e r ) ,('lasso',l a s s o C V ) ] )pipeCV.fit(X, Y)tuned_lasso = pipeCV.named_steps['lasso']tuned_lasso.alpha_Out[43]:3.147In[44]:lambdas, soln_array = skl.Lasso.path(Xs,Y,l1_ratio=1,n_alphas=100)[:2]soln_path = pd.DataFrame(soln_array.T,columns=D.columns,index=-np.log(lambdas))We can see from the coefficient plot of the standardized coefficients thatdepending on the choice of tuning parameter, some of the coefficients willbe exactly equal to zero. 280 6. Linear Model Selection and Regularization In[45]: path_fig, ax = subplots(figsize=(8,8)) soln_path.plot(ax=ax, legend=False) ax.legend(loc= 'upper left' ) ax.set_xlabel( '$-\\log(\\lambda)$' ,f o n t s i z e = 2 0 ) ax.set_ylabel( 'Standardized coefficiients' ,f o n t s i z e = 2 0 ) ; The smallest cross-validated error is lower than the test set MSE of the null model and of least squares, and very similar to the test MSE of 115526.71 of ridge regression (page 278) withλchosen by cross-validation. In[46]: np.min(tuned_lasso.mse_path_.mean(1)) Out[46]: 114690.73 Let’s again produce a plot of the cross-validation error. In[47]: lassoCV_fig, ax = subplots(figsize=(8,8)) ax.errorbar(-np.log(tuned_lasso.alphas_), tuned_lasso.mse_path_.mean(1), yerr=tuned_lasso.mse_path_.std(1) / np.sqrt(K)) ax.axvline(-np.log(tuned_lasso.alpha_), c= 'k',l s ='--') ax.set_ylim([50000,250000]) ax.set_xlabel( '$-\\log(\\lambda)$' ,f o n t s i z e = 2 0 ) ax.set_ylabel( 'Cross-validated MSE' ,f o n t s i z e = 2 0 ) ; However, the lasso has a substantial advantage over ridge regression in that the resulting coefficient estimates are sparse. Here we see that 6 of the 19 coefficient estimates are exactly zero. So the lasso model with λchosen by cross-validation contains only 13 variables. In[48]: tuned_lasso.coef_ Out[48]: array([-210.01008773, 243.4550306 , 0. , 0. , 0. , 97.69397357, -41.52283116, -0. , 0. , 39.62298193, 205.75273856, 124.55456561, -126.29986768, 15.70262427, -59.50157967, 75.24590036, 21.62698014, -12.04423675, -0. ]) As in ridge regression, we could evaluate the test error of cross-validated lasso by first splitting into test", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 328, "start_word": 104960, "end_word": 105360, "chunk_words": 400}}, "ISLP_website::c000329": {"text": "in that the resulting coefficient estimates are sparse. Here we see that 6 of the 19 coefficient estimates are exactly zero. So the lasso model with λchosen by cross-validation contains only 13 variables. In[48]: tuned_lasso.coef_ Out[48]: array([-210.01008773, 243.4550306 , 0. , 0. , 0. , 97.69397357, -41.52283116, -0. , 0. , 39.62298193, 205.75273856, 124.55456561, -126.29986768, 15.70262427, -59.50157967, 75.24590036, 21.62698014, -12.04423675, -0. ]) As in ridge regression, we could evaluate the test error of cross-validated lasso by first splitting into test and training sets and internally running cross-validation on the training set. We leave this as an exercise. 6.5.3 PCR and PLS Regression Principal Components Regression Principal components regression (PCR) can be performed using PCA()fromPCA()thesklearn.decomposition module. We now apply PCR to the Hitters data, in order to predict Salary. Again, ensure that the missing values have been removed from the data, as described in Section 6.5.1. We use LinearRegression() to fit the regression model here. Note thatLinear Regression() it fits an intercept by default, unlike the OLS()function seen earlier in Section6.5.1. 6.5 Lab: Linear Models and Regularization Methods 281In[49]:pca = PCA(n_components=2)linreg = skl.LinearRegression()pipe = Pipeline([('pca',p c a ) ,('linreg',l i n r e g ) ] )pipe.fit(X, Y)pipe.named_steps['linreg'].coef_Out[49]:array([0.09846131, 0.4758765 ])When performing PCA, the results vary depending on whether the datahas beenstandardizedor not. As in the earlier examples, this can be ac-complished by including an additional step in the pipeline.In[50]:pipe = Pipeline([('scaler',s c a l e r ) ,('pca',p c a ) ,('linreg',l i n r e g ) ] )pipe.fit(X, Y)pipe.named_steps['linreg'].coef_Out[50]:array([106.36859204, -21.60350456])We can of course use CV to choose the number of components, byusingskm.GridSearchCV, in this case fixing the parameters to vary then_components.In[51]:param_grid = {'pca__n_components':r a n g e ( 1 ,2 0 ) }grid = skm.GridSearchCV(pipe,param_grid,cv=kfold,scoring='neg_mean_squared_error')grid.fit(X, Y)Let’s plot the results as we have for other methods.In[52]:pcr_fig, ax = subplots(figsize=(8,8))n_comp = param_grid['pca__n_components']ax.errorbar(n_comp,-grid.cv_results_['mean_test_score'],grid.cv_results_['std_test_score']/n p . s q r t ( K ) )ax.set_ylabel('Cross-validated MSE',f o n t s i z e = 2 0 )ax.set_xlabel('# principal components',f o n t s i z e = 2 0 )ax.set_xticks(n_comp[::2])ax.set_ylim([50000,250000]);We see that the smallest cross-validation error occurs when 17 compo-nents are used. However, from the plot we also see that the cross-validationerror is roughly the same when only one component is included in themodel. This suggests that a model that uses just a small number of com-ponents might suffice.The CV score is provided for each possible number of components from1 to 19 inclusive. ThePCA()method", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 329, "start_word": 105280, "end_word": 105680, "chunk_words": 400}}, "ISLP_website::c000330": {"text": "2 0 )ax.set_xlabel('# principal components',f o n t s i z e = 2 0 )ax.set_xticks(n_comp[::2])ax.set_ylim([50000,250000]);We see that the smallest cross-validation error occurs when 17 compo-nents are used. However, from the plot we also see that the cross-validationerror is roughly the same when only one component is included in themodel. This suggests that a model that uses just a small number of com-ponents might suffice.The CV score is provided for each possible number of components from1 to 19 inclusive. ThePCA()method complains if we try to fit an interceptonly withn_components=0so we also compute the MSE for just the nullmodel with these splits.In[53]:Xn = np.zeros((X.shape[0], 1))cv_null = skm.cross_validate(linreg, 282 6. Linear Model Selection and Regularization Xn, Y, cv=kfold, scoring= 'neg_mean_squared_error' ) -cv_null[ 'test_score' ].mean() Out[53]: 204139.31 Theexplained_variance_ratio_ attribute of our PCAobject provides the percentage of variance explained in the predictors and in the response using different numbers of components. This concept is discussed in greater detail in Section 12.2. In[54]: pipe.named_steps[ 'pca'].explained_variance_ratio_ Out[54]: array([0.3831424 , 0.21841076]) Briefly, we can think of this as the amount of information about the predic- tors that is captured using Mprincipal components. For example, setting M=1only captures 38.31% of the variance, while M=2captures an ad- ditional 21.84%, for a total of 60.15% of the variance. By M=6it increases to 88.63%. Beyond this the increments continue to diminish, until we use allM=p= 19components, which captures all 100% of the variance. Partial Least Squares Partialleastsquares(PLS)isimplementedinthe PLSRegression() function.PLS Regression()In[55]: pls = PLSRegression(n_components=2, scale=True) pls.fit(X, Y) As was the case in PCR, we will want to use CV to choose the number of components. In[56]: param_grid = { 'n_components' :range(1, 20)} grid = skm.GridSearchCV(pls, param_grid, cv=kfold, scoring= 'neg_mean_squared_error' ) grid.fit(X, Y) As for our other methods, we plot the MSE. In[57]: pls_fig, ax = subplots(figsize=(8,8)) n_comp = param_grid[ 'n_components' ] ax.errorbar(n_comp, -grid.cv_results_[ 'mean_test_score' ], grid.cv_results_[ 'std_test_score' ]/n p . s q r t ( K ) ) ax.set_ylabel( 'Cross-validated MSE' ,f o n t s i z e = 2 0 ) ax.set_xlabel( '# principal components' ,f o n t s i z e = 2 0 ) ax.set_xticks(n_comp[::2]) ax.set_ylim([50000,250000]); CV error is minimized at 12, though there is little noticable difference between this point and a much lower number like 2 or 3 components. 6.6 Exercises 2836.6 ExercisesConceptual1. We perform best subset, forward stepwise, and backward stepwiseselection on a single data set. For each approach, we obtainp+1models, containing0,1,2,...,ppredictors. Explain your", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 330, "start_word": 105600, "end_word": 106000, "chunk_words": 400}}, "ISLP_website::c000331": {"text": "o n t s i z e = 2 0 ) ax.set_xlabel( '# principal components' ,f o n t s i z e = 2 0 ) ax.set_xticks(n_comp[::2]) ax.set_ylim([50000,250000]); CV error is minimized at 12, though there is little noticable difference between this point and a much lower number like 2 or 3 components. 6.6 Exercises 2836.6 ExercisesConceptual1. We perform best subset, forward stepwise, and backward stepwiseselection on a single data set. For each approach, we obtainp+1models, containing0,1,2,...,ppredictors. Explain your answers:(a) Which of the three models withkpredictors has the smallesttrainingRSS?(b) Which of the three models withkpredictors has the smallesttestRSS?(c) True or False:i. The predictors in thek-variable model identified by forwardstepwise are a subset of the predictors in the(k+1)-variablemodel identified by forward stepwise selection.ii. The predictors in thek-variable model identified by back-ward stepwise are a subset of the predictors in the(k+ 1)-variable model identified by backward stepwise selection.iii. The predictors in thek-variable model identified by back-ward stepwise are a subset of the predictors in the(k+ 1)-variable model identified by forward stepwise selection.iv. The predictors in thek-variable model identified by forwardstepwise are a subset of the predictors in the(k+1)-variablemodel identified by backward stepwise selection.v. The predictors in thek-variable model identified by bestsubset are a subset of the predictors in the(k+ 1)-variablemodel identified by best subset selection.2. For parts (a) through (c), indicate which of i. through iv. is correct.Justify your answer.(a) The lasso, relative to least squares, is:i. More flexible and hence will give improved prediction ac-curacy when its increase in bias is less than its decrease invariance.ii. More flexible and hence will give improved prediction accu-racy when its increase in variance is less than its decreasein bias.iii. Less flexible and hence will give improved prediction accu-racy when its increase in bias is less than its decrease invariance.iv. Less flexible and hence will give improved prediction accu-racy when its increase in variance is less than its decreasein bias.(b) Repeat (a) for ridge regression relative to least squares.(c) Repeat (a) for non-linear methods relative to least squares. 284 6. Linear Model Selection and Regularization3. Suppose we estimate the regression coefficients in a linear regressionmodel by minimizingn/summationdisplayi=1yi−β0−p/summationdisplayj=1βjxij2subject top/summationdisplayj=1|βj|≤sfor a particular value ofs. For parts (a) through (e), indicate whichof i. through v. is correct. Justify your answer.(a) As we increasesfrom 0, the training RSS will:i. Increase initially, and then eventually start decreasing in aninverted U shape.ii. Decrease initially, and then eventually start increasing in", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 331, "start_word": 105920, "end_word": 106320, "chunk_words": 400}}, "ISLP_website::c000332": {"text": "regression relative to least squares.(c) Repeat (a) for non-linear methods relative to least squares. 284 6. Linear Model Selection and Regularization3. Suppose we estimate the regression coefficients in a linear regressionmodel by minimizingn/summationdisplayi=1yi−β0−p/summationdisplayj=1βjxij2subject top/summationdisplayj=1|βj|≤sfor a particular value ofs. For parts (a) through (e), indicate whichof i. through v. is correct. Justify your answer.(a) As we increasesfrom 0, the training RSS will:i. Increase initially, and then eventually start decreasing in aninverted U shape.ii. Decrease initially, and then eventually start increasing in aU shape.iii. Steadily increase.iv. Steadily decrease.v. Remain constant.(b) Repeat (a) for test RSS.(c) Repeat (a) for variance.(d) Repeat (a) for (squared) bias.(e) Repeat (a) for the irreducible error.4. Suppose we estimate the regression coefficients in a linear regressionmodel by minimizingn/summationdisplayi=1yi−β0−p/summationdisplayj=1βjxij2+λp/summationdisplayj=1β2jfor a particular value ofλ. For parts (a) through (e), indicate whichof i. through v. is correct. Justify your answer.(a) As we increaseλfrom 0, the training RSS will:i. Increase initially, and then eventually start decreasing in aninverted U shape.ii. Decrease initially, and then eventually start increasing in aU shape.iii. Steadily increase.iv. Steadily decrease.v. Remain constant.(b) Repeat (a) for test RSS.(c) Repeat (a) for variance.(d) Repeat (a) for (squared) bias.(e) Repeat (a) for the irreducible error. 6.6 Exercises 285 5. It is well-known that ridge regression tends to give similar coefficient values to correlated variables, whereas the lasso may give quite dif- ferent coefficient values to correlated variables. We will now explore this property in a very simple setting. Suppose that n=2,p=2,x11=x12,x21=x22. Furthermore, suppose that y1+y2=0andx11+x21=0andx12+x22=0, so that the estimate for the intercept in a least squares, ridge regression, or lasso model is zero: ˆβ0=0. (a) Write out the ridge regression optimization problem in this set- ting. (b) Argue that in this setting, the ridge coefficient estimates satisfy ˆβ1=ˆβ2. (c) Write out the lasso optimization problem in this setting. (d) Argue that in this setting, the lasso coefficients ˆβ1andˆβ2are not unique—in other words, there are many possible solutions to the optimization problem in (c). Describe these solutions. 6. We will now explore ( 6.12) and (6.13) further. (a) Consider ( 6.12) withp=1. For some choice of y1andλ>0, plot (6.12) as a function of β1. Your plot should confirm that (6.12) is solved by ( 6.14). (b) Consider ( 6.13) withp=1. For some choice of y1andλ>0, plot (6.13) as a function of β1. Your plot should confirm that (6.13) is solved by ( 6.15). 7. We will now derive the Bayesian connection to", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 332, "start_word": 106240, "end_word": 106640, "chunk_words": 400}}, "ISLP_website::c000333": {"text": "in (c). Describe these solutions. 6. We will now explore ( 6.12) and (6.13) further. (a) Consider ( 6.12) withp=1. For some choice of y1andλ>0, plot (6.12) as a function of β1. Your plot should confirm that (6.12) is solved by ( 6.14). (b) Consider ( 6.13) withp=1. For some choice of y1andλ>0, plot (6.13) as a function of β1. Your plot should confirm that (6.13) is solved by ( 6.15). 7. We will now derive the Bayesian connection to the lasso and ridge regression discussed in Section 6.2.2. (a) Suppose that yi=β0+/summationtextp j=1xijβj+/epsilon1iwhere/epsilon11,...,/epsilon1nare inde- pendentandidenticallydistributedfroma N(0,σ2)distribution. Write out the likelihood for the data. (b) Assume the following prior for β:β1,...,βpare independent and identically distributed according to a double-exponential distribution with mean 0 and common scale parameter b: i.e. p(β)=1 2bexp(−|β|/b). Write out the posterior for βin this setting. (c) Argue that the lasso estimate is the modeforβunder this pos- terior distribution. (d) Nowassumethefollowingpriorfor β:β1,...,βpareindependent and identically distributed according to a normal distribution with mean zero and variance c. Write out the posterior for βin this setting. (e) Argue that the ridge regression estimate is both the modeand themeanforβunder this posterior distribution. 286 6. Linear Model Selection and RegularizationApplied8. In this exercise, we will generate simulated data, and will then usethis data to perform forward and backward stepwise selection.(a) Create a random number generator and use itsnormal()methodto generate a predictorXof lengthn= 100, as well as a noisevector/epsilon1of lengthn= 100.(b) Generate a response vectorYof lengthn= 100according tothe modelY=β0+β1X+β2X2+β3X3+/epsilon1,whereβ0,β1,β2, andβ3are constants of your choice.(c) Useforwardstepwiseselectioninordertoselectamodelcontain-ing the predictorsX,X2,...,X10. What is the model obtainedaccording toCp? Report the coefficients of the model obtained.(d) Repeat (c), using backwards stepwise selection. How does youranswer compare to the results in (c)?(e) Now fit a lasso model to the simulated data, again usingX,X2,...,X10as predictors. Use cross-validation to select the optimalvalueofλ.Createplotsofthecross-validationerrorasafunctionofλ. Report the resulting coefficient estimates, and discuss theresults obtained.(f) Now generate a response vectorYaccording to the modelY=β0+β7X7+/epsilon1,and perform forward stepwise selection and the lasso. Discussthe results obtained.9. In this exercise, we will predict the number of applications receivedusing the other variables in theCollegedata set.(a) Split the data set into a training set and a test set.(b) Fit a linear model using least squares on the training set, andreport the test error obtained.(c) Fit a ridge regression model on the training set, withλchosenby cross-validation. Report the test error obtained.(d) Fit a lasso model on the training set, withλchosen by cross-validation.", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 333, "start_word": 106560, "end_word": 106960, "chunk_words": 400}}, "ISLP_website::c000334": {"text": "stepwise selection and the lasso. Discussthe results obtained.9. In this exercise, we will predict the number of applications receivedusing the other variables in theCollegedata set.(a) Split the data set into a training set and a test set.(b) Fit a linear model using least squares on the training set, andreport the test error obtained.(c) Fit a ridge regression model on the training set, withλchosenby cross-validation. Report the test error obtained.(d) Fit a lasso model on the training set, withλchosen by cross-validation. Report the test error obtained, along with the num-ber of non-zero coefficient estimates.(e) Fit a PCR model on the training set, withMchosen by cross-validation. Report the test error obtained, along with the valueofMselected by cross-validation.(f) Fit a PLS model on the training set, withMchosen by cross-validation. Report the test error obtained, along with the valueofMselected by cross-validation. 6.6 Exercises 287(g) Comment on the results obtained. How accurately can we pre-dict the number of college applications received? Is there muchdifference among the test errors resulting from these five ap-proaches?10. Wehaveseenthatasthenumberoffeaturesusedinamodelincreases,thetrainingerrorwillnecessarilydecrease,butthetesterrormaynot.We will now explore this in a simulated data set.(a) Generate a data set withp= 20features,n=1,000observa-tions, and an associated quantitative response vector generatedaccording to the modelY=Xβ+/epsilon1,whereβhas some elements that are exactly equal to zero.(b) Splityourdatasetintoatrainingsetcontaining100observationsand a test set containing 900 observations.(c) Perform best subset selection on the training set, and plot thetraining set MSE associated with the best model of each size.(d) Plot the test set MSE associated with the best model of eachsize.(e) For which model size does the test set MSE take on its minimumvalue?Commentonyourresults.Ifittakesonitsminimumvaluefor a model containing only an intercept or a model containingall of the features, then play around with the way that you aregenerating the data in (a) until you come up with a scenario inwhich the test set MSE is minimized for an intermediate modelsize.(f) How does the model at which the test set MSE is minimizedcompare to the true model used to generate the data? Commenton the coefficient values.(g) Create a plot displaying/radicalBig/summationtextpj=1(βj−ˆβrj)2for a range of valuesofr, whereˆβrjis thejth coefficient estimate for the best modelcontainingrcoefficients. Comment on what you observe. Howdoes this compare to the test MSE plot from (d)?11. We will now try to predict per capita crime rate in theBostondataset.(a) Try out some of the regression methods explored in this chapter,such as best subset selection, the lasso, ridge regression, andPCR. Present and discuss results for the approaches that youconsider.(b) Propose a model (or", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 334, "start_word": 106880, "end_word": 107280, "chunk_words": 400}}, "ISLP_website::c000335": {"text": "Commenton the coefficient values.(g) Create a plot displaying/radicalBig/summationtextpj=1(βj−ˆβrj)2for a range of valuesofr, whereˆβrjis thejth coefficient estimate for the best modelcontainingrcoefficients. Comment on what you observe. Howdoes this compare to the test MSE plot from (d)?11. We will now try to predict per capita crime rate in theBostondataset.(a) Try out some of the regression methods explored in this chapter,such as best subset selection, the lasso, ridge regression, andPCR. Present and discuss results for the approaches that youconsider.(b) Propose a model (or set of models) that seem to perform well onthis data set, and justify your answer. Make sure that you areevaluating model performance using validation set error, cross-validation, or some other reasonable alternative, as opposed tousing training error. 288 6. Linear Model Selection and Regularization(c) Does your chosen model involve all of the features in the dataset? Why or why not? 7 Moving Beyond Linearity So far in this book, we have mostly focused on linear models. Linear models are relatively simple to describe and implement, and have advantages over other approaches in terms of interpretation and inference. However, stan- dard linear regression can have significant limitations in terms of predic- tive power. This is because the linearity assumption is almost always an approximation, and sometimes a poor one. In Chapter 6we see that we can improve upon least squares using ridge regression, the lasso, principal com- ponents regression, and other techniques. In that setting, the improvement is obtained by reducing the complexity of the linear model, and hence the variance of the estimates. But we are still using a linear model, which can only be improved so far! In this chapter we relax the linearity assumption while still attempting to maintain as much interpretability as possible. We do this by examining very simple extensions of linear models like polyno- mialregressionandstepfunctions,aswellasmoresophisticatedapproaches such as splines, local regression, and generalized additive models. •Polynomial regression extends the linear model by adding extra pre- dictors, obtained by raising each of the original predictors to a power. For example, a cubicregression uses three variables, X,X2, andX3, as predictors. This approach provides a simple way to provide a non- linear fit to data. •Step functions cut the range of a variable into Kdistinct regions in order to produce a qualitative variable. This has the effect of fitting a piecewise constant function. •Regression splines are more flexible than polynomials and step func- tions, and in fact are an", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 335, "start_word": 107200, "end_word": 107600, "chunk_words": 400}}, "ISLP_website::c000336": {"text": "obtained by raising each of the original predictors to a power. For example, a cubicregression uses three variables, X,X2, andX3, as predictors. This approach provides a simple way to provide a non- linear fit to data. •Step functions cut the range of a variable into Kdistinct regions in order to produce a qualitative variable. This has the effect of fitting a piecewise constant function. •Regression splines are more flexible than polynomials and step func- tions, and in fact are an extension of the two. They involve dividing the range of XintoKdistinct regions. Within each region, a poly- nomial function is fit to the data. However, these polynomials are © Springer Nature Switzerland AG 2023 G. James et al., An Introduction to Statistical Learning , Springer Texts in Statistics, https://doi.org/10.1007/978-3-031-38747-0_7289 290 7. Moving Beyond Linearity constrained so that they join smoothly at the region boundaries, or knots. Provided that the interval is divided into enough regions, this can produce an extremely flexible fit. •Smoothing splines are similar to regression splines, but arise in a slightly different situation. Smoothing splines result from minimizing a residual sum of squares criterion subject to a smoothness penalty. •Local regression is similar to splines, but differs in an important way. The regions are allowed to overlap, and indeed they do so in a very smooth way. •Generalized additive models allow us to extend the methods above to deal with multiple predictors. In Sections 7.1–7.6, we present a number of approaches for modeling the relationship between a response Yand a single predictor Xin a flexible way. In Section 7.7, we show that these approaches can be seamlessly in- tegrated in order to model a response Yas a function of several predictors X1,...,X p. 7.1 Polynomial Regression Historically, the standard way to extend linear regression to settings in which the relationship between the predictors and the response is non- linear has been to replace the standard linear model yi=β0+β1xi+/epsilon1i with a polynomial function yi=β0+β1xi+β2x2 i+β3x3 i+···+βdxd i+/epsilon1i, (7.1) where/epsilon1iis the error term. This approach is known as polynomial regression ,polynomial regressionand in fact we saw an example of this method in Section 3.3.2. For large enough degree d, a polynomial regression allows us to produce an extremely non-linearcurve.Noticethatthecoefficientsin( 7.1)canbeeasilyestimated using least squares linear regression because this is just a standard linear model with predictors xi,x2 i,x3 i,...,xd i. Generally speaking, it is unusual to usedgreater than 3or4because for", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 336, "start_word": 107520, "end_word": 107920, "chunk_words": 400}}, "ISLP_website::c000337": {"text": "yi=β0+β1xi+/epsilon1i with a polynomial function yi=β0+β1xi+β2x2 i+β3x3 i+···+βdxd i+/epsilon1i, (7.1) where/epsilon1iis the error term. This approach is known as polynomial regression ,polynomial regressionand in fact we saw an example of this method in Section 3.3.2. For large enough degree d, a polynomial regression allows us to produce an extremely non-linearcurve.Noticethatthecoefficientsin( 7.1)canbeeasilyestimated using least squares linear regression because this is just a standard linear model with predictors xi,x2 i,x3 i,...,xd i. Generally speaking, it is unusual to usedgreater than 3or4because for large values of d, the polynomial curve can become overly flexible and can take on some very strange shapes. This is especially true near the boundary of the Xvariable. The left-hand panel in Figure 7.1is a plot of wageagainst agefor the Wagedata set, which contains income and demographic information for males who reside in the central Atlantic region of the United States. We see the results of fitting a degree-4 polynomial using least squares (solid blue curve). Even though this is a linear regression model like any other, the individual coefficients are not of particular interest. Instead, we look at the entire fitted function across a grid of 63 values for agefrom 18 to 80 in order to understand the relationship between ageandwage. 7.1 Polynomial Regression 291 20 30 40 50 60 70 8050 100 150 200 250 300AgeWageDegree−4 Polynomial 20 30 40 50 60 70 800.00 0.05 0.10 0.15 0.20Age|||| | |||||||| |||||||| ||||| |||||||| ||||| | | |||||| |||||| || |||||||||| | | |||||| | | || ||||||||||||||||||||| |||||||| |||| |||| | | | || || | |||||| |||||||||||||| |||||||| ||||||||| |||||||| | | ||||||||||| |||| ||||||||||||||||||||||| |||| | ||||||||||||||||||||||||| || ||||| | ||| | ||| |||||||||||| | | | | | |||| | ||||||||||||| ||| ||||||||||||| |||||||| | | | | ||| |||||||||||||||||||||||||||| || ||||||||||| ||||||| |||| |||| |||||||||||||||||||||| |||| ||||| | |||||||||| | ||||||||||||| |||||||| | | ||| ||||||||| | | || |||||||||||| | | ||||||||||||||||| ||| |||||||||| |||| |||| | | |||||| ||||| || | | | |||||||||| || ||||||||||||||||||| ||||| || || |||| | | ||||||||| |||| ||||||||||||||||||| ||||||||||| ||||||| | |||||| |||||||||||||| ||||||||| | ||||| || |||||| |||||| | | |||||||| | | | | |||||||||| ||||||| || | | | ||||||||||||| |||||| | | || ||||||||||| | |||||||||||||||||| || ||| | ||||||| ||||||||||||||||||| || |||||||||||||||||||||||||||| | | |||||| ||||||||||||||||||||| | |||||||||| |||||||| ||| |||||||| |||| |||||||||| | | | | || |||||", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 337, "start_word": 107840, "end_word": 108240, "chunk_words": 400}}, "ISLP_website::c000338": {"text": "||| |||||||||| |||| |||| | | |||||| ||||| || | | | |||||||||| || ||||||||||||||||||| ||||| || || |||| | | ||||||||| |||| ||||||||||||||||||| ||||||||||| ||||||| | |||||| |||||||||||||| ||||||||| | ||||| || |||||| |||||| | | |||||||| | | | | |||||||||| ||||||| || | | | ||||||||||||| |||||| | | || ||||||||||| | |||||||||||||||||| || ||| | ||||||| ||||||||||||||||||| || |||||||||||||||||||||||||||| | | |||||| ||||||||||||||||||||| | |||||||||| |||||||| ||| |||||||| |||| |||||||||| | | | | || ||||| | |||| ||||| || | |||||||| | |||||||| ||| ||||| ||||| | ||||| |||| ||| ||| | ||||| |||| |||||||||||||||| |||||||||||||||| |||||||| |||||||||||| | ||||||||||||||||||||| ||| | | |||| |||||| |||||||||| |||||||||| || |||||||||||||||| |||| |||| || ||||||||||||||| |||||| ||||||| | | ||||||| || ||||| |||| | |||||| |||||||||||||||| |||||||||| |||| | ||||| ||||||| | |||||||||||||||||| ||| | |||||| |||| | ||||||||||||||| |||||||||||| ||||||||||| ||||| ||| | || |||||||||||||||| |||||||||||||||| |||||||| | | |||| | | |||||||||| |||||| | ||||||| |||||| || | | | | | | | | | ||||||| |||||||| ||||||| ||||| |||||||||||||||||||| ||||||||||||| |||| |||||||||||||||||||||| ||||||||||||||| |||| | | |||||||||||| | | | | | |||| ||||||||| | ||| ||||||| ||||||| ||| |||||||| | |||||||||||||||||| | | | |||| |||||||||| |||||||||| |||||||||||||||||||||||||| | |||||||||||||| |||||||||| | |||||||||||||| ||| |||| ||||||||||||||||||| ||||||||||||||||||||||||||||||||||||| |||||||||||| ||||||| ||||||||||| |||| | |||| |||||||||||||| | | | ||||||||||||||||||||||| ||||||||| | ||||||||| |||| ||| ||||| || ||| | ||||||||||||| | |||||||||||||||| | |||||||||||| ||| | | | | |||||| ||||||||||||||||||||| |||||||| ||||| | |||||||||||||||||||| ||||| ||||||||||||||||||| | ||||||||| ||||||||||||| ||| ||| | | | ||||| ||| | |||| ||||||| || ||| ||| | ||||||||||||||||||||||||||||| ||| | | |||||||||||||||||||||| |||||||||| | || |||||| || |||| ||| | ||||||||||||| | |||||||||||||| ||||||||||||||||||||||| |||||||| |||||||||| | | | |||||||||||| ||||||||||||||||||| | ||||||||||||||||||| | ||||| | | ||||| | | |||||| |||||||| || |||||||| |||| || | ||||||||| ||||| ||||||| |||| |||| |||| | |||||||| |||||||||||||||||||| |||| | |||||| ||||||| || ||| ||||||| || | | ||||||| |||| |||||| ||||||| | |||||||||||| | |||||||| | ||||||||||||||||||| |||||||||||||||| | | || |||||| ||||||||| | | |||| ||||||| |||| | | | | | | | |||||| | |||||| ||| | | |||| |||||||| ||||||||||||| | | | | | |||||||||||||||||||||| | ||| | ||||| |||||| |||||| | ||| |||||| |||||| | | | ||||||| | |||||||| |||| |||| | | | | ||||||||||||||| |||||||||||||||| ||||| |||| ||| ||", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 338, "start_word": 108160, "end_word": 108560, "chunk_words": 400}}, "ISLP_website::c000339": {"text": "| |||||| ||||||| || ||| ||||||| || | | ||||||| |||| |||||| ||||||| | |||||||||||| | |||||||| | ||||||||||||||||||| |||||||||||||||| | | || |||||| ||||||||| | | |||| ||||||| |||| | | | | | | | |||||| | |||||| ||| | | |||| |||||||| ||||||||||||| | | | | | |||||||||||||||||||||| | ||| | ||||| |||||| |||||| | ||| |||||| |||||| | | | ||||||| | |||||||| |||| |||| | | | | ||||||||||||||| |||||||||||||||| ||||| |||| ||| || || | ||||| | || ||||||| ||||||||||||||| | | | | ||| ||||| ||||||||| | ||||||||||||||| ||||| |||||||||||| || |||||||||| ||| |||||||| |||||||| | | |||||||||||||||||||| |||||| ||||| | ||| |||||||| | | ||||||||||| | ||||||||| |||||||| ||||| || ||||||| |||||||||||||| ||| | ||||| ||| |||||||||| ||| ||||| |||||||||||||||||||||||||||| |||| |||||||||||||| | |||| ||Pr(Wage>250|Age) FIGURE 7.1. TheWagedata.Left:The solid blue curve is a degree-4 polynomial ofwage(in thousands of dollars) as a function of age, fit by least squares. The dashed curves indicate an estimated 95% confidence interval. Right:We model the binary event wage>250 using logistic regression, again with a degree-4 polynomial. The fitted posterior probability of wageexceeding $250,000is shown in blue, along with an estimated 95% confidence interval. In Figure 7.1, a pair of dashed curves accompanies the fit; these are ( 2×) standard error curves. Let’s see how these arise. Suppose we have computed the fit at a particular value of age,x0: ˆf(x0)=ˆβ0+ˆβ1x0+ˆβ2x2 0+ˆβ3x3 0+ˆβ4x4 0. (7.2) Whatisthevarianceofthefit,i.e.Var ˆf(x0)?Leastsquaresreturnsvariance estimates for each of the fitted coefficients ˆβj, as well as the covariances between pairs of coefficient estimates. We can use these to compute the estimated variance of ˆf(x0).1The estimated pointwise standard error of ˆf(x0)is the square-root of this variance. This computation is repeated at each reference point x0, and we plot the fitted curve, as well as twice the standard error on either side of the fitted curve. We plot twice the standard error because, for normally distributed error terms, this quantity corresponds to an approximate 95% confidence interval. It seems like the wages in Figure 7.1are from two distinct populations: there appears to be a high earners group earning more than $250 ,000per annum, as well as a low earners group. We can treat wageas a binary variable by splitting it into these two groups. Logistic regression can then be used to predict this binary response, using polynomial functions of age 1IfˆCis the5×5covariance matrix of the ˆβj, and if", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 339, "start_word": 108480, "end_word": 108880, "chunk_words": 400}}, "ISLP_website::c000340": {"text": "this quantity corresponds to an approximate 95% confidence interval. It seems like the wages in Figure 7.1are from two distinct populations: there appears to be a high earners group earning more than $250 ,000per annum, as well as a low earners group. We can treat wageas a binary variable by splitting it into these two groups. Logistic regression can then be used to predict this binary response, using polynomial functions of age 1IfˆCis the5×5covariance matrix of the ˆβj, and if /lscriptT 0= (1 ,x0,x2 0,x3 0,x4 0), then Var[ˆf(x0)] = /lscriptT 0ˆC/lscript0. 292 7. Moving Beyond Linearity as predictors. In other words, we fit the model Pr(yi>250|xi)=exp(β0+β1xi+β2x2 i+···+βdxd i) 1 + exp( β0+β1xi+β2x2 i+···+βdxd i). (7.3) The result is shown in the right-hand panel of Figure 7.1. The gray marks on the top and bottom of the panel indicate the ages of the high earners and the low earners. The solid blue curve indicates the fitted probabilities of being a high earner, as a function of age. The estimated 95% confidence interval is shown as well. We see that here the confidence intervals are fairly wide, especially on the right-hand side. Although the sample size for this data set is substantial ( n=3,000), there are only 79high earners, which results in a high variance in the estimated coefficients and consequently wide confidence intervals. 7.2 Step Functions Using polynomial functions of the features as predictors in a linear model imposes a globalstructure on the non-linear function of X. We can instead usestep functions in order to avoid imposing such a global structure. Herestep function we break the range of Xintobins, and fit a different constant in each bin. Thisamountstoconvertingacontinuousvariableintoan orderedcategorical variable.ordered categorical variableIn greater detail, we create cutpoints c1,c2,...,c Kin the range of X, and then construct K+1new variables C0(X)= I(X<c 1), C1(X)= I(c1≤X<c 2), C2(X)= I(c2≤X<c 3), ... CK−1(X)= I(cK−1≤X<c K), CK(X)= I(cK≤X),(7.4) whereI(·)is anindicator function that returns a 1if the condition is true,indicator functionand returns a 0otherwise. For example, I(cK≤X)equals1ifcK≤X, and equals0otherwise. These are sometimes called dummyvariables. Notice that for any value of X,C0(X)+C1(X)+···+CK(X)=1 , sinceXmust be in exactly one of the K+1intervals. We then use least squares to fit a linear model using C1(X),C2(X),...,C K(X)as predictors2: yi=β0+β1C1(xi)+β2C2(xi)+···+βKCK(xi)+/epsilon1i. (7.5) For a given value of X, at most one of C1,C2,...,C Kcan be non-zero. Note that when X<c 1, all of the predictors in ( 7.5) are zero, so β0can", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 340, "start_word": 108800, "end_word": 109200, "chunk_words": 400}}, "ISLP_website::c000341": {"text": "the condition is true,indicator functionand returns a 0otherwise. For example, I(cK≤X)equals1ifcK≤X, and equals0otherwise. These are sometimes called dummyvariables. Notice that for any value of X,C0(X)+C1(X)+···+CK(X)=1 , sinceXmust be in exactly one of the K+1intervals. We then use least squares to fit a linear model using C1(X),C2(X),...,C K(X)as predictors2: yi=β0+β1C1(xi)+β2C2(xi)+···+βKCK(xi)+/epsilon1i. (7.5) For a given value of X, at most one of C1,C2,...,C Kcan be non-zero. Note that when X<c 1, all of the predictors in ( 7.5) are zero, so β0can 2We exclude C0(X)as a predictor in ( 7.5) because it is redundant with the intercept. This is similar to the fact that we need only two dummy variables to code a qualitative variable with three levels, provided that the model will contain an intercept. The decision to exclude C0(X)instead of some other Ck(X)in (7.5) is arbitrary. Alternatively, we could include C0(X),C1(X),...,C K(X), and exclude the intercept. 7.3 Basis Functions 293 20 30 40 50 60 70 8050 100 150 200 250 300AgeWagePiecewise Constant 20 30 40 50 60 70 800.00 0.05 0.10 0.15 0.20Age|||||||||||||||||||||||||| ||||||||||||||||||||| |||||| |||||||||||||||||||||||| |||||||||||||||||||||||||||||||||||||||||| |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||| |||||||||||||||||||||||||||||| ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||| |||||||||||||||||||||| |||| ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||| ||||||||||||| |||||||||||||||||||||||||||||||||| |||||||||||||| |||||||||||| |||||||||||||||||||| |||||||||||||||||||||||||||| ||||||||||||||||| |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||| ||||||||||||||| ||||||||||||||||||||||||||||||||||||||||||||| |||||||||||||||||||||||||||| |||||||||||||||||||||||||||||| |||||||||||||||||||||||||||||||| |||||||||||||||||||||||||||||||||||||| ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||| ||||||||||||||| ||||||||||||||||||||||||||||||||||||||| |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||| ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||| |||||||||||||||||||||||||||| ||||||||||||||| |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||| |||||||||||||||||||||||||||||||||||||||||| ||||||||||| ||||||||||| |||||||||||||||| |||||||||||||||| |||||||||||||||||||||||||||||||||||||||||||||| |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||| ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||| ||||||||||||||||||||||||||||||||||||||||||||||||||| ||||||||||||||||||||||||||||||||||||||||||||||||||| ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||| ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||| ||||| ||||||||||||||||||||||||||||||||||||||||||||||||| |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||| ||||||||||||||||||||||||||||||||||| ||||||| |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||| |||||| |||||||||||||||||||||||||||||||| |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||| |||||||| |||||||||||||| ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||| |||||||||||||||||| |||||||||||| ||||||||||||||| ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||| |||||| |||||||||||||||||||||||||||||||||||||||||||||| ||||||||| |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||| ||||| |||| ||| || ||||||||||| ||||||| |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||| |||||||||||||||||||||||||||||||||||||| |||||||||||||||||||||||||||||||||||||||||||||| ||||||||||||| |||||||||||||||||||||||||||||||| ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||Pr(Wage>250|Age) FIGURE 7.2. TheWagedata.Left:The solid curve displays the fitted value from a least squares regression of wage(in thousands of dollars) using step functions ofage. The dashed curves indicate an estimated 95% confidence interval. Right: We model the binary event wage>250 using logistic regression, again using step functions of age. The fitted posterior probability of wageexceeding $250,000is shown, along with an estimated 95% confidence interval. be interpreted as the mean value of YforX<c 1. By comparison, ( 7.5) predictsaresponseof β0+βjforcj≤X<c j+1,soβjrepresentstheaverage increase in the response for Xincj≤X<c j+1relative to X<c 1. An example of fitting step functions to the Wagedata from Figure 7.1is shown in the left-hand panel of Figure 7.2. We also fit the logistic regression model Pr(yi>250|xi)=exp(β0+β1C1(xi)+···+βKCK(xi)) 1 + exp( β0+β1C1(xi)+···+βKCK(xi))(7.6) in order to predict the probability that an individual is a high earner on the basis of age. The right-hand panel of Figure 7.2displays the fitted posterior probabilities obtained", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 341, "start_word": 109120, "end_word": 109520, "chunk_words": 400}}, "ISLP_website::c000342": {"text": "YforX<c 1. By comparison, ( 7.5) predictsaresponseof β0+βjforcj≤X<c j+1,soβjrepresentstheaverage increase in the response for Xincj≤X<c j+1relative to X<c 1. An example of fitting step functions to the Wagedata from Figure 7.1is shown in the left-hand panel of Figure 7.2. We also fit the logistic regression model Pr(yi>250|xi)=exp(β0+β1C1(xi)+···+βKCK(xi)) 1 + exp( β0+β1C1(xi)+···+βKCK(xi))(7.6) in order to predict the probability that an individual is a high earner on the basis of age. The right-hand panel of Figure 7.2displays the fitted posterior probabilities obtained using this approach. Unfortunately, unless there are natural breakpoints in the predictors, piecewise-constant functions can miss the action. For example, in the left- hand panel of Figure 7.2, the first bin clearly misses the increasing trend ofwagewithage. Nevertheless, step function approaches are very popular in biostatistics and epidemiology, among other disciplines. For example, 5-year age groups are often used to define the bins. 7.3 Basis Functions Polynomial and piecewise-constant regression models are in fact special cases of a basis function approach. The idea is to have at hand a fam-basis function 294 7. Moving Beyond Linearity ily of functions or transformations that can be applied to a variable X: b1(X),b2(X),...,b K(X). Instead of fitting a linear model in X, we fit the model yi=β0+β1b1(xi)+β2b2(xi)+β3b3(xi)+···+βKbK(xi)+/epsilon1i.(7.7) Note that the basis functions b1(·),b2(·),...,b K(·)are fixed and known. (In other words, we choose the functions ahead of time.) For polynomial regression, the basis functions are bj(xi)=xj i, and for piecewise constant functions they are bj(xi)= I(cj≤xi<c j+1). We can think of ( 7.7) as a standard linear model with predictors b1(xi),b2(xi),...,b K(xi). Hence, we can use least squares to estimate the unknown regression coefficients in (7.7). Importantly, this means that all of the inference tools for linear models that are discussed in Chapter 3, such as standard errors for the coefficient estimates and F-statistics for the model’s overall significance, are available in this setting. Thus far we have considered the use of polynomial functions and piece- wise constant functions for our basis functions; however, many alternatives are possible. For instance, we can use wavelets or Fourier series to construct basis functions. In the next section, we investigate a very common choice for a basis function: regression splines .regression spline 7.4 Regression Splines Now we discuss a flexible class of basis functions that extends upon the polynomial regression and piecewise constant regression approaches that we have just seen. 7.4.1 Piecewise Polynomials Insteadoffittingahigh-degreepolynomialovertheentirerangeof X,piece- wise polynomial", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 342, "start_word": 109440, "end_word": 109840, "chunk_words": 400}}, "ISLP_website::c000343": {"text": "and piece- wise constant functions for our basis functions; however, many alternatives are possible. For instance, we can use wavelets or Fourier series to construct basis functions. In the next section, we investigate a very common choice for a basis function: regression splines .regression spline 7.4 Regression Splines Now we discuss a flexible class of basis functions that extends upon the polynomial regression and piecewise constant regression approaches that we have just seen. 7.4.1 Piecewise Polynomials Insteadoffittingahigh-degreepolynomialovertheentirerangeof X,piece- wise polynomial regression involves fitting separate low-degree polynomialspiecewise polynomial regressionover different regions of X. For example, a piecewise cubic polynomial works by fitting a cubic regression model of the form yi=β0+β1xi+β2x2 i+β3x3 i+/epsilon1i, (7.8) where the coefficients β0,β1,β2, andβ3differ in different parts of the range ofX. The points where the coefficients change are called knots.knotFor example, a piecewise cubic with no knots is just a standard cubic polynomial, as in ( 7.1) withd=3. A piecewise cubic polynomial with a single knot at a point ctakes the form yi=/braceleftBigg β01+β11xi+β21x2 i+β31x3 i+/epsilon1iifxi<c β02+β12xi+β22x2 i+β32x3 i+/epsilon1iifxi≥c. In other words, we fit two different polynomial functions to the data, one on the subset of the observations with xi<c, and one on the subset of the observations with xi≥c. The first polynomial function has coefficients 7.4 Regression Splines 295 20 30 40 50 60 7050 100 150 200 250AgeWagePiecewise Cubic 20 30 40 50 60 7050 100 150 200 250AgeWageContinuous Piecewise Cubic 20 30 40 50 60 7050 100 150 200 250AgeWageCubic Spline 20 30 40 50 60 7050 100 150 200 250AgeWageLinear Spline FIGURE 7.3. Various piecewise polynomials are fit to a subset of the Wage data, with a knot at age=50.Top Left: The cubic polynomials are unconstrained. Top Right: The cubic polynomials are constrained to be continuous at age=50. Bottom Left: The cubic polynomials are constrained to be continuous, and to have continuous first and second derivatives. Bottom Right: A linear spline is shown, which is constrained to be continuous. β01,β11,β21,andβ31, and the second has coefficients β02,β12,β22,andβ32. Each of these polynomial functions can be fit using least squares applied to simple functions of the original predictor. Using more knots leads to a more flexible piecewise polynomial. In gen- eral, if we place Kdifferent knots throughout the range of X, then we will end up fitting K+1different cubic polynomials. Note that we do not need to use a cubic polynomial. For example, we can instead", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 343, "start_word": 109760, "end_word": 110160, "chunk_words": 400}}, "ISLP_website::c000344": {"text": "which is constrained to be continuous. β01,β11,β21,andβ31, and the second has coefficients β02,β12,β22,andβ32. Each of these polynomial functions can be fit using least squares applied to simple functions of the original predictor. Using more knots leads to a more flexible piecewise polynomial. In gen- eral, if we place Kdifferent knots throughout the range of X, then we will end up fitting K+1different cubic polynomials. Note that we do not need to use a cubic polynomial. For example, we can instead fit piecewise linear functions. In fact, our piecewise constant functions of Section 7.2are piecewise polynomials of degree 0! The top left panel of Figure 7.3shows a piecewise cubic polynomial fit to a subset of the Wagedata, with a single knot at age=50. We immediately see a problem: the function is discontinuous and looks ridiculous! Since each polynomial has four parameters, we are using a total of eight degrees of freedomin fitting this piecewise polynomial model.degrees of freedom 296 7. Moving Beyond Linearity 7.4.2 Constraints and Splines The top left panel of Figure 7.3looks wrong because the fitted curve is just too flexible. To remedy this problem, we can fit a piecewise polynomial under the constraint that the fitted curve must be continuous. In other words,therecannotbeajumpwhen age=50.ThetoprightplotinFigure 7.3 shows the resulting fit. This looks better than the top left plot, but the V- shaped join looks unnatural. Inthelowerleftplot,wehaveaddedtwoadditionalconstraints:nowboth the first and second derivatives of the piecewise polynomials are continuousderivativeatage=50. In other words, we are requiring that the piecewise polynomial be not only continuous when age=50, but also very smooth. Each constraint that we impose on the piecewise cubic polynomials effectively frees up one degree of freedom, by reducing the complexity of the resulting piecewise polynomial fit. So in the top left plot, we are using eight degrees of free- dom, but in the bottom left plot we imposed three constraints (continuity, continuity of the first derivative, and continuity of the second derivative) and so are left with five degrees of freedom. The curve in the bottom left plot is called a cubic spline .3In general, a cubic spline with Kknots usescubic splinea total of 4+Kdegrees of freedom. In Figure 7.3, the lower right plot is a linear spline , which is continuouslinear splineatage=50. The general definition of a degree- dspline is that it is a piecewise degree-dpolynomial, with continuity in derivatives up to degree d−1at each knot. Therefore, a linear spline", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 344, "start_word": 110080, "end_word": 110480, "chunk_words": 400}}, "ISLP_website::c000345": {"text": "derivative) and so are left with five degrees of freedom. The curve in the bottom left plot is called a cubic spline .3In general, a cubic spline with Kknots usescubic splinea total of 4+Kdegrees of freedom. In Figure 7.3, the lower right plot is a linear spline , which is continuouslinear splineatage=50. The general definition of a degree- dspline is that it is a piecewise degree-dpolynomial, with continuity in derivatives up to degree d−1at each knot. Therefore, a linear spline is obtained by fitting a line in each region of the predictor space defined by the knots, requiring continuity at each knot. In Figure 7.3, there is a single knot at age=50. Of course, we could add more knots, and impose continuity at each. 7.4.3 The Spline Basis Representation The regression splines that we just saw in the previous section may have seemed somewhat complex: how can we fit a piecewise degree- dpolynomial under the constraint that it (and possibly its first d−1derivatives) be continuous? It turns out that we can use the basis model ( 7.7) to represent a regression spline. A cubic spline with Kknots can be modeled as yi=β0+β1b1(xi)+β2b2(xi)+···+βK+3bK+3(xi)+/epsilon1i, (7.9) for an appropriate choice of basis functions b1,b2,...,b K+3. The model (7.9) can then be fit using least squares. Just as there were several ways to represent polynomials, there are also many equivalent ways to represent cubic splines using different choices of basis functions in ( 7.9). The most direct way to represent a cubic spline using (7.9) is to start off with a basis for a cubic polynomial—namely, x, x2,andx3—and then add one truncated power basis function per knot.truncated power basis 3Cubic splines are popular because most human eyes cannot detect the discontinuity at the knots. 7.4 Regression Splines 297 20 30 40 50 60 7050 100 150 200 250AgeWageNatural Cubic SplineCubic Spline FIGURE 7.4. A cubic spline and a natural cubic spline, with three knots, fit to a subset of the Wagedata. The dashed lines denote the knot locations. A truncated power basis function is defined as h(x,ξ)=( x−ξ)3 +=/braceleftbigg (x−ξ)3ifx>ξ 0otherwise ,(7.10) whereξis the knot. One can show that adding a term of the form β4h(x,ξ) to the model ( 7.8) for a cubic polynomial will lead to a discontinuity in only the third derivative at ξ; the function will remain continuous, with continuous first and second derivatives, at each of the knots. Inotherwords,inordertofitacubicsplinetoadatasetwith", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 345, "start_word": 110400, "end_word": 110800, "chunk_words": 400}}, "ISLP_website::c000346": {"text": "fit to a subset of the Wagedata. The dashed lines denote the knot locations. A truncated power basis function is defined as h(x,ξ)=( x−ξ)3 +=/braceleftbigg (x−ξ)3ifx>ξ 0otherwise ,(7.10) whereξis the knot. One can show that adding a term of the form β4h(x,ξ) to the model ( 7.8) for a cubic polynomial will lead to a discontinuity in only the third derivative at ξ; the function will remain continuous, with continuous first and second derivatives, at each of the knots. Inotherwords,inordertofitacubicsplinetoadatasetwith Kknots,we perform least squares regression with an intercept and 3+Kpredictors, of the form X,X2,X3,h(X,ξ1),h(X,ξ2),...,h (X,ξK), whereξ1,...,ξKare the knots. This amounts to estimating a total of K+4regression coeffi- cients; for this reason, fitting a cubic spline with Kknots uses K+4degrees of freedom. Unfortunately, splines can have high variance at the outer range of the predictors—that is, when Xtakes on either a very small or very large value. Figure 7.4shows a fit to the Wagedata with three knots. We see that the confidence bands in the boundary region appear fairly wild. A natu- ral spline is a regression spline with additional boundary constraints : thenatural splinefunction is required to be linear at the boundary (in the region where Xis smaller than the smallest knot, or larger than the largest knot). This addi- tional constraint means that natural splines generally produce more stable estimates at the boundaries. In Figure 7.4, a natural cubic spline is also displayed as a red line. Note that the corresponding confidence intervals are narrower. 7.4.4 Choosing the Number and Locations of the Knots When we fit a spline, where should we place the knots? The regression spline is most flexible in regions that contain a lot of knots, because in those regions the polynomial coefficients can change rapidly. Hence, one 298 7. Moving Beyond Linearity 20 30 40 50 60 70 8050 100 150 200 250 300AgeWageNatural Cubic Spline 20 30 40 50 60 70 800.00 0.05 0.10 0.15 0.20Age|||| | |||||||| |||||||| ||||| |||||||| ||||| | | |||||| |||||| || |||||||||| | | |||||| | | || ||||||||||||||||||||| |||||||| |||| |||| | | | || || | |||||| |||||||||||||| |||||||| ||||||||| |||||||| | | ||||||||||| |||| ||||||||||||||||||||||| |||| | ||||||||||||||||||||||||| || ||||| | ||| | ||| |||||||||||| | | | | | |||| | ||||||||||||| ||| ||||||||||||| |||||||| | | | | ||| |||||||||||||||||||||||||||| || ||||||||||| ||||||| |||| |||| |||||||||||||||||||||| |||| ||||| | |||||||||| | ||||||||||||| ||||||||", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 346, "start_word": 110720, "end_word": 111120, "chunk_words": 400}}, "ISLP_website::c000347": {"text": "0.15 0.20Age|||| | |||||||| |||||||| ||||| |||||||| ||||| | | |||||| |||||| || |||||||||| | | |||||| | | || ||||||||||||||||||||| |||||||| |||| |||| | | | || || | |||||| |||||||||||||| |||||||| ||||||||| |||||||| | | ||||||||||| |||| ||||||||||||||||||||||| |||| | ||||||||||||||||||||||||| || ||||| | ||| | ||| |||||||||||| | | | | | |||| | ||||||||||||| ||| ||||||||||||| |||||||| | | | | ||| |||||||||||||||||||||||||||| || ||||||||||| ||||||| |||| |||| |||||||||||||||||||||| |||| ||||| | |||||||||| | ||||||||||||| |||||||| | | ||| ||||||||| | | || |||||||||||| | | ||||||||||||||||| ||| |||||||||| |||| |||| | | |||||| ||||| || | | | |||||||||| || ||||||||||||||||||| ||||| || || |||| | | ||||||||| |||| ||||||||||||||||||| ||||||||||| ||||||| | |||||| |||||||||||||| ||||||||| | ||||| || |||||| |||||| | | |||||||| | | | | |||||||||| ||||||| || | | | ||||||||||||| |||||| | | || ||||||||||| | |||||||||||||||||| || ||| | ||||||| ||||||||||||||||||| || |||||||||||||||||||||||||||| | | |||||| ||||||||||||||||||||| | |||||||||| |||||||| ||| |||||||| |||| |||||||||| | | | | || ||||| | |||| ||||| || | |||||||| | |||||||| ||| ||||| ||||| | ||||| |||| ||| ||| | ||||| |||| |||||||||||||||| |||||||||||||||| |||||||| |||||||||||| | ||||||||||||||||||||| ||| | | |||| |||||| |||||||||| |||||||||| || |||||||||||||||| |||| |||| || ||||||||||||||| |||||| ||||||| | | ||||||| || ||||| |||| | |||||| |||||||||||||||| |||||||||| |||| | ||||| ||||||| | |||||||||||||||||| ||| | |||||| |||| | ||||||||||||||| |||||||||||| ||||||||||| ||||| ||| | || |||||||||||||||| |||||||||||||||| |||||||| | | |||| | | |||||||||| |||||| | ||||||| |||||| || | | | | | | | | | ||||||| |||||||| ||||||| ||||| |||||||||||||||||||| ||||||||||||| |||| |||||||||||||||||||||| ||||||||||||||| |||| | | |||||||||||| | | | | | |||| ||||||||| | ||| ||||||| ||||||| ||| |||||||| | |||||||||||||||||| | | | |||| |||||||||| |||||||||| |||||||||||||||||||||||||| | ||||||||||| ||| |||||||||| | |||||||||||||| ||| |||| ||||||||||||||||||| ||||||||||||||||||||||||||||||||||||| |||||||||||| ||||||| ||||||||||| |||| | |||| |||||||||||||| | | | ||||||||||||||||||||||| ||||||||| | ||||||||| |||| ||| ||||| || ||| | ||||||||||||| | ||||||||| ||||||| | |||||||||||| ||| | | | | |||||| ||||||||||||||||||||| |||||||| ||||| | |||||||||||||||||||| | |||| ||||||||||||||||||| | ||||||||| ||||||||||||| ||| ||| | | | ||||| ||| | |||| ||||||| || ||| ||| | |||||||||||||||||||||| ||||||| ||| | | |||||||||||||||||||||| |||||||||| | || |||||| || |||| ||| | ||||||||||||| | |||||||||||||| ||||||||||||||||||||||| |||||||| |||||||||| | | | |||||||||||| ||||||||||||||||||| | ||||||||||||||||||| | ||||| | | ||||| | | |||||| ||||||||", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 347, "start_word": 111040, "end_word": 111440, "chunk_words": 400}}, "ISLP_website::c000348": {"text": "||||||||| |||| ||| ||||| || ||| | ||||||||||||| | ||||||||| ||||||| | |||||||||||| ||| | | | | |||||| ||||||||||||||||||||| |||||||| ||||| | |||||||||||||||||||| | |||| ||||||||||||||||||| | ||||||||| ||||||||||||| ||| ||| | | | ||||| ||| | |||| ||||||| || ||| ||| | |||||||||||||||||||||| ||||||| ||| | | |||||||||||||||||||||| |||||||||| | || |||||| || |||| ||| | ||||||||||||| | |||||||||||||| ||||||||||||||||||||||| |||||||| |||||||||| | | | |||||||||||| ||||||||||||||||||| | ||||||||||||||||||| | ||||| | | ||||| | | |||||| |||||||| || |||||||| |||| || | ||||||||| ||||| ||||||| |||| |||| |||| | |||||||| |||||||||||||||||||| |||| | |||||| ||||||| || ||| ||||||| || | | ||||||| |||| |||||| ||||||| | |||||||||||| | |||||||| | ||||||||||||||||||| |||||||||||||||| | | || |||||| ||||||||| | | |||| ||||||| |||| | | | | | | | |||||| | |||||| ||| | | |||| |||||||| ||||||||||||| | | | | | |||||||||||||||||||||| | ||| | ||||| |||||| |||||| | ||| |||||| |||||| | | | ||||||| | |||||||| |||| |||| | | | | ||||||||||||||| |||||||||||||||| ||||| |||| ||| || || | ||||| | || ||||||| ||||||||||||||| | | | | ||| ||||| ||||||||| | ||||||||||||||| ||||| |||||||||||| || |||||||||| ||| |||||||| |||||||| | | |||||||||||||||||||| |||||| ||||| | ||| |||||||| | | ||||||||||| | ||||||||| |||||||| ||||| || ||||||| |||||||||||||| ||| | ||||| ||| |||||||||| ||| ||||| |||||||||||||||||||||||||||| |||| |||||||||||||| | |||| ||Pr(Wage>250|Age) FIGURE 7.5. A natural cubic spline function with four degrees of freedom is fit to the Wagedata.Left:A spline is fit to wage(in thousands of dollars) as a function of age.Right:Logistic regression is used to model the binary event wage>250 as a function of age. The fitted posterior probability of wageexceeding $250,000is shown. The dashed lines denote the knot locations. option is to place more knots in places where we feel the function might vary most rapidly, and to place fewer knots where it seems more stable. While this option can work well, in practice it is common to place knots in a uniform fashion. One way to do this is to specify the desired degrees of freedom, and then have the software automatically place the corresponding number of knots at uniform quantiles of the data. Figure7.5shows an example on the Wagedata. As in Figure 7.4,w e have fit a natural cubic spline with three knots, except this time the knot locations were chosen automatically as the 25th, 50th, and 75th percentiles", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 348, "start_word": 111360, "end_word": 111760, "chunk_words": 400}}, "ISLP_website::c000349": {"text": "well, in practice it is common to place knots in a uniform fashion. One way to do this is to specify the desired degrees of freedom, and then have the software automatically place the corresponding number of knots at uniform quantiles of the data. Figure7.5shows an example on the Wagedata. As in Figure 7.4,w e have fit a natural cubic spline with three knots, except this time the knot locations were chosen automatically as the 25th, 50th, and 75th percentiles ofage. This was specified by requesting four degrees of freedom. The ar- gument by which four degrees of freedom leads to three interior knots is somewhat technical.4 How many knots should we use, or equivalently how many degrees of freedom should our spline contain? One option is to try out different num- bers of knots and see which produces the best looking curve. A somewhat more objective approach is to use cross-validation, as discussed in Chap- ters5and6. With this method, we remove a portion of the data (say 10%), fit a spline with a certain number of knots to the remaining data, and then use the spline to make predictions for the held-out portion. We repeat this process multiple times until each observation has been left out once, and 4There are actually five knots, including the two boundary knots. A cubic spline with five knots has nine degrees of freedom. But natural cubic splines have two additional naturalconstraints at each boundary to enforce linearity, resulting in 9−4=5 degrees of freedom. Since this includes a constant, which is absorbed in the intercept, we count it as four degrees of freedom. 7.4 Regression Splines 299 2 4 6 8 101600 1620 1640 1660 1680Degrees of Freedom of Natural SplineMean Squared Error2 4 6 8 101600 1620 1640 1660 1680Degrees of Freedom of Cubic SplineMean Squared ErrorFIGURE 7.6. Ten-fold cross-validated mean squared errors for selecting the degrees of freedom when fitting splines to the Wagedata. The response is wage and the predictor age.Left:A natural cubic spline. Right:A cubic spline. then compute the overall cross-validated RSS. This procedure can be re- peated for different numbers of knots K. Then the value of Kgiving the smallest RSS is chosen. Figure7.6shows ten-fold cross-validated mean squared errors for splines with various degrees of freedom fit to the Wagedata. The left-hand panel corresponds to a natural cubic spline and the right-hand panel to a cu- bic spline. The", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 349, "start_word": 111680, "end_word": 112080, "chunk_words": 400}}, "ISLP_website::c000350": {"text": "the Wagedata. The response is wage and the predictor age.Left:A natural cubic spline. Right:A cubic spline. then compute the overall cross-validated RSS. This procedure can be re- peated for different numbers of knots K. Then the value of Kgiving the smallest RSS is chosen. Figure7.6shows ten-fold cross-validated mean squared errors for splines with various degrees of freedom fit to the Wagedata. The left-hand panel corresponds to a natural cubic spline and the right-hand panel to a cu- bic spline. The two methods produce almost identical results, with clear evidence that a one-degree fit (a linear regression) is not adequate. Both curves flatten out quickly, and it seems that three degrees of freedom for the natural spline and four degrees of freedom for the cubic spline are quite adequate. In Section 7.7we fit additive spline models simultaneously on several variables at a time. This could potentially require the selection of degrees of freedom for each variable. In cases like this we typically adopt a more pragmatic approach and set the degrees of freedom to a fixed number, say four, for all terms. 7.4.5 Comparison to Polynomial Regression Figure7.7compares a natural cubic spline with 15degrees of freedom to a degree-15polynomial on the Wagedata set. The extra flexibility in the poly- nomial produces undesirable results at the boundaries, while the natural cubic spline still provides a reasonable fit to the data. Regression splines often give superior results to polynomial regression. This is because unlike polynomials, which must use a high degree (exponent in the highest mono- mial term, e.g. X15) to produce flexible fits, splines introduce flexibility by increasing the number of knots but keeping the degree fixed. Generally, this approach produces more stable estimates. Splines also allow us to place more knots, and hence flexibility, over regions where the function fseems to be changing rapidly, and fewer knots where fappears more stable. 300 7. Moving Beyond Linearity 20 30 40 50 60 70 8050 100 150 200 250 300AgeWageNatural Cubic SplinePolynomial FIGURE 7.7. On theWagedata set, a natural cubic spline with 15 degrees of freedom is compared to a degree- 15polynomial. Polynomials can show wild behavior, especially near the tails. 7.5 Smoothing Splines In the last section we discussed regression splines, which we create by spec- ifying a set of knots, producing a sequence of basis functions, and then using least squares to estimate the spline coefficients. We now introduce a somewhat", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 350, "start_word": 112000, "end_word": 112400, "chunk_words": 400}}, "ISLP_website::c000351": {"text": "70 8050 100 150 200 250 300AgeWageNatural Cubic SplinePolynomial FIGURE 7.7. On theWagedata set, a natural cubic spline with 15 degrees of freedom is compared to a degree- 15polynomial. Polynomials can show wild behavior, especially near the tails. 7.5 Smoothing Splines In the last section we discussed regression splines, which we create by spec- ifying a set of knots, producing a sequence of basis functions, and then using least squares to estimate the spline coefficients. We now introduce a somewhat different approach that also produces a spline. 7.5.1 An Overview of Smoothing Splines In fitting a smooth curve to a set of data, what we really want to do is find some function, say g(x), that fits the observed data well: that is, we wantRSS =/summationtextn i=1(yi−g(xi))2to be small. However, there is a problem with this approach. If we don’t put any constraints on g(xi), then we can always make RSS zero simply by choosing gsuch that it interpolates all of theyi. Such a function would woefully overfit the data—it would be far too flexible. What we really want is a function gthat makes RSS small, but that is also smooth. How might we ensure that gis smooth? There are a number of ways to do this. A natural approach is to find the function gthat minimizes n/summationdisplay i=1(yi−g(xi))2+λ/integraldisplay g/prime/prime(t)2dt (7.11) whereλis a nonnegative tuning parameter . The function gthat minimizes (7.11) is known as a smoothing spline .smoothing splineWhat does ( 7.11) mean? Equation 7.11takes the “Loss+Penalty” for- mulation that we encounter in the context of ridge regression and the lasso in Chapter 6. The term/summationtextn i=1(yi−g(xi))2is aloss function that encour-loss functionagesgto fit the data well, and the term λ/integraltext g/prime/prime(t)2dtis apenalty term that penalizes the variability in g. The notation g/prime/prime(t)indicates the second derivative of the function g. The first derivative g/prime(t)measures the slope 7.5 Smoothing Splines 301 of a function at t, and the second derivative corresponds to the amount by which the slope is changing. Hence, broadly speaking, the second derivative of a function is a measure of its roughness : it is large in absolute value if g(t)is very wiggly near t, and it is close to zero otherwise. (The second derivative of a straight line is zero; note that a line is perfectly smooth.) The/integraltext notation is an integral, which we can think of as a summation over the range of t. In other", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 351, "start_word": 112320, "end_word": 112720, "chunk_words": 400}}, "ISLP_website::c000352": {"text": "to the amount by which the slope is changing. Hence, broadly speaking, the second derivative of a function is a measure of its roughness : it is large in absolute value if g(t)is very wiggly near t, and it is close to zero otherwise. (The second derivative of a straight line is zero; note that a line is perfectly smooth.) The/integraltext notation is an integral, which we can think of as a summation over the range of t. In other words,/integraltext g/prime/prime(t)2dtis simply a measure of the total change in the function g/prime(t), over its entire range. If gis very smooth, then g/prime(t)will be close to constant and/integraltext g/prime/prime(t)2dtwill take on a small value. Conversely, if gis jumpy and variable then g/prime(t)will vary significantly and/integraltext g/prime/prime(t)2dtwill take on a large value. Therefore, in ( 7.11),λ/integraltext g/prime/prime(t)2dten- courages gto be smooth. The larger the value of λ, the smoother gwill be. Whenλ=0, then the penalty term in ( 7.11) has no effect, and so the function gwill be very jumpy and will exactly interpolate the training observations. When λ→∞,gwill be perfectly smooth—it will just be a straight line that passes as closely as possible to the training points. In fact, in this case, gwill be the linear least squares line, since the loss function in ( 7.11) amounts to minimizing the residual sum of squares. For an intermediate value of λ,gwill approximate the training observations but will be somewhat smooth. We see that λcontrols the bias-variance trade-off of the smoothing spline. The function g(x)that minimizes ( 7.11) can be shown to have some spe- cial properties: it is a piecewise cubic polynomial with knots at the unique values of x1,...,x n, and continuous first and second derivatives at each knot. Furthermore, it is linear in the region outside of the extreme knots. In other words, the function g(x)that minimizes ( 7.11) is a natural cubic spline with knots at x1,...,x n!However, it is not the same natural cubic spline that one would get if one applied the basis function approach de- scribed in Section 7.4.3with knots at x1,...,x n—rather, it is a shrunken version of such a natural cubic spline, where the value of the tuning pa- rameterλin (7.11) controls the level of shrinkage. 7.5.2 Choosing the Smoothing Parameter λ We have seen that a smoothing spline is simply a natural cubic spline with knots at every unique value of xi.", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 352, "start_word": 112640, "end_word": 113040, "chunk_words": 400}}, "ISLP_website::c000353": {"text": "it is not the same natural cubic spline that one would get if one applied the basis function approach de- scribed in Section 7.4.3with knots at x1,...,x n—rather, it is a shrunken version of such a natural cubic spline, where the value of the tuning pa- rameterλin (7.11) controls the level of shrinkage. 7.5.2 Choosing the Smoothing Parameter λ We have seen that a smoothing spline is simply a natural cubic spline with knots at every unique value of xi. It might seem that a smoothing spline will have far too many degrees of freedom, since a knot at each data point allows a great deal of flexibility. But the tuning parameter λcontrols the roughness of the smoothing spline, and hence the effective degrees of freedom. It is possible to show that as λincreases from 0to∞, the effectiveeffective degrees of freedomdegrees of freedom, which we write dfλ, decrease from nto2. In the context of smoothing splines, why do we discuss effective degrees of freedom instead of degrees of freedom? Usually degrees of freedom refer to the number of free parameters, such as the number of coefficients fit in a polynomial or cubic spline. Although a smoothing spline has nparameters and hence nnominal degrees of freedom, these nparameters are heavily constrained or shrunk down. Hence dfλis a measure of the flexibility of the smoothing spline—the higher it is, the more flexible (and the lower-bias but higher-variance) the smoothing spline. The definition of effective degrees of 302 7. Moving Beyond Linearity freedom is somewhat technical. We can write ˆgλ=Sλy, (7.12) whereˆgλis the solution to ( 7.11) for a particular choice of λ—that is, it is ann-vector containing the fitted values of the smoothing spline at the training points x1,...,x n. Equation 7.12indicates that the vector of fitted values when applying a smoothing spline to the data can be written as a n×nmatrixSλ(for which there is a formula) times the response vector y. Then the effective degrees of freedom is defined to be dfλ=n/summationdisplay i=1{Sλ}ii, (7.13) the sum of the diagonal elements of the matrix Sλ. In fitting a smoothing spline, we do not need to select the number or location of the knots—there will be a knot at each training observation, x1,...,x n. Instead, we have another problem: we need to choose the value ofλ.Itshouldcomeasnosurprisethatonepossiblesolutiontothisproblem is cross-validation. In other words, we can find the value of λthat makes the cross-validated RSS as", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 353, "start_word": 112960, "end_word": 113360, "chunk_words": 400}}, "ISLP_website::c000354": {"text": "Then the effective degrees of freedom is defined to be dfλ=n/summationdisplay i=1{Sλ}ii, (7.13) the sum of the diagonal elements of the matrix Sλ. In fitting a smoothing spline, we do not need to select the number or location of the knots—there will be a knot at each training observation, x1,...,x n. Instead, we have another problem: we need to choose the value ofλ.Itshouldcomeasnosurprisethatonepossiblesolutiontothisproblem is cross-validation. In other words, we can find the value of λthat makes the cross-validated RSS as small as possible. It turns out that the leave- one-outcross-validation error (LOOCV) can be computed very efficiently for smoothing splines, with essentially the same cost as computing a single fit, using the following formula: RSScv(λ)=n/summationdisplay i=1(yi−ˆg(−i) λ(xi))2=n/summationdisplay i=1/bracketleftbiggyi−ˆgλ(xi) 1−{Sλ}ii/bracketrightbigg2 . The notation ˆg(−i) λ(xi)indicates the fitted value for this smoothing spline evaluated at xi, where the fit uses all of the training observations except for theith observation (xi,yi). In contrast, ˆgλ(xi)indicates the smoothing spline function fit to all of the training observations and evaluated at xi. This remarkable formula says that we can compute each of these leave- one-outfits using only ˆgλ, the original fit to allof the data!5We have a very similar formula ( 5.2) on page 205in Chapter 5for least squares linear regression. Using ( 5.2), we can very quickly perform LOOCV for the regression splines discussed earlier in this chapter, as well as for least squares regression using arbitrary basis functions. Figure7.8shows the results from fitting a smoothing spline to the Wage data. The red curve indicates the fit obtained from pre-specifying that we would like a smoothing spline with 16effective degrees of freedom. The blue curve is the smoothing spline obtained when λis chosen using LOOCV; in this case, the value of λchosen results in 6.8effective degrees of freedom (computed using ( 7.13)). For this data, there is little discernible difference between the two smoothing splines, beyond the fact that the one with 16 degrees of freedom seems slightly wigglier. Since there is little difference between the two fits, the smoothing spline fit with 6.8degrees of freedom 5The exact formulas for computing ˆg(xi)andSλare very technical; however, efficient algorithms are available for computing these quantities. 7.6 Local Regression 303 20 30 40 50 60 70 800 50 100 200 300AgeWageSmoothing Spline16 Degrees of Freedom6.8 Degrees of Freedom (LOOCV) FIGURE 7.8. Smoothing spline fits to the Wagedata. The red curve results from specifying 16effective degrees of freedom. For", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 354, "start_word": 113280, "end_word": 113680, "chunk_words": 400}}, "ISLP_website::c000355": {"text": "freedom seems slightly wigglier. Since there is little difference between the two fits, the smoothing spline fit with 6.8degrees of freedom 5The exact formulas for computing ˆg(xi)andSλare very technical; however, efficient algorithms are available for computing these quantities. 7.6 Local Regression 303 20 30 40 50 60 70 800 50 100 200 300AgeWageSmoothing Spline16 Degrees of Freedom6.8 Degrees of Freedom (LOOCV) FIGURE 7.8. Smoothing spline fits to the Wagedata. The red curve results from specifying 16effective degrees of freedom. For the blue curve, λwas found automatically by leave-one-out cross-validation, which resulted in 6.8effective degrees of freedom. is preferable, since in general simpler models are better unless the data provides evidence in support of a more complex model. 7.6 Local Regression Local regression is a different approach for fitting flexible non-linear func-local regressiontions, which involves computing the fit at a target point x0using only the nearby training observations. Figure 7.9illustrates the idea on some simu- lated data, with one target point near 0.4, and another near the boundary at0.05. In this figure the blue line represents the function f(x)from which the data were generated, and the light orange line corresponds to the local regression estimate ˆf(x). Local regression is described in Algorithm 7.1. Note that in Step 3 of Algorithm 7.1, the weights Ki0will differ for each value ofx0. In other words, in order to obtain the local regression fit at a new point, we need to fit a new weighted least squares regression model by minimizing ( 7.14) for a new set of weights. Local regression is sometimes referredtoasa memory-based procedure,becauselikenearest-neighbors,we need all the training data each time we wish to compute a prediction. We will avoid getting into the technical details of local regression here—there are books written on the topic. In order to perform local regression, there are a number of choices to be made, such as how to define the weighting function K, and whether to fit a linear, constant, or quadratic regression in Step 3. (Equation 7.14 corresponds to a linear regression.) While all of these choices make some difference, the most important choice is the spans, which is the proportion of points used to compute the local regression at x0, as defined in Step 1 above. The span plays a role like that of the tuning parameter λin smooth- 304 7. Moving Beyond Linearity 0.0 0.2 0.4 0.6 0.8 1.0−1.0 −0.5 0.0 0.5 1.0 1.5OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 355, "start_word": 113600, "end_word": 114000, "chunk_words": 400}}, "ISLP_website::c000356": {"text": "a linear, constant, or quadratic regression in Step 3. (Equation 7.14 corresponds to a linear regression.) While all of these choices make some difference, the most important choice is the spans, which is the proportion of points used to compute the local regression at x0, as defined in Step 1 above. The span plays a role like that of the tuning parameter λin smooth- 304 7. Moving Beyond Linearity 0.0 0.2 0.4 0.6 0.8 1.0−1.0 −0.5 0.0 0.5 1.0 1.5OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO 0.0 0.2 0.4 0.6 0.8 1.0−1.0 −0.5 0.0 0.5 1.0 1.5OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOLocal Regression FIGURE 7.9. Local regression illustrated on some simulated data, where the blue curve represents f(x)from which the data were generated, and the light orange curve corresponds to the local regression estimate ˆf(x). The orange colored points are local to the target point x0, represented by the orange vertical line. The yellow bell-shape superimposed on the plot indicates weights assigned to each point, decreasing to zero with distance from the target point. The fit ˆf(x0)atx0 is obtained by fitting a weighted linear regression (orange line segment), and using the fitted value at x0(orange solid dot) as the estimate ˆf(x0). ing splines: it controls the flexibility of the non-linear fit. The smaller the value of s, the more localand wiggly will be our fit; alternatively, a very large value of swill lead to a global fit to the data using all of the train- ing observations. We can again use cross-validation to choose s, or we can specify it directly. Figure 7.10displays local linear regression fits on the Wagedata, using two values of s:0.7and0.2. As expected, the fit obtained usings=0.7is smoother than that obtained using s=0.2. The idea of local regression can be generalized in many different ways. In a setting with multiple features X1,X2,...,X p, one very useful general- ization involves fitting a multiple linear regression model that is global in some variables, but local in another, such as time. Such varying coefficient modelsare a useful way of adapting a model to the most recently gatheredvarying coefficient modeldata. Local regression also generalizes very naturally when we want to fit models that are local in a pair of variables X1andX2, rather than one. We can simply use two-dimensional neighborhoods, and fit bivariate linear regression models using the observations that are near each target point in two-dimensional space. Theoretically the same approach can be imple- mented in higher dimensions, using linear", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 356, "start_word": 113920, "end_word": 114320, "chunk_words": 400}}, "ISLP_website::c000357": {"text": "time. Such varying coefficient modelsare a useful way of adapting a model to the most recently gatheredvarying coefficient modeldata. Local regression also generalizes very naturally when we want to fit models that are local in a pair of variables X1andX2, rather than one. We can simply use two-dimensional neighborhoods, and fit bivariate linear regression models using the observations that are near each target point in two-dimensional space. Theoretically the same approach can be imple- mented in higher dimensions, using linear regressions fit to p-dimensional neighborhoods. However, local regression can perform poorly if pis much larger than about 3 or 4 because there will generally be very few training observations close to x0. Nearest-neighbors regression, discussed in Chap- ter3, suffers from a similar problem in high dimensions. 7.7 Generalized Additive Models 305 Algorithm 7.1 Local Regression At X=x0 1. Gather the fraction s=k/nof training points whose xiare closest tox0. 2. Assign a weight Ki0=K(xi,x0)to each point in this neighborhood, so that the point furthest from x0has weight zero, and the closest has the highest weight. All but these knearest neighbors get weight zero. 3. Fit a weighted least squares regression of theyion thexiusing the aforementioned weights, by finding ˆβ0andˆβ1that minimize n/summationdisplay i=1Ki0(yi−β0−β1xi)2. (7.14) 4. The fitted value at x0is given by ˆf(x0)=ˆβ0+ˆβ1x0. 20 30 40 50 60 70 800 50 100 200 300AgeWageLocal Linear RegressionSpan is 0.2 (16.4 Degrees of Freedom)Span is 0.7 (5.3 Degrees of Freedom) FIGURE 7.10. Local linear fits to the Wagedata. The span specifies the fraction of the data used to compute the fit at each target point. 7.7 Generalized Additive Models In Sections 7.1–7.6, we present a number of approaches for flexibly predict- ing a response Yon the basis of a single predictor X. These approaches can be seen as extensions of simple linear regression. Here we explore the prob- lem of flexibly predicting Yon the basis of several predictors, X1,...,X p. This amounts to an extension of multiple linear regression. Generalized additive models (GAMs) provide a general framework forgeneralized additive modelextending a standard linear model by allowing non-linear functions of each ofthevariables,whilemaintaining additivity .Justlikelinearmodels,GAMs additivity can be applied with both quantitative and qualitative responses. We first 306 7. Moving Beyond Linearity 2003 2005 2007 2009−30 −20 −10 0 10 20 3020 30 40 50 60 70 80−50 −40 −30 −20 −10 0 10 20 −30 −20 −10 0 10 20 30 40<HS HS <Coll Coll", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 357, "start_word": 114240, "end_word": 114640, "chunk_words": 400}}, "ISLP_website::c000358": {"text": "extension of multiple linear regression. Generalized additive models (GAMs) provide a general framework forgeneralized additive modelextending a standard linear model by allowing non-linear functions of each ofthevariables,whilemaintaining additivity .Justlikelinearmodels,GAMs additivity can be applied with both quantitative and qualitative responses. We first 306 7. Moving Beyond Linearity 2003 2005 2007 2009−30 −20 −10 0 10 20 3020 30 40 50 60 70 80−50 −40 −30 −20 −10 0 10 20 −30 −20 −10 0 10 20 30 40<HS HS <Coll Coll >Collf1(year) f2(age) f3(education) yearageeducationFIGURE 7.11. For theWagedata, plots of the relationship between each feature and the response, wage, in the fitted model ( 7.16). Each plot displays the fitted function and pointwise standard errors. The first two functions are natural splines inyearandage, with four and five degrees of freedom, respectively. The third function is a step function, fit to the qualitative variable education . examine GAMs for a quantitative response in Section 7.7.1, and then for a qualitative response in Section 7.7.2. 7.7.1 GAMs for Regression Problems A natural way to extend the multiple linear regression model yi=β0+β1xi1+β2xi2+···+βpxip+/epsilon1i in order to allow for non-linear relationships between each feature and the response is to replace each linear component βjxijwith a (smooth) non- linear function fj(xij). We would then write the model as yi=β0+p/summationdisplay j=1fj(xij)+/epsilon1i =β0+f1(xi1)+f2(xi2)+···+fp(xip)+/epsilon1i. (7.15) This is an example of a GAM. It is called an additive model because we calculate a separate fjfor each Xj, and then add together all of their contributions. In Sections 7.1–7.6, we discuss many methods for fitting functions to a single variable. The beauty of GAMs is that we can use these methods as building blocks for fitting an additive model. In fact, for most of the methods that we have seen so far in this chapter, this can be done fairly trivially. Take, for example, natural splines, and consider the task of fitting the model wage =β0+f1(year )+f2(age)+f3(education )+/epsilon1 (7.16) on theWagedata. Here yearandageare quantitative variables, while the variable education is qualitative with five levels: <HS,HS,<Coll,Coll,>Coll, referring to the amount of high school or college education that an individ- ual has completed. We fit the first two functions using natural splines. We 7.7 Generalized Additive Models 307 2003 2005 2007 2009−30 −20 −10 0 10 20 3020 30 40 50 60 70 80−50 −40 −30 −20 −10 0 10 20 −30 −20 −10 0 10 20 30 40<HS HS <Coll Coll >Collf1(year) f2(age)", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 358, "start_word": 114560, "end_word": 114960, "chunk_words": 400}}, "ISLP_website::c000359": {"text": "yearandageare quantitative variables, while the variable education is qualitative with five levels: <HS,HS,<Coll,Coll,>Coll, referring to the amount of high school or college education that an individ- ual has completed. We fit the first two functions using natural splines. We 7.7 Generalized Additive Models 307 2003 2005 2007 2009−30 −20 −10 0 10 20 3020 30 40 50 60 70 80−50 −40 −30 −20 −10 0 10 20 −30 −20 −10 0 10 20 30 40<HS HS <Coll Coll >Collf1(year) f2(age) f3(education) yearageeducationFIGURE 7.12. Details are as in Figure 7.11, but now f1andf2are smoothing splines with four and five degrees of freedom, respectively. fit the third function using a separate constant for each level, via the usual dummy variable approach of Section 3.3.1. Figure7.11shows the results of fitting the model ( 7.16) using least squares. This is easy to do, since as discussed in Section 7.4, natural splines can be constructed using an appropriately chosen set of basis functions. Hence the entire model is just a big regression onto spline basis variables and dummy variables, all packed into one big regression matrix. Figure7.11can be easily interpreted. The left-hand panel indicates that holding ageandeducation fixed,wagetends to increase slightly with year; this may be due to inflation. The center panel indicates that holding education andyearfixed,wagetends to be highest for intermediate val- ues ofage, and lowest for the very young and very old. The right-hand panel indicates that holding yearandagefixed,wagetends to increase witheducation : the more educated a person is, the higher their salary, on average. All of these findings are intuitive. Figure7.12shows a similar triple of plots, but this time f1andf2are smoothing splines with four and five degrees of freedom, respectively. Fit- tingaGAMwithasmoothingsplineis notquiteassimpleasfittinga GAM with a natural spline, since in the case of smoothing splines, least squares cannot be used. However, standard software such as the Pythonpackage pygamcan be used to fit GAMs using smoothing splines, via an approachpygam known as backfitting . This method fits a model involving multiple predic-backfittingtors by repeatedly updating the fit for each predictor in turn, holding the others fixed. The beauty of this approach is that each time we update a function, we simply apply the fitting method for that variable to a partial residual.6 The fitted functions in Figures 7.11and7.12look rather similar. In most situations, the differences in the GAMs obtained using smoothing splines versus natural splines are small. 6A partial residual for X3, for", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 359, "start_word": 114880, "end_word": 115280, "chunk_words": 400}}, "ISLP_website::c000360": {"text": ". This method fits a model involving multiple predic-backfittingtors by repeatedly updating the fit for each predictor in turn, holding the others fixed. The beauty of this approach is that each time we update a function, we simply apply the fitting method for that variable to a partial residual.6 The fitted functions in Figures 7.11and7.12look rather similar. In most situations, the differences in the GAMs obtained using smoothing splines versus natural splines are small. 6A partial residual for X3, for example, has the form ri=yi−f1(xi1)−f2(xi2). If we knowf1andf2, then we can fit f3by treating this residual as a response in a non-linear regression on X3. 308 7. Moving Beyond Linearity We do not have to use splines as the building blocks for GAMs: we can just as well use local regression, polynomial regression, or any combination of the approaches seen earlier in this chapter in order to create a GAM. GAMsareinvestigatedinfurtherdetailinthelabattheendofthischapter. Pros and Cons of GAMs Before we move on, let us summarize the advantages and limitations of a GAM. LGAMs allow us to fit a non-linear fjto eachXj, so that we can automatically model non-linear relationships that standard linear re- gression will miss. This means that we do not need to manually try out many different transformations on each variable individually. LThe non-linear fits can potentially make more accurate predictions for the response Y. LBecause the model is additive, we can examine the effect of each Xj onYindividually while holding all of the other variables fixed. LThe smoothness of the function fjfor the variable Xjcan be sum- marized via degrees of freedom. NThe main limitation of GAMs is that the model is restricted to be additive. With many variables, important interactions can be missed. However, as with linear regression, we can manually add interaction terms to the GAM model by including additional predictors of the formXj×Xk. In addition we can add low-dimensional interaction functions of the form fjk(Xj,Xk)into the model; such terms can be fit using two-dimensional smoothers such as local regression, or two-dimensional splines (not covered here). For fully general models, we have to look for even more flexible approaches suchasrandomforestsandboosting,describedinChapter 8.GAMsprovide a useful compromise between linear and fully nonparametric models. 7.7.2 GAMs for Classification Problems GAMs can also be used in situations where Yis qualitative. For simplicity, here we assume Ytakes on values 0or1, and let p(X) = Pr( Y=1|X)be the conditional probability (given the predictors) that", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 360, "start_word": 115200, "end_word": 115600, "chunk_words": 400}}, "ISLP_website::c000361": {"text": "model; such terms can be fit using two-dimensional smoothers such as local regression, or two-dimensional splines (not covered here). For fully general models, we have to look for even more flexible approaches suchasrandomforestsandboosting,describedinChapter 8.GAMsprovide a useful compromise between linear and fully nonparametric models. 7.7.2 GAMs for Classification Problems GAMs can also be used in situations where Yis qualitative. For simplicity, here we assume Ytakes on values 0or1, and let p(X) = Pr( Y=1|X)be the conditional probability (given the predictors) that the response equals one. Recall the logistic regression model ( 4.6): log/parenleftbiggp(X) 1−p(X)/parenrightbigg =β0+β1X1+β2X2+···+βpXp. (7.17) Theleft-hand side is thelog of the oddsof P(Y=1|X)versusP(Y=0|X), which (7.17) represents as a linear function of the predictors. A natural way to extend ( 7.17) to allow for non-linear relationships is to use the model log/parenleftbiggp(X) 1−p(X)/parenrightbigg =β0+f1(X1)+f2(X2)+···+fp(Xp). (7.18) 7.8 Lab: Non-Linear Modeling 309 2003 2005 2007 2009−4 −2 0 2 420 30 40 50 60 70 80−8 −6 −4 −2 0 2 −400 −200 0 200 400<HS HS <Coll Coll >Collf1(year) f2(age) f3(education) yearageeducationFIGURE 7.13. For theWagedata, the logistic regression GAM given in ( 7.19) is fit to the binary response I(wage>250) . Each plot displays the fitted function and pointwise standard errors. The first function is linear in year, the second function a smoothing spline with five degrees of freedom in age, and the third a step function for education . There are very wide standard errors for the first level<HSofeducation . Equation 7.18is a logistic regression GAM. It has all the same pros and cons as discussed in the previous section for quantitative responses. We fit a GAM to the Wagedata in order to predict the probability that an individual’s income exceeds $250 ,000per year. The GAM that we fit takes the form log/parenleftbiggp(X) 1−p(X)/parenrightbigg =β0+β1×year +f2(age)+f3(education ),(7.19) where p(X) = Pr( wage >250|year ,age,education ). Once again f2is fit using a smoothing spline with five degrees of freedom, andf3is fit as a step function, by creating dummy variables for each of the levels of education. The resulting fit is shown in Figure 7.13. The last panel looks suspicious, with very wide confidence intervals for level <HS. In fact, noresponsevaluesequaloneforthatcategory:noindividualswithlessthan a high school education make more than $250 ,000per year. Hence we refit the GAM, excluding the individuals with less than a high school education. The resulting model is shown in Figure 7.14. As in Figures 7.11and7.12, all three panels have similar", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 361, "start_word": 115520, "end_word": 115920, "chunk_words": 400}}, "ISLP_website::c000362": {"text": "a step function, by creating dummy variables for each of the levels of education. The resulting fit is shown in Figure 7.13. The last panel looks suspicious, with very wide confidence intervals for level <HS. In fact, noresponsevaluesequaloneforthatcategory:noindividualswithlessthan a high school education make more than $250 ,000per year. Hence we refit the GAM, excluding the individuals with less than a high school education. The resulting model is shown in Figure 7.14. As in Figures 7.11and7.12, all three panels have similar vertical scales. This allows us to visually assess the relative contributions of each of the variables. We observe that ageand education have a much larger effect than yearon the probability of being a high earner. 7.8 Lab: Non-Linear Modeling In this lab, we demonstrate some of the nonlinear models discussed in this chapter. We use the Wagedata as a running example, and show that many of the complex non-linear fitting procedures discussed can easily be implemented in Python. 310 7. Moving Beyond Linearity 2003 2005 2007 2009−4 −2 0 2 420 30 40 50 60 70 80−8 −6 −4 −2 0 2 −4 −2 0 2 4HS <Coll Coll >Collf1(year) f2(age) f3(education) yearageeducationFIGURE 7.14. The same model is fit as in Figure 7.13, this time excluding the observations for which education is<HS. Now we see that increased education tends to be associated with higher salaries. As usual, we start with some of our standard imports. In[1]: import numpy as np, pandas as pd from matplotlib.pyplot import subplots import statsmodels.api as sm from ISLP import load_data from ISLP.models import (summarize, poly, ModelSpec as MS) from statsmodels.stats.anova import anova_lm We again collect the new imports needed for this lab. Many of these are developed specifically for the ISLPpackage. In[2]: from pygam import (s as s_gam, la sl _ g a m , fa sf _ g a m , LinearGAM, LogisticGAM) from ISLP.transforms import (BSpline, NaturalSpline) from ISLP.models import bs, ns from ISLP.pygam import (approx_lam, degrees_of_freedom, plot as plot_gam, anova as anova_gam) 7.8.1 Polynomial Regression and Step Functions We start by demonstrating how Figure 7.1can be reproduced. Let’s begin by loading the data. In[3]: Wage = load_data( 'Wage') y=W a g e [ 'wage'] age = Wage[ 'age'] 7.8 Lab: Non-Linear Modeling 311 Throughout most of this lab, our response is Wage['wage'] , which we have stored as yabove. As in Section 3.6.6, we will use the poly()function to create a model", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 362, "start_word": 115840, "end_word": 116240, "chunk_words": 400}}, "ISLP_website::c000363": {"text": "ISLP.pygam import (approx_lam, degrees_of_freedom, plot as plot_gam, anova as anova_gam) 7.8.1 Polynomial Regression and Step Functions We start by demonstrating how Figure 7.1can be reproduced. Let’s begin by loading the data. In[3]: Wage = load_data( 'Wage') y=W a g e [ 'wage'] age = Wage[ 'age'] 7.8 Lab: Non-Linear Modeling 311 Throughout most of this lab, our response is Wage['wage'] , which we have stored as yabove. As in Section 3.6.6, we will use the poly()function to create a model matrix that will fit a 4th degree polynomial in age. In[4]: poly_age = MS([poly( 'age',d e g r e e = 4 ) ] ) . f i t ( W a g e ) M=s m . O L S ( y ,p o l y _ a g e . t r a n s f o r m ( W a g e ) ) . f i t ( ) summarize(M) Out[4]: coef std err t P>|t| intercept 111.7036 0.729 153.283 0.000 poly(age, degree=4)[0] 447.0679 39.915 11.201 0.000 poly(age, degree=4)[1] -478.3158 39.915 -11.983 0.000 poly(age, degree=4)[2] 125.5217 39.915 3.145 0.002 poly(age, degree=4)[3] -77.9112 39.915 -1.952 0.051 This polynomial is constructed using the function poly(), which cre- ates a special transformer Poly()(usingsklearnterminology for featuretransformertransformations such as PCA()seen in Section 6.5.3) which allows for easy evaluation of the polynomial at new data points. Here poly()is referred to as ahelperfunction, and sets up the transformation; Poly()is the ac-helpertual workhorse that computes the transformation. See also the discussion of transformations on page 118. In the code above, the first line executes the fit()method using the dataframe Wage. This recomputes and stores as attributes any parameters needed by Poly()on the training data, and these will be used on all sub- sequent evaluations of the transform() method. For example, it is used on the second line, as well as in the plotting function developed below. We now create a grid of values for ageat which we want predictions. In[5]: age_grid = np.linspace(age.min(), age.max(), 100) age_df = pd.DataFrame({ 'age':a g e _ g r i d } ) Finally, we wish to plot the data and add the fit from the fourth-degree polynomial. As we will make several similar plots below, we first write a function to create all the ingredients and produce the plot. Our function takes in a model specification (here a basis specified by a transform), as well as a", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 363, "start_word": 116160, "end_word": 116560, "chunk_words": 400}}, "ISLP_website::c000364": {"text": "for ageat which we want predictions. In[5]: age_grid = np.linspace(age.min(), age.max(), 100) age_df = pd.DataFrame({ 'age':a g e _ g r i d } ) Finally, we wish to plot the data and add the fit from the fourth-degree polynomial. As we will make several similar plots below, we first write a function to create all the ingredients and produce the plot. Our function takes in a model specification (here a basis specified by a transform), as well as a grid of agevalues. The function produces a fitted curve as well as 95% confidence bands. By using an argument for basiswe can produce and plot the results with several different transforms, such as the splines we will see shortly. In[6]: def plot_wage_fit(age_df, basis, title): X=b a s i s . t r a n s f o r m ( W a g e ) Xnew = basis.transform(age_df) M=s m . O L S ( y ,X ) . f i t ( ) preds = M.get_prediction(Xnew) bands = preds.conf_int(alpha=0.05) fig, ax = subplots(figsize=(8,8)) ax.scatter(age, y, 312 7. Moving Beyond Linearity facecolor= 'gray', alpha=0.5) for val, ls in zip([preds.predicted_mean, bands[:,0], bands[:,1]], ['b','r--','r--']): ax.plot(age_df.values, val, ls, linewidth=3) ax.set_title(title, fontsize=20) ax.set_xlabel( 'Age',f o n t s i z e = 2 0 ) ax.set_ylabel( 'Wage',f o n t s i z e = 2 0 ) ; return ax We include an argument alphatoax.scatter() to add some transparency to the points. This provides a visual indication of density. Notice the use of thezip()function in the forloop above (see Section 2.3.8). We have three lines to plot, each with different colors and line types. Here zip() conveniently bundles these together as iterators in the loop.7 iteratorWe now plot the fit of the fourth-degree polynomial using this function. In[7]: plot_wage_fit(age_df, poly_age, 'Degree-4 Polynomial' ); With polynomial regression we must decide on the degree of the polyno- mial to use. Sometimes we just wing it, and decide to use second or third degree polynomials, simply to obtain a nonlinear fit. But we can make such a decision in a more systematic way. One way to do this is through hypoth- esis tests, which we demonstrate here. We now fit a series of models ranging from linear (degree-one) to degree-five polynomials, and look to determine the simplest model that is sufficient to explain the relationship between wageandage. We use the anova_lm() function, which performs a series", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 364, "start_word": 116480, "end_word": 116880, "chunk_words": 400}}, "ISLP_website::c000365": {"text": "and decide to use second or third degree polynomials, simply to obtain a nonlinear fit. But we can make such a decision in a more systematic way. One way to do this is through hypoth- esis tests, which we demonstrate here. We now fit a series of models ranging from linear (degree-one) to degree-five polynomials, and look to determine the simplest model that is sufficient to explain the relationship between wageandage. We use the anova_lm() function, which performs a series of ANOVA tests. An analysis of variance or ANOVA tests the null hypothesisanalysis of variancethat a model M1is sufficient to explain the data against the alternative hypothesis that a more complex model M2is required. The determination is based on an F-test. To perform the test, the models M1andM2must benested: the space spanned by the predictors in M1must be a subspace of the space spanned by the predictors in M2. In this case, we fit five dif- ferent polynomial models and sequentially compare the simpler model to the more complex model. In[8]: models = [MS([poly( 'age',d e g r e e = d ) ] ) for d in range(1, 6)] Xs = [model.fit_transform(Wage) for model in models] anova_lm(*[sm.OLS(y, X_).fit() for X_ in Xs]) Out[8]: df_resid ssr df_diff ss_diff F Pr(>F) 02 9 9 8 . 0 5 . 0 2 2 e + 0 6 0 . 0 NaN NaN NaN 12 9 9 7 . 0 4 . 7 9 3 e + 0 6 1 . 0 2 2 8 7 8 6 . 0 1 0 1 4 3 . 5 9 3 2 . 3 6 4 e - 3 2 22 9 9 6 . 0 4 . 7 7 8 e + 0 6 1 . 0 1 5 7 5 5 . 6 9 49 . 8 8 9 1 . 6 7 9 e - 0 3 32 9 9 5 . 0 4 . 7 7 2 e + 0 6 1 . 06 0 7 0 . 1 5 23 . 8 1 0 5 . 1 0 5 e - 0 2 7InPython speak, an “iterator” is an object with a finite number of values, that can be iterated on, as in a loop. 7.8 Lab: Non-Linear Modeling 313 42 9 9 4 . 0 4 . 7 7 0 e + 0 6 1 . 01 2 8", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 365, "start_word": 116800, "end_word": 117200, "chunk_words": 400}}, "ISLP_website::c000366": {"text": "0 4 . 7 7 2 e + 0 6 1 . 06 0 7 0 . 1 5 23 . 8 1 0 5 . 1 0 5 e - 0 2 7InPython speak, an “iterator” is an object with a finite number of values, that can be iterated on, as in a loop. 7.8 Lab: Non-Linear Modeling 313 42 9 9 4 . 0 4 . 7 7 0 e + 0 6 1 . 01 2 8 2 . 5 6 30 . 8 0 5 3 . 6 9 7 e - 0 1 Notice the *in theanova_lm() line above. This function takes a variable number of non-keyword arguments, in this case fitted models. When these models are provided as a list (as is done here), it must be prefixed by *. The p-value comparing the linear models[0] to the quadratic models[1] is essentially zero, indicating that a linear fit is not sufficient.8Similarly the p-value comparing the quadratic models[1] to the cubic models[2] is very low (0.0017), so the quadratic fit is also insufficient. The p-value comparing the cubic and degree-four polynomials, models[2] andmodels[3] , is approx- imately 5%, while the degree-five polynomial models[4] seems unnecessary because its p-value is 0.37. Hence, either a cubic or a quartic polynomial appear to provide a reasonable fit to the data, but lower- or higher-order models are not justified. Inthiscase,insteadofusingthe anova()function,wecouldhaveobtained these p-values more succinctly by exploiting the fact that poly()creates orthogonal polynomials. In[9]: summarize(M) Out[9]: coef std err t P>|t| intercept 111.7036 0.729 153.283 0.000 poly(age, degree=4)[0] 447.0679 39.915 11.201 0.000 poly(age, degree=4)[1] -478.3158 39.915 -11.983 0.000 poly(age, degree=4)[2] 125.5217 39.915 3.145 0.002 poly(age, degree=4)[3] -77.9112 39.915 -1.952 0.051 Notice that the p-values are the same, and in fact the square of the t-statistics are equal to the F-statistics from the anova_lm() function; for example: In[10]: (-11.983)**2 Out[10]: 143.59228 However, the ANOVA method works whether or not we used orthogonal polynomials, provided the models are nested. For example, we can use anova_lm() to compare the following three models, which all have a linear term in education and a polynomial in ageof different degrees: In[11]: models = [MS([ 'education' ,p o l y ( 'age',d e g r e e = d ) ] ) for d in range(1, 4)] XEs = [model.fit_transform(Wage) for model in models] anova_lm(*[sm.OLS(y, X_).fit() for X_ in XEs]) Out[11]: df_resid ssr df_diff ss_diff F", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 366, "start_word": 117120, "end_word": 117520, "chunk_words": 400}}, "ISLP_website::c000367": {"text": "used orthogonal polynomials, provided the models are nested. For example, we can use anova_lm() to compare the following three models, which all have a linear term in education and a polynomial in ageof different degrees: In[11]: models = [MS([ 'education' ,p o l y ( 'age',d e g r e e = d ) ] ) for d in range(1, 4)] XEs = [model.fit_transform(Wage) for model in models] anova_lm(*[sm.OLS(y, X_).fit() for X_ in XEs]) Out[11]: df_resid ssr df_diff ss_diff F Pr(>F) 02 9 9 7 . 0 3 . 9 0 2 e + 0 6 0 . 0 NaN NaN NaN 12 9 9 6 . 0 3 . 7 5 9 e + 0 6 1 . 0 1 4 2 8 6 2 . 7 0 1 1 1 3 . 9 9 2 3 . 8 3 8 e - 2 6 22 9 9 5 . 0 3 . 7 5 4 e + 0 6 1 . 05 9 2 6 . 2 0 74 . 7 2 9 2 . 9 7 4 e - 0 2 8Indexing starting at zero is confusing for the polynomial degree example, since models[1] is quadratic rather than linear! 314 7. Moving Beyond Linearity As an alternative to using hypothesis tests and ANOVA, we could choose the polynomial degree using cross-validation, as discussed in Chapter 5. Next we consider the task of predicting whether an individual earns more than $250,000 per year. We proceed much as before, except that first we create the appropriate response vector, and then apply the glm()function using the binomial family in order to fit a polynomial logistic regression model. In[12]: X=p o l y _ a g e . t r a n s f o r m ( W a g e ) high_earn = Wage[ 'high_earn' ]=y>2 5 0 #s h o r t h a n d glm = sm.GLM(y > 250, X, family=sm.families.Binomial()) B=g l m . f i t ( ) summarize(B) Out[12]: coef std err z P>|z| intercept -4.3012 0.345 -12.457 0.000 poly(age, degree=4)[0] 71.9642 26.133 2.754 0.006 poly(age, degree=4)[1] -85.7729 35.929 -2.387 0.017 poly(age, degree=4)[2] 34.1626 19.697 1.734 0.083 poly(age, degree=4)[3] -47.4008 24.105 -1.966 0.049 Once again, we make predictions using the get_prediction() method. In[13]: newX = poly_age.transform(age_df) preds = B.get_prediction(newX) bands = preds.conf_int(alpha=0.05) We now plot the estimated relationship. In[14]: fig, ax = subplots(figsize=(8,8))", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 367, "start_word": 117440, "end_word": 117840, "chunk_words": 400}}, "ISLP_website::c000368": {"text": "sm.GLM(y > 250, X, family=sm.families.Binomial()) B=g l m . f i t ( ) summarize(B) Out[12]: coef std err z P>|z| intercept -4.3012 0.345 -12.457 0.000 poly(age, degree=4)[0] 71.9642 26.133 2.754 0.006 poly(age, degree=4)[1] -85.7729 35.929 -2.387 0.017 poly(age, degree=4)[2] 34.1626 19.697 1.734 0.083 poly(age, degree=4)[3] -47.4008 24.105 -1.966 0.049 Once again, we make predictions using the get_prediction() method. In[13]: newX = poly_age.transform(age_df) preds = B.get_prediction(newX) bands = preds.conf_int(alpha=0.05) We now plot the estimated relationship. In[14]: fig, ax = subplots(figsize=(8,8)) rng = np.random.default_rng(0) ax.scatter(age + 0.2 * rng.uniform(size=y.shape[0]), np.where(high_earn, 0.198, 0.002), fc='gray', marker= '|') for val, ls in zip([preds.predicted_mean, bands[:,0], bands[:,1]], ['b','r--','r--']): ax.plot(age_df.values, val, ls, linewidth=3) ax.set_title( 'Degree-4 Polynomial' ,f o n t s i z e = 2 0 ) ax.set_xlabel( 'Age',f o n t s i z e = 2 0 ) ax.set_ylim([0,0.2]) ax.set_ylabel( 'P(Wage > 250)' ,f o n t s i z e = 2 0 ) ; We have drawn the agevalues corresponding to the observations with wage values above 250 as gray marks on the top of the plot, and those with wagevalues below 250 are shown as gray marks on the bottom of the plot. We added a small amount of noise to jitter the agevalues a bit so that observations with the same agevalue do not cover each other up. This type of plot is often called a rug plot.rug plotIn order to fit a step function, as discussed in Section 7.2, we first use thepd.qcut() function to discretize agebased on quantiles. Then we usepd.qcut() 7.8 Lab: Non-Linear Modeling 315 pd.get_dummies() to create the columns of the model matrix for this cate-pd.get_ dummies()gorical variable. Note that this function will include allcolumns for a given categorical, rather than the usual approach which drops one of the levels. In[15]: cut_age = pd.qcut(age, 4) summarize(sm.OLS(y, pd.get_dummies(cut_age)).fit()) Out[15]: coef std err t P>|t| (17.999, 33.75] 94.1584 1.478 63.692 0.0 (33.75, 42.0] 116.6608 1.470 79.385 0.0 (42.0, 51.0] 119.1887 1.416 84.147 0.0 (51.0, 80.0] 116.5717 1.559 74.751 0.0 Herepd.qcut() automatically picked the cutpoints based on the quan- tiles 25%, 50% and 75%, which results in four regions. We could also have specified our own quantiles directly instead of the argument 4. For cuts not based on quantiles we would use the pd.cut() function. The functionpd.cut()pd.qcut() (andpd.cut() ) returns an ordered categorical variable. The re- gression model then creates a set of dummy variables for use in the", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 368, "start_word": 117760, "end_word": 118160, "chunk_words": 400}}, "ISLP_website::c000369": {"text": "51.0] 119.1887 1.416 84.147 0.0 (51.0, 80.0] 116.5717 1.559 74.751 0.0 Herepd.qcut() automatically picked the cutpoints based on the quan- tiles 25%, 50% and 75%, which results in four regions. We could also have specified our own quantiles directly instead of the argument 4. For cuts not based on quantiles we would use the pd.cut() function. The functionpd.cut()pd.qcut() (andpd.cut() ) returns an ordered categorical variable. The re- gression model then creates a set of dummy variables for use in the regres- sion. Since ageis the only variable in the model, the value $94,158.40 is the average salary for those under 33.75 years of age, and the other coefficients are the average salary for those in the other age groups. We can produce predictions and plots just as we did in the case of the polynomial fit. 7.8.2 Splines In order to fit regression splines, we use transforms from the ISLPpackage. The actual spline evaluation functions are in the scipy.interpolate pack- age; we have simply wrapped them as transforms similar to Poly()and PCA(). In Section 7.4, we saw that regression splines can be fit by constructing an appropriate matrix of basis functions. The BSpline() function generatesBSpline()the entire matrix of basis functions for splines with the specified set of knots. By default, the B-splines produced are cubic. To change the degree, use the argument degree. In[16]: bs_ = BSpline(internal_knots=[25,40,60], intercept=True).fit(age) bs_age = bs_.transform(age) bs_age.shape Out[16]: (3000, 7) Thisresultsinaseven-columnmatrix,whichiswhatisexpectedforacubic- spline basis with 3 interior knots. We can form this same matrix using the bs()object, which facilitates adding this to a model-matrix builder (as in poly()versus its workhorse Poly()) described in Section 7.8.1. We now fit a cubic spline model to the Wagedata. In[17]: bs_age = MS([bs( 'age',i n t e r n a l _ k n o t s = [ 2 5 , 4 0 , 6 0 ] ) ] ) Xbs = bs_age.fit_transform(Wage) M=s m . O L S ( y ,X b s ) . f i t ( ) summarize(M) 316 7. Moving Beyond LinearityOut[17]:coef std err ...intercept 60.494 9.460 ...bs(age, internal_knots=[25, 40, 60])[0] 3.980 12.538 ...bs(age, internal_knots=[25, 40, 60])[1] 44.631 9.626 ...bs(age, internal_knots=[25, 40, 60])[2] 62.839 10.755 ...bs(age, internal_knots=[25, 40, 60])[3] 55.991 10.706 ...bs(age, internal_knots=[25, 40, 60])[4] 50.688 14.402 ...bs(age, internal_knots=[25, 40, 60])[5] 16.606 19.126 ...The column names are a little cumbersome, and have caused us to trun-cate the printed summary. They can be set on", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 369, "start_word": 118080, "end_word": 118480, "chunk_words": 400}}, "ISLP_website::c000370": {"text": "( y ,X b s ) . f i t ( ) summarize(M) 316 7. Moving Beyond LinearityOut[17]:coef std err ...intercept 60.494 9.460 ...bs(age, internal_knots=[25, 40, 60])[0] 3.980 12.538 ...bs(age, internal_knots=[25, 40, 60])[1] 44.631 9.626 ...bs(age, internal_knots=[25, 40, 60])[2] 62.839 10.755 ...bs(age, internal_knots=[25, 40, 60])[3] 55.991 10.706 ...bs(age, internal_knots=[25, 40, 60])[4] 50.688 14.402 ...bs(age, internal_knots=[25, 40, 60])[5] 16.606 19.126 ...The column names are a little cumbersome, and have caused us to trun-cate the printed summary. They can be set on construction using thenameargument as follows.In[18]:bs_age = MS([bs('age',internal_knots=[25,40,60],name='bs(age)')])Xbs = bs_age.fit_transform(Wage)M=s m . O L S ( y ,X b s ) . f i t ( )summarize(M)Out[18]:coef std err t P>|t|intercept 60.494 9.460 6.394 0.000bs(age, knots)[0] 3.981 12.538 0.317 0.751bs(age, knots)[1] 44.631 9.626 4.636 0.000bs(age, knots)[2] 62.839 10.755 5.843 0.000bs(age, knots)[3] 55.991 10.706 5.230 0.000bs(age, knots)[4] 50.688 14.402 3.520 0.000bs(age, knots)[5] 16.606 19.126 0.868 0.385Notice that there are 6 spline coefficients rather than 7. This is because, bydefault,bs()assumesintercept=False, since we typically have an overallintercept in the model. So it generates the spline basis with the given knots,and then discards one of the basis functions to account for the intercept.We could also use thedf(degrees of freedom) option to specify the com-plexity of the spline. We see above that with 3 knots, the spline basis has6 columns or degrees of freedom. When we specifydf=6rather than theactual knots,bs()will produce a spline with 3 knots chosen at uniformquantiles of the training data. We can see these chosen knots most easilyusingBspline()directly:In[19]:BSpline(df=6).fit(age).internal_knots_Out[19]:array([33.75, 42.0, 51.0])When asking for six degrees of freedom, the transform chooses knots atages 33.75, 42.0, and 51.0, which correspond to the 25th, 50th, and 75thpercentiles ofage.When using B-splines we need not limit ourselves to cubic polynomials(i.e.degree=3). For instance, usingdegree=0results in piecewise constantfunctions, as in our example withpd.qcut()above.In[20]:bs_age0 = MS([bs('age',df=3,degree=0)]).fit(Wage)Xbs0 = bs_age0.transform(Wage)summarize(sm.OLS(y, Xbs0).fit()) 7.8 Lab: Non-Linear Modeling 317 Out[20]: coef std err t P>|t| intercept 94.158 1.478 63.687 0.0 bs(age, df=3, degree=0)[0] 22.349 2.152 10.388 0.0 bs(age, df=3, degree=0)[1] 24.808 2.044 12.137 0.0 bs(age, df=3, degree=0)[2] 22.781 2.087 10.917 0.0 This fit should be compared with cell [15] where we use qcut()to create four bins by cutting at the 25%, 50% and 75% quantiles of age. Since we specified df=3for degree-zero splines here, there will also be knots at the same three quantiles. Although the coefficients appear different, we see that this is a result of the different coding. For example, the first coefficient is identical", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 370, "start_word": 118400, "end_word": 118800, "chunk_words": 400}}, "ISLP_website::c000371": {"text": "bs(age, df=3, degree=0)[1] 24.808 2.044 12.137 0.0 bs(age, df=3, degree=0)[2] 22.781 2.087 10.917 0.0 This fit should be compared with cell [15] where we use qcut()to create four bins by cutting at the 25%, 50% and 75% quantiles of age. Since we specified df=3for degree-zero splines here, there will also be knots at the same three quantiles. Although the coefficients appear different, we see that this is a result of the different coding. For example, the first coefficient is identical in both cases, and is the mean response in the first bin. For the second coefficient, we have 94.158 + 22 .349 = 116 .507≈116.611, the latter being the mean in the second bin in cell [15]. Here the intercept is coded by a column of ones, so the second, third and fourth coefficients are increments for those bins. Why is the sum not exactly the same? It turns out that the qcut()uses≤, whilebs()uses<when deciding bin membership. In order to fit a natural spline, we use the NaturalSpline() transformNatural Spline() with the corresponding helper ns(). Here we fit a natural spline with five degrees of freedom (excluding the intercept) and plot the results. In[21]: ns_age = MS([ns( 'age',d f = 5 ) ] ) . f i t ( W a g e ) M_ns = sm.OLS(y, ns_age.transform(Wage)).fit() summarize(M_ns) Out[21]: coef std err tP > | t | intercept 60.475 4.708 12.844 0.000 ns(age, df=5)[0] 61.527 4.709 13.065 0.000 ns(age, df=5)[1] 55.691 5.717 9.741 0.000 ns(age, df=5)[2] 46.818 4.948 9.463 0.000 ns(age, df=5)[3] 83.204 11.918 6.982 0.000 ns(age, df=5)[4] 6.877 9.484 0.725 0.468 We now plot the natural spline using our plotting function. In[22]: plot_wage_fit(age_df, ns_age, 'Natural spline, df=5' ); 7.8.3 Smoothing Splines and GAMs A smoothing spline is a special case of a GAM with squared-error loss and a single feature. To fit GAMs in Pythonwe will use the pygampackagepygam which can be installed via pip install pygam . The estimator LinearGAM()LinearGAM()uses squared-error loss. The GAM is specified by associating each column of a model matrix with a particular smoothing operation: sfor smoothing spline;lfor linear, and ffor factor or categorical variables. The argument 0 passedto sbelowindicatesthatthissmootherwillapplytothefirstcolumn of a feature matrix. Below, we pass it a matrix with a single column: X_age. The argument lamis the penalty parameter λas discussed in Section 7.5.2. In[23]: X_age = np.asarray(age).reshape((-1,1)) gam = LinearGAM(s_gam(0, lam=0.6)) gam.fit(X_age, y) 318 7. Moving Beyond LinearityOut[23]:LinearGAM(callbacks=[Deviance(), Diffs()], fit_intercept=True,max_iter=100,", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 371, "start_word": 118720, "end_word": 119120, "chunk_words": 400}}, "ISLP_website::c000372": {"text": "The estimator LinearGAM()LinearGAM()uses squared-error loss. The GAM is specified by associating each column of a model matrix with a particular smoothing operation: sfor smoothing spline;lfor linear, and ffor factor or categorical variables. The argument 0 passedto sbelowindicatesthatthissmootherwillapplytothefirstcolumn of a feature matrix. Below, we pass it a matrix with a single column: X_age. The argument lamis the penalty parameter λas discussed in Section 7.5.2. In[23]: X_age = np.asarray(age).reshape((-1,1)) gam = LinearGAM(s_gam(0, lam=0.6)) gam.fit(X_age, y) 318 7. Moving Beyond LinearityOut[23]:LinearGAM(callbacks=[Deviance(), Diffs()], fit_intercept=True,max_iter=100, scale=None, terms=s(0) + intercept, tol=0.0001,verbose=False)Thepygamlibrary generally expects a matrix of features so we reshapeageto be a matrix (a two-dimensional array) instead of a vector (i.e. a one-dimensional array). The-1in the call to thereshape()method tellsnumpyto impute the size of that dimension based on the remaining entries of theshape tuple.Let’s investigate how the fit changes with the smoothing parameterlam.The functionnp.logspace()is similar tonp.linspace()but spaces pointsnp.logspace()evenly on the log-scale. Below we varylamfrom10−2to106.In[24]:fig, ax = subplots(figsize=(8,8))ax.scatter(age, y, facecolor='gray',a l p h a = 0 . 5 )for lam in np.logspace(-2, 6, 5):gam = LinearGAM(s_gam(0, lam=lam)).fit(X_age, y)ax.plot(age_grid,gam.predict(age_grid),label='{:.1e}'.format(lam),linewidth=3)ax.set_xlabel('Age',f o n t s i z e = 2 0 )ax.set_ylabel('Wage',f o n t s i z e = 2 0 ) ;ax.legend(title='$\\lambda$');Thepygampackage can perform a search for an optimal smoothing pa-rameter.In[25]:gam_opt = gam.gridsearch(X_age, y)ax.plot(age_grid,gam_opt.predict(age_grid),label='Grid search',linewidth=4)ax.legend()figAlternatively, we can fix the degrees of freedom of the smoothing splineusing a function included in theISLP.pygampackage. Below we find a valueofλthat gives us roughly four degrees of freedom. We note here that thesedegrees of freedom include the unpenalized intercept and linear term of thesmoothing spline, hence there are at least two degrees of freedom.In[26]:age_term = gam.terms[0]lam_4 = approx_lam(X_age, age_term, 4)age_term.lam = lam_4degrees_of_freedom(X_age, age_term)Out[26]:4.000000100004728Let’svarythedegreesoffreedominasimilarplottoabove.Wechoosethedegrees of freedom as the desired degrees of freedom plus one to accountfor the fact that these smoothing splines always have an intercept term.Hence, a value of one fordfis just a linear fit.In[27]:fig, ax = subplots(figsize=(8,8))ax.scatter(X_age,y, 7.8 Lab: Non-Linear Modeling 319 facecolor= 'gray', alpha=0.3) for df in [1,3,4,8,15]: lam = approx_lam(X_age, age_term, df+1) age_term.lam = lam gam.fit(X_age, y) ax.plot(age_grid, gam.predict(age_grid), label='{:d}'.format(df), linewidth=4) ax.set_xlabel( 'Age',f o n t s i z e = 2 0 ) ax.set_ylabel( 'Wage',f o n t s i z e = 2 0 ) ; ax.legend(title= 'Degrees of freedom' ); Additive Models with Several Terms The strength of generalized additive models lies in their ability to fit mul- tivariate regression models with more flexibility than linear models. We demonstrate two approaches: the first in a more manual", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 372, "start_word": 119040, "end_word": 119440, "chunk_words": 400}}, "ISLP_website::c000373": {"text": "age_term, df+1) age_term.lam = lam gam.fit(X_age, y) ax.plot(age_grid, gam.predict(age_grid), label='{:d}'.format(df), linewidth=4) ax.set_xlabel( 'Age',f o n t s i z e = 2 0 ) ax.set_ylabel( 'Wage',f o n t s i z e = 2 0 ) ; ax.legend(title= 'Degrees of freedom' ); Additive Models with Several Terms The strength of generalized additive models lies in their ability to fit mul- tivariate regression models with more flexibility than linear models. We demonstrate two approaches: the first in a more manual fashion using nat- ural splines and piecewise constant functions, and the second using the pygampackage and smoothing splines. We now fit a GAM by hand to predict wageusing natural spline functions ofyearandage, treating education as a qualitative predictor, as in ( 7.16). Since this is just a big linear regression model using an appropriate choice of basis functions, we can simply do this using the sm.OLS() function. We will build the model matrix in a more manual fashion here, since we wish to access the pieces separately when constructing partial dependence plots. In[28]: ns_age = NaturalSpline(df=4).fit(age) ns_year = NaturalSpline(df=5).fit(Wage[ 'year']) Xs = [ns_age.transform(age), ns_year.transform(Wage[ 'year']), pd.get_dummies(Wage[ 'education' ]).values] X_bh = np.hstack(Xs) gam_bh = sm.OLS(y, X_bh).fit() Here the function NaturalSpline() is the workhorse supporting the ns() helper function. We chose to use all columns of the indicator matrix for the categorical variable education , making an intercept redundant. Finally, we stacked the three component matrices horizontally to form the model matrixX_bh. We now show how to construct partial dependence plots for each of the terms in our rudimentary GAM. We can do this by hand, given grids for ageandyear. We simply predict with new Xmatrices, fixing all but one of the features at a time. In[29]: age_grid = np.linspace(age.min(), age.max(), 100) X_age_bh = X_bh.copy()[:100] X_age_bh[:] = X_bh[:].mean(0)[None,:] X_age_bh[:,:4] = ns_age.transform(age_grid) preds = gam_bh.get_prediction(X_age_bh) bounds_age = preds.conf_int(alpha=0.05) 320 7. Moving Beyond Linearity partial_age = preds.predicted_mean center = partial_age.mean() partial_age -= center bounds_age -= center fig, ax = subplots(figsize=(8,8)) ax.plot(age_grid, partial_age, 'b',l i n e w i d t h = 3 ) ax.plot(age_grid, bounds_age[:,0], 'r--',l i n e w i d t h = 3 ) ax.plot(age_grid, bounds_age[:,1], 'r--',l i n e w i d t h = 3 ) ax.set_xlabel( 'Age') ax.set_ylabel( 'Effect on wage' ) ax.set_title( 'Partial dependence of age on wage' ,f o n t s i z e = 2 0 ) ; Let’s explain in some detail", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 373, "start_word": 119360, "end_word": 119760, "chunk_words": 400}}, "ISLP_website::c000374": {"text": "-= center fig, ax = subplots(figsize=(8,8)) ax.plot(age_grid, partial_age, 'b',l i n e w i d t h = 3 ) ax.plot(age_grid, bounds_age[:,0], 'r--',l i n e w i d t h = 3 ) ax.plot(age_grid, bounds_age[:,1], 'r--',l i n e w i d t h = 3 ) ax.set_xlabel( 'Age') ax.set_ylabel( 'Effect on wage' ) ax.set_title( 'Partial dependence of age on wage' ,f o n t s i z e = 2 0 ) ; Let’s explain in some detail what we did above. The idea is to create a new prediction matrix, where all but the columns belonging to ageare constant (and set to their training-data means). The four columns for ageare filled in with the natural spline basis evaluated at the 100 values in age_grid . 1. We made a grid of length 100 in age, and created a matrix X_age_bh with 100 rows and the same number of columns as X_bh. 2. We replaced every row of this matrix with the column means of the original. 3. We then replace just the first four columns representing agewith the natural spline basis computed at the values in age_grid . The remaining steps should by now be familiar. We also look at the effect of yearonwage; the process is the same. In[30]: year_grid = np.linspace(2003, 2009, 100) year_grid = np.linspace(Wage[ 'year'].min(), Wage['year'].max(), 100) X_year_bh = X_bh.copy()[:100] X_year_bh[:] = X_bh[:].mean(0)[None,:] X_year_bh[:,4:9] = ns_year.transform(year_grid) preds = gam_bh.get_prediction(X_year_bh) bounds_year = preds.conf_int(alpha=0.05) partial_year = preds.predicted_mean center = partial_year.mean() partial_year -= center bounds_year -= center fig, ax = subplots(figsize=(8,8)) ax.plot(year_grid, partial_year, 'b',l i n e w i d t h = 3 ) ax.plot(year_grid, bounds_year[:,0], 'r--',l i n e w i d t h = 3 ) ax.plot(year_grid, bounds_year[:,1], 'r--',l i n e w i d t h = 3 ) ax.set_xlabel( 'Year') ax.set_ylabel( 'Effect on wage' ) ax.set_title( 'Partial dependence of year on wage' ,f o n t s i z e = 2 0 ) ; We now fit the model ( 7.16) using smoothing splines rather than nat- ural splines. All of the terms in ( 7.16) are fit simultaneously, taking each other into account to explain the response. The pygampackage only works with matrices, so we must convert the categorical series education to its array representation, which can be found with the cat.codes attribute of education . Asyearonly has 7 unique values, we use only seven basis func- tions for", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 374, "start_word": 119680, "end_word": 120080, "chunk_words": 400}}, "ISLP_website::c000375": {"text": "2 0 ) ; We now fit the model ( 7.16) using smoothing splines rather than nat- ural splines. All of the terms in ( 7.16) are fit simultaneously, taking each other into account to explain the response. The pygampackage only works with matrices, so we must convert the categorical series education to its array representation, which can be found with the cat.codes attribute of education . Asyearonly has 7 unique values, we use only seven basis func- tions for it. 7.8 Lab: Non-Linear Modeling 321In[31]:gam_full = LinearGAM(s_gam(0) +s_gam(1, n_splines=7) +f_gam(2, lam=0))Xgam = np.column_stack([age,Wage['year'],Wage['education'].cat.codes])gam_full = gam_full.fit(Xgam, y)The twos_gam()terms result in smoothing spline fits, and use a defaultvalue forλ(lam=0.6), which is somewhat arbitrary. For the categorical termeducation, specified using af_gam()term, we specifylam=0to avoid anyshrinkage. We produce the partial dependence plot inageto see the effectof these choices.The values for the plot are generated by thepygampackage. We provideaplot_gam()function for partial-dependence plots inISLP.pygam, whichplot_gam()makes this job easier than in our last example with natural splines.In[32]:fig, ax = subplots(figsize=(8,8))plot_gam(gam_full, 0, ax=ax)ax.set_xlabel('Age')ax.set_ylabel('Effect on wage')ax.set_title('Partial dependence of age on wage - default lam=0.6',fontsize=20);We see that the function is somewhat wiggly. It is more natural to specifythedfthan a value forlam. We refit a GAM using four degrees of freedomeach forageandyear. Recall that the addition of one below takes intoaccount the intercept of the smoothing spline.In[33]:age_term = gam_full.terms[0]age_term.lam = approx_lam(Xgam, age_term, df=4+1)year_term = gam_full.terms[1]year_term.lam = approx_lam(Xgam, year_term, df=4+1)gam_full = gam_full.fit(Xgam, y)Note that updatingage_term.lamabove updates it ingam_full.terms[0]aswell! Likewise foryear_term.lam.Repeating the plot forage, we see that it is much smoother. We alsoproduce the plot foryear.In[34]:fig, ax = subplots(figsize=(8,8))plot_gam(gam_full,1,ax=ax)ax.set_xlabel('Year')ax.set_ylabel('Effect on wage')ax.set_title('Partial dependence of year on wage',f o n t s i z e = 2 0 )Finally we ploteducation, which is categorical. The partial dependenceplot is different, and more suitable for the set of fitted constants for eachlevel of this variable.In[35]:fig, ax = subplots(figsize=(8, 8))ax = plot_gam(gam_full, 2)ax.set_xlabel('Education')ax.set_ylabel('Effect on wage') 322 7. Moving Beyond Linearityax.set_title('Partial dependence of wage on education',fontsize=20);ax.set_xticklabels(Wage['education'].cat.categories, fontsize=8);ANOVA Tests for Additive ModelsInallofourmodels,thefunctionofyearlooksratherlinear.Wecanperforma series of ANOVA tests in order to determine which of these three modelsis best: a GAM that excludesyear(M1), a GAM that uses a linear functionofyear(M2), or a GAM that uses a spline function ofyear(M3).In[36]:gam_0 = LinearGAM(age_term + f_gam(2, lam=0))gam_0.fit(Xgam, y)gam_linear = LinearGAM(age_term +l_gam(1, lam=0) +f_gam(2, lam=0))gam_linear.fit(Xgam, y)Out[36]:LinearGAM(callbacks=[Deviance(), Diffs()], fit_intercept=True,max_iter=100, scale=None, terms=s(0) + l(1) + f(2) + intercept,tol=0.0001, verbose=False)Notice our use ofage_termin the expressions above. We do this becauseearlier we set the value forlamin this term to achieve", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 375, "start_word": 120000, "end_word": 120400, "chunk_words": 400}}, "ISLP_website::c000376": {"text": "for Additive ModelsInallofourmodels,thefunctionofyearlooksratherlinear.Wecanperforma series of ANOVA tests in order to determine which of these three modelsis best: a GAM that excludesyear(M1), a GAM that uses a linear functionofyear(M2), or a GAM that uses a spline function ofyear(M3).In[36]:gam_0 = LinearGAM(age_term + f_gam(2, lam=0))gam_0.fit(Xgam, y)gam_linear = LinearGAM(age_term +l_gam(1, lam=0) +f_gam(2, lam=0))gam_linear.fit(Xgam, y)Out[36]:LinearGAM(callbacks=[Deviance(), Diffs()], fit_intercept=True,max_iter=100, scale=None, terms=s(0) + l(1) + f(2) + intercept,tol=0.0001, verbose=False)Notice our use ofage_termin the expressions above. We do this becauseearlier we set the value forlamin this term to achieve four degrees offreedom.To directly assess the effect ofyearwe run an ANOVA on the threemodels fit above.In[37]:anova_gam(gam_0, gam_linear, gam_full)Out[37]:deviance df deviance_diff df_diff F pvalue03 7 1 4 3 6 2 . 3 6 6 2 9 9 1 . 0 0 4NaN NaN NaN NaN13 6 9 6 7 4 5 . 8 2 3 2 9 9 0 . 0 0 5 1 7 6 1 6 . 5 4 3 0 . 9 9 9 1 4 . 2 6 50 . 0 0 223 6 9 3 1 4 2 . 9 3 0 2 9 8 7 . 0 0 7 3 6 0 2 . 8 9 4 2 . 9 9 80 . 9 7 20 . 4 3 6WefindthatthereiscompellingevidencethataGAMwithalinearfunctioninyearis better than a GAM that does not includeyearat all (p-value=0.002). However, there is no evidence that a non-linear function ofyearis needed (p-value=0.435). In other words, based on the results of thisANOVA,M2is preferred.We can repeat the same process forageas well. We see there is very clearevidence that a non-linear term is required forage.In[38]:gam_0 = LinearGAM(year_term +f_gam(2, lam=0))gam_linear = LinearGAM(l_gam(0, lam=0) +year_term +f_gam(2, lam=0))gam_0.fit(Xgam, y)gam_linear.fit(Xgam, y)anova_gam(gam_0, gam_linear, gam_full) 7.8 Lab: Non-Linear Modeling 323Out[38]:deviance df deviance_diff df_diff F pvalue03 9 7 5 4 4 3 . 0 4 5 2 9 9 1 . 0 0 1NaN NaN NaN NaN13 8 5 0 2 4 6 . 9 0 8 2 9 9 0 . 0 0 1 1 2 5 1 9 6 . 1 3 7 1 . 0 0 0 1 0 1 . 2 7 00 . 0 0 023 6 9 3 1 4 2 . 9 3 0 2 9 8 7 . 0 0 7 1 5 7 1 0 3 . 9 7 8 2 . 9 9 34 2 . 4 4 80 . 0 0 0There is a (verbose)summary()method for the GAM fit. (We do notreproduce it here.)In[39]:gam_full.summary()Wecanmakepredictionsfromgamobjects,justlikefromlmobjects,usingthepredict()method", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 376, "start_word": 120320, "end_word": 120720, "chunk_words": 400}}, "ISLP_website::c000377": {"text": "1 2 5 1 9 6 . 1 3 7 1 . 0 0 0 1 0 1 . 2 7 00 . 0 0 023 6 9 3 1 4 2 . 9 3 0 2 9 8 7 . 0 0 7 1 5 7 1 0 3 . 9 7 8 2 . 9 9 34 2 . 4 4 80 . 0 0 0There is a (verbose)summary()method for the GAM fit. (We do notreproduce it here.)In[39]:gam_full.summary()Wecanmakepredictionsfromgamobjects,justlikefromlmobjects,usingthepredict()method for the classgam. Here we make predictions on thetraining set.In[40]:Yhat = gam_full.predict(Xgam)In order to fit a logistic regression GAM, we useLogisticGAM()fromLogisticGAM()pygam.In[41]:gam_logit = LogisticGAM(age_term +l_gam(1, lam=0) +f_gam(2, lam=0))gam_logit.fit(Xgam, high_earn)Out[41]:LogisticGAM(callbacks=[Deviance(), Diffs(), Accuracy()],fit_intercept=True, max_iter=100,terms=s(0) + l(1) + f(2) + intercept, tol=0.0001, verbose=False)In[42]:fig, ax = subplots(figsize=(8, 8))ax = plot_gam(gam_logit, 2)ax.set_xlabel('Education')ax.set_ylabel('Effect on wage')ax.set_title('Partial dependence of wage on education',fontsize=20);ax.set_xticklabels(Wage['education'].cat.categories, fontsize=8);The model seems to be very flat, with especially high error bars for thefirst category. Let’s look at the data a bit more closely.In[43]:pd.crosstab(Wage['high_earn'], Wage['education'])We see that there are no high earners in the first category of education,meaning that the model will have a hard time fitting. We will fit a logisticregression GAM excluding all observations falling into this category. Thisprovides more sensible results.To do so, we could subset the model matrix, though this will not removethe column fromXgam. While we can deduce which column corresponds tothis feature, for reproducibility’s sake we reform the model matrix on thissmaller subset.In[44]:only_hs = Wage['education']= ='1. < HS Grad'Wage_ = Wage.loc[∼only_hs]Xgam_ = np.column_stack([Wage_['age'],Wage_['year'],Wage_['education'].cat.codes-1])high_earn_ = Wage_['high_earn'] 324 7. Moving Beyond LinearityIn the second-to-last line above, we subtract one from the codes of thecategory, due to a bug inpygam. It just relabels the education values andhence has no effect on the fit.We now fit the model.In[45]:gam_logit_ = LogisticGAM(age_term +year_term +f_gam(2, lam=0))gam_logit_.fit(Xgam_, high_earn_)Out[45]:LogisticGAM(callbacks=[Deviance(), Diffs(), Accuracy()],fit_intercept=True, max_iter=100,terms=s(0) + s(1) + f(2) + intercept, tol=0.0001, verbose=False)Let’s look at the effect ofeducation,yearandageon high earner statusnow that we’ve removed those observations.In[46]:fig, ax = subplots(figsize=(8, 8))ax = plot_gam(gam_logit_, 2)ax.set_xlabel('Education')ax.set_ylabel('Effect on wage')ax.set_title('Partial dependence of high earner status on education',f o n t s i z e = 2 0 ) ;ax.set_xticklabels(Wage['education'].cat.categories[1:],fontsize=8);In[47]:fig, ax = subplots(figsize=(8, 8))ax = plot_gam(gam_logit_, 1)ax.set_xlabel('Year')ax.set_ylabel('Effect on wage')ax.set_title('Partial dependence of high earner status on year',fontsize=20);In[48]:fig, ax = subplots(figsize=(8, 8))ax = plot_gam(gam_logit_, 0)ax.set_xlabel('Age')ax.set_ylabel('Effect on wage')ax.set_title('Partial dependence of high earner status on age',fontsize=20);7.8.4 Local RegressionWe illustrate the use of local regression using thelowess()function fromlowess()sm.nonparametric. Some implementations of GAMs allow terms to be localregression operators; this is not the case inpygam.Here", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 377, "start_word": 120640, "end_word": 121040, "chunk_words": 400}}, "ISLP_website::c000378": {"text": "on wage')ax.set_title('Partial dependence of high earner status on education',f o n t s i z e = 2 0 ) ;ax.set_xticklabels(Wage['education'].cat.categories[1:],fontsize=8);In[47]:fig, ax = subplots(figsize=(8, 8))ax = plot_gam(gam_logit_, 1)ax.set_xlabel('Year')ax.set_ylabel('Effect on wage')ax.set_title('Partial dependence of high earner status on year',fontsize=20);In[48]:fig, ax = subplots(figsize=(8, 8))ax = plot_gam(gam_logit_, 0)ax.set_xlabel('Age')ax.set_ylabel('Effect on wage')ax.set_title('Partial dependence of high earner status on age',fontsize=20);7.8.4 Local RegressionWe illustrate the use of local regression using thelowess()function fromlowess()sm.nonparametric. Some implementations of GAMs allow terms to be localregression operators; this is not the case inpygam.Here we fit local linear regression models using spans of 0.2 and 0.5;that is, each neighborhood consists of 20% or 50% of the observations. Asexpected, using a span of 0.5 is smoother than 0.2.In[49]:lowess = sm.nonparametric.lowessfig, ax = subplots(figsize=(8,8))ax.scatter(age, y, facecolor='gray',a l p h a = 0 . 5 )for span in [0.2, 0.5]:fitted = lowess(y, 7.9 Exercises 325age,frac=span,xvals=age_grid)ax.plot(age_grid,fitted,label='{:.1f}'.format(span),linewidth=4)ax.set_xlabel('Age',f o n t s i z e = 2 0 )ax.set_ylabel('Wage',f o n t s i z e = 2 0 ) ;ax.legend(title='span',f o n t s i z e = 1 5 ) ;7.9 ExercisesConceptual1. It was mentioned in this chapter that a cubic regression spline withone knot atξcan be obtained using a basis of the formx,x2,x3, (x−ξ)3+, where(x−ξ)3+=(x−ξ)3ifx>ξand equals 0 otherwise.We will now show that a function of the formf(x)=β0+β1x+β2x2+β3x3+β4(x−ξ)3+isindeedacubicregressionspline,regardlessofthevaluesofβ0,β1,β2,β3,β4.(a) Find a cubic polynomialf1(x)=a1+b1x+c1x2+d1x3such thatf(x)=f1(x)for allx≤ξ. Expressa1,b1,c1,d1interms ofβ0,β1,β2,β3,β4.(b) Find a cubic polynomialf2(x)=a2+b2x+c2x2+d2x3such thatf(x)=f2(x)for allx>ξ. Expressa2,b2,c2,d2interms ofβ0,β1,β2,β3,β4. We have now established thatf(x)isa piecewise polynomial.(c) Show thatf1(ξ)=f2(ξ). That is,f(x)is continuous atξ.(d) Show thatf/prime1(ξ)=f/prime2(ξ). That is,f/prime(x)is continuous atξ.(e) Show thatf/prime/prime1(ξ)=f/prime/prime2(ξ). That is,f/prime/prime(x)is continuous atξ.Therefore,f(x)is indeed a cubic spline.Hint: Parts (d) and (e) of this problem require knowledge of single-variable calculus. As a reminder, given a cubic polynomialf1(x)=a1+b1x+c1x2+d1x3,the first derivative takes the formf/prime1(x)=b1+2c1x+3d1x2 326 7. Moving Beyond Linearityand the second derivative takes the formf/prime/prime1(x)=2c1+6d1x.2. Suppose that a curveˆgis computed to smoothly fit a set ofnpointsusing the following formula:ˆg= arg ming/parenleftBiggn/summationdisplayi=1(yi−g(xi))2+λ/integraldisplay/bracketleftBigg(m)(x)/bracketrightBig2dx/parenrightBigg,whereg(m)represents themth derivative ofg(andg(0)=g). Provideexample sketches ofˆgin each of the following scenarios.(a)λ=∞,m=0.(b)λ=∞,m=1.(c)λ=∞,m=2.(d)λ=∞,m=3.(e)λ=0,m=3.3. Suppose we fit a curve with basis functionsb1(X)=X,b2(X)=(X−1)2I(X≥1). (Note thatI(X≥1)equals1forX≥1and0otherwise.) We fit the linear regression modelY=β0+β1b1(X)+β2b2(X)+/epsilon1,and obtain coefficient estimatesˆβ0=1,ˆβ1=1,ˆβ2=−2. Sketch theestimated curve betweenX=−2andX=2. Note the intercepts,slopes, and other relevant information.4. Suppose we fit a curve with basis functionsb1(X)=I(0≤X≤2)−(X−1)I(1≤X≤2),b2(X)=(X−3)I(3≤X≤4) +I(4<X≤5).We fit the linear regression modelY=β0+β1b1(X)+β2b2(X)+/epsilon1,and obtain coefficient estimatesˆβ0=1,ˆβ1=1,ˆβ2=3. Sketch theestimated curve betweenX=−2andX=6. Note the intercepts,slopes, and other relevant information.5. Consider two curves,ˆg1andˆg2, defined byˆg1= arg ming/parenleftBiggn/summationdisplayi=1(yi−g(xi))2+λ/integraldisplay/bracketleftBigg(3)(x)/bracketrightBig2dx/parenrightBigg,ˆg2= arg ming/parenleftBiggn/summationdisplayi=1(yi−g(xi))2+λ/integraldisplay/bracketleftBigg(4)(x)/bracketrightBig2dx/parenrightBigg,whereg(m)represents themth derivative ofg.(a) Asλ→∞, willˆg1orˆg2have the smaller training RSS?(b) Asλ→∞, willˆg1orˆg2have the smaller test RSS?(c) Forλ=0,", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 378, "start_word": 120960, "end_word": 121360, "chunk_words": 400}}, "ISLP_website::c000379": {"text": "a curve with basis functionsb1(X)=X,b2(X)=(X−1)2I(X≥1). (Note thatI(X≥1)equals1forX≥1and0otherwise.) We fit the linear regression modelY=β0+β1b1(X)+β2b2(X)+/epsilon1,and obtain coefficient estimatesˆβ0=1,ˆβ1=1,ˆβ2=−2. Sketch theestimated curve betweenX=−2andX=2. Note the intercepts,slopes, and other relevant information.4. Suppose we fit a curve with basis functionsb1(X)=I(0≤X≤2)−(X−1)I(1≤X≤2),b2(X)=(X−3)I(3≤X≤4) +I(4<X≤5).We fit the linear regression modelY=β0+β1b1(X)+β2b2(X)+/epsilon1,and obtain coefficient estimatesˆβ0=1,ˆβ1=1,ˆβ2=3. Sketch theestimated curve betweenX=−2andX=6. Note the intercepts,slopes, and other relevant information.5. Consider two curves,ˆg1andˆg2, defined byˆg1= arg ming/parenleftBiggn/summationdisplayi=1(yi−g(xi))2+λ/integraldisplay/bracketleftBigg(3)(x)/bracketrightBig2dx/parenrightBigg,ˆg2= arg ming/parenleftBiggn/summationdisplayi=1(yi−g(xi))2+λ/integraldisplay/bracketleftBigg(4)(x)/bracketrightBig2dx/parenrightBigg,whereg(m)represents themth derivative ofg.(a) Asλ→∞, willˆg1orˆg2have the smaller training RSS?(b) Asλ→∞, willˆg1orˆg2have the smaller test RSS?(c) Forλ=0, willˆg1orˆg2have the smaller training and test RSS? 7.9 Exercises 327Applied6. In this exercise, you will further analyze theWagedata set consideredthroughout this chapter.(a) Perform polynomial regression to predictwageusingage. Usecross-validation to select the optimal degreedfor the polyno-mial. What degree was chosen, and how does this compare tothe results of hypothesis testing using ANOVA? Make a plot ofthe resulting polynomial fit to the data.(b) Fit a step function to predictwageusingage, and perform cross-validation to choose the optimal number of cuts. Make a plot ofthe fit obtained.7. TheWagedata set contains a number of other features not exploredin this chapter, such as marital status (maritl), job class (jobclass),and others. Explore the relationships between some of these otherpredictors andwage, and use non-linear fitting techniques in order tofit flexible models to the data. Create plots of the results obtained,and write a summary of your findings.8. Fit some of the non-linear models investigated in this chapter to theAutodata set. Is there evidence for non-linear relationships in thisdata set? Create some informative plots to justify your answer.9. This question uses the variablesdis(the weighted mean of distancesto five Boston employment centers) andnox(nitrogen oxides concen-tration in parts per 10 million) from theBostondata. We will treatdisas the predictor andnoxas the response.(a) Use thepoly()function from theISLP.modelsmodule to fit acubic polynomial regression to predictnoxusingdis. Report theregression output, and plot the resulting data and polynomialfits.(b) Plot the polynomial fits for a range of different polynomialdegrees (say, from 1 to 10), and report the associated residualsum of squares.(c) Perform cross-validation or another approach to select the opti-mal degree for the polynomial, and explain your results.(d) Use thebs()function from theISLP.modelsmodule to fit a re-gression spline to predictnoxusingdis. Report the output forthe fit using four degrees of freedom. How did you choose theknots? Plot the resulting fit.(e) Now fit a regression spline for a range of degrees of freedom, andplot the resulting fits and report the resulting RSS. Describe theresults obtained.(f) Perform cross-validation or another approach in order", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 379, "start_word": 121280, "end_word": 121680, "chunk_words": 400}}, "ISLP_website::c000380": {"text": "of squares.(c) Perform cross-validation or another approach to select the opti-mal degree for the polynomial, and explain your results.(d) Use thebs()function from theISLP.modelsmodule to fit a re-gression spline to predictnoxusingdis. Report the output forthe fit using four degrees of freedom. How did you choose theknots? Plot the resulting fit.(e) Now fit a regression spline for a range of degrees of freedom, andplot the resulting fits and report the resulting RSS. Describe theresults obtained.(f) Perform cross-validation or another approach in order to selectthe best degrees of freedom for a regression spline on this data.Describe your results. 328 7. Moving Beyond Linearity 10. This question relates to the Collegedata set. (a) Splitthedataintoatrainingsetandatestset.Usingout-of-state tuition as the response and the other variables as the predictors, perform forward stepwise selection on the training set in order to identify a satisfactory model that uses just a subset of the predictors. (b) Fit a GAM on the training data, using out-of-state tuition as the response and the features selected in the previous step as the predictors. Plot the results, and explain your findings. (c) Evaluate the model obtained on the test set, and explain the results obtained. (d) For which variables, if any, is there evidence of a non-linear relationship with the response? 11. In Section 7.7, it was mentioned that GAMs are generally fit using abackfitting approach. The idea behind backfitting is actually quite simple. We will now explore backfitting in the context of multiple linear regression. Suppose that we would like to perform multiple linear regression, but we do not have software to do so. Instead, we only have software to perform simple linear regression. Therefore, we take the following iterative approach: we repeatedly hold all but one coefficient esti- mate fixed at its current value, and update only that coefficient estimateusingasimplelinearregression.Theprocessiscontinuedun- tilconvergence —that is, until the coefficient estimates stop changing. We now try this out on a toy example. (a) Generate a response Yand two predictors X1andX2, with n= 100 . (b) Write a function simple_reg() that takes two arguments outcome andfeature, fits a simple linear regression model with this out- come and feature, and returns the estimated interceptand slope. (c) Initialize beta1to take on a value of your choice. It does not matter what value you choose. (d) Keeping beta1fixed, use your function simple_reg() to fit the model: Y−beta1 ·X1=β0+β2X2+/epsilon1. Store the resulting values as beta0andbeta2. (e) Keeping beta2fixed, fit the model Y−beta2", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 380, "start_word": 121600, "end_word": 122000, "chunk_words": 400}}, "ISLP_website::c000381": {"text": "two predictors X1andX2, with n= 100 . (b) Write a function simple_reg() that takes two arguments outcome andfeature, fits a simple linear regression model with this out- come and feature, and returns the estimated interceptand slope. (c) Initialize beta1to take on a value of your choice. It does not matter what value you choose. (d) Keeping beta1fixed, use your function simple_reg() to fit the model: Y−beta1 ·X1=β0+β2X2+/epsilon1. Store the resulting values as beta0andbeta2. (e) Keeping beta2fixed, fit the model Y−beta2 ·X2=β0+β1X1+/epsilon1. Store the result as beta0andbeta1(overwriting their previous values). (f) Write a for loop to repeat (c) and (d) 1,000 times. Report the estimates of beta0,beta1, andbeta2at each iteration of the for loop. Create a plot in which each of these values is displayed, withbeta0,beta1, andbeta2. 7.9 Exercises 329(g) Compare your answer in (e) to the results of simply perform-ing multiple linear regression to predictYusingX1andX2.Useaxline()method to overlay those multiple linear regressioncoefficient estimates on the plot obtained in (e).(h) On this data set, how many backfitting iterations were requiredin order to obtain a “good” approximation to the multiple re-gression coefficient estimates?12. This problem is a continuation of the previous exercise. In a toyexample withp= 100, show that one can approximate the multiplelinearregressioncoefficientestimatesbyrepeatedlyperformingsimplelinear regression in a backfitting procedure. How many backfittingiterations are required in order to obtain a “good” approximation tothe multiple regression coefficient estimates? Create a plot to justifyyour answer. 8 Tree-Based Methods In this chapter, we describe tree-based methods for regression and classifi- cation. These involve stratifying orsegmenting the predictor space into a number of simple regions. In order to make a prediction for a given ob- servation, we typically use the mean or the mode response value for the training observations in the region to which it belongs. Since the set of splitting rules used to segment the predictor space can be summarized in a tree, these types of approaches are known as decision tree methods.decision treeTree-based methods are simple and useful for interpretation. However, they typically are not competitive with the best supervised learning ap- proaches, such as those seen in Chapters 6and7, in terms of prediction accuracy. Hence in this chapter we also introduce bagging,random forests , boosting, andBayesian additive regression trees . Each of these approaches involves producing multiple trees which are then combined to yield a single consensus prediction. We will see that combining a large number of trees can often result in dramatic improvements", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 381, "start_word": 121920, "end_word": 122320, "chunk_words": 400}}, "ISLP_website::c000382": {"text": "simple and useful for interpretation. However, they typically are not competitive with the best supervised learning ap- proaches, such as those seen in Chapters 6and7, in terms of prediction accuracy. Hence in this chapter we also introduce bagging,random forests , boosting, andBayesian additive regression trees . Each of these approaches involves producing multiple trees which are then combined to yield a single consensus prediction. We will see that combining a large number of trees can often result in dramatic improvements in prediction accuracy, at the expense of some loss in interpretation. 8.1 The Basics of Decision Trees Decisiontreescanbeappliedtobothregressionandclassificationproblems. We first consider regression problems, and then move on to classification. 8.1.1 Regression Trees In order to motivate regression trees , we begin with a simple example.regression tree © Springer Nature Switzerland AG 2023 G. James et al., An Introduction to Statistical Learning , Springer Texts in Statistics, https://doi.org/10.1007/978-3-031-38747-0_8 331 332 8. Tree-Based Methods|Years < 4.5 Hits < 117.55.116.006.74FIGURE 8.1. For the Hitters data, a regression tree for predicting the log salary of a baseball player, based on the number of years that he has played in the major leagues and the number of hits that he made in the previous year. At a given internal node, the label (of the form Xj<tk) indicates the left-hand branch emanating from that split, and the right-hand branch corresponds to Xj≥tk. For instance, the split at the top of the tree results in two large branches. The left-hand branch corresponds to Years<4.5 , and the right-hand branch corresponds toYears>=4.5 . The tree has two internal nodes and three terminal nodes, or leaves. The number in each leaf is the mean of the response for the observations that fall there. Predicting Baseball Players’ Salaries Using Regression Trees We use the Hittersdata set to predict a baseball player’s Salarybased on Years(the number of years that he has played in the major leagues) and Hits(thenumberofhitsthathemadeinthepreviousyear).Wefirstremove observations that are missing Salaryvalues, and log-transform Salaryso that its distribution has more of a typical bell-shape. (Recall that Salary is measured in thousands of dollars.) Figure8.1shows a regression tree fit to this data. It consists of a series of splitting rules, starting at the top of the tree. The top split assigns observations having Years<4.5 to the left branch.1The predicted salary for these players is given by the mean response value for the players in the data set with Years<4.5 . For", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 382, "start_word": 122240, "end_word": 122640, "chunk_words": 400}}, "ISLP_website::c000383": {"text": "missing Salaryvalues, and log-transform Salaryso that its distribution has more of a typical bell-shape. (Recall that Salary is measured in thousands of dollars.) Figure8.1shows a regression tree fit to this data. It consists of a series of splitting rules, starting at the top of the tree. The top split assigns observations having Years<4.5 to the left branch.1The predicted salary for these players is given by the mean response value for the players in the data set with Years<4.5 . For such players, the mean log salary is 5.107, and so we make a prediction of e5.107thousands of dollars, i.e. $165,174, for these players. Players with Years>=4.5 are assigned to the right branch, and then that group is further subdivided by Hits. Overall, the tree stratifies or segments the players into three regions of predictor space: players who have played for four or fewer years, players who have played for five or more years and who made fewer than 118 hits last year, and players who have playedforfiveormoreyearsandwhomadeatleast118hitslastyear.These three regions can be written as R1={X|Years<4.5 },R2={X|Years>=4.5 , Hits<117.5 }, andR3={X|Years>=4.5 ,Hits>=117.5 }. Figure 8.2illustrates 1BothYearsandHitsare integers in these data; the function used to fit this tree labels the splits at the midpoint between two adjacent values. 8.1 The Basics of Decision Trees 333 YearsHits 1117.5238 14.524R1R3R2FIGURE 8.2. The three-region partition for the Hitters data set from the regression tree illustrated in Figure 8.1. the regions as a function of YearsandHits. The predicted salaries for these three groups are $1,000 ×e5.107=$165,174, $1,000 ×e5.999=$402,834, and $1,000×e6.740=$845,346 respectively. Inkeepingwiththe treeanalogy,theregions R1,R2,andR3areknownas terminal nodes orleavesof the tree. As is the case for Figure 8.1, decisionterminal node leaftrees are typically drawn upside down , in the sense that the leaves are at the bottom of the tree. The points along the tree where the predictor space is split are referred to as internal nodes . In Figure 8.1, the two internalinternal nodenodes are indicated by the text Years<4.5 andHits<117.5 . We refer to the segments of the trees that connect the nodes as branches.branchWe might interpret the regression tree displayed in Figure 8.1as follows: Yearsis the most important factor in determining Salary, and players with less experience earn lower salaries than more experienced players. Given that a player is less experienced, the number of hits that he made in the previous year seems to play little role in his salary. But among players who have been", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 383, "start_word": 122560, "end_word": 122960, "chunk_words": 400}}, "ISLP_website::c000384": {"text": "text Years<4.5 andHits<117.5 . We refer to the segments of the trees that connect the nodes as branches.branchWe might interpret the regression tree displayed in Figure 8.1as follows: Yearsis the most important factor in determining Salary, and players with less experience earn lower salaries than more experienced players. Given that a player is less experienced, the number of hits that he made in the previous year seems to play little role in his salary. But among players who have been in the major leagues for five or more years, the number of hits made in the previous year does affect salary, and players who made more hits last year tend to have higher salaries. The regression tree shown in Figure8.1is likely an over-simplification of the true relationship between Hits,Years, andSalary. However, it has advantages over other types of regression models (such as those seen in Chapters 3and6): it is easier to interpret, and has a nice graphical representation. Prediction via Stratification of the Feature Space We now discuss the process of building a regression tree. Roughly speaking, there are two steps. 1. We divide the predictor space — that is, the set of possible values forX1,X2,...,X p— intoJdistinct and non-overlapping regions, R1,R2,...,R J. 334 8. Tree-Based Methods 2. For every observation that falls into the region Rj, we make the same prediction, which is simply the mean of the response values for the training observations in Rj. For instance, suppose that in Step 1 we obtain two regions, R1andR2, and that the response mean of the training observations in the first region is10, while the response mean of the training observations in the second region is 20. Then for a given observation X=x, ifx∈R1we will predict a value of 10, and ifx∈R2we will predict a value of 20. We now elaborate on Step 1 above. How do we construct the regions R1,...,R J? In theory, the regions could have any shape. However, we choose to divide the predictor space into high-dimensional rectangles, or boxes, for simplicity and for ease of interpretation of the resulting predic- tive model. The goal is to find boxes R1,...,R Jthat minimize the RSS, given by J/summationdisplay j=1/summationdisplay i∈Rj(yi−ˆyRj)2, (8.1) whereˆyRjis the mean response for the training observations within the jth box. Unfortunately, it is computationally infeasible to consider every possible partition of the feature space into Jboxes. For this reason, we take atop-down ,greedyapproachthatisknownas recursive", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 384, "start_word": 122880, "end_word": 123280, "chunk_words": 400}}, "ISLP_website::c000385": {"text": "shape. However, we choose to divide the predictor space into high-dimensional rectangles, or boxes, for simplicity and for ease of interpretation of the resulting predic- tive model. The goal is to find boxes R1,...,R Jthat minimize the RSS, given by J/summationdisplay j=1/summationdisplay i∈Rj(yi−ˆyRj)2, (8.1) whereˆyRjis the mean response for the training observations within the jth box. Unfortunately, it is computationally infeasible to consider every possible partition of the feature space into Jboxes. For this reason, we take atop-down ,greedyapproachthatisknownas recursive binary splitting .Therecursive binary splittingapproachis top-down becauseitbeginsatthetopofthetree(atwhichpoint all observations belong to a single region) and then successively splits the predictor space; each split is indicated via two new branches further down on the tree. It is greedybecause at each step of the tree-building process, thebestsplit is made at that particular step, rather than looking ahead and picking a split that will lead to a better tree in some future step. In order to perform recursive binary splitting, we first select the pre- dictorXjand the cutpoint ssuch that splitting the predictor space into the regions {X|Xj<s}and{X|Xj≥s}leads to the greatest possible reduction in RSS. (The notation {X|Xj<s}meansthe region of predictor space in which Xjtakes on a value less than s.) That is, we consider all predictors X1,...,X p, and all possible values of the cutpoint sfor each of the predictors, and then choose the predictor and cutpoint such that the resulting tree has the lowest RSS. In greater detail, for any jands,w e define the pair of half-planes R1(j, s)={X|Xj<s}andR2(j, s)={X|Xj≥s}, (8.2) and we seek the value of jandsthat minimize the equation /summationdisplay i:xi∈R1(j,s)(yi−ˆyR1)2+/summationdisplay i:xi∈R2(j,s)(yi−ˆyR2)2, (8.3) whereˆyR1is the mean response for the training observations in R1(j, s), andˆyR2is the mean response for the training observations in R2(j, s). Finding the values of jandsthat minimize ( 8.3) can be done quite quickly, especially when the number of features pis not too large. Next, we repeat the process, looking for the best predictor and best cutpoint in order to split the data further so as to minimize the RSS within 8.1 The Basics of Decision Trees 335 |t1t2t3t4 R1R1 R2R2 R3R3 R4R4 R5R5 X1X1X1 X2X2X2 X1≤t1X2≤t2X1≤t3X2≤t4FIGURE 8.3. Top Left: A partition of two-dimensional feature space that could not result from recursive binary splitting. Top Right: The output of recursive binary splitting on a two-dimensional example. Bottom Left: A tree corresponding to the partition in the top right panel. Bottom Right: A perspective plot of", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 385, "start_word": 123200, "end_word": 123600, "chunk_words": 400}}, "ISLP_website::c000386": {"text": "best cutpoint in order to split the data further so as to minimize the RSS within 8.1 The Basics of Decision Trees 335 |t1t2t3t4 R1R1 R2R2 R3R3 R4R4 R5R5 X1X1X1 X2X2X2 X1≤t1X2≤t2X1≤t3X2≤t4FIGURE 8.3. Top Left: A partition of two-dimensional feature space that could not result from recursive binary splitting. Top Right: The output of recursive binary splitting on a two-dimensional example. Bottom Left: A tree corresponding to the partition in the top right panel. Bottom Right: A perspective plot of the prediction surface corresponding to that tree. each of the resulting regions. However, this time, instead of splitting the entire predictor space, we split one of the two previously identified regions. Wenowhavethreeregions.Again,welooktosplitoneofthesethreeregions further, so as to minimize the RSS. The process continues until a stopping criterion is reached; for instance, we may continue until no region contains more than five observations. Once the regions R1,...,R Jhave been created, we predict the response for a given test observation using the mean of the training observations in the region to which that test observation belongs. A five-region example of this approach is shown in Figure 8.3. Tree Pruning The process described above may produce good predictions on the training set, but is likely to overfit the data, leading to poor test set performance. This is because the resulting tree might be too complex. A smaller tree 336 8. Tree-Based Methods with fewer splits (that is, fewer regions R1,...,R J) might lead to lower variance and better interpretation at the cost of a little bias. One possible alternative to the process described above is to build the tree only so long as the decrease in the RSS due to each split exceeds some (high) threshold. This strategy will result in smaller trees, but is too short-sighted since a seemingly worthless split early on in the tree might be followed by a very good split—that is, a split that leads to a large reduction in RSS later on. Therefore, a better strategy is to grow a very large tree T0, and then pruneit back in order to obtain a subtree. How do we determine the bestprune subtreeway to prune the tree? Intuitively, our goal is to select a subtree that leads to the lowest test error rate. Given a subtree, we can estimate its test error using cross-validation or the validation set approach. However, estimatingthecross-validationerrorforeverypossiblesubtreewouldbetoo cumbersome, since there is an extremely large number of", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 386, "start_word": 123520, "end_word": 123920, "chunk_words": 400}}, "ISLP_website::c000387": {"text": "in RSS later on. Therefore, a better strategy is to grow a very large tree T0, and then pruneit back in order to obtain a subtree. How do we determine the bestprune subtreeway to prune the tree? Intuitively, our goal is to select a subtree that leads to the lowest test error rate. Given a subtree, we can estimate its test error using cross-validation or the validation set approach. However, estimatingthecross-validationerrorforeverypossiblesubtreewouldbetoo cumbersome, since there is an extremely large number of possible subtrees. Instead, we need a way to select a small set of subtrees for consideration. Cost complexity pruning —also known as weakest link pruning —gives uscost complexity pruning weakest link pruninga way to do just this. Rather than considering every possible subtree, we consider a sequence of trees indexed by a nonnegative tuning parameter α. For each value of αthere corresponds a subtree T⊂T0such that |T|/summationdisplay m=1/summationdisplay i:xi∈Rm(yi−ˆyRm)2+α|T| (8.4) is as small as possible. Here |T|indicates the number of terminal nodes of the tree T,Rmis the rectangle (i.e. the subset of predictor space) cor- responding to the mth terminal node, and ˆyRmis the predicted response associated with Rm—that is, the mean of the training observations in Rm. The tuning parameter αcontrols a trade-off between the subtree’s com- plexity and its fit to the training data. When α=0, then the subtree T will simply equal T0, because then ( 8.4) just measures the training error. However, as αincreases, there is a price to pay for having a tree with many terminal nodes, and so the quantity ( 8.4) will tend to be minimized for a smaller subtree. Equation 8.4is reminiscent of the lasso ( 6.7) from Chapter 6, in which a similar formulation was used in order to control the complexity of a linear model. It turns out that as we increase αfrom zero in ( 8.4), branches get pruned from the tree in a nested and predictable fashion, so obtaining the whole sequence of subtrees as a function of αis easy. We can select a value of αusing a validation set or using cross-validation. We then return to the full data set and obtain the subtree corresponding to α. This process is summarized in Algorithm 8.1. Figures8.4and8.5display the results of fitting and pruning a regression tree on the Hittersdata, using nine of the features. First, we randomly divided the data set in half, yielding 132 observations in the training", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 387, "start_word": 123840, "end_word": 124240, "chunk_words": 400}}, "ISLP_website::c000388": {"text": "obtaining the whole sequence of subtrees as a function of αis easy. We can select a value of αusing a validation set or using cross-validation. We then return to the full data set and obtain the subtree corresponding to α. This process is summarized in Algorithm 8.1. Figures8.4and8.5display the results of fitting and pruning a regression tree on the Hittersdata, using nine of the features. First, we randomly divided the data set in half, yielding 132 observations in the training set and 131 observations in the test set. We then built a large regression tree on the training data and varied αin (8.4) in order to create subtrees with different numbers of terminal nodes. Finally, we performed six-fold cross- validation in order to estimate the cross-validated MSE of the trees as 8.1 The Basics of Decision Trees 337 Algorithm 8.1 Building a Regression Tree 1. Use recursive binary splitting to grow a large tree on the training data, stopping only when each terminal node has fewer than some minimum number of observations. 2. Apply cost complexity pruning to the large tree in order to obtain a sequence of best subtrees, as a function of α. 3. Use K-fold cross-validation to choose α. That is, divide the training observations into Kfolds. For each k=1,...,K : (a) Repeat Steps 1 and 2 on all but the kth fold of the training data. (b) Evaluate the mean squared prediction error on the data in the left-outkth fold, as a function of α. Average the results for each value of α, and pick αto minimize the average error. 4. Return the subtree from Step 2 that corresponds to the chosen value ofα. a function of α. (We chose to perform six-fold cross-validation because 132 is an exact multiple of six.) The unpruned regression tree is shown in Figure 8.4. The green curve in Figure 8.5shows the CV error as a function of the number of leaves,2while the orange curve indicates the test error. Also shown are standard error bars around the estimated errors. For reference, the training error curve is shown in black. The CV error is a reasonable approximation of the test error: the CV error takes on its minimum for a three-node tree, while the test error also dips down at the three-node tree (though it takes on its lowest value at the ten-node tree). The pruned tree containing three terminal nodes", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 388, "start_word": 124160, "end_word": 124560, "chunk_words": 400}}, "ISLP_website::c000389": {"text": "of leaves,2while the orange curve indicates the test error. Also shown are standard error bars around the estimated errors. For reference, the training error curve is shown in black. The CV error is a reasonable approximation of the test error: the CV error takes on its minimum for a three-node tree, while the test error also dips down at the three-node tree (though it takes on its lowest value at the ten-node tree). The pruned tree containing three terminal nodes is shown in Figure 8.1. 8.1.2 Classification Trees Aclassification tree is very similar to a regression tree, except that it isclassification treeused to predict a qualitative response rather than a quantitative one. Re- call that for a regression tree, the predicted response for an observation is given by the mean response of the training observations that belong to the same terminal node. In contrast, for a classification tree, we predict that each observation belongs to the most commonly occurring class of training observations in the region to which it belongs. In interpreting the results of a classification tree, we are often interested not only in the class prediction corresponding to a particular terminal node region, but also in the class proportions among the training observations that fall into that region. The task of growing a classification tree is quite similar to the task of growing a regression tree. Just as in the regression setting, we use recursive 2Although CV error is computed as a function of α, it is convenient to display the result as a function of |T|, the number of leaves; this is based on the relationship between αand|T|in the original tree grown to all the training data. 338 8. Tree-Based Methods|Years < 4.5 RBI < 60.5Putouts < 82Years < 3.5Years < 3.5Hits < 117.5 Walks < 43.5Runs < 47.5Walks < 52.5RBI < 80.5Years < 6.55.4874.622 5.1835.394 6.1896.015 5.5716.4076.5496.459 7.0077.289FIGURE 8.4.Regression tree analysis for theHittersdata. The unpruned treethat results from top-down greedy splitting on the training data is shown.binary splitting to grow a classification tree. However, in the classificationsetting, RSS cannot be used as a criterion for making the binary splits.A natural alternative to RSS is theclassification error rate. Since we planclassificationerror rateto assign an observation in a given region to themost commonly occurringclassof training observations in that region, the classification error rate issimply the fraction of the training observations in that region that do notbelong to the", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 389, "start_word": 124480, "end_word": 124880, "chunk_words": 400}}, "ISLP_website::c000390": {"text": "results from top-down greedy splitting on the training data is shown.binary splitting to grow a classification tree. However, in the classificationsetting, RSS cannot be used as a criterion for making the binary splits.A natural alternative to RSS is theclassification error rate. Since we planclassificationerror rateto assign an observation in a given region to themost commonly occurringclassof training observations in that region, the classification error rate issimply the fraction of the training observations in that region that do notbelong to the most common class:E=1−maxk(ˆpmk).(8.5)Hereˆpmkrepresents the proportion of training observations in themthregion that are from thekth class. However, it turns out that classificationerror is not sufficiently sensitive for tree-growing, and in practice two othermeasures are preferable.TheGini indexis defined byGini indexG=K/summationdisplayk=1ˆpmk(1−ˆpmk),(8.6)a measure of total variance across theKclasses. It is not hard to seethat the Gini index takes on a small value if all of theˆpmk’s are close tozero or one. For this reason the Gini index is referred to as a measure of 8.1 The Basics of Decision Trees 339 2468100.0 0.2 0.4 0.6 0.8 1.0Tree SizeMean Squared ErrorTrainingCross−ValidationTest FIGURE 8.5. Regression tree analysis for the Hitters data. The training, cross-validation, and test MSE are shown as a function of the number of terminal nodes in the pruned tree. Standard error bands are displayed. The minimum cross-validation error occurs at a tree size of three. nodepurity—a small value indicates that a node contains predominantly observations from a single class. An alternative to the Gini index is entropy, given byentropy D=−K/summationdisplay k=1ˆpmklog ˆpmk. (8.7) Since0≤ˆpmk≤1, it follows that 0≤−ˆpmklog ˆpmk. One can show that the entropy will take on a value near zero if the ˆpmk’s are all near zero or near one. Therefore, like the Gini index, the entropy will take on a small value if the mth node is pure. In fact, it turns out that the Gini index and the entropy are quite similar numerically. When building a classification tree, either the Gini index or the entropy are typically used to evaluate the quality of a particular split, since these two approaches are more sensitive to node purity than is the classification error rate. Any of these three approaches might be used when pruningthe tree, but the classification error rate is preferable if prediction accuracy of the final pruned tree is the goal. Figure8.6shows an example on the Heartdata set. These data con- tain a binary outcome HDfor 303 patients who", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 390, "start_word": 124800, "end_word": 125200, "chunk_words": 400}}, "ISLP_website::c000391": {"text": "the Gini index or the entropy are typically used to evaluate the quality of a particular split, since these two approaches are more sensitive to node purity than is the classification error rate. Any of these three approaches might be used when pruningthe tree, but the classification error rate is preferable if prediction accuracy of the final pruned tree is the goal. Figure8.6shows an example on the Heartdata set. These data con- tain a binary outcome HDfor 303 patients who presented with chest pain. An outcome value of Yesindicates the presence of heart disease based on an angiographic test, while Nomeans no heart disease. There are 13 predic- tors including Age,Sex,Chol(a cholesterol measurement), and other heart and lung function measurements. Cross-validation results in a tree with six terminal nodes. In our discussion thus far, we have assumed that the predictor vari- ables take on continuous values. However, decision trees can be constructed even in the presence of qualitative predictor variables. For instance, in the Heartdata, some of the predictors, such as Sex,Thal(Thallium stress test), 340 8. Tree-Based Methods|Thal:a Ca < 0.5MaxHR < 161.5RestBP < 157Chol < 244MaxHR < 156MaxHR < 145.5ChestPain:bcChol < 244 Sex < 0.5Ca < 0.5Slope < 1.5Age < 52Thal:bChestPain:aOldpeak < 1.1RestECG < 1No YesNoNoYesNoNo NoNo YesYes NoNoNoYesYes YesYes 510150.0 0.1 0.2 0.3 0.4 0.5 0.6Tree SizeErrorTrainingCross−ValidationTest|Thal:a Ca < 0.5MaxHR < 161.5ChestPain:bcCa < 0.5 No NoNo YesYes YesFIGURE 8.6. Heartdata.Top:The unpruned tree. Bottom Left: Cross-valida- tion error, training, and test error, for different sizes of the pruned tree. Bottom Right:The pruned tree corresponding to the minimal cross-validation error. andChestPain , are qualitative. Therefore, a split on one of these variables amounts to assigning some of the qualitative values to one branch and assigning the remaining to the other branch. In Figure 8.6, some of the in- ternal nodes correspond to splitting qualitative variables. For instance, the top internal node corresponds to splitting Thal. The text Thal:aindicates that the left-hand branch coming out of that node consists of observations with the first value of the Thalvariable (normal), and the right-hand node consists of the remaining observations (fixed or reversible defects). The text ChestPain:bc twosplitsdownthetreeontheleftindicatesthattheleft-hand branch coming out of that node consists of observations with the second and third values of the ChestPain variable, where the possible values are typical angina, atypical angina, non-anginal pain, and asymptomatic. Figure8.6has a surprising characteristic: some of the splits yield two terminal nodes that", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 391, "start_word": 125120, "end_word": 125520, "chunk_words": 400}}, "ISLP_website::c000392": {"text": "left-hand branch coming out of that node consists of observations with the first value of the Thalvariable (normal), and the right-hand node consists of the remaining observations (fixed or reversible defects). The text ChestPain:bc twosplitsdownthetreeontheleftindicatesthattheleft-hand branch coming out of that node consists of observations with the second and third values of the ChestPain variable, where the possible values are typical angina, atypical angina, non-anginal pain, and asymptomatic. Figure8.6has a surprising characteristic: some of the splits yield two terminal nodes that have the same predicted value . For instance, consider the split RestECG<1 near the bottom right of the unpruned tree. Regardless of the value of RestECG, a response value of Yesis predicted for those ob- 8.1 The Basics of Decision Trees 341 servations. Why, then, is the split performed at all? The split is performed because it leads to increased node purity . That is, all 9 of the observations corresponding to the right-hand leaf have a response value of Yes, whereas 7/11of those corresponding to the left-hand leaf have a response value of Yes. Why is node purity important? Suppose that we have a test obser- vation that belongs to the region given by that right-hand leaf. Then we can be pretty certain that its response value is Yes. In contrast, if a test observation belongs to the region given by the left-hand leaf, then its re- sponse value is probably Yes, but we are much less certain. Even though the split RestECG<1 does not reduce the classification error, it improves the Gini index and the entropy, which are more sensitive to node purity. 8.1.3 Trees Versus Linear Models Regressionandclassificationtreeshaveaverydifferentflavorfromthemore classicalapproachesforregressionandclassificationpresentedinChapters 3 and4. In particular, linear regression assumes a model of the form f(X)=β0+p/summationdisplay j=1Xjβj, (8.8) whereas regression trees assume a model of the form f(X)=M/summationdisplay m=1cm·1(X∈Rm) (8.9) whereR1,...,R Mrepresent a partition of feature space, as in Figure 8.3. Which model is better? It depends on the problem at hand. If the re- lationship between the features and the response is well approximated by a linear model as in ( 8.8), then an approach such as linear regression will likely work well, and will outperform a method such as a regression tree that does not exploit this linear structure. If instead there is a highly non- linear and complex relationship between the features and the response as indicated by model ( 8.9), then decision trees may outperform classical ap-", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 392, "start_word": 125440, "end_word": 125840, "chunk_words": 400}}, "ISLP_website::c000393": {"text": "hand. If the re- lationship between the features and the response is well approximated by a linear model as in ( 8.8), then an approach such as linear regression will likely work well, and will outperform a method such as a regression tree that does not exploit this linear structure. If instead there is a highly non- linear and complex relationship between the features and the response as indicated by model ( 8.9), then decision trees may outperform classical ap- proaches. An illustrative example is displayed in Figure 8.7. The relative performances of tree-based and classical approaches can be assessed by es- timating the test error, using either cross-validation or the validation set approach (Chapter 5). Of course, other considerations beyond simply test error may come into play in selecting a statistical learning method; for instance, in certain set- tings, prediction using a tree may be preferred for the sake of interpretabil- ity and visualization. 8.1.4 Advantages and Disadvantages of Trees Decision trees for regression and classification have a number of advantages over the more classical approaches seen in Chapters 3and4: LTrees are very easy to explain to people. In fact, they are even easier to explain than linear regression! 342 8. Tree-Based Methods −2 −1 0 1 2−2 −1 0 1 2X1X2 −2 −1 0 1 2−2 −1 0 1 2X1X2 −2 −1 0 1 2−2 −1 0 1 2X1X2 −2 −1 0 1 2−2 −1 0 1 2X1X2 FIGURE 8.7.Top Row:A two-dimensional classification example in which thetrue decision boundary is linear, and is indicated by the shaded regions. A classicalapproach that assumes a linear boundary (left) will outperform a decision treethat performs splits parallel to the axes (right).Bottom Row:Here the true de-cision boundary is non-linear. Here a linear model is unable to capture the truedecision boundary (left), whereas a decision tree is successful (right).LSome people believe that decision trees more closely mirror humandecision-making than do the regression and classification approachesseen in previous chapters.LTrees can be displayed graphically, and are easily interpreted even bya non-expert (especially if they are small).LTrees can easily handle qualitative predictors without the need tocreate dummy variables.MUnfortunately, trees generally do not have the same level of predictiveaccuracy as some of the other regression and classification approachesseen in this book.MAdditionally, trees can be very non-robust. In other words, a smallchange in the data can cause a large change in the final estimatedtree.However,byaggregatingmanydecisiontrees,usingmethodslikebagging,random forests, andboosting, the predictive", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 393, "start_word": 125760, "end_word": 126160, "chunk_words": 400}}, "ISLP_website::c000394": {"text": "classification approachesseen in previous chapters.LTrees can be displayed graphically, and are easily interpreted even bya non-expert (especially if they are small).LTrees can easily handle qualitative predictors without the need tocreate dummy variables.MUnfortunately, trees generally do not have the same level of predictiveaccuracy as some of the other regression and classification approachesseen in this book.MAdditionally, trees can be very non-robust. In other words, a smallchange in the data can cause a large change in the final estimatedtree.However,byaggregatingmanydecisiontrees,usingmethodslikebagging,random forests, andboosting, the predictive performance of trees can besubstantially improved. We introduce these concepts in the next section. 8.2Bagging,RandomForests,Boosting,andBayesianAdditiveRegressionTrees 343 8.2 Bagging, Random Forests, Boosting, and Bayesian Additive Regression Trees Anensemble method is an approach that combines many simple “buildingensembleblock” models in order to obtain a single and potentially very powerful model. These simple building block models are sometimes known as weak learners, since they may lead to mediocre predictions on their own.weak learnersWe will now discuss bagging, random forests, boosting, and Bayesian additive regression trees. These are ensemble methods for which the simple building block is a regression or a classification tree. 8.2.1 Bagging The bootstrap, introduced in Chapter 5, is an extremely powerful idea. It is used in many situations in which it is hard or even impossible to directly compute the standard deviation of a quantity of interest. We see here that the bootstrap can be used in a completely different context, in order to improve statistical learning methods such as decision trees. The decision trees discussed in Section 8.1suffer from high variance . This means that if we split the training data into two parts at random, and fit a decision tree to both halves, the results that we get could be quite different. In contrast, a procedure with low variance will yield similar results if applied repeatedly to distinct data sets; linear regression tends to have low variance, if the ratio of ntopis moderately large. Bootstrap aggregation , orbagging, is a general-purpose procedure for reducing thebaggingvariance of a statistical learning method; we introduce it here because it is particularly useful and frequently used in the context of decision trees. Recall that given a set of nindependent observations Z1,...,Z n, each with variance σ2, the variance of the mean ¯Zof the observations is given byσ2/n. In other words, averaging a set of observations reduces variance . Hence a natural way to reduce the variance and increase the test set ac-", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 394, "start_word": 126080, "end_word": 126480, "chunk_words": 400}}, "ISLP_website::c000395": {"text": "is a general-purpose procedure for reducing thebaggingvariance of a statistical learning method; we introduce it here because it is particularly useful and frequently used in the context of decision trees. Recall that given a set of nindependent observations Z1,...,Z n, each with variance σ2, the variance of the mean ¯Zof the observations is given byσ2/n. In other words, averaging a set of observations reduces variance . Hence a natural way to reduce the variance and increase the test set ac- curacy of a statistical learning method is to take many training sets from the population, build a separate prediction model using each training set, and average the resulting predictions. In other words, we could calculate ˆf1(x),ˆf2(x),..., ˆfB(x)usingBseparate training sets, and average them in order to obtain a single low-variance statistical learning model, given by ˆfavg(x)=1 BB/summationdisplay b=1ˆfb(x). Of course, this is not practical because we generally do not have access to multiple training sets. Instead, we can bootstrap, by taking repeated samples from the (single) training data set. In this approach we generate Bdifferent bootstrapped training data sets. We then train our method on thebth bootstrapped training set in order to get ˆf∗b(x), and finally average all the predictions, to obtain ˆfbag(x)=1 BB/summationdisplay b=1ˆf∗b(x). 344 8. Tree-Based Methods 0 50 100 150 200 250 3000.100.150.200.250.30 Number of TreesError Test: BaggingTest: RandomForestOOB: BaggingOOB: RandomForestFIGURE 8.8. Bagging and random forest results for the Heartdata. The test error (black and orange) is shown as a function of B, the number of bootstrapped training sets used. Random forests were applied with m=√p. The dashed line indicates the test error resulting from a single classification tree. The green and blue traces show the OOB error, which in this case is — by chance — considerably lower. This is called bagging. While bagging can improve predictions for many regression methods, it is particularly useful for decision trees. To apply bagging to regression trees,wesimplyconstruct Bregressiontreesusing Bbootstrappedtraining sets, and average the resulting predictions. These trees are grown deep, and are not pruned. Hence each individual tree has high variance, but low bias. Averaging these Btrees reduces the variance. Bagging has been demonstrated to give impressive improvements in accuracy by combining together hundreds or even thousands of trees into a single procedure. Thus far, we have described the bagging procedure in the regression context,topredictaquantitativeoutcome Y.Howcanbaggingbeextended to a classification problem where Yis qualitative? In that situation, there areafewpossibleapproaches,butthesimplestisasfollows.Foragiventest observation, we", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 395, "start_word": 126400, "end_word": 126800, "chunk_words": 400}}, "ISLP_website::c000396": {"text": "and average the resulting predictions. These trees are grown deep, and are not pruned. Hence each individual tree has high variance, but low bias. Averaging these Btrees reduces the variance. Bagging has been demonstrated to give impressive improvements in accuracy by combining together hundreds or even thousands of trees into a single procedure. Thus far, we have described the bagging procedure in the regression context,topredictaquantitativeoutcome Y.Howcanbaggingbeextended to a classification problem where Yis qualitative? In that situation, there areafewpossibleapproaches,butthesimplestisasfollows.Foragiventest observation, we can record the class predicted by each of the Btrees, and take amajority vote : the overall prediction is the most commonly occurringmajority voteclass among the Bpredictions. Figure8.8shows the results from bagging trees on the Heartdata. The test error rate is shown as a function of B, the number of trees constructed using bootstrapped training data sets. We see that the bagging test error rate is slightly lower in this case than the test error rate obtained from a single tree. The number of trees Bis not a critical parameter with bagging; using a very large value of Bwill not lead to overfitting. In practice we 8.2Bagging,RandomForests,Boosting,andBayesianAdditiveRegressionTrees 345 use a value of Bsufficiently large that the error has settled down. Using B= 100 is sufficient to achieve good performance in this example. Out-of-Bag Error Estimation It turns out that there is a very straightforward way to estimate the test error of a bagged model, without the need to perform cross-validation or the validation set approach. Recall that the key to bagging is that trees are repeatedly fit to bootstrapped subsets of the observations. One can show that on average, each bagged tree makes use of around two-thirds of the observations.3The remaining one-third of the observations not used to fit a given bagged tree are referred to as the out-of-bag (OOB) observations. Weout-of-bagcan predict the response for the ith observation using each of the trees in which that observation was OOB. This will yield around B/3predictions for theith observation. In order to obtain a single prediction for the ith observation, we can average these predicted responses (if regression is the goal) or can take a majority vote (if classification is the goal). This leads to a single OOB prediction for the ith observation. An OOB prediction can be obtained in this way for each of the nobservations, from which the overall OOB MSE (for a regression problem) or classification error (for", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 396, "start_word": 126720, "end_word": 127120, "chunk_words": 400}}, "ISLP_website::c000397": {"text": "This will yield around B/3predictions for theith observation. In order to obtain a single prediction for the ith observation, we can average these predicted responses (if regression is the goal) or can take a majority vote (if classification is the goal). This leads to a single OOB prediction for the ith observation. An OOB prediction can be obtained in this way for each of the nobservations, from which the overall OOB MSE (for a regression problem) or classification error (for a classificationproblem)canbecomputed.TheresultingOOBerrorisavalid estimate of the test error for the bagged model, since the response for each observation is predicted using only the trees that were not fit using that observation. Figure 8.8displays the OOB error on the Heartdata. It can be shown that with Bsufficiently large, OOB error is virtually equivalent to leave-one-out cross-validation error. The OOB approach for estimating the test error is particularly convenient when performing bagging on large data sets for which cross-validation would be computationally onerous. Variable Importance Measures As we have discussed, bagging typically results in improved accuracy over prediction using a single tree. Unfortunately, however, it can be difficult to interpret the resulting model. Recall that one of the advantages of decision trees is the attractive and easily interpreted diagram that results, such as the one displayed in Figure 8.1. However, when we bag a large number of trees, it is no longer possible to represent the resulting statistical learning procedure using a single tree, and it is no longer clear which variables are most important to the procedure. Thus, bagging improves prediction accuracy at the expense of interpretability. Althoughthecollectionofbaggedtreesismuchmoredifficulttointerpret than a single tree, one can obtain an overall summary of the importance of eachpredictorusingtheRSS(forbaggingregressiontrees)ortheGiniindex (for bagging classification trees). In the case of bagging regression trees, we can record the total amount that the RSS ( 8.1) is decreased due to splits over a given predictor, averaged over all Btrees. A large value indicates an important predictor. Similarly, in the context of bagging classification 3This relates to Exercise 2of Chapter 5. 346 8. Tree-Based Methods ThalCaChestPainOldpeakMaxHRRestBPAgeCholSlopeSexExAngRestECGFbs 0 20 40 60 80 100Variable ImportanceFIGURE 8.9. A variable importance plot for the Heartdata. Variable impor- tance is computed using the mean decrease in Gini index, and expressed relative to the maximum. trees, we can add up the total amount that the Gini index ( 8.6) is decreased by splits over a given predictor, averaged over all", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 397, "start_word": 127040, "end_word": 127440, "chunk_words": 400}}, "ISLP_website::c000398": {"text": "an important predictor. Similarly, in the context of bagging classification 3This relates to Exercise 2of Chapter 5. 346 8. Tree-Based Methods ThalCaChestPainOldpeakMaxHRRestBPAgeCholSlopeSexExAngRestECGFbs 0 20 40 60 80 100Variable ImportanceFIGURE 8.9. A variable importance plot for the Heartdata. Variable impor- tance is computed using the mean decrease in Gini index, and expressed relative to the maximum. trees, we can add up the total amount that the Gini index ( 8.6) is decreased by splits over a given predictor, averaged over all Btrees. A graphical representation of the variable importances in theHeartdatavariable importanceisshowninFigure 8.9.WeseethemeandecreaseinGiniindexforeachvari- able, relative to the largest. The variables with the largest mean decrease in Gini index are Thal,Ca, andChestPain . 8.2.2 Random Forests Random forests provide an improvement over bagged trees by way of arandom forestsmall tweak that decorrelates the trees. As in bagging, we build a number ofdecisiontreesonbootstrappedtrainingsamples.Butwhenbuildingthese decision trees, each time a split in a tree is considered, a random sample of mpredictors is chosen as split candidates from the full set of ppredictors. The split is allowed to use only one of those mpredictors. A fresh sample of mpredictors is taken at each split, and typically we choose m≈√p—that is, the number of predictors considered at each split is approximately equal to the square root of the total number of predictors (4 out of the 13 for the Heartdata). In other words, in building a random forest, at each split in the tree, the algorithm is not even allowed to consider a majority of the available predictors. This may sound crazy, but it has a clever rationale. Suppose that there is one very strong predictor in the data set, along with a num- ber of other moderately strong predictors. Then in the collection of bagged trees, most or all of the trees will use this strong predictor in the top split. Consequently, all of the bagged trees will look quite similar to each other. 8.2Bagging,RandomForests,Boosting,andBayesianAdditiveRegressionTrees 347 Hence the predictions from the bagged trees will be highly correlated. Un- fortunately, averaging many highly correlated quantities does not lead to as large of a reduction in variance as averaging many uncorrelated quan- tities. In particular, this means that bagging will not lead to a substantial reduction in variance over a single tree in this setting. Random forests overcome this problem by forcing each split to consider only a subset of the predictors. Therefore, on average (p−m)/pof the splits", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 398, "start_word": 127360, "end_word": 127760, "chunk_words": 400}}, "ISLP_website::c000399": {"text": "Hence the predictions from the bagged trees will be highly correlated. Un- fortunately, averaging many highly correlated quantities does not lead to as large of a reduction in variance as averaging many uncorrelated quan- tities. In particular, this means that bagging will not lead to a substantial reduction in variance over a single tree in this setting. Random forests overcome this problem by forcing each split to consider only a subset of the predictors. Therefore, on average (p−m)/pof the splits will not even consider the strong predictor, and so other predictors will have more of a chance. We can think of this process as decorrelating the trees, thereby making the average of the resulting trees less variable and hence more reliable. The main difference between bagging and random forests is the choice of predictor subset size m. For instance, if a random forest is built using m=p, then this amounts simply to bagging. On the Heartdata, random forests using m=√pleads to a reduction in both test error and OOB error over bagging (Figure 8.8). Using a small value of min building a random forest will typically be helpful when we have a large number of correlated predictors. We applied random forests to a high-dimensional biological data set consisting of ex- pression measurements of 4,718 genes measured on tissue samples from 349 patients. There are around 20,000 genes in humans, and individual genes have different levels of activity, or expression, in particular cells, tissues, and biological conditions. In this data set, each of the patient samples has a qualitative label with 15 different levels: either normal or 1 of 14 different types of cancer. Our goal was to use random forests to predict cancer type based on the 500genes that have the largest variance in the training set. We randomly divided the observations into a training and a test set, and applied random forests to the training set for three different values of the number of splitting variables m. The results are shown in Figure 8.10. The error rate of a single tree is 45.7%, and the null rate is 75.4%.4We see that using400trees is sufficient to give good performance, and that the choice m=√pgave a small improvement in test error over bagging ( m=p) in this example. As with bagging, random forests will not overfit if we increase B, so in practice we use a value of Bsufficiently large for", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 399, "start_word": 127680, "end_word": 128080, "chunk_words": 400}}, "ISLP_website::c000400": {"text": "values of the number of splitting variables m. The results are shown in Figure 8.10. The error rate of a single tree is 45.7%, and the null rate is 75.4%.4We see that using400trees is sufficient to give good performance, and that the choice m=√pgave a small improvement in test error over bagging ( m=p) in this example. As with bagging, random forests will not overfit if we increase B, so in practice we use a value of Bsufficiently large for the error rate to have settled down. 8.2.3 Boosting We now discuss boosting, yet another approach for improving the predic-boostingtions resulting from a decision tree. Like bagging, boosting is a general approach that can be applied to many statistical learning methods for re- gression or classification. Here we restrict our discussion of boosting to the context of decision trees. Recallthatbagginginvolvescreatingmultiplecopiesoftheoriginaltrain- ing data set using the bootstrap, fitting a separate decision tree to each copy, and then combining all of the trees in order to create a single predic- 4The null rate results from simply classifying each observation to the dominant class overall, which is in this case the normal class. 348 8. Tree-Based Methods 0 100 200 300 400 5000.2 0.3 0.4 0.5Number of TreesTest Classification Errorm=pm=p/2m=p FIGURE 8.10. Results from random forests for the 15-class gene expression data set with p= 500 predictors. The test error is displayed as a function of the number of trees. Each colored line corresponds to a different value of m, the number of predictors available for splitting at each interior tree node. Random forests ( m<p ) lead to a slight improvement over bagging ( m=p). A single classification tree has an error rate of 45.7%. tive model. Notably, each tree is built on a bootstrap data set, independent of the other trees. Boosting works in a similar way, except that the trees are grownsequentially : each tree is grown using information from previously grown trees. Boosting does not involve bootstrap sampling; instead each tree is fit on a modified version of the original data set. Considerfirsttheregressionsetting.Likebagging,boostinginvolvescom- bining a large number of decision trees, ˆf1,..., ˆfB. Boosting is described in Algorithm 8.2. What is the idea behind this procedure? Unlike fitting a single large deci- sion tree to the data, which amounts to fitting the data hard and potentially overfitting, the boosting approach instead learns slowly . Given the current model, we fit", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 400, "start_word": 128000, "end_word": 128400, "chunk_words": 400}}, "ISLP_website::c000401": {"text": "previously grown trees. Boosting does not involve bootstrap sampling; instead each tree is fit on a modified version of the original data set. Considerfirsttheregressionsetting.Likebagging,boostinginvolvescom- bining a large number of decision trees, ˆf1,..., ˆfB. Boosting is described in Algorithm 8.2. What is the idea behind this procedure? Unlike fitting a single large deci- sion tree to the data, which amounts to fitting the data hard and potentially overfitting, the boosting approach instead learns slowly . Given the current model, we fit a decision tree to the residuals from the model. That is, we fit a tree using the current residuals, rather than the outcome Y, as the re- sponse. We then add this new decision tree into the fitted function in order to update the residuals. Each of these trees can be rather small, with just a few terminal nodes, determined by the parameter din the algorithm. By fitting small trees to the residuals, we slowly improve ˆfin areas where it does not perform well. The shrinkage parameter λslows the process down even further, allowing more and different shaped trees to attack the resid- uals. In general, statistical learning approaches that learn slowly tend to perform well. Note that in boosting, unlike in bagging, the construction of each tree depends strongly on the trees that have already been grown. We have just described the process of boosting regression trees. Boosting classification trees proceeds in a similar but slightly more complex way, and the details are omitted here. 8.2Bagging,RandomForests,Boosting,andBayesianAdditiveRegressionTrees 349 Algorithm 8.2 Boosting for Regression Trees 1. Setˆf(x)=0 andri=yifor alliin the training set. 2. Forb=1,2,...,B , repeat: (a) Fit a tree ˆfbwithdsplits (d+1terminal nodes) to the training data(X,r). (b) Update ˆfby adding in a shrunken version of the new tree: ˆf(x)←ˆf(x)+λˆfb(x). (8.10) (c) Update the residuals, ri←ri−λˆfb(xi). (8.11) 3. Output the boosted model, ˆf(x)=B/summationdisplay b=1λˆfb(x). (8.12) Boosting has three tuning parameters: 1. The number of trees B. Unlike bagging and random forests, boosting can overfit if Bis too large, although this overfitting tends to occur slowly if at all. We use cross-validation to select B. 2. The shrinkage parameter λ, a small positive number. This controls therateatwhichboostinglearns.Typicalvaluesare 0.01or0.001,and the right choice can depend on the problem. Very small λcan require using a very large value of Bin order to achieve good performance. 3. The number dof splits in each tree, which controls the complexity of the boosted ensemble. Often d=1works well, in", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 401, "start_word": 128320, "end_word": 128720, "chunk_words": 400}}, "ISLP_website::c000402": {"text": "boosting can overfit if Bis too large, although this overfitting tends to occur slowly if at all. We use cross-validation to select B. 2. The shrinkage parameter λ, a small positive number. This controls therateatwhichboostinglearns.Typicalvaluesare 0.01or0.001,and the right choice can depend on the problem. Very small λcan require using a very large value of Bin order to achieve good performance. 3. The number dof splits in each tree, which controls the complexity of the boosted ensemble. Often d=1works well, in which case each tree is a stump, consisting of a single split. In this case, the boostedstumpensemble is fitting an additive model, since each term involves only a single variable. More generally dis theinteraction depth , and controlsinteraction depththe interaction order of the boosted model, since dsplits can involve at mostdvariables. InFigure 8.11,weappliedboostingtothe15-classcancergeneexpression data set, in order to develop a classifier that can distinguish the normal class from the 14 cancer classes. We display the test error as a function of the total number of trees and the interaction depth d. We see that simple stumps with an interaction depth of one perform well if enough of them are included. This model outperforms the depth-two model, and both out- perform a random forest. This highlights one difference between boosting and random forests: in boosting, because the growth of a particular tree takes into account the other trees that have already been grown, smaller 350 8. Tree-Based Methods 0 1000 2000 3000 4000 50000.05 0.10 0.15 0.20 0.25Number of TreesTest Classification ErrorBoosting: depth=1Boosting: depth=2RandomForest: m=p FIGURE 8.11.Results from performing boosting and random forests on the15-class gene expressiondata set in order to predictcancerversusnormal. The testerror is displayed as a function of the number of trees. For the two boosted models,λ=0.01. Depth-1 trees slightly outperform depth-2 trees, and both outperformthe random forest, although the standard errors are around 0.02, making none ofthese differences significant. The test error rate for a single tree is 24%.trees are typically sufficient. Using smaller trees can aid in interpretabilityas well; for instance, using stumps leads to an additive model.8.2.4 Bayesian Additive Regression TreesFinally, we discussBayesian additive regression trees(BART), another en-Bayesianadditiveregressiontreessemblemethodthatusesdecisiontreesasitsbuildingblocks.Forsimplicity,we present BART for regression (as opposed to classification).Recall that bagging and random forests make predictions from an aver-age of regression trees, each of which is built using a random sample of dataand/or predictors. Each tree is built separately from the others. By con-trast, boosting uses a weighted sum", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 402, "start_word": 128640, "end_word": 129040, "chunk_words": 400}}, "ISLP_website::c000403": {"text": "24%.trees are typically sufficient. Using smaller trees can aid in interpretabilityas well; for instance, using stumps leads to an additive model.8.2.4 Bayesian Additive Regression TreesFinally, we discussBayesian additive regression trees(BART), another en-Bayesianadditiveregressiontreessemblemethodthatusesdecisiontreesasitsbuildingblocks.Forsimplicity,we present BART for regression (as opposed to classification).Recall that bagging and random forests make predictions from an aver-age of regression trees, each of which is built using a random sample of dataand/or predictors. Each tree is built separately from the others. By con-trast, boosting uses a weighted sum of trees, each of which is constructedby fitting a tree to the residual of the current fit. Thus, each new tree at-tempts to capture signal that is not yet accounted for by the current setof trees. BART is related to both approaches: each tree is constructed ina random manner as in bagging and random forests, and each tree tries tocapture signal not yet accounted for by the current model, as in boosting.The main novelty in BART is the way in which new trees are generated.Before we introduce the BART algorithm, we define some notation. WeletKdenote the number of regression trees, andBthe number of iterationsfor which the BART algorithm will be run. The notationˆfbk(x)representsthe prediction atxfor thekth regression tree used in thebth iteration. Atthe end of each iteration, theKtrees from that iteration will be summed,i.e.ˆfb(x)=/summationtextKk=1ˆfbk(x)forb=1,...,B.In the first iteration of the BART algorithm, all trees are initialized tohaveasinglerootnode,withˆf1k(x)=1nK/summationtextni=1yi,themeanoftheresponse 8.2Bagging,RandomForests,Boosting,andBayesianAdditiveRegressionTrees 351 (a):ˆfb−1 k(X) (b): Possibility #1 for ˆfb k(X)|X < 169.17X < 114.305X < 140.35−0.5031 0.2667 −0.2470 0.4079|X < 169.17X < 114.305X < 140.35−0.5110 0.2693 −0.2649 0.4221(c): Possibility #2 for ˆfb k(X) (d): Possibility #3 for ˆfb k(X)|X < 169.17 −0.1218 0.4079|X < 169.17X < 114.305X < 106.755X < 140.35−0.05089 −1.03100 0.26670 −0.24700 0.40790FIGURE 8.12. A schematic of perturbed trees from the BART algorithm. (a): Thekth tree at the (b−1)st iteration, ˆfb−1 k(X), is displayed. Panels (b)–(d) display three of many possibilities for ˆfb k(X), given the form of ˆfb−1 k(X).(b):One possibility is that ˆfb k(X)has the same structure as ˆfb−1 k(X), but with different predictions at the terminal nodes. (c):Another possibility is that ˆfb k(X)results from pruning ˆfb−1 k(X).(d):Alternatively, ˆfb k(X)may have more terminal nodes thanˆfb−1 k(X). values divided by the total number of trees. Thus, ˆf1(x)=/summationtextK k=1ˆf1 k(x)= 1 n/summationtextn i=1yi. In subsequent iterations, BART updates each of the Ktrees, one at a time. In the bth iteration, to update the kth tree, we subtract from each response value the predictions", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 403, "start_word": 128960, "end_word": 129360, "chunk_words": 400}}, "ISLP_website::c000404": {"text": "that ˆfb k(X)has the same structure as ˆfb−1 k(X), but with different predictions at the terminal nodes. (c):Another possibility is that ˆfb k(X)results from pruning ˆfb−1 k(X).(d):Alternatively, ˆfb k(X)may have more terminal nodes thanˆfb−1 k(X). values divided by the total number of trees. Thus, ˆf1(x)=/summationtextK k=1ˆf1 k(x)= 1 n/summationtextn i=1yi. In subsequent iterations, BART updates each of the Ktrees, one at a time. In the bth iteration, to update the kth tree, we subtract from each response value the predictions from all but the kth tree, in order to obtain apartial residual ri=yi−/summationdisplay k/prime<kˆfb k/prime(xi)−/summationdisplay k/prime>kˆfb−1 k/prime(xi) for theith observation, i=1,...,n . Rather than fitting a fresh tree to this partial residual, BART randomly chooses a perturbation to the tree from the previous iteration ( ˆfb−1 k) from a set of possible perturbations, favoring ones that improve the fit to the partial residual. There are two components to this perturbation: 1. Wemaychangethestructureofthetreebyaddingorpruningbranches. 2. We may change the prediction in each terminal node of the tree. Figure8.12illustrates examples of possible perturbations to a tree. The output of BART is a collection of prediction models, ˆfb(x)=K/summationdisplay k=1ˆfb k(x),forb=1,2,...,B. 352 8. Tree-Based Methods Algorithm 8.3 Bayesian Additive Regression Trees 1. Letˆf1 1(x)=ˆf1 2(x)=···=ˆf1 K(x)=1 nK/summationtextn i=1yi. 2. Compute ˆf1(x)=/summationtextK k=1ˆf1 k(x)=1 n/summationtextn i=1yi. 3. Forb=2,...,B : (a) Fork=1,2,...,K : i. Fori=1,...,n , compute the current partial residual ri=yi−/summationdisplay k/prime<kˆfb k/prime(xi)−/summationdisplay k/prime>kˆfb−1 k/prime(xi). ii. Fit a new tree, ˆfb k(x), tori, by randomly perturbing the kth tree from the previous iteration, ˆfb−1 k(x). Perturbations that improve the fit are favored. (b) Compute ˆfb(x)=/summationtextK k=1ˆfb k(x). 4. Compute the mean after Lburn-in samples, ˆf(x)=1 B−LB/summationdisplay b=L+1ˆfb(x). We typically throw away the first few of these prediction models, since models obtained in the earlier iterations — known as the burn-inperiodburn-in— tend not to provide very good results. We can let Ldenote the num- ber of burn-in iterations; for instance, we might take L= 200 . Then, to obtain a single prediction, we simply take the average after the burn-in iterations, ˆf(x)=1 B−L/summationtextB b=L+1ˆfb(x). However, it is also possible to com- pute quantities other than the average: for instance, the percentiles of ˆfL+1(x),..., ˆfB(x)provide a measure of uncertainty in the final predic- tion. The overall BART procedure is summarized in Algorithm 8.3. A key element of the BART approach is that in Step 3(a)ii., we do notfit a fresh tree to the current partial residual: instead, we", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 404, "start_word": 129280, "end_word": 129680, "chunk_words": 400}}, "ISLP_website::c000405": {"text": "to obtain a single prediction, we simply take the average after the burn-in iterations, ˆf(x)=1 B−L/summationtextB b=L+1ˆfb(x). However, it is also possible to com- pute quantities other than the average: for instance, the percentiles of ˆfL+1(x),..., ˆfB(x)provide a measure of uncertainty in the final predic- tion. The overall BART procedure is summarized in Algorithm 8.3. A key element of the BART approach is that in Step 3(a)ii., we do notfit a fresh tree to the current partial residual: instead, we try to improve the fit to the current partial residual by slightly modifying the tree obtained in the previous iteration (see Figure 8.12). Roughly speaking, this guards against overfitting since it limits how “hard” we fit the data in each iteration. Furthermore, the individual trees are typically quite small. We limit the tree size in order to avoid overfitting the data, which would be more likely to occur if we grew very large trees. Figure8.13shows the result of applying BART to the Heartdata, using K= 200 trees, as the number of iterations is increased to 10,000. During the initial iterations, the test and training errors jump around a bit. After this initial burn-in period, the error rates settle down. We note that there is only a small difference between the training error and the test error, indicating that the tree perturbation process largely avoids overfitting. 8.2Bagging,RandomForests,Boosting,andBayesianAdditiveRegressionTrees 353 5 10 50 100 50050000.0 0.1 0.2 0.3 0.4 0.5Number of IterationsErrorBART Training ErrorBART Test ErrorBoosting Training ErrorBoosting Test Error FIGURE 8.13. BART and boosting results for the Heartdata. Both training and test errors are displayed. After a burn-in period of 100iterations (shown in gray), the error rates for BART settle down. Boosting begins to overfit after a few hundred iterations. ThetrainingandtesterrorsforboostingarealsodisplayedinFigure 8.13. We see that the test error for boosting approaches that of BART, but then begins to increase as the number of iterations increases. Furthermore, the training error for boosting decreases as the number of iterations increases, indicating that boosting has overfit the data. Though the details are outside of the scope of this book, it turns out that the BART method can be viewed as a Bayesian approach to fitting an ensemble of trees: each time we randomly perturb a tree in order to fit the residuals, we are in fact drawing a new tree from a posterior distribution. (Of course, this Bayesian connection is the motivation for BART’s name.)", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 405, "start_word": 129600, "end_word": 130000, "chunk_words": 400}}, "ISLP_website::c000406": {"text": "as the number of iterations increases, indicating that boosting has overfit the data. Though the details are outside of the scope of this book, it turns out that the BART method can be viewed as a Bayesian approach to fitting an ensemble of trees: each time we randomly perturb a tree in order to fit the residuals, we are in fact drawing a new tree from a posterior distribution. (Of course, this Bayesian connection is the motivation for BART’s name.) Furthermore, Algorithm 8.3can be viewed as a Markov chain Monte CarloMarkov chain Monte Carloalgorithm for fitting the BART model. WhenweapplyBART,wemustselectthenumberoftrees K,thenumber ofiterations B,andthenumberofburn-initerations L.Wetypicallychoose largevaluesfor BandK,andamoderatevaluefor L:forinstance, K= 200 , B=1,000, andL= 100 is a reasonable choice. BART has been shown to have very impressive out-of-box performance — that is, it performs well with minimal tuning. 8.2.5 Summary of Tree Ensemble Methods Trees are an attractive choice of weak learner for an ensemble method for a number of reasons, including their flexibility and ability to handle 354 8. Tree-Based Methodspredictors of mixed types (i.e. qualitative as well as quantitative). We havenow seen four approaches for fitting an ensemble of trees: bagging, randomforests, boosting, and BART.• Inbagging, the trees are grown independently on random samples ofthe observations. Consequently, the trees tend to be quite similar toeach other. Thus, bagging can get caught in local optima and can failto thoroughly explore the model space.• Inrandom forests, the trees are once again grown independently onrandom samples of the observations. However, each split on each treeis performed using a random subset of the features, thereby decorre-lating the trees, and leading to a more thorough exploration of modelspace relative to bagging.• Inboosting, we only use the original data, and do not draw any ran-dom samples. The trees are grown successively, using a “slow” learn-ing approach: each new tree is fit to the signal that is left over fromthe earlier trees, and shrunken down before it is used.• InBART, we once again only make use of the original data, and wegrow the trees successively. However, each tree is perturbed in orderto avoid local minima and achieve a more thorough exploration ofthe model space.8.3 Lab: Tree-Based MethodsWe import some of our usual libraries at this top level.In[1]:import numpy as npimport pandas as pdfrom matplotlib.pyplot import subplotsfrom statsmodels.datasets import get_rdatasetimport sklearn.model_selection as skmfrom ISLP import load_data, confusion_tablefrom ISLP.models import ModelSpec as MSWe also collect the new imports needed", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 406, "start_word": 129920, "end_word": 130320, "chunk_words": 400}}, "ISLP_website::c000407": {"text": "is used.• InBART, we once again only make use of the original data, and wegrow the trees successively. However, each tree is perturbed in orderto avoid local minima and achieve a more thorough exploration ofthe model space.8.3 Lab: Tree-Based MethodsWe import some of our usual libraries at this top level.In[1]:import numpy as npimport pandas as pdfrom matplotlib.pyplot import subplotsfrom statsmodels.datasets import get_rdatasetimport sklearn.model_selection as skmfrom ISLP import load_data, confusion_tablefrom ISLP.models import ModelSpec as MSWe also collect the new imports needed for this lab.In[2]:from sklearn.tree import (DecisionTreeClassifier as DTC,DecisionTreeRegressor as DTR,plot_tree,export_text)from sklearn.metrics import (accuracy_score,log_loss)from sklearn.ensemble import \\(RandomForestRegressor as RF,GradientBoostingRegressor as GBR)from ISLP.bart import BART 8.3 Lab: Tree-Based Methods 355 8.3.1 Fitting Classification Trees We first use classification trees to analyze the Carseats data set. In these data,Salesis a continuous variable, and so we begin by recoding it as a binary variable. We use the where()function to create a variable, calledwhere()High, which takes on a value of Yesif theSalesvariable exceeds 8, and takes on a value of Nootherwise. In[3]: Carseats = load_data( 'Carseats' ) High = np.where(Carseats.Sales > 8, \"Yes\", \"No\") We now use DecisionTreeClassifier() to fit a classification tree in orderDecisionTree Classifier() to predict Highusing all variables but Sales. To do so, we must form a model matrix as we did when fitting regression models. In[4]: model = MS(Carseats.columns.drop( 'Sales' ), intercept=False) D=m o d e l . f i t _ t r a n s f o r m ( C a r s e a t s ) feature_names = list(D.columns) X=n p . a s a r r a y ( D ) We have converted Dfrom a data frame to an array X, which is needed in some of the analysis below. We also need the feature_names for annotating our plots later. Thereareseveraloptionsneededtospecifytheclassifier,suchas max_depth (how deep to grow the tree), min_samples_split (minimum number of ob- servations in a node to be eligible for splitting) and criterion (whether to use Gini or cross-entropy as the split criterion). We also set random_state for reproducibility; ties in the split criterion are broken at random. In[5]: clf = DTC(criterion= 'entropy' , max_depth=3, random_state=0) clf.fit(X, High) Out[5]: DecisionTreeClassifier(criterion= 'entropy' ,m a x _ d e p t h = 3 ) In our discussion of qualitative features in Section 3.3, we noted that for a linear regression model such a feature could be represented by including a matrix of dummy variables", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 407, "start_word": 130240, "end_word": 130640, "chunk_words": 400}}, "ISLP_website::c000408": {"text": "(whether to use Gini or cross-entropy as the split criterion). We also set random_state for reproducibility; ties in the split criterion are broken at random. In[5]: clf = DTC(criterion= 'entropy' , max_depth=3, random_state=0) clf.fit(X, High) Out[5]: DecisionTreeClassifier(criterion= 'entropy' ,m a x _ d e p t h = 3 ) In our discussion of qualitative features in Section 3.3, we noted that for a linear regression model such a feature could be represented by including a matrix of dummy variables (one-hot-encoding) in the model matrix, using the formula notation of statsmodels . As mentioned in Section 8.1, there is a more natural way to handle qualitative features when building a decision tree, that does not require such dummy variables; each split amounts to partitioning the levels into two groups. However, the sklearnimplementa- tion of decision trees does not take advantage of this approach; instead it simply treats the one-hot-encoded levels as separate variables. In[6]: accuracy_score(High, clf.predict(X)) Out[6]: 0.7275 With only the default arguments, the training error rate is 21%. For clas- sification trees, we can access the value of the deviance using log_loss() ,log_loss() 356 8. Tree-Based Methods −2/summationdisplay m/summationdisplay knmklog ˆpmk, wherenmkis the number of observations in the mth terminal node that belong to the kth class. In[7]: resid_dev = np.sum(log_loss(High, clf.predict_proba(X))) resid_dev Out[7]: 0.4711 This is closely related to the entropy, defined in ( 8.7). A small deviance indicates a tree that provides a good fit to the (training) data. One of the most attractive properties of trees is that they can be graphi- callydisplayed.Hereweusethe plot()functiontodisplaythetreestructure (not shown here). In[8]: ax = subplots(figsize=(12,12))[1] plot_tree(clf, feature_names=feature_names, ax=ax); The most important indicator of Salesappears to be ShelveLoc . We can see a text representation of the tree using export_text() , whichexport_text()displays the split criterion (e.g. Price <= 92.5 ) for each branch. For leaf nodesitshowstheoverallprediction( YesorNo).Wecanalsoseethenumber of observations in that leaf that take on values of YesandNoby specifying show_weights=True . In[9]: print(export_text(clf, feature_names=feature_names, show_weights=True)) Out[9]: |--- ShelveLoc[Good] <= 0.50 || - - - P r i c e < = 9 2 . 5 0 ||| - - - I n c o m e < = 5 7 . 0 0 |||| - - - w e i g h t s : [ 7 . 0 0 , 3 . 0 0 ] c l a s s : N o ||| - - - I n c", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 408, "start_word": 130560, "end_word": 130960, "chunk_words": 400}}, "ISLP_website::c000409": {"text": "In[9]: print(export_text(clf, feature_names=feature_names, show_weights=True)) Out[9]: |--- ShelveLoc[Good] <= 0.50 || - - - P r i c e < = 9 2 . 5 0 ||| - - - I n c o m e < = 5 7 . 0 0 |||| - - - w e i g h t s : [ 7 . 0 0 , 3 . 0 0 ] c l a s s : N o ||| - - - I n c o m e > 5 7 . 0 0 |||| - - - w e i g h t s : [ 7 . 0 0 , 2 9 . 0 0 ] c l a s s : Y e s || - - - P r i c e > 9 2 . 5 0 ||| - - - A d v e r t i s i n g < = 1 3 . 5 0 |||| - - - w e i g h t s : [ 1 8 3 . 0 0 , 4 1 . 0 0 ] c l a s s : N o ||| - - - A d v e r t i s i n g > 1 3 . 5 0 |||| - - - w e i g h t s : [ 2 0 . 0 0 , 2 5 . 0 0 ] c l a s s : Y e s |--- ShelveLoc[Good] > 0.50 || - - - P r i c e < = 1 3 5 . 0 0 ||| - - - U S [ Y e s ] < = 0 . 5 0 |||| - - - w e i g h t s : [ 6 . 0 0 , 1 1 . 0 0 ] c l a s s : Y e s ||| - - - U S [ Y e s ] > 0 . 5 0 |||| - - - w e i g h t s : [ 2 . 0 0 , 4 9 . 0 0 ] c l a s s : Y e s || - - - P r i c e > 1 3 5 . 0 0 ||| - - - I n c o m e < = 4 6 . 0", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 409, "start_word": 130880, "end_word": 131280, "chunk_words": 400}}, "ISLP_website::c000410": {"text": "- - - U S [ Y e s ] > 0 . 5 0 |||| - - - w e i g h t s : [ 2 . 0 0 , 4 9 . 0 0 ] c l a s s : Y e s || - - - P r i c e > 1 3 5 . 0 0 ||| - - - I n c o m e < = 4 6 . 0 0 |||| - - - w e i g h t s : [ 6 . 0 0 , 0 . 0 0 ] c l a s s : N o ||| - - - I n c o m e > 4 6 . 0 0 |||| - - - w e i g h t s : [ 5 . 0 0 , 6 . 0 0 ] c l a s s : Y e s 8.3 Lab: Tree-Based Methods 357 In order to properly evaluate the performance of a classification tree on these data, we must estimate the test error rather than simply computing the training error. We split the observations into a training set and a test set, build the tree using the training set, and evaluate its performance on the test data. This pattern is similar to that in Chapter 6, with the linear models replaced here by decision trees — the code for validation is almost identical. This approach leads to correct predictions for 68.5% of the locations in the test data set. In[10]: validation = skm.ShuffleSplit(n_splits=1, test_size=200, random_state=0) results = skm.cross_validate(clf, D, High, cv=validation) results[ 'test_score' ] Out[10]: array([0.685]) Next, we consider whether pruning the tree might lead to improved clas- sification performance. We first split the data into a training and test set. We will use cross-validation to prune the tree on the training set, and then evaluate the performance of the pruned tree on the test set. In[11]: (X_train, X_test, High_train, High_test) = skm.train_test_split(X, High, test_size=0.5, random_state=0) We first refit the full tree on the training set; here we do not set a max_depth parameter, since we will learn that through cross-validation. In[12]: clf = DTC(criterion= 'entropy' ,r a n d o m _ s t a t e = 0 ) clf.fit(X_train, High_train) accuracy_score(High_test, clf.predict(X_test)) Out[12]: 0.735 Next we use the cost_complexity_pruning_path() method of clfto extractcost_ complexity_ pruning_", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 410, "start_word": 131200, "end_word": 131600, "chunk_words": 400}}, "ISLP_website::c000411": {"text": "of the pruned tree on the test set. In[11]: (X_train, X_test, High_train, High_test) = skm.train_test_split(X, High, test_size=0.5, random_state=0) We first refit the full tree on the training set; here we do not set a max_depth parameter, since we will learn that through cross-validation. In[12]: clf = DTC(criterion= 'entropy' ,r a n d o m _ s t a t e = 0 ) clf.fit(X_train, High_train) accuracy_score(High_test, clf.predict(X_test)) Out[12]: 0.735 Next we use the cost_complexity_pruning_path() method of clfto extractcost_ complexity_ pruning_ path()cost-complexity values. In[13]: ccp_path = clf.cost_complexity_pruning_path(X_train, High_train) kfold = skm.KFold(10, random_state=1, shuffle=True) This yields a set of impurities and αvalues from which we can extract an optimal one by cross-validation. In[14]: grid = skm.GridSearchCV(clf, {'ccp_alpha' :c c p _ p a t h . c c p _ a l p h a s } , refit=True, 358 8. Tree-Based Methodscv=kfold,scoring='accuracy')grid.fit(X_train, High_train)grid.best_score_Out[14]:0.685Let’s take a look at the pruned true.In[15]:ax = subplots(figsize=(12, 12))[1]best_ = grid.best_estimator_plot_tree(best_,feature_names=feature_names,ax=ax);Thisisquiteabushytree.Wecouldcounttheleaves,orquerybest_instead.In[16]:best_.tree_.n_leavesOut[16]:30The tree with 30 terminal nodes results in the lowest cross-validation errorrate, with an accuracy of 68.5%. How well does this pruned tree performon the test data set? Once again, we apply thepredict()function.In[17]:print(accuracy_score(High_test,best_.predict(X_test)))confusion = confusion_table(best_.predict(X_test),High_test)confusionOut[17]:0.72Truth No YesPredictedNo 108 61Yes 10 21Now 72.0% of the test observations are correctly classified, which isslightly worse than the error for the full tree (with 35 leaves). So cross-validation has not helped us much here; it only pruned off 5 leaves, ata cost of a slightly worse error. These results would change if we were tochange the random number seeds above; even though cross-validation givesan unbiased approach to model selection, it does have variance.8.3.2 Fitting Regression TreesHere we fit a regression tree to theBostondata set. The steps are similarto those for classification trees.In[18]:Boston = load_data(\"Boston\")model = MS(Boston.columns.drop('medv'), intercept=False)D=m o d e l . f i t _ t r a n s f o r m ( B o s t o n )feature_names = list(D.columns)X=n p . a s a r r a y ( D ) 8.3 Lab: Tree-Based Methods 359First, we split the data into training and test sets, and fit the tree to thetraining data. Here we use 30% of the data for the test set.In[19]:(X_train,X_test,y_train,y_test) = skm.train_test_split(X,Boston['medv'],test_size=0.3,random_state=0)Having formed our training and test data sets, we fit the regression tree.In[20]:reg = DTR(max_depth=3)reg.fit(X_train, y_train)ax = subplots(figsize=(12,12))[1]plot_tree(reg,feature_names=feature_names,ax=ax);The variablelstatmeasures the percentage of individuals with lowersocioeconomic status. The tree indicates that lower values oflstatcorre-spond to more expensive houses. The tree predicts a", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 411, "start_word": 131520, "end_word": 131920, "chunk_words": 400}}, "ISLP_website::c000412": {"text": "r a y ( D ) 8.3 Lab: Tree-Based Methods 359First, we split the data into training and test sets, and fit the tree to thetraining data. Here we use 30% of the data for the test set.In[19]:(X_train,X_test,y_train,y_test) = skm.train_test_split(X,Boston['medv'],test_size=0.3,random_state=0)Having formed our training and test data sets, we fit the regression tree.In[20]:reg = DTR(max_depth=3)reg.fit(X_train, y_train)ax = subplots(figsize=(12,12))[1]plot_tree(reg,feature_names=feature_names,ax=ax);The variablelstatmeasures the percentage of individuals with lowersocioeconomic status. The tree indicates that lower values oflstatcorre-spond to more expensive houses. The tree predicts a median house priceof $12,042 for small-sized homes (rm < 6.8), in suburbs in which residentshave low socioeconomic status (lstat > 14.4) and the crime-rate is mod-erate (crim > 5.8).Now we use the cross-validation function to see whether pruning the treewill improve performance.In[21]:ccp_path = reg.cost_complexity_pruning_path(X_train, y_train)kfold = skm.KFold(5,shuffle=True,random_state=10)grid = skm.GridSearchCV(reg,{'ccp_alpha':c c p _ p a t h . c c p _ a l p h a s } ,refit=True,cv=kfold,scoring='neg_mean_squared_error')G=g r i d . f i t ( X _ t r a i n ,y _ t r a i n )In keeping with the cross-validation results, we use the pruned tree tomake predictions on the test set.In[22]:best_ = grid.best_estimator_np.mean((y_test - best_.predict(X_test))**2)Out[22]:28.07In other words, the test set MSE associated with the regression tree is28.07. The square root of the MSE is therefore around 5.30, indicating thatthis model leads to test predictions that are within around $5300 of thetrue median home value for the suburb.Let’s plot the best tree to see how interpretable it is.In[23]:ax = subplots(figsize=(12,12))[1]plot_tree(G.best_estimator_,feature_names=feature_names,ax=ax); 360 8. Tree-Based Methods8.3.3 Bagging and Random ForestsHere we apply bagging and random forests to theBostondata, using theRandomForestRegressor()from thesklearn.ensemblepackage. Recall thatRandomForestRegressor()sklearn.ensemblebagging is simply a special case of a random forest withm=p. Therefore,theRandomForestRegressor()function can be used to perform both baggingand random forests. We start with bagging.In[24]:bag_boston = RF(max_features=X_train.shape[1], random_state=0)bag_boston.fit(X_train, y_train)Out[24]:RandomForestRegressor(max_features=12, random_state=0)The argumentmax_featuresindicates that all 12 predictors should beconsidered for each split of the tree — in other words, that bagging shouldbe done. How well does this bagged model perform on the test set?In[25]:ax = subplots(figsize=(8,8))[1]y_hat_bag = bag_boston.predict(X_test)ax.scatter(y_hat_bag, y_test)np.mean((y_test - y_hat_bag)**2)Out[25]:14.63The test set MSE associated with the bagged regression tree is 14.63, abouthalf that obtained using an optimally-pruned single tree. We could changethenumberoftreesgrownfromthedefaultof100byusingthen_estimatorsargument:In[26]:bag_boston = RF(max_features=X_train.shape[1],n_estimators=500,random_state=0).fit(X_train, y_train)y_hat_bag = bag_boston.predict(X_test)np.mean((y_test - y_hat_bag)**2)Out[26]:14.61There is not much change. Bagging and random forests cannot overfit byincreasing the number of trees, but can underfit if the number is too small.Growing a random forest proceeds in exactly the same way, exceptthat we use", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 412, "start_word": 131840, "end_word": 132240, "chunk_words": 400}}, "ISLP_website::c000413": {"text": "this bagged model perform on the test set?In[25]:ax = subplots(figsize=(8,8))[1]y_hat_bag = bag_boston.predict(X_test)ax.scatter(y_hat_bag, y_test)np.mean((y_test - y_hat_bag)**2)Out[25]:14.63The test set MSE associated with the bagged regression tree is 14.63, abouthalf that obtained using an optimally-pruned single tree. We could changethenumberoftreesgrownfromthedefaultof100byusingthen_estimatorsargument:In[26]:bag_boston = RF(max_features=X_train.shape[1],n_estimators=500,random_state=0).fit(X_train, y_train)y_hat_bag = bag_boston.predict(X_test)np.mean((y_test - y_hat_bag)**2)Out[26]:14.61There is not much change. Bagging and random forests cannot overfit byincreasing the number of trees, but can underfit if the number is too small.Growing a random forest proceeds in exactly the same way, exceptthat we use a smaller value of themax_featuresargument. By default,RandomForestRegressor()usespvariables when building a random forest ofregression trees (i.e. it defaults to bagging), andRandomForestClassifier()uses√pvariableswhenbuildingarandomforestofclassificationtrees.Herewe usemax_features=6.In[27]:RF_boston = RF(max_features=6,random_state=0).fit(X_train, y_train)y_hat_RF = RF_boston.predict(X_test)np.mean((y_test - y_hat_RF)**2)Out[27]:20.04The test set MSE is 20.04; this indicates that random forests did some-what worse than bagging in this case. Extracting thefeature_importances_values from the fitted model, we can view the importance of each variable. 8.3 Lab: Tree-Based Methods 361 In[28]: feature_imp = pd.DataFrame( {'importance' :RF_boston.feature_importances_}, index=feature_names) feature_imp.sort_values(by= 'importance' ,a s c e n d i n g = F a l s e ) Out[28]: importance lstat 0.368683 rm 0.333842 ptratio 0.057306 indus 0.053303 crim 0.052426 dis 0.042493 nox 0.034410 age 0.024327 tax 0.022368 rad 0.005048 zn 0.003238 chas 0.002557 Thisisarelativemeasure ofthetotaldecrease innodeimpuritythat results from splits over that variable, averaged over all trees (this was plotted in Figure8.9for a model fit to the Heartdata). The results indicate that across all of the trees considered in the random forest, the wealth level of the community ( lstat) and the house size ( rm) are by far the two most important variables. 8.3.4 Boosting Here we use GradientBoostingRegressor() fromsklearn.ensemble to fitGradient Boosting Regressor()boosted regression trees to the Bostondata set. For classification we would useGradientBoostingClassifier() . The argument n_estimators=5000 indi- Gradient Boosting Classifier()cates that we want 5000 trees, and the option max_depth=3 limits the depth of each tree. The argument learning_rate is theλmentioned earlier in the description of boosting. In[29]: boost_boston = GBR(n_estimators=5000, learning_rate=0.001, max_depth=3, random_state=0) boost_boston.fit(X_train, y_train) We can see how the training error decreases with the train_score_ at- tribute. To get an idea of how the test error decreases we can use the staged_predict() method to get the predicted values along the path. In[30]: test_error = np.zeros_like(boost_boston.train_score_) for idx, y_ in enumerate(boost_boston.staged_predict(X_test)): test_error[idx] = np.mean((y_test - y_)**2) plot_idx = np.arange(boost_boston.train_score_.shape[0]) ax = subplots(figsize=(8,8))[1] ax.plot(plot_idx, boost_boston.train_score_, 'b', label='Training' ) 362 8. Tree-Based Methods ax.plot(plot_idx, test_error, 'r', label='Test') ax.legend(); We now use the boosted model to predict", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 413, "start_word": 132160, "end_word": 132560, "chunk_words": 400}}, "ISLP_website::c000414": {"text": "y_train) We can see how the training error decreases with the train_score_ at- tribute. To get an idea of how the test error decreases we can use the staged_predict() method to get the predicted values along the path. In[30]: test_error = np.zeros_like(boost_boston.train_score_) for idx, y_ in enumerate(boost_boston.staged_predict(X_test)): test_error[idx] = np.mean((y_test - y_)**2) plot_idx = np.arange(boost_boston.train_score_.shape[0]) ax = subplots(figsize=(8,8))[1] ax.plot(plot_idx, boost_boston.train_score_, 'b', label='Training' ) 362 8. Tree-Based Methods ax.plot(plot_idx, test_error, 'r', label='Test') ax.legend(); We now use the boosted model to predict medvon the test set: In[31]: y_hat_boost = boost_boston.predict(X_test); np.mean((y_test - y_hat_boost)**2) Out[31]: 14.48 The test MSE obtained is 14.48, similar to the test MSE for bagging. If we want to, we can perform boosting with a different value of the shrinkage parameter λin(8.10).Thedefaultvalueis0.001,butthisiseasilymodified. Here we take λ=0.2. In[32]: boost_boston = GBR(n_estimators=5000, learning_rate=0.2, max_depth=3, random_state=0) boost_boston.fit(X_train, y_train) y_hat_boost = boost_boston.predict(X_test); np.mean((y_test - y_hat_boost)**2) Out[32]: 14.50 In this case, using λ=0.2leads to a almost the same test MSE as when usingλ=0.001. 8.3.5 Bayesian Additive Regression Trees In this section we demonstrate a Pythonimplementation of BART found in theISLP.bart package. We fit a model to the Bostonhousing data set. This BART()estimator is designed for quantitative outcome variables, thoughBART()other implementations are available for fitting logistic and probit models to categorical outcomes. In[33]: bart_boston = BART(random_state=0, burnin=5, ndraw=15) bart_boston.fit(X_train, y_train) Out[33]: BART(burnin=5, ndraw=15, random_state=0) On this data set, with this split into test and training, we see that the test error of BART is similar to that of random forest. In[34]: yhat_test = bart_boston.predict(X_test.astype(np.float32)) np.mean((y_test - yhat_test)**2) Out[34]: 20.92 We can check how many times each variable appeared in the collection of trees. This gives a summary similar to the variable importance plot for boosting and random forests. 8.4 Exercises 363 In[35]: var_inclusion = pd.Series(bart_boston.variable_inclusion_.mean(0), index=D.columns) var_inclusion Out[35]: crim 25.333333 zn 27.000000 indus 21.266667 chas 20.466667 nox 25.400000 rm 32.400000 age 26.133333 dis 25.666667 rad 24.666667 tax 23.933333 ptratio 25.000000 lstat 31.866667 dtype: float64 8.4 Exercises Conceptual 1. Draw an example (of your own invention) of a partition of two- dimensional feature space that could result from recursive binary splitting. Your example should contain at least six regions. Draw a decision tree corresponding to this partition. Be sure to label all as- pects of your figures, including the regions R1,R2,..., the cutpoints t1,t2,..., and so forth. Hint: Your result should look something like Figures 8.1and8.2. 2. It is mentioned in Section 8.2.3that boosting using depth-one", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 414, "start_word": 132480, "end_word": 132880, "chunk_words": 400}}, "ISLP_website::c000415": {"text": "Exercises Conceptual 1. Draw an example (of your own invention) of a partition of two- dimensional feature space that could result from recursive binary splitting. Your example should contain at least six regions. Draw a decision tree corresponding to this partition. Be sure to label all as- pects of your figures, including the regions R1,R2,..., the cutpoints t1,t2,..., and so forth. Hint: Your result should look something like Figures 8.1and8.2. 2. It is mentioned in Section 8.2.3that boosting using depth-one trees (orstumps) leads to an additivemodel: that is, a model of the form f(X)=p/summationdisplay j=1fj(Xj). Explain why this is the case. You can begin with ( 8.12) in Algorithm 8.2. 3. Consider the Gini index, classification error, and entropy in a simple classification setting with two classes. Create a single plot that dis- plays each of these quantities as a function of ˆpm1. Thex-axis should displayˆpm1, ranging from 0to1, and the y-axis should display the value of the Gini index, classification error, and entropy. Hint: In a setting with two classes, ˆpm1=1−ˆpm2. You could make this plot by hand, but it will be much easier to make in R. 4. This question relates to the plots in Figure 8.14. 364 8. Tree-Based Methods| X2 < 1 X1 < 1 X1 < 0 X2 < 2 -1.80 -1.06 0.21 0.63 2.49 5 15 10 0 3 0 1 X2 X1 0 1 FIGURE 8.14. Left: A partition of the predictor space corresponding to Exer- cise4a.Right: A tree corresponding to Exercise 4b. (a) Sketch the tree corresponding to the partition of the predictor space illustrated in the left-hand panel of Figure 8.14. The num- bers inside the boxes indicate the mean of Ywithin each region. (b) Create a diagram similar to the left-hand panel of Figure 8.14, using the tree illustrated in the right-hand panel of the same figure. You should divide up the predictor space into the correct regions, and indicate the mean for each region. 5. Suppose we produce ten bootstrapped samples from a data set containing red and green classes. We then apply a classification tree to each bootstrapped sample and, for a specific value of X, produce 10estimates of P(Class is Red |X): 0.1,0.15,0.2,0.2,0.55,0.6,0.6,0.65,0.7,and0.75. There are two common ways to combine these results together into a single class prediction. One is the majority vote approach discussed in this chapter. The second approach is to classify based on the", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 415, "start_word": 132800, "end_word": 133200, "chunk_words": 400}}, "ISLP_website::c000416": {"text": "the mean for each region. 5. Suppose we produce ten bootstrapped samples from a data set containing red and green classes. We then apply a classification tree to each bootstrapped sample and, for a specific value of X, produce 10estimates of P(Class is Red |X): 0.1,0.15,0.2,0.2,0.55,0.6,0.6,0.65,0.7,and0.75. There are two common ways to combine these results together into a single class prediction. One is the majority vote approach discussed in this chapter. The second approach is to classify based on the average probability.Inthisexample,whatisthefinalclassificationundereach of these two approaches? 6. Provide a detailed explanation of the algorithm that is used to fit a regression tree. Applied 7. In Section 8.3.3, we applied random forests to the Bostondata using max_features = 6 and using n_estimators = 100 andn_estimators = 500. Create a plot displaying the test error resulting from random forests on this data set for a more comprehensive range of values formax_features andn_estimators . You can model your plot after Figure8.10. Describe the results obtained. 8. Inthelab,aclassificationtreewasappliedtothe Carseats datasetaf- ter converting Salesinto a qualitative response variable. Now we will seek to predict Salesusing regression trees and related approaches, treating the response as a quantitative variable. 8.4 Exercises 365(a) Split the data set into a training set and a test set.(b) Fit a regression tree to the training set. Plot the tree, and inter-pret the results. What test MSE do you obtain?(c) Use cross-validation in order to determine the optimal level oftree complexity. Does pruning the tree improve the test MSE?(d) Use the bagging approach in order to analyze this data. Whattest MSE do you obtain? Use thefeature_importance_values todetermine which variables are most important.(e) Use random forests to analyze this data. What test MSE doyou obtain? Use thefeature_importance_values to determinewhichvariablesaremostimportant.Describetheeffectofm,thenumber of variables considered at each split, on the error rateobtained.(f) Now analyze the data using BART, and report your results.9. This problem involves theOJdata set which is part of theISLPpackage.(a) Create a training set containing a random sample of800obser-vations, and a test set containing the remaining observations.(b) Fit a tree to the training data, withPurchaseas the responseand the other variables as predictors. What is the training errorrate?(c) Create a plot of the tree, and interpret the results. How manyterminal nodes does the tree have?(d) Use theexport_tree()function to produce a text summary ofthe fitted tree. Pick one of the terminal nodes, and interpret theinformation displayed.(e) Predict the response on the test data, and produce a", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 416, "start_word": 133120, "end_word": 133520, "chunk_words": 400}}, "ISLP_website::c000417": {"text": "containing a random sample of800obser-vations, and a test set containing the remaining observations.(b) Fit a tree to the training data, withPurchaseas the responseand the other variables as predictors. What is the training errorrate?(c) Create a plot of the tree, and interpret the results. How manyterminal nodes does the tree have?(d) Use theexport_tree()function to produce a text summary ofthe fitted tree. Pick one of the terminal nodes, and interpret theinformation displayed.(e) Predict the response on the test data, and produce a confusionmatrix comparing the test labels to the predicted test labels.What is the test error rate?(f) Use cross-validation on the training set in order to determinethe optimal tree size.(g) Produce a plot with tree size on thex-axis and cross-validatedclassification error rate on they-axis.(h) Which tree size corresponds to the lowest cross-validated classi-fication error rate?(i) Produce a pruned tree corresponding to the optimal tree sizeobtained using cross-validation. If cross-validation does not leadto selection of a pruned tree, then create a pruned tree with fiveterminal nodes.(j) Compare the training error rates between the pruned and un-pruned trees. Which is higher?(k) Compare the test error rates between the pruned and unprunedtrees. Which is higher? 366 8. Tree-Based Methods 10. We now use boosting to predict Salaryin theHittersdata set. (a) Remove the observations for whom the salary information is unknown, and then log-transform the salaries. (b) Create a training set consisting of the first 200 observations, and a test set consisting of the remaining observations. (c) Perform boosting on the training set with 1,000 trees for a range of values of the shrinkage parameter λ. Produce a plot with different shrinkage values on the x-axis and the corresponding training set MSE on the y-axis. (d) Produce a plot with different shrinkage values on the x-axis and the corresponding test set MSE on the y-axis. (e) Compare the test MSE of boosting to the test MSE that results from applying two of the regression approaches seen in Chapters 3and6. (f) Which variables appear to be the most important predictors in the boosted model? (g) Now apply bagging to the training set. What is the test set MSE for this approach? 11. This question uses the Caravandata set. (a) Create a training set consisting of the first 1,000 observations, and a test set consisting of the remaining observations. (b) Fit a boosting model to the training set with Purchase as the response and the other variables as", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 417, "start_word": 133440, "end_word": 133840, "chunk_words": 400}}, "ISLP_website::c000418": {"text": "in Chapters 3and6. (f) Which variables appear to be the most important predictors in the boosted model? (g) Now apply bagging to the training set. What is the test set MSE for this approach? 11. This question uses the Caravandata set. (a) Create a training set consisting of the first 1,000 observations, and a test set consisting of the remaining observations. (b) Fit a boosting model to the training set with Purchase as the response and the other variables as predictors. Use 1,000 trees, and a shrinkage value of 0.01. Which predictors appear to be the most important? (c) Use the boosting model to predict the response on the test data. Predictthatapersonwillmakeapurchaseiftheestimatedprob- ability of purchase is greater than 20 % . Form a confusion ma- trix. What fraction of the people predicted to make a purchase do in fact make one? How does this compare with the results obtained from applying KNN or logistic regression to this data set? 12. Apply boosting, bagging, random forests, and BART to a data set of your choice. Be sure to fit the models on a training set and to evaluate their performance on a test set. How accurate are the results compared to simple methods like linear or logistic regression? Which of these approaches yields the best performance? 9 Support Vector Machines In this chapter, we discuss the support vector machine (SVM), an approach for classification that was developed in the computer science community in the 1990s and that has grown in popularity since then. SVMs have been shown to perform well in a variety of settings, and are often considered one of the best “out of the box” classifiers. The support vector machine is a generalization of a simple and intu- itive classifier called the maximal margin classifier , which we introduce in Section9.1. Though it is elegant and simple, we will see that this classifier unfortunately cannot be applied to most data sets, since it requires that the classes be separable by a linear boundary. In Section 9.2, we introduce thesupport vector classifier , an extension of the maximal margin classifier that can be applied in a broader range of cases. Section 9.3introduces the support vector machine , which is a further extension of the support vec- tor classifier in order to accommodate non-linear class boundaries. Support vector machines are intended for the binary classification setting in which there are two", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 418, "start_word": 133760, "end_word": 134160, "chunk_words": 400}}, "ISLP_website::c000419": {"text": "data sets, since it requires that the classes be separable by a linear boundary. In Section 9.2, we introduce thesupport vector classifier , an extension of the maximal margin classifier that can be applied in a broader range of cases. Section 9.3introduces the support vector machine , which is a further extension of the support vec- tor classifier in order to accommodate non-linear class boundaries. Support vector machines are intended for the binary classification setting in which there are two classes; in Section 9.4we discuss extensions of support vector machines to the case of more than two classes. In Section 9.5we discuss thecloseconnectionsbetweensupportvectormachinesandotherstatistical methods such as logistic regression. People often loosely refer to the maximal margin classifier, the support vector classifier, and the support vector machine as “support vector machines”. To avoid confusion, we will carefully distinguish between these three notions in this chapter. 9.1 Maximal Margin Classifier In this section, we define a hyperplane and introduce the concept of an optimal separating hyperplane. © Springer Nature Switzerland AG 2023 G. James et al., An Introduction to Statistical Learning , Springer Texts in Statistics, https://doi.org/10.1007/978-3-031-38747-0_9 367 368 9. Support Vector Machines 9.1.1 What Is a Hyperplane? In ap-dimensional space, a hyperplane is a flat affine subspace ofhyperplanedimension p−1.1For instance, in two dimensions, a hyperplane is a flat one-dimensional subspace—in other words, a line. In three dimensions, a hyperplane is a flat two-dimensional subspace—that is, a plane. In p>3 dimensions, it can be hard to visualize a hyperplane, but the notion of a (p−1)-dimensional flat subspace still applies. The mathematical definition of a hyperplane is quite simple. In two di- mensions, a hyperplane is defined by the equation β0+β1X1+β2X2=0 (9.1) for parameters β0,β1, andβ2. When we say that ( 9.1) “defines” the hyper- plane, we mean that any X=(X1,X2)Tfor which ( 9.1) holds is a point on the hyperplane. Note that ( 9.1) is simply the equation of a line, since indeed in two dimensions a hyperplane is a line. Equation 9.1can be easily extended to the p-dimensional setting: β0+β1X1+β2X2+···+βpXp=0 (9.2) defines a p-dimensional hyperplane, again in the sense that if a point X= (X1,X2,...,X p)Tinp-dimensional space (i.e. a vector of length p) satisfies (9.2), thenXlies on the hyperplane. Now, suppose that Xdoes not satisfy ( 9.2); rather, β0+β1X1+β2X2+···+βpXp>0. (9.3) Then this tells us that Xlies to one side of the hyperplane. On the other hand, if β0+β1X1+β2X2+···+βpXp<0, (9.4) thenXlies on", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 419, "start_word": 134080, "end_word": 134480, "chunk_words": 400}}, "ISLP_website::c000420": {"text": "indeed in two dimensions a hyperplane is a line. Equation 9.1can be easily extended to the p-dimensional setting: β0+β1X1+β2X2+···+βpXp=0 (9.2) defines a p-dimensional hyperplane, again in the sense that if a point X= (X1,X2,...,X p)Tinp-dimensional space (i.e. a vector of length p) satisfies (9.2), thenXlies on the hyperplane. Now, suppose that Xdoes not satisfy ( 9.2); rather, β0+β1X1+β2X2+···+βpXp>0. (9.3) Then this tells us that Xlies to one side of the hyperplane. On the other hand, if β0+β1X1+β2X2+···+βpXp<0, (9.4) thenXlies on the other side of the hyperplane. So we can think of the hyperplane as dividing p-dimensional space into two halves. One can easily determineonwhichsideofthehyperplaneapointliesbysimplycalculating the sign of the left-hand side of ( 9.2). A hyperplane in two-dimensional space is shown in Figure 9.1. 9.1.2 Classification Using a Separating Hyperplane Now suppose that we have an n×pdata matrix Xthat consists of n training observations in p-dimensional space, x1= x11 ... x1p ,...,x n= xn1 ... xnp , (9.5) and that these observations fall into two classes—that is, y1,...,y n∈ {−1,1}where−1represents one class and 1the other class. We also have a 1The word affineindicates that the subspace need not pass through the origin. 9.1 Maximal Margin Classifier 369 −1.5 −1.0 −0.5 0.0 0.5 1.0 1.5−1.5 −1.0 −0.5 0.0 0.5 1.0 1.5X1X2 FIGURE 9.1. The hyperplane 1+2 X1+3X2=0is shown. The blue region is the set of points for which 1+2 X1+3X2>0, and the purple region is the set of points for which 1+2 X1+3X2<0. test observation, a p-vector of observed features x∗=/parenleftbigx∗ 1... x∗ p/parenrightbigT. Our goal is to develop a classifier based on the training data that will correctly classify the test observation using its feature measurements. We have seen a number of approaches for this task, such as linear discriminant analysis and logistic regression in Chapter 4, and classification trees, bagging, and boosting in Chapter 8. We will now see a new approach that is based upon the concept of a separating hyperplane .separating hyperplaneSuppose that it is possible to construct a hyperplane that separates the training observations perfectly according to their class labels. Examples of three such separating hyperplanes are shown in the left-hand panel of Figure9.2. We can label the observations from the blue class as yi=1and those from the purple class as yi=−1. Then a separating hyperplane has the property that β0+β1xi1+β2xi2+···+βpxip>0 ifyi=1, (9.6) and β0+β1xi1+β2xi2+···+βpxip<0 ifyi=−1. (9.7) Equivalently, a separating hyperplane has the property that yi(β0+β1xi1+β2xi2+···+βpxip)>0 (9.8)", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 420, "start_word": 134400, "end_word": 134800, "chunk_words": 400}}, "ISLP_website::c000421": {"text": "separating hyperplane .separating hyperplaneSuppose that it is possible to construct a hyperplane that separates the training observations perfectly according to their class labels. Examples of three such separating hyperplanes are shown in the left-hand panel of Figure9.2. We can label the observations from the blue class as yi=1and those from the purple class as yi=−1. Then a separating hyperplane has the property that β0+β1xi1+β2xi2+···+βpxip>0 ifyi=1, (9.6) and β0+β1xi1+β2xi2+···+βpxip<0 ifyi=−1. (9.7) Equivalently, a separating hyperplane has the property that yi(β0+β1xi1+β2xi2+···+βpxip)>0 (9.8) for alli=1,...,n . Ifaseparatinghyperplaneexists,wecanuseittoconstructaverynatural classifier: a test observation is assigned a class depending on which side of the hyperplane it is located. The right-hand panel of Figure 9.2shows an example of such a classifier. That is, we classify the test observation x∗ basedonthesignof f(x∗)=β0+β1x∗ 1+β2x∗ 2+···+βpx∗ p.Iff(x∗)ispositive, then we assign the test observation to class 1, and iff(x∗)is negative, then we assign it to class −1. We can also make use of the magnitude off(x∗). If 370 9. Support Vector Machines −1 0 1 2 3−1 0 1 2 3−1 0 1 2 3−1 0 1 2 3X1X1 X2X2 FIGURE 9.2. Left:There are two classes of observations, shown in blue and in purple, each of which has measurements on two variables. Three separating hyperplanes, out of many possible, are shown in black. Right:A separating hy- perplane is shown in black. The blue and purple grid indicates the decision rule made by a classifier based on this separating hyperplane: a test observation that falls in the blue portion of the grid will be assigned to the blue class, and a test observation that falls into the purple portion of the grid will be assigned to the purple class. f(x∗)is far from zero, then this means that x∗lies far from the hyperplane, and so we can be confident about our class assignment for x∗. On the other hand,iff(x∗)isclosetozero,then x∗islocatednearthehyperplane,andso we are less certain about the class assignment for x∗. Not surprisingly, and as we see in Figure 9.2, a classifier that is based on a separating hyperplane leads to a linear decision boundary. 9.1.3 The Maximal Margin Classifier In general, if our data can be perfectly separated using a hyperplane, then there will in fact exist an infinite number of such hyperplanes. This is becauseagivenseparatinghyperplanecanusuallybeshiftedatinybitupor down,orrotated,withoutcomingintocontactwithanyoftheobservations. Three possible separating hyperplanes are shown in the left-hand panel of Figure 9.2. In order to construct a classifier based upon a separating hyperplane, we must", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 421, "start_word": 134720, "end_word": 135120, "chunk_words": 400}}, "ISLP_website::c000422": {"text": "as we see in Figure 9.2, a classifier that is based on a separating hyperplane leads to a linear decision boundary. 9.1.3 The Maximal Margin Classifier In general, if our data can be perfectly separated using a hyperplane, then there will in fact exist an infinite number of such hyperplanes. This is becauseagivenseparatinghyperplanecanusuallybeshiftedatinybitupor down,orrotated,withoutcomingintocontactwithanyoftheobservations. Three possible separating hyperplanes are shown in the left-hand panel of Figure 9.2. In order to construct a classifier based upon a separating hyperplane, we must have a reasonable way to decide which of the infinite possible separating hyperplanes to use. A natural choice is the maximal margin hyperplane (also known as themaximal margin hyperplaneoptimal separating hyperplane ), which is the separating hyperplane that optimal separating hyperplaneis farthest from the training observations. That is, we can compute the (perpendicular) distance from each training observation to a given separat- ing hyperplane; the smallest such distance is the minimal distance from the observations to the hyperplane, and is known as the margin. The maximal margin margin hyperplane is the separating hyperplane for which the margin is largest—that is, it is the hyperplane that has the farthest minimum dis- tance to the training observations. We can then classify a test observation basedonwhichsideofthemaximalmarginhyperplaneitlies.Thisisknown 9.1 Maximal Margin Classifier 371 −10123−10123 X1X2 FIGURE 9.3. There are two classes of observations, shown in blue and in purple. The maximal margin hyperplane is shown as a solid line. The margin is the distance from the solid line to either of the dashed lines. The two blue points and the purple point that lie on the dashed lines are the support vectors, and the distance from those points to the hyperplane is indicated by arrows. The purple and blue grid indicates the decision rule made by a classifier based on this separating hyperplane. as themaximal margin classifier . We hope that a classifier that has a largemaximal margin classifiermargin on the training data will also have a large margin on the test data, and hence will classify the test observations correctly. Although the maxi- mal margin classifier is often successful, it can also lead to overfitting when pis large. Ifβ0,β1,...,βpare the coefficients of the maximal margin hyperplane, then the maximal margin classifier classifies the test observation x∗based on the sign of f(x∗)=β0+β1x∗ 1+β2x∗ 2+···+βpx∗ p. Figure9.3shows the maximal margin hyperplane on the data set of Figure9.2. Comparing the right-hand panel of Figure 9.2to Figure 9.3,", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 422, "start_word": 135040, "end_word": 135440, "chunk_words": 400}}, "ISLP_website::c000423": {"text": "have a large margin on the test data, and hence will classify the test observations correctly. Although the maxi- mal margin classifier is often successful, it can also lead to overfitting when pis large. Ifβ0,β1,...,βpare the coefficients of the maximal margin hyperplane, then the maximal margin classifier classifies the test observation x∗based on the sign of f(x∗)=β0+β1x∗ 1+β2x∗ 2+···+βpx∗ p. Figure9.3shows the maximal margin hyperplane on the data set of Figure9.2. Comparing the right-hand panel of Figure 9.2to Figure 9.3, we see that the maximal margin hyperplane shown in Figure 9.3does in- deed result in a greater minimal distance between the observations and the separating hyperplane—that is, a larger margin. In a sense, the maximal margin hyperplane represents the mid-line of the widest “slab” that we can insert between the two classes. ExaminingFigure 9.3,weseethatthreetrainingobservationsareequidis- tant from the maximal margin hyperplane and lie along the dashed lines indicating the width of the margin. These three observations are known as support vectors ,sincetheyarevectorsin p-dimensionalspace(inFigure 9.3,support vector p=2) and they “support” the maximal margin hyperplane in the sense that if these points were moved slightly then the maximal margin hyper- plane would move as well. Interestingly, the maximal margin hyperplane depends directly on the support vectors, but not on the other observations: amovementtoanyoftheotherobservationswouldnotaffecttheseparating hyperplane, provided that the observation’s movement does not cause it to 372 9. Support Vector Machines cross the boundary set by the margin. The fact that the maximal margin hyperplane depends directly on only a small subset of the observations is an important property that will arise later in this chapter when we discuss the support vector classifier and support vector machines. 9.1.4 Construction of the Maximal Margin Classifier We now consider the task of constructing the maximal margin hyperplane based on a set of ntraining observations x1,...,x n∈Rpand associated class labels y1,...,y n∈{−1,1}. Briefly, the maximal margin hyperplane is the solution to the optimization problem maximize β0,β1,...,βp,MM (9.9) subject top/summationdisplay j=1β2 j=1, (9.10) yi(β0+β1xi1+β2xi2+···+βpxip)≥M∀i=1, . . . , n. (9.11) This optimization problem ( 9.9)–(9.11) is actually simpler than it looks. First of all, the constraint in ( 9.11) that yi(β0+β1xi1+β2xi2+···+βpxip)≥M∀i=1,...,n guarantees that each observation will be on the correct side of the hyper- plane, provided that Mis positive. (Actually, for each observation to be on the correct side of the hyperplane we would simply need yi(β0+β1xi1+ β2xi2+···+βpxip)>0, so the constraint in ( 9.11) in fact requires that each", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 423, "start_word": 135360, "end_word": 135760, "chunk_words": 400}}, "ISLP_website::c000424": {"text": "top/summationdisplay j=1β2 j=1, (9.10) yi(β0+β1xi1+β2xi2+···+βpxip)≥M∀i=1, . . . , n. (9.11) This optimization problem ( 9.9)–(9.11) is actually simpler than it looks. First of all, the constraint in ( 9.11) that yi(β0+β1xi1+β2xi2+···+βpxip)≥M∀i=1,...,n guarantees that each observation will be on the correct side of the hyper- plane, provided that Mis positive. (Actually, for each observation to be on the correct side of the hyperplane we would simply need yi(β0+β1xi1+ β2xi2+···+βpxip)>0, so the constraint in ( 9.11) in fact requires that each observation be on the correct side of the hyperplane, with some cushion, provided that Mis positive.) Second,notethat( 9.10)isnotreallyaconstraintonthehyperplane,since ifβ0+β1xi1+β2xi2+···+βpxip=0defines a hyperplane, then so does k(β0+β1xi1+β2xi2+···+βpxip)=0 for anyk/negationslash=0. However, ( 9.10) adds meaningto( 9.11);onecanshowthatwiththisconstrainttheperpendicular distance from the ith observation to the hyperplane is given by yi(β0+β1xi1+β2xi2+···+βpxip). Therefore, the constraints ( 9.10) and (9.11) ensure that each observation is on the correct side of the hyperplane and at least a distance Mfrom the hyperplane. Hence, Mrepresents the margin of our hyperplane, and the optimization problem chooses β0,β1,...,βpto maximize M. This is exactly the definition of the maximal margin hyperplane! The problem ( 9.9)–(9.11) can be solved efficiently, but details of this optimization are outside of the scope of this book. 9.1.5 The Non-separable Case The maximal margin classifier is a very natural way to perform classifi- cation,if a separating hyperplane exists . However, as we have hinted, in many cases no separating hyperplane exists, and so there is no maximal 9.2 Support Vector Classifiers 373 0123−1.0 −0.5 0.0 0.5 1.0 1.5 2.0X1X2 FIGURE 9.4. There are two classes of observations, shown in blue and in purple. In this case, the two classes are not separable by a hyperplane, and so the maximal margin classifier cannot be used. margin classifier. In this case, the optimization problem ( 9.9)–(9.11) has no solution with M> 0. An example is shown in Figure 9.4. In this case, we cannotexactlyseparate the two classes. However, as we will see in the next section, we can extend the concept of a separating hyperplane in order to develop a hyperplane that almostseparates the classes, using a so-called soft margin . The generalization of the maximal margin classifier to the non-separable case is known as the support vector classifier . 9.2 Support Vector Classifiers 9.2.1 Overview of the Support Vector Classifier In Figure 9.4, we see that observations that belong to two classes are not necessarily separable by a hyperplane. In", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 424, "start_word": 135680, "end_word": 136080, "chunk_words": 400}}, "ISLP_website::c000425": {"text": "see in the next section, we can extend the concept of a separating hyperplane in order to develop a hyperplane that almostseparates the classes, using a so-called soft margin . The generalization of the maximal margin classifier to the non-separable case is known as the support vector classifier . 9.2 Support Vector Classifiers 9.2.1 Overview of the Support Vector Classifier In Figure 9.4, we see that observations that belong to two classes are not necessarily separable by a hyperplane. In fact, even if a separating hyper- plane does exist, then there are instances in which a classifier based on a separating hyperplane might not be desirable. A classifier based on a separating hyperplane will necessarily perfectly classify all of the training observations; this can lead to sensitivity to individual observations. An ex- ample is shown in Figure 9.5. The addition of a single observation in the right-hand panel of Figure 9.5leads to a dramatic change in the maxi- mal margin hyperplane. The resulting maximal margin hyperplane is not satisfactory—for one thing, it has only a tiny margin. This is problematic because as discussed previously, the distance of an observation from the hyperplane can be seen as a measure of our confidence that the obser- vation was correctly classified. Moreover, the fact that the maximal mar- gin hyperplane is extremely sensitive to a change in a single observation suggests that it may have overfit the training data. In this case, we might be willing to consider a classifier based on a hy- perplane that does notperfectly separate the two classes, in the interest of 374 9. Support Vector Machines −1 0 1 2 3−1 0 1 2 3−1 0 1 2 3−1 0 1 2 3X1X1X2X2 FIGURE 9.5. Left:Two classes of observations are shown in blue and in purple, along with the maximal margin hyperplane. Right:An additional blue observation has been added, leading to a dramatic shift in the maximal margin hyperplane shown as a solid line. The dashed line indicates the maximal margin hyperplane that was obtained in the absence of this additional point. • Greater robustness to individual observations, and • Better classification of mostof the training observations. That is, it could be worthwhile to misclassify a few training observations in order to do a better job in classifying the remaining observations. Thesupport vector classifier , sometimes called a soft margin classifier ,support vector classifier soft margin classifierdoes exactly", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 425, "start_word": 136000, "end_word": 136400, "chunk_words": 400}}, "ISLP_website::c000426": {"text": "hyperplane shown as a solid line. The dashed line indicates the maximal margin hyperplane that was obtained in the absence of this additional point. • Greater robustness to individual observations, and • Better classification of mostof the training observations. That is, it could be worthwhile to misclassify a few training observations in order to do a better job in classifying the remaining observations. Thesupport vector classifier , sometimes called a soft margin classifier ,support vector classifier soft margin classifierdoes exactly this. Rather than seeking the largest possible margin so that every observation is not only on the correct side of the hyperplane but also on the correct side of the margin, we instead allow some observations to be on the incorrect side of the margin, or even the incorrect side of the hyperplane. (The margin is softbecause it can be violated by some of the training observations.) An example is shown in the left-hand panel ofFigure 9.6.Mostoftheobservationsareonthecorrectsideofthemargin. However, a small subset of the observations are on the wrong side of the margin. An observation can be not only on the wrong side of the margin, but also on the wrong side of the hyperplane. In fact, when there is no separating hyperplane,suchasituationisinevitable.Observationsonthewrongsideof thehyperplanecorrespondtotrainingobservationsthataremisclassifiedby the support vector classifier. The right-hand panel of Figure 9.6illustrates such a scenario. 9.2.2 Details of the Support Vector Classifier The support vector classifier classifies a test observation depending on which side of a hyperplane it lies. The hyperplane is chosen to correctly separate most of the training observations into the two classes, but may 9.2 Support Vector Classifiers 375 −0.50.0 0.5 1.0 1.5 2.0 2.5−1 0 1 2 3 412345678910 −0.50.0 0.5 1.0 1.5 2.0 2.5−1 0 1 2 3 4123456789101112X1X1 X2X2 FIGURE 9.6. Left:A support vector classifier was fit to a small data set. The hyperplane is shown as a solid line and the margins are shown as dashed lines. Purple observations: Observations 3,4,5, and6are on the correct side of the margin, observation 2is on the margin, and observation 1 is on the wrong side of the margin. Blue observations: Observations 7and10are on the correct side of the margin, observation 9is on the margin, and observation 8is on the wrong side of the margin. No observations are on the wrong side of the hyperplane. Right: Same as left panel with two additional points, 11and12. These two observations are on the wrong side of the hyperplane", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 426, "start_word": 136320, "end_word": 136720, "chunk_words": 400}}, "ISLP_website::c000427": {"text": "on the correct side of the margin, observation 2is on the margin, and observation 1 is on the wrong side of the margin. Blue observations: Observations 7and10are on the correct side of the margin, observation 9is on the margin, and observation 8is on the wrong side of the margin. No observations are on the wrong side of the hyperplane. Right: Same as left panel with two additional points, 11and12. These two observations are on the wrong side of the hyperplane and the wrong side of the margin. misclassifyafewobservations.Itisthesolutiontotheoptimizationproblem maximize β0,β1,...,βp,/epsilon11,...,/epsilon1n,MM (9.12) subject top/summationdisplay j=1β2 j=1, (9.13) yi(β0+β1xi1+β2xi2+···+βpxip)≥M(1−/epsilon1i),(9.14) /epsilon1i≥0,n/summationdisplay i=1/epsilon1i≤C, (9.15) whereCis a nonnegative tuning parameter. As in ( 9.11),Mis the width of the margin; we seek to make this quantity as large as possible. In ( 9.14), /epsilon11,...,/epsilon1nareslack variables that allow individual observations to be onslack variablethe wrong side of the margin or the hyperplane; we will explain them in greater detail momentarily. Once we have solved ( 9.12)–(9.15), we classify a test observation x∗as before, by simply determining on which side of the hyperplane it lies. That is, we classify the test observation based on the sign off(x∗)=β0+β1x∗ 1+···+βpx∗ p. The problem ( 9.12)–(9.15) seems complex, but insight into its behavior can be made through a series of simple observations presented below. First of all, the slack variable /epsilon1itells us where the ith observation is located, relative to the hyperplane and relative to the margin. If /epsilon1i=0then the ith observation is on the correct side of the margin, as we saw in Section 9.1.4. If/epsilon1i>0then the ith observation is on the wrong side of the margin, and we say that the ith observation has violatedthe margin. If /epsilon1i>1then it is on the wrong side of the hyperplane. 376 9. Support Vector Machines We now consider the role of the tuning parameter C. In (9.15),Cbounds the sum of the /epsilon1i’s, and so it determines the number and severity of the vio- lations to the margin (and to the hyperplane) that we will tolerate. We can think of Cas abudgetfor the amount that the margin can be violated by thenobservations. If C=0 then there is no budget for violations to the margin, and it must be the case that /epsilon11=···=/epsilon1n=0, in which case (9.12)–(9.15) simply amounts to the maximal margin hyperplane optimiza- tion problem ( 9.9)–(9.11). (Of course, a maximal margin hyperplane exists only if the two classes are separable.) For", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 427, "start_word": 136640, "end_word": 137040, "chunk_words": 400}}, "ISLP_website::c000428": {"text": "vio- lations to the margin (and to the hyperplane) that we will tolerate. We can think of Cas abudgetfor the amount that the margin can be violated by thenobservations. If C=0 then there is no budget for violations to the margin, and it must be the case that /epsilon11=···=/epsilon1n=0, in which case (9.12)–(9.15) simply amounts to the maximal margin hyperplane optimiza- tion problem ( 9.9)–(9.11). (Of course, a maximal margin hyperplane exists only if the two classes are separable.) For C>0no more than Cobserva- tions can be on the wrong side of the hyperplane, because if an observation is on the wrong side of the hyperplane then /epsilon1i>1, and (9.15) requires that/summationtextn i=1/epsilon1i≤C. As the budget Cincreases, we become more tolerant of violations to the margin, and so the margin will widen. Conversely, as C decreases, we become less tolerant of violations to the margin and so the margin narrows. An example is shown in Figure 9.7. Inpractice, Cistreatedasatuningparameterthatisgenerallychosenvia cross-validation. As with the tuning parameters that we have seen through- out this book, Ccontrols the bias-variance trade-off of the statistical learn- ing technique. When Cis small, we seek narrow margins that are rarely violated; this amounts to a classifier that is highly fit to the data, which may have low bias but high variance. On the other hand, when Cis larger, the margin is wider and we allow more violations to it; this amounts to fitting the data less hard and obtaining a classifier that is potentially more biased but may have lower variance. The optimization problem ( 9.12)–(9.15) has a very interesting property: it turns out that only observations that either lie on the margin or that violate the margin will affect the hyperplane, and hence the classifier ob- tained. In other words, an observation that lies strictly on the correct side of the margin does not affect the support vector classifier! Changing the position of that observation would not change the classifier at all, provided that its position remains on the correct side of the margin. Observations that lie directly on the margin, or on the wrong side of the margin for their class, are known as support vectors . These observations do affect the support vector classifier. The fact that only support vectors affect the classifier is in line with our previous assertion that Ccontrols the bias-variance trade-off of the support vector classifier. When the tuning parameter", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 428, "start_word": 136960, "end_word": 137360, "chunk_words": 400}}, "ISLP_website::c000429": {"text": "not change the classifier at all, provided that its position remains on the correct side of the margin. Observations that lie directly on the margin, or on the wrong side of the margin for their class, are known as support vectors . These observations do affect the support vector classifier. The fact that only support vectors affect the classifier is in line with our previous assertion that Ccontrols the bias-variance trade-off of the support vector classifier. When the tuning parameter Cis large, then the margin is wide, many observations violate the margin, and so there are many support vectors. In this case, many observations are involved in determining the hyperplane. The top left panel in Figure 9.7illustrates this setting: this classifier has low variance (since many observations are support vectors) but potentially high bias. In contrast, if Cis small, then there will be fewer support vectors and hence the resulting classifier will have low bias but high variance. The bottom right panel in Figure 9.7illustrates this setting, with only eight support vectors. The fact that the support vector classifier’s decision rule is based only on a potentially small subset of the training observations (the support vec- tors) means that it is quite robust to the behavior of observations that are far away from the hyperplane. This property is distinct from some of 9.3 Support Vector Machines 377 −1012−3 −2 −1 0 1 2 3−1012−3 −2 −1 0 1 2 3 −1012−3 −2 −1 0 1 2 3−1012−3 −2 −1 0 1 2 3X1X1X1X1X2X2 X2X2 FIGURE 9.7. A support vector classifier was fit using four different values of the tuning parameter Cin (9.12)–(9.15). The largest value of Cwas used in the top left panel, and smaller values were used in the top right, bottom left, and bottom right panels. When Cis large, then there is a high tolerance for observations being on the wrong side of the margin, and so the margin will be large. As Cdecreases, the tolerance for observations being on the wrong side of the margin decreases, and the margin narrows. the other classification methods that we have seen in preceding chapters, such as linear discriminant analysis. Recall that the LDA classification rule depends on the mean of allof the observations within each class, as well as the within-class covariance matrix computed using allof the observations. In contrast, logistic regression, unlike LDA, has very low sensitivity to ob-", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 429, "start_word": 137280, "end_word": 137680, "chunk_words": 400}}, "ISLP_website::c000430": {"text": "margin will be large. As Cdecreases, the tolerance for observations being on the wrong side of the margin decreases, and the margin narrows. the other classification methods that we have seen in preceding chapters, such as linear discriminant analysis. Recall that the LDA classification rule depends on the mean of allof the observations within each class, as well as the within-class covariance matrix computed using allof the observations. In contrast, logistic regression, unlike LDA, has very low sensitivity to ob- servations far from the decision boundary. In fact we will see in Section 9.5 that the support vector classifier and logistic regression are closely related. 9.3 Support Vector Machines We first discuss a general mechanism for converting a linear classifier into one that produces non-linear decision boundaries. We then introduce the support vector machine, which does this in an automatic way. 378 9. Support Vector Machines −4 −2 0 2 4−4 −2 0 2 4−4 −2 0 2 4−4 −2 0 2 4X1X1X2X2 FIGURE 9.8. Left:The observations fall into two classes, with a non-lin- ear boundary between them. Right:The support vector classifier seeks a linear boundary, and consequently performs very poorly. 9.3.1 Classification with Non-Linear Decision Boundaries The support vector classifier is a natural approach for classification in the two-class setting, if the boundary between the two classes is linear. How- ever, in practice we are sometimes faced with non-linear class boundaries. For instance, consider the data in the left-hand panel of Figure 9.8. It is clear that a support vector classifier or any linear classifier will perform poorly here. Indeed, the support vector classifier shown in the right-hand panel of Figure 9.8is useless here. In Chapter 7, we are faced with an analogous situation. We see there that the performance of linear regression can suffer when there is a non- linear relationship between the predictors and the outcome. In that case, we consider enlarging the feature space using functions of the predictors, such as quadratic and cubic terms, in order to address this non-linearity. In the case of the support vector classifier, we could address the prob- lem of possibly non-linear boundaries between classes in a similar way, by enlarging the feature space using quadratic, cubic, and even higher-order polynomial functions of the predictors. For instance, rather than fitting a support vector classifier using pfeatures X1,X2,...,X p, we could instead fit a support vector classifier using 2pfeatures X1,X2 1,X2,X2", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 430, "start_word": 137600, "end_word": 138000, "chunk_words": 400}}, "ISLP_website::c000431": {"text": "of the predictors, such as quadratic and cubic terms, in order to address this non-linearity. In the case of the support vector classifier, we could address the prob- lem of possibly non-linear boundaries between classes in a similar way, by enlarging the feature space using quadratic, cubic, and even higher-order polynomial functions of the predictors. For instance, rather than fitting a support vector classifier using pfeatures X1,X2,...,X p, we could instead fit a support vector classifier using 2pfeatures X1,X2 1,X2,X2 2,...,X p,X2 p. 9.3 Support Vector Machines 379 Then (9.12)–(9.15) would become maximize β0,β11,β12,...,βp1,βp2,/epsilon11,...,/epsilon1n,MM (9.16) subject to yi β0+p/summationdisplay j=1βj1xij+p/summationdisplay j=1βj2x2 ij ≥M(1−/epsilon1i), n/summationdisplay i=1/epsilon1i≤C,/epsilon1i≥0,p/summationdisplay j=12/summationdisplay k=1β2 jk=1. Why does this lead to a non-linear decision boundary? In the enlarged feature space, the decision boundary that results from ( 9.16) is in fact lin- ear. But in the original feature space, the decision boundary is of the form q(x)=0 , whereqis a quadratic polynomial, and its solutions are gener- ally non-linear. One might additionally want to enlarge the feature space with higher-order polynomial terms, or with interaction terms of the form XjXj/primeforj/negationslash=j/prime. Alternatively, other functions of the predictors could be considered rather than polynomials. It is not hard to see that there are many possible ways to enlarge the feature space, and that unless we are careful, we could end up with a huge number of features. Then compu- tations would become unmanageable. The support vector machine, which we present next, allows us to enlarge the feature space used by the support vector classifier in a way that leads to efficient computations. 9.3.2 The Support Vector Machine Thesupport vector machine (SVM) is an extension of the support vectorsupport vector machineclassifier that results from enlarging the feature space in a specific way, usingkernels. We will now discuss this extension, the details of which are kernel somewhat complex and beyond the scope of this book. However, the main idea is described in Section 9.3.1: we may want to enlarge our feature space in order to accommodate a non-linear boundary between the classes. The kernel approach that we describe here is simply an efficient computational approach for enacting this idea. We have not discussed exactly how the support vector classifier is com- puted because the details become somewhat technical. However, it turns out that the solution to the support vector classifier problem ( 9.12)–(9.15) involves only the inner products of the observations (as", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 431, "start_word": 137920, "end_word": 138320, "chunk_words": 400}}, "ISLP_website::c000432": {"text": "Section 9.3.1: we may want to enlarge our feature space in order to accommodate a non-linear boundary between the classes. The kernel approach that we describe here is simply an efficient computational approach for enacting this idea. We have not discussed exactly how the support vector classifier is com- puted because the details become somewhat technical. However, it turns out that the solution to the support vector classifier problem ( 9.12)–(9.15) involves only the inner products of the observations (as opposed to the observations themselves). The inner product of two r-vectors aandbis defined as /angbracketlefta, b/angbracketright=/summationtextr i=1aibi. Thus the inner product of two observations xi,xi/primeis given by /angbracketleftxi,xi/prime/angbracketright=p/summationdisplay j=1xijxi/primej. (9.17) It can be shown that • The linear support vector classifier can be represented as f(x)=β0+n/summationdisplay i=1αi/angbracketleftx, x i/angbracketright, (9.18) 380 9. Support Vector Machines where there are nparameters αi,i=1,...,n , one per training observation. • To estimate the parameters α1,...,αnandβ0, all we need are the/parenleftbign 2/parenrightbig inner products /angbracketleftxi,xi/prime/angbracketrightbetween all pairs of training observations. (The notation/parenleftbign 2/parenrightbig meansn(n−1)/2, and gives the number of pairs among a set of nitems.) Notice that in ( 9.18), in order to evaluate the function f(x), we need to computetheinnerproductbetweenthenewpoint xandeachofthetraining pointsxi. However, it turns out that αiis nonzero only for the support vectors in the solution—that is, if a training observation is not a support vector, then its αiequals zero. So if Sis the collection of indices of these support points, we can rewrite any solution function of the form ( 9.18) as f(x)=β0+/summationdisplay i∈Sαi/angbracketleftx, x i/angbracketright, (9.19) which typically involves far fewer terms than in ( 9.18).2 Tosummarize,inrepresentingthelinearclassifier f(x),andincomputing its coefficients, all we need are inner products. Now suppose that every time the inner product ( 9.17) appears in the representation ( 9.18), or in a calculation of the solution for the support vector classifier, we replace it with a generalization of the inner product of the form K(xi,xi/prime), (9.20) whereKis some function that we will refer to as a kernel. A kernel is akernelfunction that quantifies the similarity of two observations. For instance, we could simply take K(xi,xi/prime)=p/summationdisplay j=1xijxi/primej, (9.21) which would just give us back the support vector classifier. Equation 9.21 is known as a linearkernel because the support vector classifier is linear in the features; the linear kernel essentially quantifies the similarity of a pair of observations using Pearson (standard) correlation. But one could instead choose another form for", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 432, "start_word": 138240, "end_word": 138640, "chunk_words": 400}}, "ISLP_website::c000433": {"text": "function that we will refer to as a kernel. A kernel is akernelfunction that quantifies the similarity of two observations. For instance, we could simply take K(xi,xi/prime)=p/summationdisplay j=1xijxi/primej, (9.21) which would just give us back the support vector classifier. Equation 9.21 is known as a linearkernel because the support vector classifier is linear in the features; the linear kernel essentially quantifies the similarity of a pair of observations using Pearson (standard) correlation. But one could instead choose another form for ( 9.20). For instance, one could replace every instance of/summationtextp j=1xijxi/primejwith the quantity K(xi,xi/prime) = (1 +p/summationdisplay j=1xijxi/primej)d. (9.22) This is known as a polynomial kernel of degree d, wheredis a positivepolynomial kernelinteger. Using such a kernel with d> 1, instead of the standard linear kernel(9.21),inthesupportvectorclassifieralgorithmleadstoamuchmore flexibledecision boundary.Itessentiallyamountstofitting a support vector 2By expanding each of the inner products in ( 9.19), it is easy to see that f(x)is a linear function of the coordinates of x. Doing so also establishes the correspondence between the αiand the original parameters βj. 9.3 Support Vector Machines 381 −4 −2 0 2 4−4 −2 0 2 4 −4 −2 0 2 4−4 −2 0 2 4 X1X1X2X2 FIGURE 9.9. Left:An SVM with a polynomial kernel of degree 3 is applied to the non-linear data from Figure 9.8, resulting in a far more appropriate decision rule.Right:An SVM with a radial kernel is applied. In this example, either kernel is capable of capturing the decision boundary. classifier in a higher-dimensional space involving polynomials of degree d, rather than in the original feature space. When the support vector classifier iscombinedwithanon-linearkernelsuchas( 9.22),theresultingclassifieris known as a support vector machine. Note that in this case the (non-linear) function has the form f(x)=β0+/summationdisplay i∈SαiK(x, x i). (9.23) The left-hand panel of Figure 9.9shows an example of an SVM with a polynomial kernel applied to the non-linear data from Figure 9.8. The fit is a substantial improvement over the linear support vector classifier. When d=1, then the SVM reduces to the support vector classifier seen earlier in this chapter. The polynomial kernel shown in ( 9.22) is one example of a possible non-linear kernel, but alternatives abound. Another popular choice is the radial kernel , which takes the formradial kernel K(xi,xi/prime) = exp( −γp/summationdisplay j=1(xij−xi/primej)2). (9.24) In (9.24),γis a positive constant. The right-hand panel of Figure 9.9shows an example of an SVM with a radial kernel on this non-linear data; it also", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 433, "start_word": 138560, "end_word": 138960, "chunk_words": 400}}, "ISLP_website::c000434": {"text": "classifier. When d=1, then the SVM reduces to the support vector classifier seen earlier in this chapter. The polynomial kernel shown in ( 9.22) is one example of a possible non-linear kernel, but alternatives abound. Another popular choice is the radial kernel , which takes the formradial kernel K(xi,xi/prime) = exp( −γp/summationdisplay j=1(xij−xi/primej)2). (9.24) In (9.24),γis a positive constant. The right-hand panel of Figure 9.9shows an example of an SVM with a radial kernel on this non-linear data; it also does a good job in separating the two classes. How does the radial kernel ( 9.24) actually work? If a given test obser- vationx∗=(x∗ 1,...,x∗ p)Tis far from a training observation xiin terms of Euclidean distance, then/summationtextp j=1(x∗ j−xij)2will be large, and so K(x∗,xi)= exp(−γ/summationtextp j=1(x∗ j−xij)2)will be tiny. This means that in ( 9.23),xiwill play virtually no role in f(x∗). Recall that the predicted class label for the test observation x∗is based on the sign of f(x∗). In other words, training observations that are far from x∗will play essentially no role in the pre- dicted class label for x∗. This means that the radial kernel has very local 382 9. Support Vector Machines False positive rateTrue positive rate0.0 0.2 0.4 0.6 0.8 1.00.0 0.2 0.4 0.6 0.8 1.0Support Vector ClassifierLDAFalse positive rateTrue positive rate0.0 0.2 0.4 0.6 0.8 1.00.0 0.2 0.4 0.6 0.8 1.0Support Vector ClassifierSVM: γ=10−3SVM: γ=10−2SVM: γ=10−1FIGURE 9.10. ROC curves for the Heartdata training set. Left:The support vector classifier and LDA are compared. Right:The support vector classifier is compared to an SVM using a radial basis kernel with γ= 10−3,10−2, and10−1. behavior, in the sense that only nearby training observations have an effect on the class label of a test observation. What is the advantage of using a kernel rather than simply enlarging the feature space using functions of the original features, as in ( 9.16)? One advantage is computational, and it amounts to the fact that using kernels, one need only compute K(xi,x/prime i)for all/parenleftbign 2/parenrightbig distinct pairs i, i/prime. This can be done without explicitly working in the enlarged feature space. This is im- portant because in many applications of SVMs, the enlarged feature space is so large that computations are intractable. For some kernels, such as the radial kernel ( 9.24), the feature space is implicitand infinite-dimensional, so we could never do the computations there anyway! 9.3.3 An Application to the Heart Disease Data", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 434, "start_word": 138880, "end_word": 139280, "chunk_words": 400}}, "ISLP_website::c000435": {"text": "using kernels, one need only compute K(xi,x/prime i)for all/parenleftbign 2/parenrightbig distinct pairs i, i/prime. This can be done without explicitly working in the enlarged feature space. This is im- portant because in many applications of SVMs, the enlarged feature space is so large that computations are intractable. For some kernels, such as the radial kernel ( 9.24), the feature space is implicitand infinite-dimensional, so we could never do the computations there anyway! 9.3.3 An Application to the Heart Disease Data InChapter 8weapplydecisiontreesandrelatedmethodstothe Heartdata. Theaim isto use 13predictorssuchas Age,Sex,andCholinorderto predict whether an individual has heart disease. We now investigate how an SVM compares to LDA on this data. After removing 6 missing observations, the data consist of 297 subjects, which we randomly split into 207 training and 90 test observations. We first fit LDA and the support vector classifier to the training data. NotethatthesupportvectorclassifierisequivalenttoanSVMusingapoly- nomial kernel of degree d=1. The left-hand panel of Figure 9.10displays ROC curves (described in Section 4.4.2) for the training set predictions for both LDA and the support vector classifier. Both classifiers compute scores of the form ˆf(X)=ˆβ0+ˆβ1X1+ˆβ2X2+···+ˆβpXpfor each observation. For any given cutoff t, we classify observations into the heart disease or no heart disease categories depending on whether ˆf(X)<torˆf(X)≥t. The ROC curve is obtained by forming these predictions and computing the false positive and true positive rates for a range of values of t. An opti- mal classifier will hug the top left corner of the ROC plot. In this instance 9.4 SVMs with More than Two Classes 383 False positive rateTrue positive rate0.0 0.2 0.4 0.6 0.8 1.00.0 0.2 0.4 0.6 0.8 1.0Support Vector ClassifierLDAFalse positive rateTrue positive rate0.0 0.2 0.4 0.6 0.8 1.00.0 0.2 0.4 0.6 0.8 1.0Support Vector ClassifierSVM: γ=10−3SVM: γ=10−2SVM: γ=10−1FIGURE 9.11. ROC curves for the test set of the Heartdata.Left:The support vector classifier and LDA are compared. Right:The support vector classifier is compared to an SVM using a radial basis kernel with γ= 10−3,10−2, and10−1. LDA and the support vector classifier both perform well, though there is a suggestion that the support vector classifier may be slightly superior. The right-hand panel of Figure 9.10displays ROC curves for SVMs using a radial kernel, with various values of γ. Asγincreases and the fit becomes more non-linear, the ROC curves improve. Using γ= 10−1appears to give an almost perfect ROC curve. However, these curves represent training error rates, which can be misleading in", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 435, "start_word": 139200, "end_word": 139600, "chunk_words": 400}}, "ISLP_website::c000436": {"text": "kernel with γ= 10−3,10−2, and10−1. LDA and the support vector classifier both perform well, though there is a suggestion that the support vector classifier may be slightly superior. The right-hand panel of Figure 9.10displays ROC curves for SVMs using a radial kernel, with various values of γ. Asγincreases and the fit becomes more non-linear, the ROC curves improve. Using γ= 10−1appears to give an almost perfect ROC curve. However, these curves represent training error rates, which can be misleading in terms of performance on new test data. Figure 9.11displays ROC curves computed on the 90test observa- tions. We observe some differences from the training ROC curves. In the left-hand panel of Figure 9.11, the support vector classifier appears to have a small advantage over LDA (although these differences are not statisti- cally significant). In the right-hand panel, the SVM using γ= 10−1, which showed the best results on the training data, produces the worst estimates on the test data. This is once again evidence that while a more flexible method will often produce lower training error rates, this does not neces- sarily lead to improved performance on test data. The SVMs with γ= 10−2 andγ= 10−3perform comparably to the support vector classifier, and all three outperform the SVM with γ= 10−1. 9.4 SVMs with More than Two Classes So far, our discussion has been limited to the case of binary classification: that is, classification in the two-class setting. How can we extend SVMs to the more general case where we have some arbitrary number of classes? It turns out that the concept of separating hyperplanes upon which SVMs are based does not lend itself naturally to more than two classes. Though a number of proposals for extending SVMs to the K-class case have been made, the two most popular are the one-versus-one andone-versus-all approaches. We briefly discuss those two approaches here. 384 9. Support Vector Machines 9.4.1 One-Versus-One Classification Suppose that we would like to perform classification using SVMs, and there areK> 2classes. A one-versus-one orall-pairs approach constructs/parenleftbigK 2/parenrightbig one-versus- one SVMs, each of which compares a pair of classes. For example, one such SVM might compare the kth class, coded as +1, to thek/primeth class, coded as−1. We classify a test observation using each of the/parenleftbigK 2/parenrightbig classifiers, and we tally the number of times that the test observation is assigned to each of theKclasses. The final classification is", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 436, "start_word": 139520, "end_word": 139920, "chunk_words": 400}}, "ISLP_website::c000437": {"text": "that we would like to perform classification using SVMs, and there areK> 2classes. A one-versus-one orall-pairs approach constructs/parenleftbigK 2/parenrightbig one-versus- one SVMs, each of which compares a pair of classes. For example, one such SVM might compare the kth class, coded as +1, to thek/primeth class, coded as−1. We classify a test observation using each of the/parenleftbigK 2/parenrightbig classifiers, and we tally the number of times that the test observation is assigned to each of theKclasses. The final classification is performed by assigning the test observation to the class to which it was most frequently assigned in these/parenleftbigK 2/parenrightbig pairwise classifications. 9.4.2 One-Versus-All Classification Theone-versus-all approach (also referred to as one-versus-rest ) is an al-one-versus- all one-versus- restternative procedure for applying SVMs in the case of K> 2classes. We fitKSVMs, each time comparing one of the Kclasses to the remaining K−1classes. Let β0k,β1k,...,βpkdenote the parameters that result from fitting an SVM comparing the kth class (coded as +1) to the others (coded as−1). Letx∗denote a test observation. We assign the observation to the class for which β0k+β1kx∗ 1+β2kx∗ 2+···+βpkx∗ pis largest, as this amounts to a high level of confidence that the test observation belongs to the kth class rather than to any of the other classes. 9.5 Relationship to Logistic Regression When SVMs were first introduced in the mid-1990s, they made quite a splash in the statistical and machine learning communities. This was due in part to their good performance, good marketing, and also to the fact that the underlying approach seemed both novel and mysterious. The idea of finding a hyperplane that separates the data as well as possible, while al- lowing some violations to this separation, seemed distinctly different from classical approaches for classification, such as logistic regression and lin- ear discriminant analysis. Moreover, the idea of using a kernel to expand the feature space in order to accommodate non-linear class boundaries ap- peared to be a unique and valuable characteristic. However, since that time, deep connections between SVMs and other more classical statistical methods have emerged. It turns out that one can rewrite the criterion ( 9.12)–(9.15) for fitting the support vector classifier f(X)=β0+β1X1+···+βpXpas minimize β0,β1,...,βp  n/summationdisplay i=1max [0 ,1−yif(xi)] +λp/summationdisplay j=1β2 j  , (9.25) whereλis a nonnegative tuning parameter. When λis large then β1,...,βp are small, more violations to the margin are tolerated, and a low-variance but high-bias classifier will result. When λis", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 437, "start_word": 139840, "end_word": 140240, "chunk_words": 400}}, "ISLP_website::c000438": {"text": "unique and valuable characteristic. However, since that time, deep connections between SVMs and other more classical statistical methods have emerged. It turns out that one can rewrite the criterion ( 9.12)–(9.15) for fitting the support vector classifier f(X)=β0+β1X1+···+βpXpas minimize β0,β1,...,βp  n/summationdisplay i=1max [0 ,1−yif(xi)] +λp/summationdisplay j=1β2 j  , (9.25) whereλis a nonnegative tuning parameter. When λis large then β1,...,βp are small, more violations to the margin are tolerated, and a low-variance but high-bias classifier will result. When λis small then few violations to the margin will occur; this amounts to a high-variance but low-bias 9.5 Relationship to Logistic Regression 385 classifier. Thus, a small value of λin (9.25) amounts to a small value of C in (9.15). Note that the λ/summationtextp j=1β2 jterm in ( 9.25) is the ridge penalty term from Section 6.2.1, and plays a similar role in controlling the bias-variance trade-off for the support vector classifier. Now(9.25)takesthe“Loss+Penalty”formthatwehaveseenrepeatedly throughout this book: minimize β0,β1,...,βp{L(X,y,β)+λP(β)}. (9.26) In (9.26),L(X,y,β)is some loss function quantifying the extent to which the model, parametrized by β, fits the data (X,y), andP(β)is a penalty function on the parameter vector βwhose effect is controlled by a nonneg- ative tuning parameter λ. For instance, ridge regression and the lasso both take this form with L(X,y,β)=n/summationdisplay i=1 yi−β0−p/summationdisplay j=1xijβj 2 and with P(β)=/summationtextp j=1β2 jfor ridge regression and P(β)=/summationtextp j=1|βj|for the lasso. In the case of ( 9.25) the loss function instead takes the form L(X,y,β)=n/summationdisplay i=1max [0 ,1−yi(β0+β1xi1+···+βpxip)]. This is known as hinge loss , and is depicted in Figure 9.12. However, ithinge lossturns out that the hinge loss function is closely related to the loss function used in logistic regression, also shown in Figure 9.12. An interesting characteristic of the support vector classifier is that only support vectors play a role in the classifier obtained; observations on the correct side of the margin do not affect it. This is due to the fact that the loss function shown in Figure 9.12is exactly zero for observations for which yi(β0+β1xi1+···+βpxip)≥1; these correspond to observations that are on the correct side of the margin.3In contrast, the loss function for logistic regression shown in Figure 9.12is not exactly zero anywhere. But it is very small for observations that are far from the decision boundary. Due to the similarities between their loss functions, logistic regression and the support vector classifier often give very similar results. When the classes are well", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 438, "start_word": 140160, "end_word": 140560, "chunk_words": 400}}, "ISLP_website::c000439": {"text": "loss function shown in Figure 9.12is exactly zero for observations for which yi(β0+β1xi1+···+βpxip)≥1; these correspond to observations that are on the correct side of the margin.3In contrast, the loss function for logistic regression shown in Figure 9.12is not exactly zero anywhere. But it is very small for observations that are far from the decision boundary. Due to the similarities between their loss functions, logistic regression and the support vector classifier often give very similar results. When the classes are well separated, SVMs tend to behave better than logistic regression; in more overlapping regimes, logistic regression is often preferred. When the support vector classifier and SVM were first introduced, it was thought that the tuning parameter Cin (9.15) was an unimportant “nui- sance” parameter that could be set to some default value, like 1. However, the “Loss + Penalty” formulation ( 9.25) for the support vector classifier indicates that this is not the case. The choice of tuning parameter is very important and determines the extent to which the model underfits or over- fits the data, as illustrated, for example, in Figure 9.7. 3With this hinge-loss + penalty representation, the margin corresponds to the value one, and the width of the margin is determined by/summationtextβ2 j. 386 9. Support Vector Machines −6 −4 −2 0 202468LossSVM LossLogistic Regression Loss yi(β0+β1xi1+...+βpxip)FIGURE 9.12. The SVM and logistic regression loss functions are compared, as a function of yi(β0+β1xi1+···+βpxip). Whenyi(β0+β1xi1+···+βpxip)is greater than 1, then the SVM loss is zero, since this corresponds to an observation that is on the correct side of the margin. Overall, the two loss functions have quite similar behavior. We have established that the support vector classifier is closely related to logistic regression and other preexisting statistical methods. Is the SVM unique in its use of kernels to enlarge the feature space to accommodate non-linear class boundaries? The answer to this question is “no”. We could just as well perform logistic regression or many of the other classification methods seen in this book using non-linear kernels; this is closely related to some of the non-linear approaches seen in Chapter 7. However, for his- torical reasons, the use of non-linear kernels is much more widespread in the context of SVMs than in the context of logistic regression or other methods. Though we have not addressed it here, there is in fact an extension of the SVM for regression (i.e. for a quantitative", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 439, "start_word": 140480, "end_word": 140880, "chunk_words": 400}}, "ISLP_website::c000440": {"text": "regression or many of the other classification methods seen in this book using non-linear kernels; this is closely related to some of the non-linear approaches seen in Chapter 7. However, for his- torical reasons, the use of non-linear kernels is much more widespread in the context of SVMs than in the context of logistic regression or other methods. Though we have not addressed it here, there is in fact an extension of the SVM for regression (i.e. for a quantitative rather than a qualita- tive response), called support vector regression . In Chapter 3, we saw thatsupport vector regressionleast squares regression seeks coefficients β0,β1,...,βpsuch that the sum of squared residuals is as small as possible. (Recall from Chapter 3that residuals are defined as yi−β0−β1xi1−···−βpxip.) Support vector regression instead seeks coefficients that minimize a different type of loss, where only residuals larger in absolute value than some positive constant contribute to the loss function. This is an extension of the margin used in support vector classifiers to the regression setting. 9.6 Lab: Support Vector Machines 3879.6 Lab: Support Vector MachinesIn this lab, we use thesklearn.svmlibrary to demonstrate the supportvector classifier and the support vector machine.We import some of our usual libraries.In[1]:import numpy as npfrom matplotlib.pyplot import subplots, cmimport sklearn.model_selection as skmfrom ISLP import load_data, confusion_tableWe also collect the new imports needed for this lab.In[2]:from sklearn.svm import SVCfrom ISLP.svm import plot as plot_svmfrom sklearn.metrics import RocCurveDisplayWe will use the functionRocCurveDisplay.from_estimator()to produceRocCurveDisplay.from_estimator()several ROC plots, using a shorthandroc_curve.In[3]:roc_curve = RocCurveDisplay.from_estimator#s h o r t h a n d9.6.1 Support Vector ClassifierWe now use theSupportVectorClassifier()function (abbreviatedSVC())SupportVectorClassifier()fromsklearnto fit the support vector classifier for a given value of theparameterC. TheCargument allows us to specify the cost of a violationto the margin. When thecostargument is small, then the margins will bewide and many support vectors will be on the margin or will violate themargin. When theCargument is large, then the margins will be narrow andthere will be few support vectors on the margin or violating the margin.Here we demonstrate the use ofSVC()on a two-dimensional example, sothat we can plot the resulting decision boundary. We begin by generatingthe observations, which belong to two classes, and checking whether theclasses are linearly separable.In[4]:rng = np.random.default_rng(1)X=r n g . s t a n d a r d _ n o r m a l ( ( 5 0 ,2 ) )y=n p . a r r a y ( [ - 1", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 440, "start_word": 140800, "end_word": 141200, "chunk_words": 400}}, "ISLP_website::c000441": {"text": "support vectors on the margin or violating the margin.Here we demonstrate the use ofSVC()on a two-dimensional example, sothat we can plot the resulting decision boundary. We begin by generatingthe observations, which belong to two classes, and checking whether theclasses are linearly separable.In[4]:rng = np.random.default_rng(1)X=r n g . s t a n d a r d _ n o r m a l ( ( 5 0 ,2 ) )y=n p . a r r a y ( [ - 1 ] * 2 5 + [ 1 ] * 2 5 )X[y==1] += 1fig, ax = subplots(figsize=(8,8))ax.scatter(X[:,0],X[:,1],c=y,cmap=cm.coolwarm);They are not. We now fit the classifier.In[5]:svm_linear = SVC(C=10, kernel='linear')svm_linear.fit(X, y)Out[5]:SVC(C=10, kernel='linear')The support vector classifier with two features can be visualized by plot-ting values of itsdecision function. We have included a function for this indecisionfunctiontheISLPpackage (inspired by a similar example in thesklearndocs). 388 9. Support Vector MachinesIn[6]:fig, ax = subplots(figsize=(8,8))plot_svm(X,y,svm_linear,ax=ax)The decision boundary between the two classes is linear (because weused the argumentkernel='linear'). The support vectors are marked with+and the remaining observations are plotted as circles.What if we instead used a smaller value of the cost parameter?In[7]:svm_linear_small = SVC(C=0.1, kernel='linear')svm_linear_small.fit(X, y)fig, ax = subplots(figsize=(8,8))plot_svm(X,y,svm_linear_small,ax=ax)With a smaller value of the cost parameter, we obtain a larger number ofsupport vectors, because the margin is now wider. For linear kernels, wecan extract the coefficients of the linear decision boundary as follows:In[8]:svm_linear.coef_Out[8]:array([[1.173 , 0.7734]])Since the support vector machine is an estimator insklearn, we can usethe usual machinery to tune it.In[9]:kfold = skm.KFold(5,random_state=0,shuffle=True)grid = skm.GridSearchCV(svm_linear,{'C':[0.001,0.01,0.1,1,5,10,100]},refit=True,cv=kfold,scoring='accuracy')grid.fit(X, y)grid.best_params_Out[9]:{'C':1 }Wecaneasilyaccessthecross-validationerrorsforeachofthesemodelsingrid.cv_results_. This prints out a lot of detail, so we extract the accuracyresults only.In[10]:grid.cv_results_[('mean_test_score')]Out[10]:array([0.46, 0.46, 0.72, 0.74, 0.74, 0.74, 0.74])We see thatC=1results in the highest cross-validation accuracy of 0.74,though the accuracy is the same for several values ofC. The classifiergrid.best_estimator_can be used to predict the class label on a set oftest observations. Let’s generate a test data set. 9.6 Lab: Support Vector Machines 389In[11]:X_test = rng.standard_normal((20, 2))y_test = np.array([-1]*10+[1]*10)X_test[y_test==1] += 1Nowwepredicttheclasslabelsofthesetestobservations.Hereweusethebest model selected by cross-validation in order to make the predictions.In[12]:best_ = grid.best_estimator_y_test_hat = best_.predict(X_test)confusion_table(y_test_hat, y_test)Out[12]:Truth -1 1Predicted-1 8 4126Thus, with this value ofC, 70% of the test observations are correctly clas-sified. What if we had instead usedC=0.001?In[13]:svm_ = SVC(C=0.001,kernel='linear').fit(X, y)y_test_hat = svm_.predict(X_test)confusion_table(y_test_hat, y_test)Out[13]:Truth -1 1Predicted-1 2 018 1 0In this case 60% of test observations are correctly classified.We now consider a situation in which the two classes are linearly sepa-rable. Then we can find an optimal separating hyperplane using theSVC()estimator. We first", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 441, "start_word": 141120, "end_word": 141520, "chunk_words": 400}}, "ISLP_website::c000442": {"text": "by cross-validation in order to make the predictions.In[12]:best_ = grid.best_estimator_y_test_hat = best_.predict(X_test)confusion_table(y_test_hat, y_test)Out[12]:Truth -1 1Predicted-1 8 4126Thus, with this value ofC, 70% of the test observations are correctly clas-sified. What if we had instead usedC=0.001?In[13]:svm_ = SVC(C=0.001,kernel='linear').fit(X, y)y_test_hat = svm_.predict(X_test)confusion_table(y_test_hat, y_test)Out[13]:Truth -1 1Predicted-1 2 018 1 0In this case 60% of test observations are correctly classified.We now consider a situation in which the two classes are linearly sepa-rable. Then we can find an optimal separating hyperplane using theSVC()estimator. We first further separate the two classes in our simulated dataso that they are linearly separable:In[14]:X[y==1] += 1.9;fig, ax = subplots(figsize=(8,8))ax.scatter(X[:,0], X[:,1], c=y, cmap=cm.coolwarm);Now the observations are just barely linearly separable.In[15]:svm_ = SVC(C=1e5, kernel='linear').fit(X, y)y_hat = svm_.predict(X)confusion_table(y_hat, y)Out[15]:Truth -1 1Predicted-1 25 010 2 5We fit the support vector classifier and plot the resulting hyperplane, usinga very large value ofCso that no observations are misclassified.In[16]:fig, ax = subplots(figsize=(8,8))plot_svm(X,y,svm_,ax=ax) 390 9. Support Vector Machines Indeed no training errors were made and only three support vectors were used. In fact, the large value of Calso means that these three support points areon the margin , and define it. One may wonder how good the classifier could be on test data that depends on only three data points! We now try a smaller value of C. In[17]: svm_ = SVC(C=0.1, kernel= 'linear' ).fit(X, y) y_hat = svm_.predict(X) confusion_table(y_hat, y) Out[17]: Truth -1 1 Predicted -1 25 0 10 2 5 UsingC=0.1, we again do not misclassify any training observations, but we also obtain a much wider margin and make use of twelve support vectors. These jointly define the orientation of the decision boundary, and since there are more of them, it is more stable. It seems possible that this model will perform better on test data than the model with C=1e5(and indeed, a simple experiment with a large test set would bear this out). In[18]: fig, ax = subplots(figsize=(8,8)) plot_svm(X, y, svm_, ax=ax) 9.6.2 Support Vector Machine In order to fit an SVM using a non-linear kernel, we once again use the SVC()estimator. However, now we use a different value of the parameter kernel. To fit an SVM with a polynomial kernel we use kernel=\"poly\" , and to fit an SVM with a radial kernel we use kernel=\"rbf\" . In the former case we also use the degreeargument to specify a degree for the polynomial kernel (this is din (9.22)), and in the latter case we", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 442, "start_word": 141440, "end_word": 141840, "chunk_words": 400}}, "ISLP_website::c000443": {"text": "Machine In order to fit an SVM using a non-linear kernel, we once again use the SVC()estimator. However, now we use a different value of the parameter kernel. To fit an SVM with a polynomial kernel we use kernel=\"poly\" , and to fit an SVM with a radial kernel we use kernel=\"rbf\" . In the former case we also use the degreeargument to specify a degree for the polynomial kernel (this is din (9.22)), and in the latter case we use gammato specify a value ofγfor the radial basis kernel ( 9.24). We first generate some data with a non-linear class boundary, as follows: In[19]: X=r n g . s t a n d a r d _ n o r m a l ( ( 2 0 0 ,2 ) ) X[:100] += 2 X[100:150] -= 2 y=n p . a r r a y ( [ 1 ] * 1 5 0 + [ 2 ] * 5 0 ) Plotting the data makes it clear that the class boundary is indeed non- linear. In[20]: fig, ax = subplots(figsize=(8,8)) ax.scatter(X[:,0], X[:,1], c=y, cmap=cm.coolwarm) Out[20]: <matplotlib.collections.PathCollection at 0x7faa9ba52eb0> 9.6 Lab: Support Vector Machines 391The data is randomly split into training and testing groups. We then fitthe training data using theSVC()estimator with a radial kernel andγ=1:In[21]:(X_train,X_test,y_train,y_test) = skm.train_test_split(X,y,test_size=0.5,random_state=0)svm_rbf = SVC(kernel=\"rbf\",g a m m a = 1 ,C = 1 )svm_rbf.fit(X_train, y_train)TheplotshowsthattheresultingSVMhasadecidedlynon-linearbound-ary.In[22]:fig, ax = subplots(figsize=(8,8))plot_svm(X_train,y_train,svm_rbf,ax=ax)We can see from the figure that there are a fair number of training errorsin this SVM fit. If we increase the value ofC, we can reduce the numberof training errors. However, this comes at the price of a more irregulardecision boundary that seems to be at risk of overfitting the data.In[23]:svm_rbf = SVC(kernel=\"rbf\",g a m m a = 1 ,C = 1 e 5 )svm_rbf.fit(X_train, y_train)fig, ax = subplots(figsize=(8,8))plot_svm(X_train,y_train,svm_rbf,ax=ax)We can perform cross-validation usingskm.GridSearchCV()to select thebest choice ofγandCfor an SVM with a radial kernel:In[24]:kfold = skm.KFold(5,random_state=0,shuffle=True)grid = skm.GridSearchCV(svm_rbf,{'C':[0.1,1,10,100,1000],'gamma':[0.5,1,2,3,4]},refit=True,cv=kfold,scoring='accuracy');grid.fit(X_train, y_train)grid.best_params_Out[24]:{'C':1 0 0 ,'gamma':1 }The best choice of parameters under five-fold CV is achieved atC=1andgamma=0.5, though several other values also achieve the same value.In[25]:best_svm = grid.best_estimator_fig, ax = subplots(figsize=(8,8))plot_svm(X_train, 392 9. Support Vector Machines y_train, best_svm, ax=ax) y_hat_test = best_svm.predict(X_test) confusion_table(y_hat_test, y_test) Out[25]: Truth 1 2 Predicted 16 9 6 26 1 9 With these parameters, 12% of test observations are misclassified by this SVM. 9.6.3 ROC Curves SVMsandsupportvectorclassifiersoutputclasslabelsforeachobservation. However, it is also possible to obtain fitted values for", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 443, "start_word": 141760, "end_word": 142160, "chunk_words": 400}}, "ISLP_website::c000444": {"text": "skm.GridSearchCV(svm_rbf,{'C':[0.1,1,10,100,1000],'gamma':[0.5,1,2,3,4]},refit=True,cv=kfold,scoring='accuracy');grid.fit(X_train, y_train)grid.best_params_Out[24]:{'C':1 0 0 ,'gamma':1 }The best choice of parameters under five-fold CV is achieved atC=1andgamma=0.5, though several other values also achieve the same value.In[25]:best_svm = grid.best_estimator_fig, ax = subplots(figsize=(8,8))plot_svm(X_train, 392 9. Support Vector Machines y_train, best_svm, ax=ax) y_hat_test = best_svm.predict(X_test) confusion_table(y_hat_test, y_test) Out[25]: Truth 1 2 Predicted 16 9 6 26 1 9 With these parameters, 12% of test observations are misclassified by this SVM. 9.6.3 ROC Curves SVMsandsupportvectorclassifiersoutputclasslabelsforeachobservation. However, it is also possible to obtain fitted values for each observation, which are the numerical scores used to obtain the class labels. For instance, in the case of a support vector classifier, the fitted value for an observation X=(X1,X2,...,X p)Ttakes the form ˆβ0+ˆβ1X1+ˆβ2X2+...+ˆβpXp. For an SVM with a non-linear kernel, the equation that yields the fitted value is given in ( 9.23). The sign of the fitted value determines on which side of the decision boundary the observation lies. Therefore, the relationship between the fitted value and the class prediction for a given observation is simple: if the fitted value exceeds zero then the observation is assigned to one class, and if it is less than zero then it is assigned to the other. By changing this threshold from zero to some positive value, we skew the classifications in favor of one class versus the other. By considering a range of these thresholds, positive and negative, we produce the ingredients for a ROC plot. We can access these values by calling the decision_function().function_ decision() method of a fitted SVM estimator. The function ROCCurveDisplay.from_estimator() (which we have abbre- viated to roc_curve() ) will produce a plot of a ROC curve. It takes a fittedroc_curve()estimator as its first argument, followed by a model matrix Xand labels y. The argument nameis used in the legend, while coloris used for the color of the line. Results are plotted on our axis object ax. In[26]: fig, ax = subplots(figsize=(8,8)) roc_curve(best_svm, X_train, y_train, name='Training' , color='r', ax=ax); In this example, the SVM appears to provide accurate predictions. By increasing γwe can produce a more flexible fit and generate further im- provements in accuracy. In[27]: svm_flex = SVC(kernel= \"rbf\", gamma=50, 9.6 Lab: Support Vector Machines 393 C=1) svm_flex.fit(X_train, y_train) fig, ax = subplots(figsize=(8,8)) roc_curve(svm_flex, X_train, y_train, name='Training $\\gamma=50$' , color='r', ax=ax); However, these ROC curves are all on the training data. We are really more interested in the level of prediction accuracy on the test data.", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 444, "start_word": 142080, "end_word": 142480, "chunk_words": 400}}, "ISLP_website::c000445": {"text": "color='r', ax=ax); In this example, the SVM appears to provide accurate predictions. By increasing γwe can produce a more flexible fit and generate further im- provements in accuracy. In[27]: svm_flex = SVC(kernel= \"rbf\", gamma=50, 9.6 Lab: Support Vector Machines 393 C=1) svm_flex.fit(X_train, y_train) fig, ax = subplots(figsize=(8,8)) roc_curve(svm_flex, X_train, y_train, name='Training $\\gamma=50$' , color='r', ax=ax); However, these ROC curves are all on the training data. We are really more interested in the level of prediction accuracy on the test data. When we compute the ROC curves on the test data, the model with γ=0.5 appears to provide the most accurate results. In[28]: roc_curve(svm_flex, X_test, y_test, name='Test $\\gamma=50$' , color='b', ax=ax) fig; Let’s look at our tuned SVM. In[29]: fig, ax = subplots(figsize=(8,8)) for (X_, y_, c, name) in zip( (X_train, X_test), (y_train, y_test), ('r','b'), ('CV tuned on training' , 'CV tuned on test' )): roc_curve(best_svm, X_, y_, name=name, ax=ax, color=c) 9.6.4 SVM with Multiple Classes If the response is a factor containing more than two levels, then the SVC() function will perform multi-class classification using either the one-versus- one approach (when decision_function_shape=='ovo' ) or one-versus-rest4 (whendecision_function_shape=='ovr' ). We explore that setting briefly here by generating a third class of observations. In[30]: rng = np.random.default_rng(123) X=n p . v s t a c k ( [ X ,r n g . s t a n d a r d _ n o r m a l ( ( 5 0 ,2 ) ) ] ) y=n p . h s t a c k ( [ y ,[ 0 ] * 5 0 ] ) X[y==0,1] += 2 fig, ax = subplots(figsize=(8,8)) ax.scatter(X[:,0], X[:,1], c=y, cmap=cm.coolwarm); 4One-versus-rest is also known as one-versus-all. 394 9. Support Vector MachinesWe now fit an SVM to the data:In[31]:svm_rbf_3 = SVC(kernel=\"rbf\",C=10,gamma=1,decision_function_shape='ovo');svm_rbf_3.fit(X, y)fig, ax = subplots(figsize=(8,8))plot_svm(X,y,svm_rbf_3,scatter_cmap=cm.tab10,ax=ax)Thesklearn.svmlibrary can also be used to perform support vector re-gression with a numerical response using the estimatorSupportVector-Regression().SupportVectorRegression()9.6.5 Application to Gene Expression DataWe now examine theKhandata set, which consists of a number of tissuesamples corresponding to four distinct types of small round blue cell tu-mors. For each tissue sample, gene expression measurements are available.The data set consists of training data,xtrainandytrain, and testing data,xtestandytest.We examine the dimension of the data:In[32]:Khan = load_data('Khan')Khan['xtrain'].shape, Khan['xtest'].shapeOut[32]:((63, 2308), (20, 2308))This data set consists of expression measurements for 2,308 genes. Thetraining and test sets consist of 63 and 20 observations, respectively.We will use a support vector approach to predict", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 445, "start_word": 142400, "end_word": 142800, "chunk_words": 400}}, "ISLP_website::c000446": {"text": "now examine theKhandata set, which consists of a number of tissuesamples corresponding to four distinct types of small round blue cell tu-mors. For each tissue sample, gene expression measurements are available.The data set consists of training data,xtrainandytrain, and testing data,xtestandytest.We examine the dimension of the data:In[32]:Khan = load_data('Khan')Khan['xtrain'].shape, Khan['xtest'].shapeOut[32]:((63, 2308), (20, 2308))This data set consists of expression measurements for 2,308 genes. Thetraining and test sets consist of 63 and 20 observations, respectively.We will use a support vector approach to predict cancer subtype usinggeneexpressionmeasurements.Inthisdataset,thereisaverylargenumberof features relative to the number of observations. This suggests that weshould use a linear kernel, because the additional flexibility that will resultfrom using a polynomial or radial kernel is unnecessary.In[33]:khan_linear = SVC(kernel='linear',C = 1 0 )khan_linear.fit(Khan['xtrain'], Khan['ytrain'])confusion_table(khan_linear.predict(Khan['xtrain']),Khan['ytrain'])Out[33]:Truth 1 2 3 4Predicted18 0 0 020 2 3 0 030 0 1 2 040 0 0 2 0We see that there arenotraining errors. In fact, this is not surprising,becausethelargenumberofvariablesrelativetothenumberofobservationsimplies that it is easy to find hyperplanes that fully separate the classes. 9.7 Exercises 395We are more interested in the support vector classifier’s performance onthe test observations.In[34]:confusion_table(khan_linear.predict(Khan['xtest']),Khan['ytest'])Out[34]:Truth 1 2 3 4Predicted13 0 0 020 6 2 030 0 4 040 0 0 5We see that usingC=10yields two test set errors on these data.9.7 ExercisesConceptual1. This problem involves hyperplanes in two dimensions.(a) Sketch the hyperplane1+3X1−X2=0. Indicate the set ofpoints for which1+3X1−X2>0, as well as the set of pointsfor which1+3X1−X2<0.(b) On the same plot, sketch the hyperplane−2+X1+2X2=0.Indicate the set of points for which−2+X1+2X2>0, as wellas the set of points for which−2+X1+2X2<0.2. We have seen that inp=2dimensions, a linear decision boundarytakes the formβ0+β1X1+β2X2=0. We now investigate a non-lineardecision boundary.(a) Sketch the curve(1 +X1)2+ (2−X2)2=4.(b) On your sketch, indicate the set of points for which(1 +X1)2+ (2−X2)2>4,as well as the set of points for which(1 +X1)2+ (2−X2)2≤4.(c) Suppose that a classifier assigns an observation to the blue classif(1 +X1)2+ (2−X2)2>4,and to the red class otherwise. To what class is the observation(0,0)classified?(−1,1)?(2,2)?(3,8)?(d) Argue that while the decision boundary in (c) is not linear interms ofX1andX2, it is linear in terms ofX1,X21,X2, andX22. 396 9. Support Vector Machines 3. Here we explore the maximal margin classifier on a toy data set. (a) We are given n=7observations in p=2dimensions. For each observation, there is an associated class label. Obs.X1X2 Y 1 3 4 Red 2 2 2 Red 3 4 4 Red 4 1 4 Red 5 2 1 Blue 6 4 3 Blue 7 4 1", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 446, "start_word": 142720, "end_word": 143120, "chunk_words": 400}}, "ISLP_website::c000447": {"text": "the decision boundary in (c) is not linear interms ofX1andX2, it is linear in terms ofX1,X21,X2, andX22. 396 9. Support Vector Machines 3. Here we explore the maximal margin classifier on a toy data set. (a) We are given n=7observations in p=2dimensions. For each observation, there is an associated class label. Obs.X1X2 Y 1 3 4 Red 2 2 2 Red 3 4 4 Red 4 1 4 Red 5 2 1 Blue 6 4 3 Blue 7 4 1 Blue Sketch the observations. (b) Sketchtheoptimalseparatinghyperplane,andprovidetheequa- tion for this hyperplane (of the form ( 9.1)). (c) Describe the classification rule for the maximal margin classifier. It should be something along the lines of “Classify to Red if β0+β1X1+β2X2>0, and classify to Blue otherwise.” Provide the values for β0,β1, andβ2. (d) On your sketch, indicate the margin for the maximal margin hyperplane. (e) Indicate the support vectors for the maximal margin classifier. (f) Argue that a slight movement of the seventh observation would not affect the maximal margin hyperplane. (g) Sketch a hyperplane that is notthe optimal separating hyper- plane, and provide the equation for this hyperplane. (h) Draw an additional observation on the plot so that the two classes are no longer separable by a hyperplane. Applied 4. Generate a simulated two-class data set with 100 observations and two features in which there is a visible but non-linear separation be- tween the two classes. Show that in this setting, a support vector machine with a polynomial kernel (with degree greater than 1) or a radial kernel will outperform a support vector classifier on the train- ing data. Which technique performs best on the test data? Make plots and report training and test error rates in order to back up your assertions. 5. WehaveseenthatwecanfitanSVMwithanon-linearkernelinorder toperformclassificationusinganon-lineardecisionboundary.Wewill now see that we can also obtain a non-linear decision boundary by performing logistic regression using non-linear transformations of the features. 9.7 Exercises 397 (a) Generateadatasetwith n= 500 andp=2,suchthattheobser- vationsbelong totwoclasses witha quadratic decision boundary between them. For instance, you can do this as follows: rng = np.random.default_rng(5) x1 = rng.uniform(size=500) - 0.5 x2 = rng.uniform(size=500) - 0.5 y=x 1 * * 2-x 2 * * 2>0 (b) Plot the observations, colored according to their class labels. Your plot should display X1on thex-axis, and X2on they- axis. (c) Fit a logistic regression model to the data, using X1andX2as predictors. (d) Apply this model to the training", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 447, "start_word": 143040, "end_word": 143440, "chunk_words": 400}}, "ISLP_website::c000448": {"text": "n= 500 andp=2,suchthattheobser- vationsbelong totwoclasses witha quadratic decision boundary between them. For instance, you can do this as follows: rng = np.random.default_rng(5) x1 = rng.uniform(size=500) - 0.5 x2 = rng.uniform(size=500) - 0.5 y=x 1 * * 2-x 2 * * 2>0 (b) Plot the observations, colored according to their class labels. Your plot should display X1on thex-axis, and X2on they- axis. (c) Fit a logistic regression model to the data, using X1andX2as predictors. (d) Apply this model to the training data in order to obtain a pre- dicted class label for each training observation. Plot the ob- servations, colored according to the predicted class labels. The decision boundary should be linear. (e) Now fit a logistic regression model to the data using non-linear functions of X1andX2as predictors (e.g. X2 1,X1×X2,log(X2), and so forth). (f) Apply this model to the training data in order to obtain a pre- dicted class label for each training observation. Plot the ob- servations, colored according to the predicted class labels. The decision boundary should be obviously non-linear. If it is not, then repeat (a)–(e) until you come up with an example in which the predicted class labels are obviously non-linear. (g) Fit a support vector classifier to the data with X1andX2as predictors. Obtain a class prediction for each training observa- tion. Plot the observations, colored according to the predicted class labels . (h) Fit a SVM using a non-linear kernel to the data. Obtain a class prediction for each training observation. Plot the observations, colored according to the predicted class labels . (i) Comment on your results. 6. AttheendofSection 9.6.1,itisclaimedthatinthecaseofdatathatis just barely linearly separable, a support vector classifier with a small value of Cthat misclassifies a couple of training observations may perform better on test data than one with a huge value of Cthat does not misclassify any training observations. You will now investigate this claim. (a) Generatetwo-classdatawith p=2insuchawaythattheclasses are just barely linearly separable. (b) Compute the cross-validation error rates for support vector classifiers with a range of Cvalues. How many training obser- vations are misclassified for each value of Cconsidered, and how does this relate to the cross-validation errors obtained? 398 9. Support Vector Machines(c) Generate an appropriate test data set, and compute the testerrorscorrespondingtoeachofthevaluesofCconsidered.Whichvalue ofCleads to the fewest test errors, and how does thiscompare to the values ofCthat yield the fewest training errorsand the fewest cross-validation errors?(d) Discuss your results.7. In this problem,", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 448, "start_word": 143360, "end_word": 143760, "chunk_words": 400}}, "ISLP_website::c000449": {"text": "Compute the cross-validation error rates for support vector classifiers with a range of Cvalues. How many training obser- vations are misclassified for each value of Cconsidered, and how does this relate to the cross-validation errors obtained? 398 9. Support Vector Machines(c) Generate an appropriate test data set, and compute the testerrorscorrespondingtoeachofthevaluesofCconsidered.Whichvalue ofCleads to the fewest test errors, and how does thiscompare to the values ofCthat yield the fewest training errorsand the fewest cross-validation errors?(d) Discuss your results.7. In this problem, you will use support vector approaches in order topredict whether a given car gets high or low gas mileage based on theAutodata set.(a) Create a binary variable that takes on a1for cars with gasmileage above the median, and a0for cars with gas mileagebelow the median.(b) Fit a support vector classifier to the data with various values ofC, in order to predict whether a car gets high or low gas mileage.Report the cross-validation errors associated with different val-ues of this parameter. Comment on your results. Note you willneed to fit the classifier without the gas mileage variable to pro-duce sensible results.(c) Now repeat (b), this time using SVMs with radial and polyno-mial basis kernels, with different values ofgammaanddegreeandC. Comment on your results.(d) Make some plots to back up your assertions in (b) and (c).Hint: In the lab, we used theplot_svm()function for fitted SVMs.Whenp>2, you can use the keyword argumentfeaturestocreate plots displaying pairs of variables at a time.8. This problem involves theOJdata set which is part of theISLPpackage.(a) Create a training set containing a random sample of800observations, and a test set containing the remainingobservations.(b) Fit a support vector classifier to the training data usingC = 0.01, withPurchaseas the response and the other variablesas predictors. How many support points are there?(c) What are the training and test error rates?(d) Use cross-validation to select an optimalC. Consider values inthe range0.01to10.(e) Compute the training and test error rates using this new valueforC.(f) Repeat parts (b) through (e) using a support vector machinewith a radial kernel. Use the default value forgamma.(g) Repeat parts (b) through (e) using a support vector machinewith a polynomial kernel. Setdegree = 2.(h) Overall, which approach seems to give the best results on thisdata? 10 Deep Learning This chapter covers the important topic of deep learning . At the time ofdeep learningwriting(2020),deeplearningisaveryactiveareaofresearchinthemachine learning and artificial intelligence communities. The cornerstone of deep learning is the neural network .neural networkNeural networks rose to fame", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 449, "start_word": 143680, "end_word": 144080, "chunk_words": 400}}, "ISLP_website::c000450": {"text": "through (e) using a support vector machinewith a radial kernel. Use the default value forgamma.(g) Repeat parts (b) through (e) using a support vector machinewith a polynomial kernel. Setdegree = 2.(h) Overall, which approach seems to give the best results on thisdata? 10 Deep Learning This chapter covers the important topic of deep learning . At the time ofdeep learningwriting(2020),deeplearningisaveryactiveareaofresearchinthemachine learning and artificial intelligence communities. The cornerstone of deep learning is the neural network .neural networkNeural networks rose to fame in the late 1980s. There was a lot of excite- ment and a certain amount of hype associated with this approach, and they were the impetus for the popular Neural Information Processing Systems meetings (NeurIPS, formerly NIPS) held every year, typically in exotic places like ski resorts. This was followed by a synthesis stage, where the properties of neural networks were analyzed by machine learners, math- ematicians and statisticians; algorithms were improved, and the method- ology stabilized. Then along came SVMs, boosting, and random forests, and neural networks fell somewhat from favor. Part of the reason was that neural networks required a lot of tinkering, while the new methods were more automatic. Also, on many problems the new methods outperformed poorly-trained neural networks. This was the status quo for the first decade in the new millennium. All the while, though, a core group of neural-network enthusiasts were pushingtheirtechnologyharderonever-largercomputingarchitecturesand data sets. Neural networks resurfaced after 2010 with the new name deep learning, with new architectures, additional bells and whistles, and a string of success stories on some niche problems such as image and video classifi- cation, speech and text modeling. Many in the field believe that the major reason for these successes is the availability of ever-larger training datasets, made possible by the wide-scale use of digitization in science and industry. In this chapter we discuss the basics of neural networks and deep learn- ing, and then go into some of the specializations for specific problems, such as convolutional neural networks (CNNs) for image classification, and re- current neural networks (RNNs) for time series and other sequences. We © Springer Nature Switzerland AG 2023 G. James et al., An Introduction to Statistical Learning , Springer Texts in Statistics, https://doi.org/10.1007/978-3-031-38747-0_10 399 400 10. Deep Learning X1X2X3X4A1A2A3A4A5f(X)YHiddenLayerInputLayerOutputLayer FIGURE 10.1. Neural network with a single hidden layer. The hidden layer computes activations Ak=hk(X)that are nonlinear transformations of linear combinations of the inputs X1,X2,...,X p.", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 450, "start_word": 144000, "end_word": 144400, "chunk_words": 400}}, "ISLP_website::c000451": {"text": "the specializations for specific problems, such as convolutional neural networks (CNNs) for image classification, and re- current neural networks (RNNs) for time series and other sequences. We © Springer Nature Switzerland AG 2023 G. James et al., An Introduction to Statistical Learning , Springer Texts in Statistics, https://doi.org/10.1007/978-3-031-38747-0_10 399 400 10. Deep Learning X1X2X3X4A1A2A3A4A5f(X)YHiddenLayerInputLayerOutputLayer FIGURE 10.1. Neural network with a single hidden layer. The hidden layer computes activations Ak=hk(X)that are nonlinear transformations of linear combinations of the inputs X1,X2,...,X p. Hence these Akare not directly ob- served. The functions hk(·)are not fixed in advance, but are learned during the training of the network. The output layer is a linear model that uses these acti- vationsAkas inputs, resulting in a function f(X). will also demonstrate these models using the Python torch package, along with a number of helper packages. The material in this chapter is slightly more challenging than elsewhere in this book. 10.1 Single Layer Neural Networks A neural network takes an input vector of pvariables X=(X1,X2,...,X p) and builds a nonlinear function f(X)to predict the response Y. We have built nonlinear prediction models in earlier chapters, using trees, boosting and generalized additive models. What distinguishes neural networks from these methods is the particular structure of the model. Figure 10.1shows a simple feed-forward neural network for modeling a quantitative responsefeed-forward neural networkusingp=4predictors. In the terminology of neural networks, the four fea- turesX1,...,X 4make up the units in the input layer . The arrows indicate input layer that each of the inputs from the input layer feeds into each of the Khidden units(we get to pick K; here we chose 5). The neural network model hashidden unitsthe form f(X)= β0+/summationtextK k=1βkhk(X) =β0+/summationtextK k=1βkg(wk0+/summationtextp j=1wkjXj).(10.1) It is built up here in two steps. First the Kactivations Ak,k=1,...,K , inactivationsthehiddenlayerarecomputedasfunctionsoftheinputfeatures X1,...,X p, Ak=hk(X)=g(wk0+/summationtextp j=1wkjXj), (10.2) 10.1 Single Layer Neural Networks 401 −4 −2 0240.0 0.2 0.4 0.6 0.8 1.0zg(z)sigmoidReLU FIGURE 10.2. Activation functions. The piecewise-linear ReLUfunction is pop- ular for its efficiency and computability. We have scaled it down by a factor of five for ease of comparison. whereg(z)is a nonlinear activation function that is specified in advance.activation functionWe can think of each Akas a different transformation hk(X)of the original features, much like the basis functions of Chapter 7. These Kactivations from the hidden layer then feed into the output layer, resulting in f(X)=β0+K/summationdisplay k=1βkAk, (10.3) a linear regression model in the K=5", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 451, "start_word": 144320, "end_word": 144720, "chunk_words": 400}}, "ISLP_website::c000452": {"text": "The piecewise-linear ReLUfunction is pop- ular for its efficiency and computability. We have scaled it down by a factor of five for ease of comparison. whereg(z)is a nonlinear activation function that is specified in advance.activation functionWe can think of each Akas a different transformation hk(X)of the original features, much like the basis functions of Chapter 7. These Kactivations from the hidden layer then feed into the output layer, resulting in f(X)=β0+K/summationdisplay k=1βkAk, (10.3) a linear regression model in the K=5 activations. All the parameters β0,...,βKandw10,...,w Kpneed to be estimated from data. In the early instances of neural networks, the sigmoidactivation function was favored,sigmoid g(z)=ez 1+ez=1 1+e−z, (10.4) which is the same function used in logistic regression to convert a linear function into probabilities between zero and one (see Figure 10.2). The preferred choice in modern neural networks is the ReLU(rectified linearReLUunit) activation function, which takes the formrectified linear unit g(z)=( z)+=/braceleftbigg0ifz<0 zotherwise .(10.5) A ReLU activation can be computed and stored more efficiently than a sigmoid activation. Although it thresholds at zero, because we apply it to a linear function ( 10.2) the constant term wk0will shift this inflection point. So in words, the model depicted in Figure 10.1derives five new features by computing five different linear combinations of X, and then squashes each through an activation function g(·)to transform it. The final model is linear in these derived variables. Thename neuralnetwork originallyderivedfromthinkingofthesehidden units as analogous to neurons in the brain — values of the activations Ak=hk(X)close to one are firing, while those close to zero are silent (using the sigmoid activation function). The nonlinearity in the activation function g(·)is essential, since without it the model f(X)in (10.1) would collapse into a simple linear model in 402 10. Deep Learning X1,...,X p. Moreover, having a nonlinear activation function allows the model to capture complex nonlinearities and interaction effects. Consider a very simple example with p=2 input variables X=(X1,X2), and K=2hidden units h1(X)andh2(X)withg(z)=z2. We specify the other parameters as β0=0,β1=1 4,β2=−1 4, w10=0,w 11=1,w 12=1 , w20=0,w 21=1,w 22=−1.(10.6) From (10.2), this means that h1(X) = (0 + X1+X2)2, h2(X) = (0 + X1−X2)2.(10.7) Then plugging ( 10.7) into (10.1), we get f(X)=0 +1 4·(0 + X1+X2)2−1 4·(0 + X1−X2)2 =1 4/bracketleftbig (X1+X2)2−(X1−X2)2/bracketrightbig =X1X2.(10.8) So the sum of two nonlinear transformations of linear functions can give us an interaction! In practice we would not use a quadratic function for g(z), since", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 452, "start_word": 144640, "end_word": 145040, "chunk_words": 400}}, "ISLP_website::c000453": {"text": "units h1(X)andh2(X)withg(z)=z2. We specify the other parameters as β0=0,β1=1 4,β2=−1 4, w10=0,w 11=1,w 12=1 , w20=0,w 21=1,w 22=−1.(10.6) From (10.2), this means that h1(X) = (0 + X1+X2)2, h2(X) = (0 + X1−X2)2.(10.7) Then plugging ( 10.7) into (10.1), we get f(X)=0 +1 4·(0 + X1+X2)2−1 4·(0 + X1−X2)2 =1 4/bracketleftbig (X1+X2)2−(X1−X2)2/bracketrightbig =X1X2.(10.8) So the sum of two nonlinear transformations of linear functions can give us an interaction! In practice we would not use a quadratic function for g(z), since we would always get a second-degree polynomial in the original coordinates X1,...,X p. The sigmoid or ReLU activations do not have such a limitation. Fitting a neural network requires estimating the unknown parameters in (10.1). For a quantitative response, typically squared-error loss is used, so that the parameters are chosen to minimize n/summationdisplay i=1(yi−f(xi))2. (10.9) DetailsabouthowtoperformthisminimizationareprovidedinSection 10.7. 10.2 Multilayer Neural Networks Modern neural networks typically have more than one hidden layer, and often many units per layer. In theory a single hidden layer with a large number of units has the ability to approximate most functions. However, the learning task of discovering a good solution is made much easier with multiple layers each of modest size. We will illustrate a large dense network on the famous and publicly available MNISThandwritten digit dataset.1Figure10.3shows examples of these digits. The idea is to build a model to classify the images into their correct digit class 0–9. Every image has p= 28 ×28 = 784 pixels, each of which is an eight-bit grayscale value between 0 and 255 representing 1See LeCun, Cortes, and Burges (2010) “The MNIST database of handwritten digits”, available at http://yann.lecun.com/exdb/mnist . 10.2 Multilayer Neural Networks 403 FIGURE 10.3. Examples of handwritten digits from the MNISTcorpus. Each grayscale image has 28×28pixels, each of which is an eight-bit number (0–255) which represents how dark that pixel is. The first 3, 5, and 8 are enlarged to show their 784 individual pixel values. the relative amount of the written digit in that tiny square.2These pixels are stored in the input vector X(in, say, column order). The output is the class label, represented by a vector Y=(Y0,Y1,...,Y 9)of 10 dummy variables, with a one in the position corresponding to the label, and zeros elsewhere. In the machine learning community, this is known as one-hot encoding. There are 60,000 training images, and 10,000 test images.one-hot encodingOn a historical note, digit recognition problems were the catalyst", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 453, "start_word": 144960, "end_word": 145360, "chunk_words": 400}}, "ISLP_website::c000454": {"text": "the relative amount of the written digit in that tiny square.2These pixels are stored in the input vector X(in, say, column order). The output is the class label, represented by a vector Y=(Y0,Y1,...,Y 9)of 10 dummy variables, with a one in the position corresponding to the label, and zeros elsewhere. In the machine learning community, this is known as one-hot encoding. There are 60,000 training images, and 10,000 test images.one-hot encodingOn a historical note, digit recognition problems were the catalyst that accelerated the development of neural network technology in the late 1980s at AT&T Bell Laboratories and elsewhere. Pattern recognition tasks of this kind are relatively simple for humans. Our visual system occupies a large fraction of our brains, and good recognition is an evolutionary force for survival. These tasks are not so simple for machines, and it has taken more than 30 years to refine the neural-network architectures to match human performance. Figure10.4shows a multilayer network architecture that works well for solving the digit-classification task. It differs from Figure 10.1in several ways: • It has two hidden layers L1(256 units) and L2(128 units) rather than one. Later we will see a network with seven hidden layers. • It has ten output variables, rather than one. In this case the ten vari- ables really represent a single qualitative variable and so are quite dependent. (We have indexed them by the digit class 0–9 rather than 1–10, for clarity.) More generally, in multi-task learning one can pre-multi-task learningdict different responses simultaneously with a single network; they all have a say in the formation of the hidden layers. • The loss function used for training the network is tailored for the multiclass classification task. 2In the analog-to-digital conversion process, only part of the written numeral may fall in the square representing a particular pixel. 404 10. Deep LearningX1X2X3X4X5X6...XpA(1)1A(1)2A(1)3A(1)4...A(1)K1A(2)1A(2)2A(2)3...A(2)K2f0(X)Y0f1(X)Y1......f9(X)Y9HiddenlayerL2HiddenlayerL1InputlayerOutputlayer W1W2BFIGURE 10.4. Neural network diagram with two hidden layers and multiple outputs, suitable for the MNISThandwritten-digit problem. The input layer has p= 784 units, the two hidden layers K1= 256 andK2= 128 units respectively, and the output layer 10units. Along with intercepts (referred to as biasesin the deep-learning community) this network has 235,146 parameters (referred to as weights). The first hidden layer is as in ( 10.2), with A(1) k=h(1) k(X) =g(w(1) k0+/summationtextp j=1w(1) kjXj)(10.10) fork=1,...,K 1. The second hidden layer treats the activations A(1) kof the first hidden layer as inputs and computes", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 454, "start_word": 145280, "end_word": 145680, "chunk_words": 400}}, "ISLP_website::c000455": {"text": "the MNISThandwritten-digit problem. The input layer has p= 784 units, the two hidden layers K1= 256 andK2= 128 units respectively, and the output layer 10units. Along with intercepts (referred to as biasesin the deep-learning community) this network has 235,146 parameters (referred to as weights). The first hidden layer is as in ( 10.2), with A(1) k=h(1) k(X) =g(w(1) k0+/summationtextp j=1w(1) kjXj)(10.10) fork=1,...,K 1. The second hidden layer treats the activations A(1) kof the first hidden layer as inputs and computes new activations A(2) /lscript=h(2) /lscript(X) =g(w(2) /lscript0+/summationtextK1 k=1w(2) /lscriptkA(1) k)(10.11) for/lscript=1,...,K 2.Notice that each of the activations in the second layer A(2) /lscript=h(2) /lscript(X)is a function of the input vector X. This is the case because while they are explicitly a function of the activations A(1) kfrom layer L1, these in turn are functions of X. This would also be the case with more hidden layers. Thus, through a chain of transformations, the network is able to build up fairly complex transformations of Xthat ultimately feed into the output layer as features. We have introduced additional superscript notation such as h(2) /lscript(X)and w(2) /lscriptjin (10.10) and (10.11) to indicate to which layer the activations and weights(coefficients) belong, in this case layer 2. The notation W1in Fig-weights 10.2 Multilayer Neural Networks 405 ure10.4represents the entire matrix of weights that feed from the input layer to the first hidden layer L1. This matrix will have 785×256 = 200 ,960 elements; there are 785 rather than 784 because we must account for the intercept or biasterm.3 biasEach element A(1) kfeeds to the second hidden layer L2via the matrix of weightsW2of dimension 257×128 = 32 ,896. We now get to the output layer, where we now have ten responses rather than one. The first step is to compute ten different linear models similar to our single model ( 10.1), Zm=βm0+/summationtextK2 /lscript=1βm/lscripth(2) /lscript(X) =βm0+/summationtextK2 /lscript=1βm/lscriptA(2) /lscript,(10.12) form=0,1,...,9. The matrix Bstores all 129×10 = 1 ,290of these weights. If these were all separate quantitative responses, we would simply set eachfm(X)=Zmand be done. However, we would like our estimates to represent class probabilities fm(X) = Pr( Y=m|X), just like in multi- nomial logistic regression in Section 4.3.5. So we use the special softmaxsoftmaxactivation function (see ( 4.13) on page 145), fm(X) = Pr( Y=m|X)=eZm /summationtext9 /lscript=0eZ/lscript, (10.13) form=0,1,...,9. This ensures that the 10 numbers behave like proba- bilities (non-negative and sum to one). Even though the goal", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 455, "start_word": 145600, "end_word": 146000, "chunk_words": 400}}, "ISLP_website::c000456": {"text": "these weights. If these were all separate quantitative responses, we would simply set eachfm(X)=Zmand be done. However, we would like our estimates to represent class probabilities fm(X) = Pr( Y=m|X), just like in multi- nomial logistic regression in Section 4.3.5. So we use the special softmaxsoftmaxactivation function (see ( 4.13) on page 145), fm(X) = Pr( Y=m|X)=eZm /summationtext9 /lscript=0eZ/lscript, (10.13) form=0,1,...,9. This ensures that the 10 numbers behave like proba- bilities (non-negative and sum to one). Even though the goal is to build a classifier, our model actually estimates a probability for each of the 10 classes. The classifier then assigns the image to the class with the highest probability. To train this network, since the response is qualitative, we look for coef- ficient estimates that minimize the negative multinomial log-likelihood −n/summationdisplay i=19/summationdisplay m=0yimlog(fm(xi)), (10.14) also known as the cross-entropy . This is a generalization of the crite-cross- entropy rion (4.5) for two-class logistic regression. Details on how to minimize this objective are given in Section 10.7. If the response were quantitative, we would instead minimize squared-error loss as in ( 10.9). Table10.1compares the test performance of the neural network with two simple models presented in Chapter 4that make use of linear decision boundaries:multinomiallogisticregressionandlineardiscriminantanalysis. The improvement of neural networks over both of these linear methods is dramatic:thenetworkwithdropoutregularizationachievesatesterrorrate below 2% on the 10,000test images. (We describe dropout regularization in Section10.7.3.) In Section 10.9.2of the lab, we present the code for fitting this model, which runs in just over two minutes on a laptop computer. 3The use of “weights” for coefficients and “bias” for the intercepts wk0in (10.2) is popular in the machine learning community; this use of bias is not to be confused with the “bias-variance” usage elsewhere in this book. 406 10. Deep Learning Method Test Error Neural Network + Ridge Regularization 2.3% Neural Network + Dropout Regularization 1.8% Multinomial Logistic Regression 7.2% Linear Discriminant Analysis 12.7% TABLE 10.1. Test error rate on the MNISTdata, for neural networks with two forms of regularization, as well as multinomial logistic regression and linear dis- criminant analysis. In this example, the extra complexity of the neural network leads to a marked improvement in test error. FIGURE 10.5. A sample of images from the CIFAR100 database: a collection of natural images from everyday life, with 100 different classes represented. Adding the number of coefficients in W1,W2andB, we get235,146in all, more than 33 times the", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 456, "start_word": 145920, "end_word": 146320, "chunk_words": 400}}, "ISLP_website::c000457": {"text": "error rate on the MNISTdata, for neural networks with two forms of regularization, as well as multinomial logistic regression and linear dis- criminant analysis. In this example, the extra complexity of the neural network leads to a marked improvement in test error. FIGURE 10.5. A sample of images from the CIFAR100 database: a collection of natural images from everyday life, with 100 different classes represented. Adding the number of coefficients in W1,W2andB, we get235,146in all, more than 33 times the number 785×9=7,065needed for multinomial logistic regression. Recall that there are 60,000images in the training set. While this might seem like a large training set, there are almost four times asmanycoefficientsintheneuralnetworkmodelasthereareobservationsin the training set! To avoid overfitting, some regularization is needed. In this example, we used two forms of regularization: ridge regularization, which is similar to ridge regression from Chapter 6, anddropoutregularization.dropoutWe discuss both forms of regularization in Section 10.7. 10.3 Convolutional Neural Networks Neural networks rebounded around 2010 with big successes in image classi- fication. Around that time, massive databases of labeled images were being accumulated, with ever-increasing numbers of classes. Figure 10.5shows 75 images drawn from the CIFAR100 database.4This database consists of 60,000 images labeled according to 20 superclasses (e.g. aquatic mammals), with five classes per superclass (beaver, dolphin, otter, seal, whale). Each image has a resolution of 32×32pixels, with three eight-bit numbers per pixel representing red, green and blue. The numbers for each image are organized in a three-dimensional array called a feature map . The first twofeature map 4See Chapter 3 of Krizhevsky (2009) “Learning multiple layers of fea- tures from tiny images”, available at https://www.cs.toronto.edu/~kriz/ learning-features-2009-TR.pdf . 10.3 Convolutional Neural Networks 407 FIGURE 10.6. Schematic showing how a convolutional neural network classifies an image of a tiger. The network takes in the image and identifies local features. It then combines the local features in order to create compound features, which in this example include eyes and ears. These compound features are used to output the label “tiger”. axes are spatial (both are 32-dimensional), and the third is the channelchannelaxis,5representing the three colors. There is a designated training set of 50,000 images, and a test set of 10,000. A special family of convolutional neural networks (CNNs) has evolved forconvolutional neural networksclassifying images such as these, and has shown spectacular success on a wide range of problems. CNNs mimic to some degree how humans classify images, by recognizing", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 457, "start_word": 146240, "end_word": 146640, "chunk_words": 400}}, "ISLP_website::c000458": {"text": "ears. These compound features are used to output the label “tiger”. axes are spatial (both are 32-dimensional), and the third is the channelchannelaxis,5representing the three colors. There is a designated training set of 50,000 images, and a test set of 10,000. A special family of convolutional neural networks (CNNs) has evolved forconvolutional neural networksclassifying images such as these, and has shown spectacular success on a wide range of problems. CNNs mimic to some degree how humans classify images, by recognizing specific features or patterns anywhere in the image that distinguish each particular object class. In this section we give a brief overview of how they work. Figure10.6illustrates the idea behind a convolutional neural network on a cartoon image of a tiger.6 The network first identifies low-level features in the input image, such as small edges, patches of color, and the like. These low-level features are then combined to form higher-level features, such as parts of ears, eyes, and so on. Eventually, the presence or absence of these higher-level features contributes to the probability of any given output class. Howdoesaconvolutionalneuralnetworkbuildupthishierarchy?Itcom- bines two specialized types of hidden layers, called convolution layers and poolinglayers. Convolution layers search for instances of small patterns in the image, whereas pooling layers downsample these to select a prominent subset. In order to achieve state-of-the-art results, contemporary neural- network architectures make use of many convolution and pooling layers. We describe convolution and pooling layers next. 10.3.1 Convolution Layers Aconvolution layer is made up of a large number of convolution filters , eachconvolution layer convolution filter5The term channel is taken from the signal-processing literature. Each channel is a distinct source of information. 6Thanks to Elena Tuzhilina for producing the diagram and https://www. cartooning4kids.com/ for permission to use the cartoon tiger. 408 10. Deep Learning of which is a template that determines whether a particular local feature is present in an image. A convolution filter relies on a very simple operation, called a convolution , which basically amounts to repeatedly multiplying matrix elements and then adding the results. To understand how a convolution filter works, consider a very simple example of a 4×3image: Original Image = abc def ghi jkl . Now consider a 2×2filter of the form Convolution Filter =/bracketleftbiggαβ γδ/bracketrightbigg . When we convolve the image with the filter, we get the result7 Convolved Image = aα+bβ+dγ+eδbα+cβ+eγ+fδ dα+eβ+gγ+hδeα+fβ+hγ+iδ gα+hβ+jγ+kδhα+iβ+kγ+lδ . For instance, the top-left element comes from multiplying", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 458, "start_word": 146560, "end_word": 146960, "chunk_words": 400}}, "ISLP_website::c000459": {"text": "operation, called a convolution , which basically amounts to repeatedly multiplying matrix elements and then adding the results. To understand how a convolution filter works, consider a very simple example of a 4×3image: Original Image = abc def ghi jkl . Now consider a 2×2filter of the form Convolution Filter =/bracketleftbiggαβ γδ/bracketrightbigg . When we convolve the image with the filter, we get the result7 Convolved Image = aα+bβ+dγ+eδbα+cβ+eγ+fδ dα+eβ+gγ+hδeα+fβ+hγ+iδ gα+hβ+jγ+kδhα+iβ+kγ+lδ . For instance, the top-left element comes from multiplying each element in the2×2filter by the corresponding element in the top left 2×2portion of the image, and adding the results. The other elements are obtained in a similar way: the convolution filter is applied to every 2×2submatrix of the original image in order to obtain the convolved image. If a 2×2submatrix of the original image resembles the convolution filter, then it will have a largevalue in the convolved image; otherwise, it will have a smallvalue. Thus,the convolved image highlights regions of the original image that resemble the convolution filter. We have used 2×2as an example; in general convolution filters are small /lscript1×/lscript2arrays, with /lscript1and/lscript2small positive integers that are not necessarily equal. Figure10.7illustratestheapplicationoftwoconvolutionfilterstoa 192× 179image of a tiger, shown on the left-hand side.8Each convolution filter is a15×15image containing mostly zeros (black), with a narrow strip of ones (white) oriented either vertically or horizontally within the image. When each filter is convolved with the image of the tiger, areas of the tiger that resemble the filter (i.e. that have either horizontal or vertical stripes or edges) are givenlarge values,and areas of the tiger that do not resemble the feature are given small values. The convolved images are displayed on the right-hand side. We see that the horizontal stripe filter picks out horizontal stripes and edges in the original image, whereas the vertical stripe filter picks out vertical stripes and edges in the original image. 7The convolved image is smaller than the original image because its dimension is given by the number of 2×2submatrices in the original image. Note that 2×2is the dimension of the convolution filter. If we want the convolved image to have the same dimension as the original image, then padding can be applied. 8The tiger image used in Figures 10.7–10.9was obtained from the public domain image resource https://www.needpix.com/ . 10.3 Convolutional Neural Networks 409 FIGURE 10.7. Convolution filters find local features in an image, such as edges and small", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 459, "start_word": 146880, "end_word": 147280, "chunk_words": 400}}, "ISLP_website::c000460": {"text": "image because its dimension is given by the number of 2×2submatrices in the original image. Note that 2×2is the dimension of the convolution filter. If we want the convolved image to have the same dimension as the original image, then padding can be applied. 8The tiger image used in Figures 10.7–10.9was obtained from the public domain image resource https://www.needpix.com/ . 10.3 Convolutional Neural Networks 409 FIGURE 10.7. Convolution filters find local features in an image, such as edges and small shapes. We begin with the image of the tiger shown on the left, and apply the two small convolution filters in the middle. The convolved images high- light areas in the original image where details similar to the filters are found. Specifically, the top convolved image highlights the tiger’s vertical stripes, whereas the bottom convolved image highlights the tiger’s horizontal stripes. We can think of the original image as the input layer in a convolutional neural network, and the convolved images as the units in the first hidden layer. We have used a large image and two large filters in Figure 10.7for illus- tration. For the CIFAR100 database there are 32×32color pixels per image, and we use 3×3convolution filters. In a convolution layer, we use a whole bank of filters to pick out a variety of differently-oriented edges and shapes in the image. Using predefined filters in this way is standard practice in image processing. By contrast, with CNNs the filters are learnedfor the specific classification task. We can think of the filter weights as the parameters going from an input layer to a hidden layer, with one hidden unit for each pixel in the convolved image. This is in fact the case, though the parameters are highly structured and constrained (see Exercise 4for more details). They operate on localized patches in the input image (so there are many structural zeros), and the sameweightsina givenfilter are reusedfor allpossible patchesin the image (so the weights are constrained).9 We now give some additional details. • Since the input image is in color, it has three channels represented by a three-dimensional feature map (array). Each channel is a two- dimensional ( 32×32) feature map — one for red, one for green, and one for blue. A single convolution filter will also have three channels, one per color, each of dimension 3×3, with potentially different filter weights. The results of the three convolutions are", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 460, "start_word": 147200, "end_word": 147600, "chunk_words": 400}}, "ISLP_website::c000461": {"text": "image (so the weights are constrained).9 We now give some additional details. • Since the input image is in color, it has three channels represented by a three-dimensional feature map (array). Each channel is a two- dimensional ( 32×32) feature map — one for red, one for green, and one for blue. A single convolution filter will also have three channels, one per color, each of dimension 3×3, with potentially different filter weights. The results of the three convolutions are summed to form a two-dimensional output feature map. Note that at this point the color information has been used, and is not passed on to subsequent layers except through its role in the convolution. 9This used to be called weight sharing in the early years of neural networks. 410 10. Deep Learning • If we use Kdifferent convolution filters at this first hidden layer, we getKtwo-dimensional output feature maps, which together are treated as a single three-dimensional feature map. We view each of theKoutput feature maps as a separate channel of information, so now we have Kchannels in contrast to the three color channels of the original input feature map. The three-dimensional feature map is just like the activations in a hidden layer of a simple neural network, except organized and produced in a spatially structured way. • We typically apply the ReLU activation function ( 10.5) to the con- volved image. This step is sometimes viewed as a separate layer in the convolutional neural network, in which case it is referred to as a detector layer .detector layer 10.3.2 Pooling Layers Apoolinglayer provides a way to condense a large image into a smallerpoolingsummary image. While there are a number of possible ways to perform pooling, the max pooling operation summarizes each non-overlapping 2×2 block of pixels in an image using the maximum value in the block. This reduces the size of the image by a factor of two in each direction, and it also provides some location invariance : i.e. as long as there is a large value in one of the four pixels in the block, the whole block registers as a large value in the reduced image. Here is a simple example of max pooling: Max pool 1253 3012 2134 1120 →/bracketleftbigg35 24/bracketrightbigg . 10.3.3 Architecture of a Convolutional Neural Network So far we have defined a single convolution layer — each filter produces a new two-dimensional", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 461, "start_word": 147520, "end_word": 147920, "chunk_words": 400}}, "ISLP_website::c000462": {"text": "each direction, and it also provides some location invariance : i.e. as long as there is a large value in one of the four pixels in the block, the whole block registers as a large value in the reduced image. Here is a simple example of max pooling: Max pool 1253 3012 2134 1120 →/bracketleftbigg35 24/bracketrightbigg . 10.3.3 Architecture of a Convolutional Neural Network So far we have defined a single convolution layer — each filter produces a new two-dimensional feature map. The number of convolution filters in a convolution layer is akin to the number of units at a particular hidden layer in a fully-connected neural network of the type we saw in Section 10.2. This number also defines the number of channels in the resulting three- dimensional feature map. We have also described a pooling layer, which reduces the first two dimensions of each three-dimensional feature map. Deep CNNs havemanysuchlayers.Figure 10.8showsa typicalarchitecture for a CNN for the CIFAR100 image classification task. At the input layer, we see the three-dimensional feature map of a color image, where the channel axis represents each color by a 32×32two- dimensional feature map of pixels. Each convolution filter produces a new channel at the first hidden layer, each of which is a 32×32feature map (after some padding at the edges). After this first round of convolutions, we now have a new “image”; a feature map with considerably more channels than the three color input channels (six in the figure, since we used six convolution filters). 3216328164322500100convolveconvolveconvolvepoolpoolpoolflatten8FIGURE 10.8. Architecture of a deep CNN for the CIFAR100 classification task. Convolution layers are interspersed with 2×2max-pool layers, which reduce the size by a factor of 2 in both dimensions. This is followed by a max-pool layer, which reduces the size of the feature map in each channel by a factor of four: two in each dimension. Thisconvolve-then-poolsequenceisnowrepeatedforthenexttwolayers. Some details are as follows: • Each subsequent convolve layer is similar to the first. It takes as input the three-dimensional feature map from the previous layer and treats it like a single multi-channel image. Each convolution filter learned has as many channels as this feature map. • Since the channel feature maps are reduced in size after each pool layer, we usually increase the number of filters in the next convolve layer to compensate. • Sometimes we repeat several convolve layers before a pool layer. This effectively increases", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 462, "start_word": 147840, "end_word": 148240, "chunk_words": 400}}, "ISLP_website::c000463": {"text": "layer is similar to the first. It takes as input the three-dimensional feature map from the previous layer and treats it like a single multi-channel image. Each convolution filter learned has as many channels as this feature map. • Since the channel feature maps are reduced in size after each pool layer, we usually increase the number of filters in the next convolve layer to compensate. • Sometimes we repeat several convolve layers before a pool layer. This effectively increases the dimension of the filter. These operations are repeated until the pooling has reduced each channel feature map down to just a few pixels in each dimension. At this point the three-dimensional feature maps are flattened — the pixels are treated as separate units — and fed into one or more fully-connected layers before reaching the output layer, which is a softmax activation for the 100 classes (as in (10.13)). There are many tuning parameters to be selected in constructing such a network, apart from the number, nature, and sizes of each layer. Dropout learning can be used at each layer, as well as lasso or ridge regularization (see Section 10.7). The details of constructing a convolutional neural net- work can seem daunting. Fortunately, terrific software is available, with extensive examples and vignettes that provide guidance on sensible choices for the parameters. For the CIFAR100 official test set, the best accuracy as of this writing is just above 75%, but undoubtedly this performance will continue to improve. 10.3.4 Data Augmentation An additional important trick used with image modeling is data augment-data aug- mentationation. Essentially, each training image is replicated many times, with each replicate randomly distorted in a natural way such that human recognition is unaffected. Figure 10.9shows some examples. Typical distortions are10.3 Convolutional Neural Networks 411 412 10. Deep Learning FIGURE 10.9. Data augmentation. The original image (leftmost) is distorted in natural ways to produce different images with the same class label. These distortions do not fool humans, and act as a form of regularization when fitting the CNN. zoom, horizontal and vertical shift, shear, small rotations, and in this case horizontal flips. At face value this is a way of increasing the training set considerably with somewhat different examples, and thus protects against overfitting. In fact we can see this as a form of regularization: we build a cloud of images around each original image, all with the", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 463, "start_word": 148160, "end_word": 148560, "chunk_words": 400}}, "ISLP_website::c000464": {"text": "same class label. These distortions do not fool humans, and act as a form of regularization when fitting the CNN. zoom, horizontal and vertical shift, shear, small rotations, and in this case horizontal flips. At face value this is a way of increasing the training set considerably with somewhat different examples, and thus protects against overfitting. In fact we can see this as a form of regularization: we build a cloud of images around each original image, all with the same label. This kind of fattening of the data is similar in spirit to ridge regularization. We will see in Section 10.7.2that the stochastic gradient descent al- gorithms for fitting deep learning models repeatedly process randomly- selected batches of, say, 128 training images at a time. This works hand-in- glove with augmentation, because we can distort each image in the batch on the fly, and hence do not have to store all the new images. 10.3.5 Results Using a Pretrained Classifier Here we use an industry-level pretrained classifier to predict the class of some new images. The resnet50 classifier is a convolutional neural network that was trained using the imagenet data set, which consists of millions of images that belong to an ever-growing number of categories.10Figure10.10 demonstrates the performance of resnet50 on six photographs (private col- lection of one of the authors).11The CNN does a reasonable job classifying the hawk in the second image. If we zoom out as in the third image, it gets confused and chooses the fountain rather than the hawk. In the final image a “jacamar” is a tropical bird from South and Central America with similar coloring to the South African Cape Weaver. We give more details on this example in Section 10.9.4. Much of the work in fitting a CNN is in learning the convolution filters at the hidden layers; these are the coefficients of a CNN. For models fit to massive corpora such as imagenet with many classes, the output of these filters can serve as features for general natural-image classification prob- lems. One can use these pretrained hidden layers for new problems with much smaller training sets (a process referred to as weight freezing ), andweight freezingjust train the last few layers of the network, which requires much less data. 10For more information about resnet50 , see He, Zhang, Ren, and Sun (2015) “Deep residual learning for image recognition”, https://arxiv.org/abs/1512.03385 . For", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 464, "start_word": 148480, "end_word": 148880, "chunk_words": 400}}, "ISLP_website::c000465": {"text": "as imagenet with many classes, the output of these filters can serve as features for general natural-image classification prob- lems. One can use these pretrained hidden layers for new problems with much smaller training sets (a process referred to as weight freezing ), andweight freezingjust train the last few layers of the network, which requires much less data. 10For more information about resnet50 , see He, Zhang, Ren, and Sun (2015) “Deep residual learning for image recognition”, https://arxiv.org/abs/1512.03385 . For de- tails about imagenet , see Russakovsky, Deng, et al. (2015) “ImageNet Large Scale Visual Recognition Challenge”, in International Journal of Computer Vision . 11Theseresnet results can change with time, since the publicly-trained model gets updated periodically. 10.4 Document Classification 413 flamingo Cooper’s hawk Cooper’s hawk flamingo 0.83 kite 0.60fountain 0.35 spoonbill 0.17 great grey owl 0.09 nail 0.12 white stork 0.00 robin 0.06hook 0.07 Lhasa Apso cat Cape weaver Tibetan terrier 0.56 Old English sheepdog 0.82 jacamar 0.28 Lhasa 0.32Shih-Tzu 0.04macaw 0.12 cocker spaniel 0.03 Persian cat 0.04robin 0.12 FIGURE 10.10. Classification of six photographs using the resnet50 CNN trained on the imagenet corpus. The table below the images displays the true (intended) label at the top of each panel, and the top three choices of the classifier (out of 100). The numbers are the estimated probabilities for each choice. (A kite is a raptor, but not a hawk.) The vignettes and book12that accompany the keraspackage give more details on such applications. 10.4 Document Classification In this section we introduce a new type of example that has important applications in industry and science: predicting attributes of documents. Examples of documents include articles in medical journals, Reuters news feeds, emails, tweets, and so on. Our example will be IMDb(Internet Movie Database) ratings — short documents where viewers have written critiques of movies.13The response in this case is the sentiment of the review, which will bepositiveornegative. 12Deep Learning with R by F. Chollet and J.J. Allaire, 2018, Manning Publications. 13For details, see Maas et al. (2011) “Learning word vectors for sentiment analysis”, inProceedings of the 49th Annual Meeting of the Association for Computational Lin- guistics: Human Language Technologies , pages 142–150. 414 10. Deep Learning Here is the beginning of a rather amusing negative review: This has to be one of the worst films of the 1990s. When my friends & I were watching this film (being the target audience it", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 465, "start_word": 148800, "end_word": 149200, "chunk_words": 400}}, "ISLP_website::c000466": {"text": "F. Chollet and J.J. Allaire, 2018, Manning Publications. 13For details, see Maas et al. (2011) “Learning word vectors for sentiment analysis”, inProceedings of the 49th Annual Meeting of the Association for Computational Lin- guistics: Human Language Technologies , pages 142–150. 414 10. Deep Learning Here is the beginning of a rather amusing negative review: This has to be one of the worst films of the 1990s. When my friends & I were watching this film (being the target audience it was aimed at) we just sat & watched the first half an hour with our jaws touching the floor at how bad it really was. The rest of the time, everyone else in the theater just started talking to each other, leaving or generally crying into their popcorn ... Each review can be a different length, include slang or non-words, have spelling errors, etc. We need to find a way to featurize such a document.featurizeThis is modern parlance for defining a set of predictors. The simplest and most common featurization is the bag-of-words model.bag-of-wordsWe score each document for the presence or absence of each of the words in a language dictionary — in this case an English dictionary. If the dictionary contains Mwords,thatmeansforeachdocumentwecreateabinaryfeature vector of length M, and score a 1for every word present, and 0otherwise. That can be a very wide feature vector, so we limit the dictionary — in this case to the 10,000 most frequently occurring words in the training corpus of 25,000 reviews. Fortunately there are nice tools for doing this automatically. Here is the beginning of a positive review that has been redacted in this way: /angbracketleftSTART/angbracketrightthis film was just brilliant casting location scenery story direction everyone’s really suited the part they played and you could just imagine being there robert /angbracketleftUNK/angbracketrightis an amazing actor and now the same being director /angbracketleftUNK/angbracketrightfather came from the same scottish island as myself so i loved ... Here we can see many words have been omitted, and some unknown words (UNK) have been marked as such. With this reduction the binary feature vector has length 10,000, and consists mostly of 0’s and a smattering of 1’s in the positions corresponding to words that are present in the document. We have a training set and test set, each with 25,000 examples, and each balanced with regard to sentiment . The resulting training feature matrix X has dimension 25,000×10,000, but", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 466, "start_word": 149120, "end_word": 149520, "chunk_words": 400}}, "ISLP_website::c000467": {"text": "we can see many words have been omitted, and some unknown words (UNK) have been marked as such. With this reduction the binary feature vector has length 10,000, and consists mostly of 0’s and a smattering of 1’s in the positions corresponding to words that are present in the document. We have a training set and test set, each with 25,000 examples, and each balanced with regard to sentiment . The resulting training feature matrix X has dimension 25,000×10,000, but only 1.3% of the binary entries are non- zero. We call such a matrix sparse, because most of the values are the same (zero in this case); it can be stored efficiently in sparse matrix format .14 sparse matrix formatThere are a variety of ways to account for the document length; here we only score a word as in or out of the document, but for example one could instead record the relative frequency of words. We split off a validation set of size 2,000 from the 25,000 training observations (for model tuning), and fit two model sequences: • A lasso logistic regression using the glmnetpackage; • A two-class neural network with two hidden layers, each with 16 ReLU units. 14Rather than store the whole matrix, we can store instead the location and values for the nonzero entries. In this case, since the nonzero entries are all 1, just the locations are stored. 10.4 Document Classification 415 FIGURE 10.11. Accuracy of the lasso and a two-hidden-layer neural network on theIMDbdata. For the lasso, the x-axis displays −log(λ), while for the neural network it displays epochs (number of times the fitting algorithm passes through the training set). Both show a tendency to overfit, and achieve approximately the same test accuracy. Both methods produce a sequence of solutions. The lasso sequence is in- dexed by the regularization parameter λ. The neural-net sequence is in- dexed by the number of gradient-descent iterations used in the fitting, as measured by training epochs or passes through the training set (Sec- tion10.7). Notice that the training accuracy in Figure 10.11(black points) increases monotonically in both cases. We can use the validation error to pick a good solution from each sequence (blue points in the plots), which would then be used to make predictions on the test data set. Note that a two-class neural network amounts to a nonlinear logistic regression model. From ( 10.12) and (10.13)", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 467, "start_word": 149440, "end_word": 149840, "chunk_words": 400}}, "ISLP_website::c000468": {"text": "in the fitting, as measured by training epochs or passes through the training set (Sec- tion10.7). Notice that the training accuracy in Figure 10.11(black points) increases monotonically in both cases. We can use the validation error to pick a good solution from each sequence (blue points in the plots), which would then be used to make predictions on the test data set. Note that a two-class neural network amounts to a nonlinear logistic regression model. From ( 10.12) and (10.13) we can see that log/parenleftbiggPr(Y=1|X) Pr(Y=0|X)/parenrightbigg =Z1−Z0 (10.15) =( β10−β00)+K2/summationdisplay /lscript=1(β1/lscript−β0/lscript)A(2) /lscript. (This shows the redundancy in the softmax function; for Kclasses we really only need to estimate K−1sets of coefficients. See Section 4.3.5.) In Figure10.11we show accuracy (fraction correct) rather than classificationaccuracy error (fraction incorrect), the former being more popular in the machine learning community. Both models achieve a test-set accuracy of about 88%. The bag-of-words model summarizes a document by the words present, and ignores their context. There are at least two popular ways to take the context into account: • Thebag-of-n-gramsmodel. For example, a bag of 2-grams recordsbag-of-n- grams/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF 468 1 0 1 20.6 0.7 0.8 0.9 1.0Lasso −log(λ)Accuracy /uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF /uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF /uni25CF/uni25CF/uni25CFtrainvalidationtest/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF 51 0 1 5 2 00.6 0.7 0.8 0.9 1.0Neural Net EpochsAccuracy/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF 416 10. Deep Learningthe consecutive co-occurrence of every distinct pair of words. “Bliss-fully long” can be seen as a positive phrase in a movie review, while“blissfully short” a negative.• Treat the document as a sequence, taking account of all the words inthe context of those that preceded and those that follow.In the next section we explore models for sequences of data, which haveapplications in weather forecasting, speech recognition, language transla-tion, and time-series prediction, to name a few. We continue with thisIMDbexample there.10.5 Recurrent Neural NetworksMany data sources are sequential in nature, and call for special treatmentwhen building predictive models. Examples include:• Documents such as book and movie reviews, newspaper articles, andtweets. The sequence and relative positions of words in a documentcapture the narrative, theme and tone, and can be exploited in taskssuch as topic classification, sentiment analysis, and language transla-tion.• Time series of temperature, rainfall, wind speed, air quality, and soon. We may want to forecast the weather several days ahead, or cli-mate several decades ahead.• Financialtimeseries,wherewetrackmarketindices,tradingvolumes,stock and bond prices, and exchange rates. Here prediction is oftendifficult, but as we will see, certain indices can be predicted withreasonable accuracy.• Recorded speech, musical recordings,", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 468, "start_word": 149760, "end_word": 150160, "chunk_words": 400}}, "ISLP_website::c000469": {"text": "and relative positions of words in a documentcapture the narrative, theme and tone, and can be exploited in taskssuch as topic classification, sentiment analysis, and language transla-tion.• Time series of temperature, rainfall, wind speed, air quality, and soon. We may want to forecast the weather several days ahead, or cli-mate several decades ahead.• Financialtimeseries,wherewetrackmarketindices,tradingvolumes,stock and bond prices, and exchange rates. Here prediction is oftendifficult, but as we will see, certain indices can be predicted withreasonable accuracy.• Recorded speech, musical recordings, and other sound recordings. Wemay want to give a text transcription of a speech, or perhaps a lan-guage translation. We may want to assess the quality of a piece ofmusic, or assign certain attributes.• Handwriting, such as doctor’s notes, and handwritten digits such aszip codes. Here we want to turn the handwriting into digital text, orread the digits (optical character recognition).In arecurrent neural network(RNN), the input objectXis asequence.recurrentneuralnetworkConsider a corpus of documents, such as the collection ofIMDbmovie re-views. Each document can be represented as a sequence ofLwords, soX={X1,X2,...,XL}, where eachX/lscriptrepresents a word. The order ofthe words, and closeness of certain words in a sentence, convey semanticmeaning. RNNs are designed to accommodate and take advantage of thesequential nature of such input objects, much like convolutional neural net-works accommodate the spatial structure of image inputs. The outputYcan also be a sequence (such as in language translation), but often is ascalar, like the binary sentiment label of a movie review document. 10.5 Recurrent Neural Networks 417 A1A2A3AL-1AL=A/lscriptO/lscriptY X/lscriptO1X1O2X2O3X3OL-1XL-1OLY XL...WUBWBWBWBWBWBUUUUFIGURE 10.12. Schematic of a simple recurrent neural network. The input is a sequence of vectors {X/lscript}L 1, and here the target is a single response. The network processes the input sequence Xsequentially; each X/lscriptfeeds into the hidden layer, which also has as input the activation vector A/lscript−1from the previous element in the sequence, and produces the current activation vector A/lscript. The same collections of weights W,UandBare used as each element of the sequence is processed. The output layer produces a sequence of predictions O/lscriptfrom the current activation A/lscript, but typically only the last of these, OL, is of relevance. To the left of the equal sign is a concise representation of the network, which is unrolled into a more explicit version on the right. Figure10.12illustratesthestructureofaverybasicRNNwithasequence X={X1,X2,...,X L}as input, a simple output Y, and a hidden-layer sequence {A/lscript}L 1={A1,A2,...,A L}. EachX/lscriptis a vector; in the document example X/lscriptcould represent a one-hot encoding for the /lscriptth", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 469, "start_word": 150080, "end_word": 150480, "chunk_words": 400}}, "ISLP_website::c000470": {"text": "processed. The output layer produces a sequence of predictions O/lscriptfrom the current activation A/lscript, but typically only the last of these, OL, is of relevance. To the left of the equal sign is a concise representation of the network, which is unrolled into a more explicit version on the right. Figure10.12illustratesthestructureofaverybasicRNNwithasequence X={X1,X2,...,X L}as input, a simple output Y, and a hidden-layer sequence {A/lscript}L 1={A1,A2,...,A L}. EachX/lscriptis a vector; in the document example X/lscriptcould represent a one-hot encoding for the /lscriptth word based on the language dictionary for the corpus (see the top panel in Figure 10.13 for a simple example). As the sequence is processed one vector X/lscriptat a time, the network updates the activations A/lscriptin the hidden layer, taking as input the vector X/lscriptand the activation vector A/lscript−1from the previous step in the sequence. Each A/lscriptfeeds into the output layer and produces a prediction O/lscriptforY.OL, the last of these, is the most relevant. In detail, suppose each vector X/lscriptof the input sequence has pcomponents XT /lscript=(X/lscript1,X/lscript2,...,X /lscriptp), and the hidden layer consists of KunitsAT /lscript= (A/lscript1,A/lscript2,...,A /lscriptK). As in Figure 10.4, we represent the collection of K× (p+1) shared weights wkjfor the input layer by a matrix W, and similarly Uis aK×Kmatrix of the weights uksfor the hidden-to-hidden layers, andBis aK+1vector of weights βkfor the output layer. Then A/lscriptk=g/parenleftBig wk0+p/summationdisplay j=1wkjX/lscriptj+K/summationdisplay s=1uksA/lscript−1,s/parenrightBig , (10.16) and the output O/lscriptis computed as O/lscript=β0+K/summationdisplay k=1βkA/lscriptk (10.17) for a quantitative response, or with an additional sigmoid activation func- tion for a binary response, for example. Here g(·)is an activation function such as ReLU. Notice that the same weights W,UandBare used as we 418 10. Deep Learning process each element in the sequence, i.e. they are not functions of /lscript. This is a form of weight sharing used by RNNs, and similar to the use of filtersweight sharingin convolutional neural networks (Section 10.3.1.) As we proceed from be- ginning to end, the activations A/lscriptaccumulate a history of what has been seen before, so that the learned context can be used for prediction. For regression problems the loss function for an observation (X,Y)is (Y−OL)2, (10.18) whichonlyreferencesthefinaloutput OL=β0+/summationtextK k=1βkALk.ThusO1,O2, ...,O L−1arenotused.Whenwefitthemodel,eachelement X/lscriptoftheinput sequence Xcontributes to OLvia the chain ( 10.16), and hence contributes indirectly to learning the shared parameters W,UandBvia the loss (10.18). Withninput sequence/response pairs (xi,yi),the parameters are found by minimizing the sum of squares n/summationdisplay i=1(yi−oiL)2=n/summationdisplay i=1/parenleftBig yi−/parenleftbig β0+K/summationdisplay k=1βkg/parenleftbig wk0+p/summationdisplay j=1wkjxiLj+K/summationdisplay s=1uksai,L−1,s/parenrightbig/parenrightbig/parenrightBig2 .", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 470, "start_word": 150400, "end_word": 150800, "chunk_words": 400}}, "ISLP_website::c000471": {"text": "a history of what has been seen before, so that the learned context can be used for prediction. For regression problems the loss function for an observation (X,Y)is (Y−OL)2, (10.18) whichonlyreferencesthefinaloutput OL=β0+/summationtextK k=1βkALk.ThusO1,O2, ...,O L−1arenotused.Whenwefitthemodel,eachelement X/lscriptoftheinput sequence Xcontributes to OLvia the chain ( 10.16), and hence contributes indirectly to learning the shared parameters W,UandBvia the loss (10.18). Withninput sequence/response pairs (xi,yi),the parameters are found by minimizing the sum of squares n/summationdisplay i=1(yi−oiL)2=n/summationdisplay i=1/parenleftBig yi−/parenleftbig β0+K/summationdisplay k=1βkg/parenleftbig wk0+p/summationdisplay j=1wkjxiLj+K/summationdisplay s=1uksai,L−1,s/parenrightbig/parenrightbig/parenrightBig2 . (10.19) Here we use lowercase letters for the observed yiand vector sequences xi={xi1,xi2,...,x iL},15as well as the derived activations. Since the intermediate outputs O/lscriptare not used, one may well ask why they are there at all. First of all, they come for free, since they use the same outputweights Bneededtoproduce OL,andprovideanevolvingprediction for the output. Furthermore, for some learning tasks the response is also a sequence, and so the output sequence {O1,O2,...,O L}is explicitly needed. When used at full strength, recurrent neural networks can be quite com- plex. We illustrate their use in two simple applications. In the first, we continue with the IMDbsentiment analysis of the previous section, where we process the words in the reviews sequentially. In the second application, we illustrate their use in a financial time series forecasting problem. 10.5.1 Sequential Models for Document Classification Here we return to our classification task with the IMDbreviews. Our ap- proach in Section 10.4was to use the bag-of-words model. Here the plan is to use instead the sequence of words occurring in a document to make predictions about the label for the entire document. We have, however, a dimensionality problem: each word in our document is represented by a one-hot-encoded vector (dummy variable) with 10,000 elements (one per word in the dictionary)! An approach that has become popular is to represent each word in a much lower-dimensional embeddingembeddingspace. This means that rather than representing each word by a binary vector with 9,999 zeros and a single one in some position, we will represent it instead by a set of mreal numbers, none of which are typically zero. Here mis the embedding dimension, and can be in the low 100s, or even less. This means (in our case) that we need a matrix Eof dimension m×10,000, 15This is a sequence of vectors; each element xi/lscriptis ap-vector. 10.5 Recurrent Neural Networks 419thisisoneofthebestfilmsactuallythebestIhaveeverseenthefilmstartsonefalldayOne−hotEmbedFIGURE 10.13. Depiction of a sequence of 20words representing a single", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 471, "start_word": 150720, "end_word": 151120, "chunk_words": 400}}, "ISLP_website::c000472": {"text": "with 9,999 zeros and a single one in some position, we will represent it instead by a set of mreal numbers, none of which are typically zero. Here mis the embedding dimension, and can be in the low 100s, or even less. This means (in our case) that we need a matrix Eof dimension m×10,000, 15This is a sequence of vectors; each element xi/lscriptis ap-vector. 10.5 Recurrent Neural Networks 419thisisoneofthebestfilmsactuallythebestIhaveeverseenthefilmstartsonefalldayOne−hotEmbedFIGURE 10.13. Depiction of a sequence of 20words representing a single doc- ument: one-hot encoded using a dictionary of 16words (top panel) and embedded in anm-dimensional space with m=5(bottom panel). where each column is indexed by one of the 10,000 words in our dictionary, and the values in that column give the mcoordinates for that word in the embedding space. Figure10.13illustrates the idea (with a dictionary of 16 rather than 10,000, and m=5). Where does Ecome from? If we have a large corpus of labeled documents, we can have the neural network learnEas part of the optimization. In this case Eis referred to as an embedding layer,embedding layerand a specialized Eis learned for the task at hand. Otherwise we can insert a precomputed matrix Ein the embedding layer, a process known asweight freezing . Two pretrained embeddings, word2vec andGloVe, areweight freezing word2vec GloVewidely used.16These are built from a very large corpus of documents by a variant of principal components analysis (Section 12.2). The idea is that the positions of words in the embedding space preserve semantic meaning; e.g. synonyms should appear near each other. So far, so good. Each document is now represented as a sequence of m- vectors that represents the sequence of words. The next step is to limit each document to the last Lwords. Documents that are shorter than L get padded with zeros upfront. So now each document is represented by a series consisting of LvectorsX={X1,X2,...,X L}, and each X/lscriptin the sequence has mcomponents. We now use the RNN structure in Figure 10.12. The training corpus consists of nseparate series (documents) of length L, each of which gets processed sequentially from left to right. In the process, a parallel series of hidden activation vectors A/lscript,/lscript=1,...,L is created as in ( 10.16) for each document. A/lscriptfeedsintotheoutputlayertoproducetheevolvingprediction O/lscript. We use the final value OLto predict the response: the sentiment of the review. 16word2vec is described in Mikolov, Chen, Corrado, and Dean (2013), available athttps://code.google.com/archive/p/word2vec .GloVeis described in Pennington, Socher,", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 472, "start_word": 151040, "end_word": 151440, "chunk_words": 400}}, "ISLP_website::c000473": {"text": "the RNN structure in Figure 10.12. The training corpus consists of nseparate series (documents) of length L, each of which gets processed sequentially from left to right. In the process, a parallel series of hidden activation vectors A/lscript,/lscript=1,...,L is created as in ( 10.16) for each document. A/lscriptfeedsintotheoutputlayertoproducetheevolvingprediction O/lscript. We use the final value OLto predict the response: the sentiment of the review. 16word2vec is described in Mikolov, Chen, Corrado, and Dean (2013), available athttps://code.google.com/archive/p/word2vec .GloVeis described in Pennington, Socher, and Manning (2014), available at https://nlp.stanford.edu/projects/glove . 420 10. Deep Learning This is a simple RNN, and has relatively few parameters. If there are K hidden units, the common weight matrix WhasK×(m+ 1) parameters, the matrix UhasK×Kparameters, and Bhas2(K+ 1) for the two-class logistic regression as in ( 10.15). These are used repeatedly as we process the sequence X={X/lscript}L 1from left to right, much like we use a single convolution filter to process each patch in an image (Section 10.3.1). If the embedding layer Eis learned, that adds an additional m×Dparameters (D= 10 ,000here), and is by far the biggest cost. We fit the RNN as described in Figure 10.12and the accompaying text to theIMDbdata. The model had an embedding matrix Ewithm= 32 (which was learned in training as opposed to precomputed), followed by a single recurrent layer with K= 32 hidden units. The model was trained with dropout regularization on the 25,000 reviews in the designated training set, and achieved a disappointing 76% accuracy on the IMDbtest data. A network using the GloVepretrained embedding matrix Eperformed slightly worse. For ease of exposition we have presented a very simple RNN. More elab- orate versions use long term andshort term memory (LSTM). Two tracks of hidden-layer activations are maintained, so that when the activation A/lscript is computed, it gets input from hidden units both further back in time, and closer in time — a so-called LSTM RNN . With long sequences, thisLSTM RNNovercomes the problem of early signals being washed out by the time they get propagated through the chain to the final activation vector AL. When we refit our model using the LSTM architecture for the hidden layer, the performance improved to 87% on the IMDbtest data. This is com- parable with the 88% achieved by the bag-of-words model in Section 10.4. We give details on fitting these models in Section 10.9.6. Despite this added LSTM complexity, our RNN is", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 473, "start_word": 151360, "end_word": 151760, "chunk_words": 400}}, "ISLP_website::c000474": {"text": "thisLSTM RNNovercomes the problem of early signals being washed out by the time they get propagated through the chain to the final activation vector AL. When we refit our model using the LSTM architecture for the hidden layer, the performance improved to 87% on the IMDbtest data. This is com- parable with the 88% achieved by the bag-of-words model in Section 10.4. We give details on fitting these models in Section 10.9.6. Despite this added LSTM complexity, our RNN is still somewhat “entry level”. We could probably achieve slightly better results by changing the size of the model, changing the regularization, and including additional hidden layers. However, LSTM models take a long time to train, which makes exploring many architectures and parameter optimization tedious. RNNs provide a rich framework for modeling data sequences, and they continue to evolve. There have been many advances in the development of RNNs — in architecture, data augmentation, and in the learning algo- rithms. At the time of this writing (early 2020) the leading RNN configura- tions report accuracy above 95% on the IMDbdata. The details are beyond the scope of this book.17 10.5.2 Time Series Forecasting Figure10.14shows historical trading statistics from the New York Stock Exchange. Shown are three daily time series covering the period December 3, 1962 to December 31, 1986:18 17AnIMDbleaderboard can be found at https://paperswithcode.com/sota/ sentiment-analysis-on-imdb . 18These data were assembled by LeBaron and Weigend (1998) IEEE Transactions on Neural Networks , 9(1): 213–220. 10.5 Recurrent Neural Networks 421Log(Trading Volume)−1.0 0.0 0.5 1.0Dow Jones Return−0.04 0.00 0.04 19651970197519801985−13 −11 −9 −8Log(Volatility)FIGURE 10.14. Historical trading statistics from the New York Stock Exchange. Daily values of the normalized log trading volume, DJIA return, and log volatility are shown for a 24-year period from 1962–1986. We wish to predict trading volume on any day, given the history on all earlier days. To the left of the red bar (January 2, 1980) is training data, and to the right test data. •Log trading volume .Thisisthefractionofalloutstandingsharesthat are traded on that day, relative to a 100-day moving average of past turnover, on the log scale. •Dow Jones return . This is the difference between the log of the Dow Jones Industrial Index on consecutive trading days. •Log volatility . This is based on the absolute values of daily price movements. Predicting stock prices is a notoriously hard problem, but it turns out that predicting trading volume based", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 474, "start_word": 151680, "end_word": 152080, "chunk_words": 400}}, "ISLP_website::c000475": {"text": "and to the right test data. •Log trading volume .Thisisthefractionofalloutstandingsharesthat are traded on that day, relative to a 100-day moving average of past turnover, on the log scale. •Dow Jones return . This is the difference between the log of the Dow Jones Industrial Index on consecutive trading days. •Log volatility . This is based on the absolute values of daily price movements. Predicting stock prices is a notoriously hard problem, but it turns out that predicting trading volume based on recent past history is more manageable (and is useful for planning trading strategies). An observation here consists of the measurements (vt,rt,zt)on dayt, in this case the values for log_volume ,DJ_return andlog_volatility . There areatotalof T=6,051suchtriples,eachofwhichisplottedasatimeseries in Figure 10.14. One feature that strikes us immediately is that the day- to-day observations are not independent of each other. The series exhibit auto-correlation — in this case values nearby in time tend to be similarauto- correlation to each other. This distinguishes time series from other data sets we have encountered, in which observations can be assumed to be independent of 422 10. Deep Learning 0 5 10 15 20 25 30 350.0 0.4 0.8Log( Trading Volume) LagAutocorrelation FunctionFIGURE 10.15. The autocorrelation function for log_volume . We see that nearby values are fairly strongly correlated, with correlations above 0.2as far as 20 days apart. each other. To be clear, consider pairs of observations (vt,vt−/lscript),alagof/lscriptlagdays apart. If we take all such pairs in the vtseries and compute their corre- lation coefficient, this gives the autocorrelation at lag /lscript. Figure10.15shows the autocorrelation function for all lags up to 37, and we see considerable correlation. Another interesting characteristic of this forecasting problem is that the response variable vt—log_volume — is also a predictor! In particular, we will use the past values of log_volume to predict values in the future. RNN forecaster We wish to predict a value vtfrom past values vt−1,vt−2,..., and also to make use of past values of the other series rt−1,rt−2,...andzt−1,zt−2,.... Although our combined data is quite a long series with 6,051 trading days, the structure of the problem is different from the previous document- classification example. • We only have one series of data, not 25,000. • We have an entire seriesof targets vt, and the inputs include past values of this series. How do we represent this problem in terms of the structure displayed in Figure10.12? The idea is to extract", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 475, "start_word": 152000, "end_word": 152400, "chunk_words": 400}}, "ISLP_website::c000476": {"text": "of past values of the other series rt−1,rt−2,...andzt−1,zt−2,.... Although our combined data is quite a long series with 6,051 trading days, the structure of the problem is different from the previous document- classification example. • We only have one series of data, not 25,000. • We have an entire seriesof targets vt, and the inputs include past values of this series. How do we represent this problem in terms of the structure displayed in Figure10.12? The idea is to extract many short mini-series of input se- quencesX={X1,X2,...,X L}with a predefined length L(called the laglagin this context), and a corresponding target Y. They have the form X1= vt−L rt−L zt−L ,X2= vt−L+1 rt−L+1 zt−L+1 ,···,XL= vt−1 rt−1 zt−1 ,andY=vt. (10.20) So here the target Yis the value of log_volume vtat a single timepoint t, and the input sequence Xis the series of 3-vectors {X/lscript}L 1each consisting of the three measurements log_volume ,DJ_return andlog_volatility from dayt−L,t−L+1, up tot−1. Each value of tmakes a separate (X,Y) pair, for trunning from L+1toT. For the NYSEdata we will use the past 10.5 Recurrent Neural Networks 423 1980198219841986−1.0 0.0 0.5 1.0Test Period: Observed and Predicted Yearlog(Trading Volume)FIGURE 10.16. RNN forecast of log_volume on theNYSEtest data. The black lines are the true volumes, and the superimposed orange the forecasts. The fore- casted series accounts for 42% of the variance of log_volume . five trading days to predict the next day’s trading volume. Hence, we use L=5. SinceT=6,051, we can create 6,046 such (X,Y)pairs. Clearly L is a parameter that should be chosen with care, perhaps using validation data. We fit this model with K= 12 hidden units using the 4,281 training sequences derived from the data before January 2, 1980 (see Figure 10.14), and then used it to forecast the 1,770 values of log_volume after this date. We achieve an R2=0.42on the test data. Details are given in Sec- tion10.9.6. As astraw man ,19using yesterday’s value for log_volume as the prediction for today has R2=0.18. Figure 10.16shows the forecast results. We have plotted the observed values of the daily log_volume for the test period 1980–1986 in black, and superimposed the predicted series in orange. The correspondence seems rather good. In forecasting the value of log_volume in the test period, we have to use the test data itself in forming the input sequences X. This may feel like cheating, but in fact it is not; we are always", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 476, "start_word": 152320, "end_word": 152720, "chunk_words": 400}}, "ISLP_website::c000477": {"text": "log_volume as the prediction for today has R2=0.18. Figure 10.16shows the forecast results. We have plotted the observed values of the daily log_volume for the test period 1980–1986 in black, and superimposed the predicted series in orange. The correspondence seems rather good. In forecasting the value of log_volume in the test period, we have to use the test data itself in forming the input sequences X. This may feel like cheating, but in fact it is not; we are always using past data to predict the future. Autoregression The RNN we just fit has much in common with a traditional autoregressionauto- regression (AR) linear model, which we present now for comparison. We first consider the response sequence vtalone, and construct a response vector yand a matrixMof predictors for least squares regression as follows: y= vL+1 vL+2 vL+3 ... vT M= 1 vLvL−1··· v1 1vL+1 vL··· v2 1vL+2vL+1··· v3 ............... 1vT−1vT−2···vT−L .(10.21) Mandyeach have T−Lrows, one per observation. We see that the predictors for any given response vton daytare the previous Lvalues 19A straw man here refers to a simple and sensible prediction that can be used as a baseline for comparison. 424 10. Deep Learning of the same series. Fitting a regression of yonMamounts to fitting the model ˆvt=ˆβ0+ˆβ1vt−1+ˆβ2vt−2+···+ˆβLvt−L, (10.22) and is called an order- Lautoregressive model, or simply AR( L). For the NYSEdata we can include lagged versions of DJ_return andlog_volatility , rtandzt, in the predictor matrix M, resulting in 3L+1columns. An AR model with L=5 achieves a test R2of0.41, slightly inferior to the 0.42 achieved by the RNN. Of course the RNN and AR models are very similar. They both use the same response Yand input sequences Xof length L=5 and dimen- sionp=3 in this case. The RNN processes this sequence from left to right with the same weights W(for the input layer), while the AR model simply treats all Lelements of the sequence equally as a vector of L×p predictors — a process called flattening in the neural network literature.flatteningOf course the RNN also includes the hidden layer activations A/lscriptwhich transfer information along the sequence, and introduces additional nonlin- earity. From ( 10.19) withK= 12 hidden units, we see that the RNN has 13 + 12 ×(1 + 3 + 12) = 205 parameters, compared to the 16 for the AR( 5) model. An obvious extension of the AR model is to use the set of lagged", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 477, "start_word": 152640, "end_word": 153040, "chunk_words": 400}}, "ISLP_website::c000478": {"text": "of L×p predictors — a process called flattening in the neural network literature.flatteningOf course the RNN also includes the hidden layer activations A/lscriptwhich transfer information along the sequence, and introduces additional nonlin- earity. From ( 10.19) withK= 12 hidden units, we see that the RNN has 13 + 12 ×(1 + 3 + 12) = 205 parameters, compared to the 16 for the AR( 5) model. An obvious extension of the AR model is to use the set of lagged predic- tors as the input vector to an ordinary feedforward neural network ( 10.1), and hence add more flexibility. This achieved a test R2=0.42, slightly better than the linear AR, and the same as the RNN. All the models can be improved by including the variable day_of_week corresponding to the day tof the target vt(which can be learned from the calendar dates supplied with the data); trading volume is often higher on Mondays and Fridays. Since there are five trading days, this one-hot en- codes to five binary variables. The performance of the AR model improved toR2=0.46as did the RNN, and the nonlinear AR model improved to R2=0.47. We used the most simple version of the RNN in our examples here. AdditionalexperimentswiththeLSTMextensionoftheRNNyieldedsmall improvements, typically of up to 1% in R2in these examples. We give details of how we fit all three models in Section 10.9.6. 10.5.3 Summary of RNNs We have illustrated RNNs through two simple use cases, and have only scratched the surface. There are many variations and enhancements of the simple RNN we used for sequence modeling. One approach we did not discuss uses a one- dimensional convolutional neural network, treating the sequence of vectors (say words, as represented in the embedding space) as an image. The con- volution filter slides along the sequence in a one-dimensional fashion, with the potential to learn particular phrases or short subsequences relevant to the learning task. One can also have additional hidden layers in an RNN. For example, with two hidden layers, the sequence A/lscriptis treated as an input sequence to the next hidden layer in an obvious fashion. 10.6 When to Use Deep Learning 425 The RNN we used scanned the document from beginning to end; alter- nativebidirectional RNNs scan the sequences in both directions.bidirectionalIn language translation the target is also a sequence of words, in a language different from that of the input sequence. Both the input se- quence", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 478, "start_word": 152960, "end_word": 153360, "chunk_words": 400}}, "ISLP_website::c000479": {"text": "hidden layers in an RNN. For example, with two hidden layers, the sequence A/lscriptis treated as an input sequence to the next hidden layer in an obvious fashion. 10.6 When to Use Deep Learning 425 The RNN we used scanned the document from beginning to end; alter- nativebidirectional RNNs scan the sequences in both directions.bidirectionalIn language translation the target is also a sequence of words, in a language different from that of the input sequence. Both the input se- quence and the target sequence are represented by a structure similar to Figure10.12, and they share the hidden units. In this so-called Seq2SeqSeq2Seqlearning, the hidden units are thought to capture the semantic meaning of the sentences. Some of the big breakthroughs in language modeling and translation resulted from the relatively recent improvements in such RNNs. Algorithms used to fit RNNs can be complex and computationally costly. Fortunately, good software protects users somewhat from these complexi- ties,andmakesspecifyingandfittingthesemodelsrelativelypainless.Many of the models that we enjoy in daily life (like Google Translate ) use state- of-the-art architectures developed by teams of highly skilled engineers, and have been trained using massive computational and data resources. 10.6 When to Use Deep Learning The performance of deep learning in this chapter has been rather impres- sive. It nailed the digit classification problem, and deep CNNs have really revolutionized image classification. We see daily reports of new success sto- ries for deep learning. Many of these are related to image classification tasks, such as machine diagnosis of mammograms or digital X-ray images, ophthalmology eye scans, annotations of MRI scans, and so on. Likewise there are numerous successes of RNNs in speech and language translation, forecasting, and document modeling. The question that then begs an an- swer is:should we discard all our older tools, and use deep learning on every problem with data? To address this question, we revisit our Hittersdataset from Chapter 6. This is a regression problem, where the goal is to predict the Salaryof a baseball player in 1987 using his performance statistics from 1986. After removing players with missing responses, we are left with 263 players and 19 variables. We randomly split the data into a training set of 176 players (twothirds),andatestsetof87players(onethird).Weusedthreemethods for fitting a regression model to these data. • Alinearmodelwasusedtofitthetrainingdata,andmakepredictions on the test data. The model has 20 parameters. • The same linear model was fit with lasso regularization. The tuning parameter was selected", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 479, "start_word": 153280, "end_word": 153680, "chunk_words": 400}}, "ISLP_website::c000480": {"text": "the goal is to predict the Salaryof a baseball player in 1987 using his performance statistics from 1986. After removing players with missing responses, we are left with 263 players and 19 variables. We randomly split the data into a training set of 176 players (twothirds),andatestsetof87players(onethird).Weusedthreemethods for fitting a regression model to these data. • Alinearmodelwasusedtofitthetrainingdata,andmakepredictions on the test data. The model has 20 parameters. • The same linear model was fit with lasso regularization. The tuning parameter was selected by 10-fold cross-validation on the training data.Itselectedamodelwith12variableshavingnonzerocoefficients. • A neural network with one hidden layer consisting of 64 ReLUunits was fit to the data. This model has 1,345 parameters.20 20The model was fit by stochastic gradient descent with a batch size of 32 for 1,000 epochs, and 10% dropout regularization. The test error performance flattened out and started to slowly increase after 1,000 epochs. These fitting details are discussed in Sec- tion10.7. 426 10. Deep Learning Model # Parameters Mean Abs. Error Test Set R2 Linear Regression 20 254.7 0.56 Lasso 12 252.3 0.51 Neural Network 1345 257.4 0.54 TABLE 10.2. Prediction results on the Hitters test data for linear models fit by ordinary least squares and lasso, compared to a neural network fit by stochastic gradient descent with dropout regularization. Coefficient Std. error t-statistic p-value Intercept -226.67 86.26 -2.63 0.0103 Hits 3.06 1.02 3.00 0.0036 Walks 0.181 2.04 0.09 0.9294 CRuns 0.859 0.12 7.09 <0.0001 PutOuts 0.465 0.13 3.60 0.0005 TABLE 10.3. Least squares coefficient estimates associated with the regres- sion ofSalaryon four variables chosen by lasso on the Hitters data set. This model achieved the best performance on the test data, with a mean absolute error of 224.8. The results reported here were obtained from a regression on the test data, which was not used in fitting the lasso model. Table10.2compares the results. We see similar performance for all three models. We report the mean absolute error on the test data, as well as the test R2for each method, which are all respectable (see Exercise 5). We spent a fair bit of time fiddling with the configuration parameters of the neural network to achieve these results. It is possible that if we were to spend more time, and got the form and amount of regularization just right, that we might be able to match or even outperform linear regression and the lasso. But with great ease we obtained", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 480, "start_word": 153600, "end_word": 154000, "chunk_words": 400}}, "ISLP_website::c000481": {"text": "the test data, as well as the test R2for each method, which are all respectable (see Exercise 5). We spent a fair bit of time fiddling with the configuration parameters of the neural network to achieve these results. It is possible that if we were to spend more time, and got the form and amount of regularization just right, that we might be able to match or even outperform linear regression and the lasso. But with great ease we obtained linear models that work well. Linear models are much easier to present and understand than the neural network, which is essentially a black box. The lasso selected 12 of the 19 variables in making its prediction. So in cases like this we are much better off following the Occam’s razor principle: when faced with several methodsOccam’s razorthat give roughly equivalent performance, pick the simplest. After a bit more exploration with the lasso model, we identified an even simpler model with four variables. We then refit the linear model with these fourvariablestothetrainingdata(theso-called relaxed lasso ),andachieved a test mean absolute error of 224.8, the overall winner! It is tempting to present the summary table from this fit, so we can see coefficients and p- values; however, since the model was selected on the training data, there would be selection bias . Instead, we refit the model on the test data, which was not used in the selection. Table 10.3shows the results. Wehaveanumberofverypowerfultoolsatourdisposal,includingneural networks, random forests and boosting, support vector machines and gen- eralized additive models, to name a few. And then we have linear models, and simple variants of these. When faced with new data modeling and pre- diction problems, it’s tempting to always go for the trendy new methods. Often they give extremely impressive results, especially when the datasets are very large and can support the fitting of high-dimensional nonlinear models. However, ifwe can produce models with the simpler tools that 10.7 Fitting a Neural Network 427 perform as well, they are likely to be easier to fit and understand, and po- tentially less fragile than the more complex approaches. Wherever possible, it makes sense to try the simpler models as well, and then make a choice based on the performance/complexity tradeoff. Typically we expect deep learning to be an attractive choice when the sample size of the training set is extremely large, and when interpretability of the model is not", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 481, "start_word": 153920, "end_word": 154320, "chunk_words": 400}}, "ISLP_website::c000482": {"text": "10.7 Fitting a Neural Network 427 perform as well, they are likely to be easier to fit and understand, and po- tentially less fragile than the more complex approaches. Wherever possible, it makes sense to try the simpler models as well, and then make a choice based on the performance/complexity tradeoff. Typically we expect deep learning to be an attractive choice when the sample size of the training set is extremely large, and when interpretability of the model is not a high priority. 10.7 Fitting a Neural Network Fitting neural networks is somewhat complex, and we give a brief overview here. The ideas generalize to much more complex networks. Readers who find this material challenging can safely skip it. Fortunately, as we see in the lab at the end of this chapter, good software is available to fit neural network models in a relatively automated way, without worrying about the technical details of the model-fitting procedure. We start with the simple network depicted in Figure 10.1in Section 10.1. In model ( 10.1) the parameters are β=(β0,β1,...,βK), as well as each of thewk=(wk0,wk1,...,w kp),k=1,...,K . Givenobservations (xi,yi),i= 1, . . . , n, wecouldfitthemodelbysolvinganonlinearleastsquaresproblem minimize {wk}K 1,β1 2n/summationdisplay i=1(yi−f(xi))2, (10.23) where f(xi)=β0+K/summationdisplay k=1βkg/parenleftBig wk0+p/summationdisplay j=1wkjxij/parenrightBig . (10.24) The objective in ( 10.23) looks simple enough, but because of the nested arrangement of the parameters and the symmetry of the hidden units, it is not straightforward to minimize. The problem is nonconvex in the param- eters, and hence there are multiple solutions. As an example, Figure 10.17 shows a simple nonconvex function of a single variable θ; there are two solutions: one is a local minimum and the other is a global minimum . Fur-local minimum global minimumthermore, ( 10.1) is the very simplest of neural networks; in this chapter we have presented much more complex ones where these problems are com- pounded. To overcome some of these issues and to protect from overfitting, two general strategies are employed when fitting neural networks. •Slow Learning: the model is fit in a somewhat slow iterative fash- ion, using gradient descent . The fitting process is then stopped whengradient descentoverfitting is detected. •Regularization: penaltiesareimposedontheparameters,usuallylasso or ridge as discussed in Section 6.2. Suppose we represent all the parameters in one long vector θ. Then we can rewrite the objective in ( 10.23) as R(θ)=1 2n/summationdisplay i=1(yi−fθ(xi))2, (10.25) 428 10. Deep Learning FIGURE 10.17. Illustration of", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 482, "start_word": 154240, "end_word": 154640, "chunk_words": 400}}, "ISLP_website::c000483": {"text": "from overfitting, two general strategies are employed when fitting neural networks. •Slow Learning: the model is fit in a somewhat slow iterative fash- ion, using gradient descent . The fitting process is then stopped whengradient descentoverfitting is detected. •Regularization: penaltiesareimposedontheparameters,usuallylasso or ridge as discussed in Section 6.2. Suppose we represent all the parameters in one long vector θ. Then we can rewrite the objective in ( 10.23) as R(θ)=1 2n/summationdisplay i=1(yi−fθ(xi))2, (10.25) 428 10. Deep Learning FIGURE 10.17. Illustration of gradient descent for one-dimensional θ. The objective function R(θ)is not convex, and has two minima, one at θ=−0.46 (local), the other at θ=1.02(global). Starting at some value θ0(typically ran- domly chosen), each step in θmoves downhill — against the gradient — until it cannot go down any further. Here gradient descent reached the global minimum in7steps. where we make explicit the dependence of fon the parameters. The idea of gradient descent is very simple. 1. Start with a guess θ0for all the parameters in θ, and set t=0. 2. Iterate until the objective ( 10.25) fails to decrease: (a) Findavector δthatreflectsasmallchangein θ,suchthat θt+1= θt+δreducesthe objective; i.e. such that R(θt+1)<R(θt). (b) Sett←t+1. One can visualize (Figure 10.17) standing in a mountainous terrain, and the goal is to get to the bottom through a series of steps. As long as each step goes downhill, we must eventually get to the bottom. In this case we were lucky, because with our starting guess θ0we end up at the global minimum. In general we can hope to end up at a (good) local minimum. 10.7.1 Backpropagation Howdowefindthedirectionstomove θsoastodecreasetheobjective R(θ) in (10.25)? Thegradient ofR(θ), evaluated at some current value θ=θm,gradientis the vector of partial derivatives at that point: ∇R(θm)=∂R(θ) ∂θ/vextendsingle/vextendsingle/vextendsingle θ=θm. (10.26) The subscript θ=θmmeans that after computing the vector of derivatives, we evaluate it at the current guess, θm. This gives the direction in θ-space in which R(θ)increases most rapidly. The idea of gradient descent is to moveθa little in the opposite direction (since we wish to go downhill): θm+1←θm−ρ∇R(θm). (10.27)−1.0 −0.5 0.0 0.5 1.00123456 θR(θ) θ0θ1θ2θ7/uni25CF/uni25CF/uni25CF/uni25CFR(θ0)R(θ1)R(θ2)R(θ7) 10.7 Fitting a Neural Network 429 For a small enough value of the learning rate ρ, this step will decrease thelearning rateobjective R(θ); i.e.R(θm+1)≤R(θm). If the gradient vector is zero, then we may have arrived at a minimum of the objective. How complicated is the calculation ( 10.26)? It turns out that it is quite simple here,", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 483, "start_word": 154560, "end_word": 154960, "chunk_words": 400}}, "ISLP_website::c000484": {"text": "descent is to moveθa little in the opposite direction (since we wish to go downhill): θm+1←θm−ρ∇R(θm). (10.27)−1.0 −0.5 0.0 0.5 1.00123456 θR(θ) θ0θ1θ2θ7/uni25CF/uni25CF/uni25CF/uni25CFR(θ0)R(θ1)R(θ2)R(θ7) 10.7 Fitting a Neural Network 429 For a small enough value of the learning rate ρ, this step will decrease thelearning rateobjective R(θ); i.e.R(θm+1)≤R(θm). If the gradient vector is zero, then we may have arrived at a minimum of the objective. How complicated is the calculation ( 10.26)? It turns out that it is quite simple here, and remains simple even for much more complex networks, because of the chain rule of differentiation.chain ruleSinceR(θ)=/summationtextn i=1Ri(θ)=1 2/summationtextn i=1(yi−fθ(xi))2is a sum, its gradient is also a sum over the nobservations, so we will just examine one of these terms, Ri(θ)=1 2/parenleftBig yi−β0−K/summationdisplay k=1βkg/parenleftbig wk0+p/summationdisplay j=1wkjxij/parenrightbig/parenrightBig2 . (10.28) To simplify the expressions to follow, we write zik=wk0+/summationtextp j=1wkjxij. First we take the derivative with respect to βk: ∂Ri(θ) ∂βk=∂Ri(θ) ∂fθ(xi)·∂fθ(xi) ∂βk =−(yi−fθ(xi))·g(zik). (10.29) And now we take the derivative with respect to wkj: ∂Ri(θ) ∂wkj=∂Ri(θ) ∂fθ(xi)·∂fθ(xi) ∂g(zik)·∂g(zik) ∂zik·∂zik ∂wkj =−(yi−fθ(xi))·βk·g/prime(zik)·xij. (10.30) Notice that both these expressions contain the residual yi−fθ(xi). In (10.29) we see that a fraction of that residual gets attributed to each of the hidden units according to the value of g(zik). Then in ( 10.30) we see a similar attribution to input jvia hidden unit k. So the act of differen- tiation assigns a fraction of the residual to each of the parameters via the chain rule — a process known as backpropagation in the neural networkbackprop- agationliterature. Although these calculations are straightforward, it takes careful bookkeeping to keep track of all the pieces. 10.7.2 Regularization and Stochastic Gradient Descent Gradient descent usually takes many steps to reach a local minimum. In practice, there are a number of approaches for accelerating the process. Also, when nis large, instead of summing ( 10.29)–(10.30) over all nob- servations, we can sample a small fraction or minibatch of them each timeminibatchwe compute a gradient step. This process is known as stochastic gradient descent(SGD) and is the state of the art for learning deep neural networks.stochastic gradient descentFortunately, there is very good software for setting up deep learning mod- els, and for fitting them to data, so most of the technicalities are hidden from the user. We now turn to the multilayer network (Figure 10.4) used in the digit recognitionproblem.Thenetworkhasover235,000weights,whichisaround four times the number of training examples. Regularization is essential here", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 484, "start_word": 154880, "end_word": 155280, "chunk_words": 400}}, "ISLP_website::c000485": {"text": "timeminibatchwe compute a gradient step. This process is known as stochastic gradient descent(SGD) and is the state of the art for learning deep neural networks.stochastic gradient descentFortunately, there is very good software for setting up deep learning mod- els, and for fitting them to data, so most of the technicalities are hidden from the user. We now turn to the multilayer network (Figure 10.4) used in the digit recognitionproblem.Thenetworkhasover235,000weights,whichisaround four times the number of training examples. Regularization is essential here 430 10. Deep Learning 0 5 10 15 20 25 300.1 0.2 0.3 0.4EpochsValue of Objective FunctionTraining SetValidation Set 0 5 10 15 20 25 300.00 0.02 0.04 0.06 0.08 0.10 0.12EpochsClassification ErrorFIGURE 10.18. Evolution of training and validation errors for the MNISTneural network depicted in Figure 10.4, as a function of training epochs. The objective refers to the log-likelihood ( 10.14). to avoid overfitting. The first row in Table 10.1uses ridge regularization on the weights. This is achieved by augmenting the objective function ( 10.14) with a penalty term: R(θ;λ)=−n/summationdisplay i=19/summationdisplay m=0yimlog(fm(xi)) + λ/summationdisplay jθ2 j. (10.31) The parameter λis often preset at a small value, or else it is found using the validation-set approach of Section 5.3.1. We can also use different values of λfor the groups of weights from different layers; in this case W1andW2 were penalized, while the relatively few weights Bof the output layer were not penalized at all. Lasso regularization is also popular as an additional form of regularization, or as an alternative to ridge. Figure10.18shows some metrics that evolve during the training of the network on the MNISTdata. It turns out that SGD naturally enforces its own form of approximately quadratic regularization.21Here the minibatch sizewas128observationspergradientupdate.Theterm epochslabelingtheepochshorizontal axis in Figure 10.18counts the number of times an equivalent of the full training set has been processed. For this network, 20% of the 60,000 training observations were used as a validation set in order to determine when training should stop. So in fact 48,000 observations were used for training, and hence there are 48,000/128≈375minibatch gradient updates per epoch. We see that the value of the validation objective actually starts to increase by 30 epochs, so early stopping can also be used as an additionalearly stoppingform of regularization. 21This and other properties of SGD for deep learning are the subject of much research in the machine learning literature at the time of writing. 10.7 Fitting a Neural", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 485, "start_word": 155200, "end_word": 155600, "chunk_words": 400}}, "ISLP_website::c000486": {"text": "when training should stop. So in fact 48,000 observations were used for training, and hence there are 48,000/128≈375minibatch gradient updates per epoch. We see that the value of the validation objective actually starts to increase by 30 epochs, so early stopping can also be used as an additionalearly stoppingform of regularization. 21This and other properties of SGD for deep learning are the subject of much research in the machine learning literature at the time of writing. 10.7 Fitting a Neural Network 431 FIGURE 10.19. Dropout Learning. Left: a fully connected network. Right: net- work with dropout in the input and hidden layer. The nodes in grey are selected at random, and ignored in an instance of training. 10.7.3 Dropout Learning The second row in Table 10.1is labeled dropout. This is a relatively newdropoutand efficient form of regularization, similar in some respects to ridge reg- ularization. Inspired by random forests (Section 8.2), the idea is to ran- domly remove a fraction φof the units in a layer when fitting the model. Figure10.19illustrates this. This is done separately each time a training observation is processed. The surviving units stand in for those missing, and their weights are scaled up by a factor of 1/(1−φ)to compensate. This prevents nodes from becoming over-specialized, and can be seen as a form of regularization. In practice dropout is achieved by randomly set- ting the activations for the “dropped out” units to zero, while keeping the architecture intact. 10.7.4 Network Tuning The network in Figure 10.4is considered to be relatively straightforward; it nevertheless requires a number of choices that all have an effect on the performance: •The number of hidden layers, and the number of units per layer. Modern thinking is that the number of units per hidden layer can be large, and overfitting can be controlled via the various forms of regularization. •Regularization tuning parameters. These include the dropout rate φ and the strength λof lasso and ridge regularization, and are typically set separately at each layer. •Details of stochastic gradient descent. These include the batch size, the number of epochs, and if used, details of data augmentation (Sec- tion10.3.4.) Choices such as these can make a difference. In preparing this MNISTexam- ple, we achieved a respectable 1.8%misclassification error after some trial and error. Finer tuning and training of a similar network can get under 1%error on these data, but the tinkering process can be tedious,", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 486, "start_word": 155520, "end_word": 155920, "chunk_words": 400}}, "ISLP_website::c000487": {"text": "and ridge regularization, and are typically set separately at each layer. •Details of stochastic gradient descent. These include the batch size, the number of epochs, and if used, details of data augmentation (Sec- tion10.3.4.) Choices such as these can make a difference. In preparing this MNISTexam- ple, we achieved a respectable 1.8%misclassification error after some trial and error. Finer tuning and training of a similar network can get under 1%error on these data, but the tinkering process can be tedious, and can result in overfitting if done carelessly. 432 10. Deep Learning 251020500.0 0.5 1.0 1.5 2.0Degrees of FreedomErrorTraining ErrorTest Error FIGURE 10.20. Double descent phenomenon, illustrated using error plots for a one-dimensional natural spline example. The horizontal axis refers to the number of spline basis functions on the log scale. The training error hits zero when the degrees of freedom coincides with the sample size n= 20 , the “interpolation threshold”, and remains zero thereafter. The test error increases dramatically at this threshold, but then descends again to a reasonable value before finally increasing again. 10.8 Interpolation and Double Descent Throughoutthisbook,wehaverepeatedlydiscussedthebias-variancetrade- off, first presented in Section 2.2.2. This trade-off indicates that statistical learning methods tend to perform the best, in terms of test-set error, for an intermediate level of model complexity. In particular, if we plot “flexibil- ity” on the x-axis and error on the y-axis, then we generally expect to see that test error has a U-shape, whereas training error decreases monotoni- cally. Two “typical” examples of this behavior can be seen in the right-hand panel of Figure 2.9on page29, and in Figure 2.17on page39. One implica- tion of the bias-variance trade-off is that it is generally not a good idea to interpolate the training data — that is, to get zero training error — sinceinterpolatethat will often result in very high test error. However,itturnsoutthatincertainspecificsettingsitcanbepossiblefor a statistical learning method that interpolates the training data to perform well — or at least, better than a slightly less complex model that does not quite interpolate the data. This phenomenon is known as double descent , and is displayed in Figure 10.20. “Double descent” gets its name from the fact that the test error has a U-shape before the interpolation threshold is reached, and then it descends again (for a while, at least) as an increasingly flexible model is fit. We now describe the set-up that resulted in Figure 10.20. We", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 487, "start_word": 155840, "end_word": 156240, "chunk_words": 400}}, "ISLP_website::c000488": {"text": "or at least, better than a slightly less complex model that does not quite interpolate the data. This phenomenon is known as double descent , and is displayed in Figure 10.20. “Double descent” gets its name from the fact that the test error has a U-shape before the interpolation threshold is reached, and then it descends again (for a while, at least) as an increasingly flexible model is fit. We now describe the set-up that resulted in Figure 10.20. We simulated n= 20 observations from the model Y= sin( X)+/epsilon1, whereX∼U[−5,5](uniform distribution), and /epsilon1∼N(0,σ2)withσ=0.3. We then fit a natural spline to the data, as described in Section 7.4, withd 10.8 Interpolation and Double Descent 433 −4 −2 0 2 4−3 −2 −1 0 1 2 38 Degrees of Freedom seq(−5, 5, len = 1000)−4 −2 0 2 4−3 −2 −1 0 1 2 320 Degrees of Freedom seq(−5, 5, len = 1000)f(seq(−5, 5, len = 1000)) −4 −2 0 2 4−3 −2 −1 0 1 2 342 Degrees of Freedom −4 −2 0 2 4−3 −2 −1 0 1 2 380 Degrees of Freedomf(seq(−5, 5, len = 1000))FIGURE 10.21. Fitted functions ˆfd(X)(orange), true function f(X)(black) and the observed 20training data points. A different value of d(degrees of freedom) is used in each panel. For d≥20the orange curves all interpolate the training points, and hence the training error is zero. degrees of freedom.22Recall from Section 7.4that fitting a natural spline withddegrees of freedom amounts to fitting a least-squares regression of the response onto a set of dbasis functions. The upper-left panel of Figure10.21shows the data, the true function f(X), andˆf8(X), the fitted natural spline with d=8degrees of freedom. Next,wefitanaturalsplinewith d= 20 degreesoffreedom.Since n= 20 , this means that n=d, and we have zero training error; in other words, we have interpolated the training data! We can see from the top-right panel of Figure10.21thatˆf20(X)makes wild excursions, and hence the test error will be large. We now continue to fit natural splines to the data, with increasing values ofd. Ford>20, the least squares regression of Yontodbasis functions is not unique: there are an infinite number of least squares coefficient es- timates that achieve zero error. To select among them, we choose the one with the smallest sum of squared coefficients,/summationtextd j=1ˆβ2 j. This is known as theminimum-norm solution. The two lower panels of Figure 10.21show the minimum-norm natural spline fits with d= 42", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 488, "start_word": 156160, "end_word": 156560, "chunk_words": 400}}, "ISLP_website::c000489": {"text": "be large. We now continue to fit natural splines to the data, with increasing values ofd. Ford>20, the least squares regression of Yontodbasis functions is not unique: there are an infinite number of least squares coefficient es- timates that achieve zero error. To select among them, we choose the one with the smallest sum of squared coefficients,/summationtextd j=1ˆβ2 j. This is known as theminimum-norm solution. The two lower panels of Figure 10.21show the minimum-norm natural spline fits with d= 42 andd= 80 degrees of freedom. Incredibly, ˆf42(X) is quite a bit lessless wild than ˆf20(X),even though it makes use of more degrees of freedom . Andˆf80(X)is not much different. How can this be? Essentially, ˆf20(X)isverywildbecausethereisjustasinglewaytointerpo- laten= 20 observations using d= 20 basis functions, and that single way results in a somewhat extreme fitted function. By contrast, there are an 22This implies the choice of dknots, here chosen at dequi-probability quantiles of the training data. When d>n , the quantiles are found by interpolation. 434 10. Deep Learning infinite number of ways to interpolate n= 20 observations using d= 42 or d= 80 basis functions, and the smoothest of them — that is, the minimum norm solution — is much less wild than ˆf20(X)! In Figure 10.20, we display the training error and test error associated withˆfd(X), for a range of values of the degrees of freedom d. We see that the training error drops to zero once d= 20 and beyond; i.e. once the interpolation threshold is reached. By contrast, the test error shows a U- shape for d≤20, grows extremely large around d= 20 , and then shows a second region of descent for d>20. For this example the signal-to-noise ratio — Var(f(X))/σ2— is5.9, which is quite high (the data points are close to the true curve). So an estimate that interpolates the data and does not wander too far inbetween the observed data points will likely do well. In Figures 10.20and10.21, we have illustrated the double descent phe- nomenon in a simple one-dimensional setting using natural splines. How- ever, it turns out that the same phenomenon can arise for deep learning. Basically, when we fit neural networks with a huge number of parameters, we are sometimes able to get good results with zero training error. This is particularlytrueinproblemswithhighsignal-to-noiseratio,suchasnatural image recognition and language translation, for example. This is because the techniques used to fit neural networks, including stochastic gradient", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 489, "start_word": 156480, "end_word": 156880, "chunk_words": 400}}, "ISLP_website::c000490": {"text": "In Figures 10.20and10.21, we have illustrated the double descent phe- nomenon in a simple one-dimensional setting using natural splines. How- ever, it turns out that the same phenomenon can arise for deep learning. Basically, when we fit neural networks with a huge number of parameters, we are sometimes able to get good results with zero training error. This is particularlytrueinproblemswithhighsignal-to-noiseratio,suchasnatural image recognition and language translation, for example. This is because the techniques used to fit neural networks, including stochastic gradient descent, naturally lend themselves to selecting a “smooth” interpolating model that has good test-set performance on these kinds of problems. Some points are worth emphasizing: •The double-descent phenomenon does not contradict the bias-variance trade-off, as presented in Section 2.2.2.Rather, the double-descent curve seen in the right-hand side of Figure 10.20is a consequence of the fact that the x-axis displays the number of spline basis functions used, which does not properly capture the true “flexibility” of models that interpolate the training data. Stated another way, in this exam- ple, the minimum-norm natural spline with d= 42 has lower variance than the natural spline with d= 20 . •Most of the statistical learning methods seen in this book do not exhibit double descent. For instance, regularization approaches typically do not interpolate the training data, and thus double descent does not occur. This is not a drawback of regularized methods: they can give great results without interpolating the data ! In particular, in the examples here, if we had fit the natural splines using ridge regression with an appropriately-chosen penalty rather than least squares, then we would not have seen double descent, and in fact would have obtained better test error results. •In Chapter 9, we saw that maximal margin classifiers and SVMs that have zero training error nonetheless often achieve very good test error. This is in part because those methods seek smooth minimum norm solutions. This is similar to the fact that the minimum-norm natural spline can give good results with zero training error. •The double-descent phenomenon has been used by the machine learn- ing community to explain the successful practice of using an over- 10.9 Lab: Deep Learning 435 parametrized neural network (many layers, and many hidden units), and then fitting all the way to zero training error. However, fitting to zero error is not always optimal, and whether it is advisable de- pends on the signal-to-noise ratio. For instance,", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 490, "start_word": 156800, "end_word": 157200, "chunk_words": 400}}, "ISLP_website::c000491": {"text": "that the minimum-norm natural spline can give good results with zero training error. •The double-descent phenomenon has been used by the machine learn- ing community to explain the successful practice of using an over- 10.9 Lab: Deep Learning 435 parametrized neural network (many layers, and many hidden units), and then fitting all the way to zero training error. However, fitting to zero error is not always optimal, and whether it is advisable de- pends on the signal-to-noise ratio. For instance, we may use ridge regularization to avoid overfitting a neural network, as in ( 10.31). In this case, provided that we use an appropriate choice for the tuning parameter λ, we will never interpolate the training data, and thus will not see the double descent phenomenon. Nonetheless we can get very good test-set performance, likely much better than we would have achieved had we interpolated the training data. Early stopping during stochastic gradient descent can also serve as a form of regular- ization that prevents us from interpolating the training data, while still getting very good results on test data. To summarize: though double descent can sometimes occur in neural net- works, we typically do not want to rely on this behavior. Moreover, it is important to remember that the bias-variance trade-off always holds (though it is possible that test error as a function of flexibility may not exhibit a U-shape, depending on how we have parametrized the notion of “flexibility” on the x-axis). 10.9 Lab: Deep Learning In this section we demonstrate how to fit the examples discussed in the text. We use the Python torch package, along with the pytorch_lightningtorch pytorch_ lightningpackage which provides utilities to simplify fitting and evaluating mod- els. This code can be impressively fast with certain special processors, such as Apple’s new M1 chip. The package is well-structured, flexible, and will feel comfortable to Pythonusers. A good companion is the site py- torch.org/tutorials . Much of our code is adapted from there, as well as the pytorch_lightning documentation.23 We start with several standard imports that we have seen before. In[1]: import numpy as np, pandas as pd from matplotlib.pyplot import subplots from sklearn.linear_model import \\ (LinearRegression, LogisticRegression, Lasso) from sklearn.preprocessing import StandardScaler from sklearn.model_selection import KFold from sklearn.pipeline import Pipeline from ISLP import load_data from ISLP.models import ModelSpec as MS from sklearn.model_selection import \\ (train_test_split, GridSearchCV) 23The precise URLs at the time of writing", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 491, "start_word": 157120, "end_word": 157520, "chunk_words": 400}}, "ISLP_website::c000492": {"text": "Much of our code is adapted from there, as well as the pytorch_lightning documentation.23 We start with several standard imports that we have seen before. In[1]: import numpy as np, pandas as pd from matplotlib.pyplot import subplots from sklearn.linear_model import \\ (LinearRegression, LogisticRegression, Lasso) from sklearn.preprocessing import StandardScaler from sklearn.model_selection import KFold from sklearn.pipeline import Pipeline from ISLP import load_data from ISLP.models import ModelSpec as MS from sklearn.model_selection import \\ (train_test_split, GridSearchCV) 23The precise URLs at the time of writing are https://pytorch.org/tutorials/ beginner/basics/intro.html andhttps://pytorch-lightning.readthedocs.io/en/ latest/. 436 10. Deep Learning Torch-Specific Imports There are a number of imports for torch. (These are not included with ISLP, so must be installed separately.) First we import the main library and essential tools used to specify sequentially-structured networks. In[2]: import torch from torch import nn from torch.optim import RMSprop from torch.utils.data import TensorDataset There are several other helper packages for torch. For instance, the torchmetrics package has utilities to compute various metrics to evalu-torchmetricsate performance when fitting a model. The torchinfo package provides atorchinfouseful summary of the layers of a model. We use the read_image() functionread_image()when loading test images in Section 10.9.4. In[3]: from torchmetrics import (MeanAbsoluteError, R2Score) from torchinfo import summary from torchvision.io import read_image The package pytorch_lightning is a somewhat higher-level interface to torchthat simplifies the specification and fitting of models by reducing the amount of boilerplate code needed (compared to using torchalone). In[4]: from pytorch_lightning import Trainer from pytorch_lightning.loggers import CSVLogger In order to reproduce results we use seed_everything() . We will alsoseed_ everything() instruct torchto use deterministic algorithms where possible. In[5]: from pytorch_lightning.utilities.seed import seed_everything seed_everything(0, workers=True) torch.use_deterministic_algorithms(True, warn_only=True) We will use several datasets shipped with torchvision for our examples:torchvisiona pretrained network for image classification, as well as some transforms used for preprocessing. In[6]: from torchvision.datasets import MNIST, CIFAR100 from torchvision.models import (resnet50, ResNet50_Weights) from torchvision.transforms import (Resize, Normalize, CenterCrop, ToTensor) We have provided a few utilities in ISLPspecifically for this lab. The SimpleDataModule andSimpleModule are simple versions of objects used inpytorch_lightning , the high-level module for fitting torchmodels. Al- though more advanced uses such as computing on graphical processing units (GPUs) and parallel data processing are possible in this module, we will not be focusing much on these in this lab. The ErrorTracker handles collections of targets and predictions over each mini-batch in the validation or test stage, allowing computation of the metric over the entire validation or test", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 492, "start_word": 157440, "end_word": 157840, "chunk_words": 400}}, "ISLP_website::c000493": {"text": "this lab. The SimpleDataModule andSimpleModule are simple versions of objects used inpytorch_lightning , the high-level module for fitting torchmodels. Al- though more advanced uses such as computing on graphical processing units (GPUs) and parallel data processing are possible in this module, we will not be focusing much on these in this lab. The ErrorTracker handles collections of targets and predictions over each mini-batch in the validation or test stage, allowing computation of the metric over the entire validation or test data set. 10.9 Lab: Deep Learning 437 In[7]: from ISLP.torch import (SimpleDataModule, SimpleModule, ErrorTracker, rec_num_workers) In addition we have included some helper functions to load the IMDb database, as well as a lookup that maps integers to particular keys in the database. We’ve included a slightly modified copy of the preprocessed IMDb data from keras, a separate package for fitting deep learning models. Thiskerassaves us significant preprocessing and allows us to focus on specifying and fitting the models themselves. In[8]: from ISLP.torch.imdb import (load_lookup, load_tensor, load_sparse, load_sequential) Finally, we introduce some utility imports not directly related to torch. Theglob()function from the globmodule is used to find all files matchingglob()wildcardcharacters,whichwewilluseinourexampleapplyingthe ResNet50 model to some of our own images. The jsonmodule will be used to load ajsonJSON file for looking up classes to identify the labels of the pictures in the ResNet50 example. In[9]: from glob import glob import json 10.9.1 Single Layer Network on Hitters Data We start by fitting the models in Section 10.6on theHittersdata. In[10]: Hitters = load_data( 'Hitters' ).dropna() n=H i t t e r s . s h a p e [ 0 ] We will fit two linear models (least squares and lasso) and compare their performance to that of a neural network. For this comparison we will use mean absolute error on a validation dataset. MAE(y,ˆy)=1 nn/summationdisplay i=1|yi−ˆyi|. We set up the model matrix and the response. In[11]: model = MS(Hitters.columns.drop( 'Salary' ), intercept=False) X=m o d e l . f i t _ t r a n s f o r m ( H i t t e r s ) . t o _ n u m p y ( ) Y=H i t t e r s [ 'Salary' ].to_numpy() Theto_numpy() method above converts pandasdata frames or series toto_numpy()numpyarrays. We do this because we will need to use sklearnto fit the lasso model, and it requires this conversion. We also use a", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 493, "start_word": 157760, "end_word": 158160, "chunk_words": 400}}, "ISLP_website::c000494": {"text": "o d e l . f i t _ t r a n s f o r m ( H i t t e r s ) . t o _ n u m p y ( ) Y=H i t t e r s [ 'Salary' ].to_numpy() Theto_numpy() method above converts pandasdata frames or series toto_numpy()numpyarrays. We do this because we will need to use sklearnto fit the lasso model, and it requires this conversion. We also use a linear regres- sion method from sklearn, rather than the method in Chapter 3 from statsmodels , to facilitate the comparisons. We now split the data into test and training, fixing the random state used by sklearnto do the split. 438 10. Deep Learning In[12]: (X_train, X_test, Y_train, Y_test) = train_test_split(X, Y, test_size=1/3, random_state=1) Linear Models We fit the linear model and evaluate the test error directly. In[13]: hit_lm = LinearRegression().fit(X_train, Y_train) Yhat_test = hit_lm.predict(X_test) np.abs(Yhat_test - Y_test).mean() Out[13]: 259.7153 Next we fit the lasso using sklearn. We are using mean absolute error to select and evaluate a model, rather than mean squared error. The spe- cialized solver we used in Section 6.5.2uses only mean squared error. So here, with a bit more work, we cre atea cross-validation grid and perform the cross-validation directly. We encode a pipeline with two steps: we first normalize the features using a StandardScaler() transform, and then fit the lasso without further normalization. In[14]: scaler = StandardScaler(with_mean=True, with_std=True) lasso = Lasso(warm_start=True, max_iter=30000) standard_lasso = Pipeline(steps=[( 'scaler' ,s c a l e r ) , ('lasso' ,l a s s o ) ] ) We need to create a grid of values for λ. As is common practice, we choose a grid of 100 values of λ, uniform on the log scale from lam_max down to 0.01*lam_max . Herelam_maxis the smallest value of λwith an all- zero solution. This value equals the largest absolute inner-product between any predictor and the (centered) response.24 In[15]: X_s = scaler.fit_transform(X_train) n=X _ s . s h a p e [ 0 ] lam_max = np.fabs(X_s.T.dot(Y_train - Y_train.mean())).max() / n param_grid = { 'alpha' :n p . e x p ( n p . l i n s p a c e ( 0 ,n p . l o g ( 0 . 0 1 ) ,1 0 0 ) ) *l a m _ m a x } Note that we", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 494, "start_word": 158080, "end_word": 158480, "chunk_words": 400}}, "ISLP_website::c000495": {"text": "predictor and the (centered) response.24 In[15]: X_s = scaler.fit_transform(X_train) n=X _ s . s h a p e [ 0 ] lam_max = np.fabs(X_s.T.dot(Y_train - Y_train.mean())).max() / n param_grid = { 'alpha' :n p . e x p ( n p . l i n s p a c e ( 0 ,n p . l o g ( 0 . 0 1 ) ,1 0 0 ) ) *l a m _ m a x } Note that we had to transform the data first, since the scale of the vari- ables impacts the choice of λ. We now perform cross-validation using this sequence of λvalues. In[16]: cv = KFold(10, shuffle=True, random_state=1) grid = GridSearchCV(lasso, 24The derivation of this result is beyond the scope of this book. 10.9 Lab: Deep Learning 439param_grid,cv=cv,scoring='neg_mean_absolute_error')grid.fit(X_train, Y_train);Weextractthelassomodelwithbestcross-validatedmeanabsoluteerror,and evaluate its performance onX_testandY_test, which were not usedin cross-validation.In[17]:trained_lasso = grid.best_estimator_Yhat_test = trained_lasso.predict(X_test)np.fabs(Yhat_test - Y_test).mean()Out[17]:257.2382This is similar to the results we got for the linear model fit by least squares.However, these results can vary a lot for different train/test splits; we en-courage the reader to try a different seed in code block 12 and rerun thesubsequent code up to this point.Specifying a Network: Classes and InheritanceTo fit the neural network, we first set up a model structure that describesthe network. Doing so requires us to define new classes specific to the modelwe wish to fit. Typically this is done inpytorchby sub-classing a genericrepresentation of a network, which is the approach we take here. Althoughthis example is simple, we will go through the steps in some detail, since itwill serve us well for the more complex examples to follow.In[18]:class HittersModel(nn.Module):def __init__(self, input_size):super(HittersModel, self).__init__()self.flatten = nn.Flatten()self.sequential = nn.Sequential(nn.Linear(input_size, 50),nn.ReLU(),nn.Dropout(0.4),nn.Linear(50, 1))def forward(self, x):x=s e l f . f l a t t e n ( x )return torch.flatten(self.sequential(x))Theclassstatement identifies the code chunk as a declaration for a classHittersModelthat inherits from the base classnn.Module. This base class isubiquitous intorchand represents the mappings in the neural networks.Indented beneath theclassstatement are the methods of this class: inthis case__init__andforward. The__init__method is called when aninstance of the class is created as in the cell below. In the methods,selfalways refers to an instance of the class. In the__init__method, we haveattached two objects toselfas attributes:flattenandsequential. Theseare used in theforwardmethod to describe the map that this moduleimplements. 440 10. Deep LearningThere is one additional line in the__init__method, which is a call tosuper(). This function allows subclasses (i.e.HittersModel)", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 495, "start_word": 158400, "end_word": 158800, "chunk_words": 400}}, "ISLP_website::c000496": {"text": "the mappings in the neural networks.Indented beneath theclassstatement are the methods of this class: inthis case__init__andforward. The__init__method is called when aninstance of the class is created as in the cell below. In the methods,selfalways refers to an instance of the class. In the__init__method, we haveattached two objects toselfas attributes:flattenandsequential. Theseare used in theforwardmethod to describe the map that this moduleimplements. 440 10. Deep LearningThere is one additional line in the__init__method, which is a call tosuper(). This function allows subclasses (i.e.HittersModel) to access meth-super()ods of the class they inherit from. For example, the classnn.Modulehas itsown__init__method, which is different from theHittersModel.__init__()method we’ve written above. Usingsuper()allows us to call the methodof the base class. Fortorchmodels, we will always be making thissuper()call as it is necessary for the model to be properly interpreted bytorch.Theobjectnn.Modulehasmoremethodsthansimply__init__andforward.These methods are directly accessible toHittersModelinstances because ofthis inheritance. One such method we will see shortly is theeval()method,used to disable dropout for when we want to evaluate the model on testdata.In[19]:hit_model = HittersModel(X.shape[1])The objectself.sequentialis a composition of four maps. The firstmaps the 19 features ofHittersto 50 dimensions, introducing50×19 + 50parameters for the weights andinterceptof the map (often called thebias).ThislayeristhenmappedtoaReLUlayerfollowedbya40%dropoutlayer,and finally a linear map down to 1 dimension, again with a bias. The totalnumber of trainable parameters is therefore50×19 + 50 + 50 + 1 = 1051.The packagetorchinfoprovides asummary()function that neatly sum-marizes this information. We specify the size of the input and see the sizeof each tensor as it passes through layers of the network.In[20]:summary(hit_model,input_size=X_train.shape,col_names=['input_size','output_size','num_params'])Out[20]:=====================================================================Layer (type:depth-idx) Input Shape Output Shape Param#=====================================================================HittersModel[175, 19] [175]--Flatten: 1-1[175, 19] [175, 19] --Sequential: 1-2[175, 19] [175, 1] --Linear: 2-1[175, 19] [175, 50] 1,000ReLU: 2-2[175, 50] [175, 50] --Dropout: 2-3[175, 50][175, 50]--Linear: 2-4[175, 50] [175, 1] 51=====================================================================Total params: 1,051Trainable params: 1,051We have truncated the end of the output slightly, here and in subsequentuses.We now need to transform our training data into a form accessible totorch. The basic datatype intorchis atensor, which is very similar toanndarrayfrom early chapters. We also note here thattorchtypicallyworks with 32-bit (single precision) rather than 64-bit (double precision)floating point numbers. We therefore convert our data tonp.float32beforeforming the tensor. TheXandYtensors are then arranged into aDatasetDataset 10.9 Lab: Deep Learning 441 recognized by torchusingTensorDataset() .Tensor Dataset()In[21]: X_train_t = torch.tensor(X_train.astype(np.float32)) Y_train_t = torch.tensor(Y_train.astype(np.float32)) hit_train = TensorDataset(X_train_t, Y_train_t) We do the same for the test data. In[22]: X_test_t = torch.tensor(X_test.astype(np.float32)) Y_test_t = torch.tensor(Y_test.astype(np.float32)) hit_test = TensorDataset(X_test_t, Y_test_t) Finally, this dataset is passed to a DataLoader() which ultimately passes data", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 496, "start_word": 158720, "end_word": 159120, "chunk_words": 400}}, "ISLP_website::c000497": {"text": "also note here thattorchtypicallyworks with 32-bit (single precision) rather than 64-bit (double precision)floating point numbers. We therefore convert our data tonp.float32beforeforming the tensor. TheXandYtensors are then arranged into aDatasetDataset 10.9 Lab: Deep Learning 441 recognized by torchusingTensorDataset() .Tensor Dataset()In[21]: X_train_t = torch.tensor(X_train.astype(np.float32)) Y_train_t = torch.tensor(Y_train.astype(np.float32)) hit_train = TensorDataset(X_train_t, Y_train_t) We do the same for the test data. In[22]: X_test_t = torch.tensor(X_test.astype(np.float32)) Y_test_t = torch.tensor(Y_test.astype(np.float32)) hit_test = TensorDataset(X_test_t, Y_test_t) Finally, this dataset is passed to a DataLoader() which ultimately passes data into our network. While this may seem like a lot of overhead, this structure is helpful for more complex tasks where data may live on different machines, or where data must be passed to a GPU. We provide a helper function SimpleDataModule() inISLPto make this task easier for standardSimpleData Module() usage. One of its arguments is num_workers , which indicates how many processes we will use for loading the data. For small data like Hitters this will have little effect, but it does provide an advantage for the MNIST andCIFAR100 examples below. The torchpackage will inspect the process running and determine a maximum number of workers.25We’ve included a function rec_num_workers() to compute this so we know how many workers might be reasonable (here the max was 16). In[23]: max_num_workers = rec_num_workers() The general training setup in pytorch_lightning involves training, vali- dation and test data. These are each represented by different data loaders. During each epoch, we run a training step to learn the model and a vali- dation step to track the error. The test data is typically used at the end of training to evaluate the model. In this case, as we had split only into test and training, we’ll use the test data as validation data with the argument validation=hit_test . The validation argument can be a float between 0 and 1, an integer, or a Dataset. If a float (respectively, integer), it is interpreted as a percentage (respectively number) of the trainingobservations to be used for validation. If it is a Dataset, it is passed directly to a data loader. In[24]: hit_dm = SimpleDataModule(hit_train, hit_test, batch_size=32, num_workers=min(4, max_num_workers), validation=hit_test) Next we must provide a pytorch_lightning module that controls the steps performed during the training process. We provide methods for our SimpleModule() that simply record the value of the loss function and any additionalmetricsattheendofeachepoch.Theseoperationsarecontrolled by the methods SimpleModule.[training/test/validation]_step() , though we will not be modifying these in our", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 497, "start_word": 159040, "end_word": 159440, "chunk_words": 400}}, "ISLP_website::c000498": {"text": "(respectively number) of the trainingobservations to be used for validation. If it is a Dataset, it is passed directly to a data loader. In[24]: hit_dm = SimpleDataModule(hit_train, hit_test, batch_size=32, num_workers=min(4, max_num_workers), validation=hit_test) Next we must provide a pytorch_lightning module that controls the steps performed during the training process. We provide methods for our SimpleModule() that simply record the value of the loss function and any additionalmetricsattheendofeachepoch.Theseoperationsarecontrolled by the methods SimpleModule.[training/test/validation]_step() , though we will not be modifying these in our examples. 25This depends on the computing hardware and the number of cores available. 442 10. Deep Learning In[25]: hit_module = SimpleModule.regression(hit_model, metrics={ 'mae':MeanAbsoluteError()}) By using the SimpleModule.regression() method, we indicate that weSimpleModule. regression() will use squared-error loss as in ( 10.23). We have also asked for mean ab- solute error to be tracked as well in the metrics that are logged. We log our results via CSVLogger() , which in this case stores the results in a CSV file within a directory logs/hitters . After the fitting is complete, this allows us to load the results as a pd.DataFrame() and visualize them below. There are several ways to log the results within pytorch_lightning , though we will not cover those here in detail. In[26]: hit_logger = CSVLogger( 'logs',n a m e = 'hitters' ) Finally we are ready to train our model and log the results. We use theTrainer() object from pytorch_lightning to do this work. The argu- mentdatamodule=hit_dm tells the trainer how training/validation/test logs are produced, while the first argument hit_module specifies the network architecture as well as the training/validation/test steps. The callbacks argument allows for several tasks to be carried out at various points while training a model. Here our ErrorTracker() callback will enable us to com- pute validation error while training and, finally, the test error. We now fit the model for 50 epochs. In[27]: hit_trainer = Trainer(deterministic=True, max_epochs=50, log_every_n_steps=5, logger=hit_logger, callbacks=[ErrorTracker()]) hit_trainer.fit(hit_module, datamodule=hit_dm) At each step of SGD, the algorithm randomly selects 32 training observa- tions for the computation of the gradient. Recall from Section 10.7that an epoch amounts to the number of SGD steps required to process nobserva- tions. Since the training set has n= 175, and we specified a batch_size of 32 in the construction of hit_dm, an epoch is 175/32 = 5.5SGD steps. After having fit the model, we can evaluate performance on our test data using the test()method of our trainer. In[28]:", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 498, "start_word": 159360, "end_word": 159760, "chunk_words": 400}}, "ISLP_website::c000499": {"text": "of SGD, the algorithm randomly selects 32 training observa- tions for the computation of the gradient. Recall from Section 10.7that an epoch amounts to the number of SGD steps required to process nobserva- tions. Since the training set has n= 175, and we specified a batch_size of 32 in the construction of hit_dm, an epoch is 175/32 = 5.5SGD steps. After having fit the model, we can evaluate performance on our test data using the test()method of our trainer. In[28]: hit_trainer.test(hit_module, datamodule=hit_dm) Out[28]: [{'test_loss' :1 0 4 0 9 8 . 5 4 6 9 , 'test_mae' :2 2 9 . 5 0 1 2 } ] The results of the fit have been logged into a CSV file. We can find the results specific to this run in the experiment.metrics_file_path attribute of our logger. Note that each time the model is fit, the logger will output results into a new subdirectory of our directory logs/hitters . We now create a plot of the MAE (mean absolute error) as a function of the number of epochs. First we retrieve the logged summaries. hit_results = pd.read_csv(hit_logger.experiment.metrics_file_path) Since we will produce similar plots in later examples, we write a simple generic function to produce this plot. 10.9 Lab: Deep Learning 443In[29]:def summary_plot(results,ax,col='loss',valid_legend='Validation',training_legend='Training',ylabel='Loss',fontsize=20):for (column,color,label) in zip([f'train_{col}_epoch',f'valid_{col}'],['black','red'],[training_legend,valid_legend]):results.plot(x='epoch',y=column,label=label,marker='o',color=color,ax=ax)ax.set_xlabel('Epoch')ax.set_ylabel(ylabel)return axWe now set up our axes, and use our function to produce the MAE plot.In[30]:fig, ax = subplots(1, 1, figsize=(6, 6))ax = summary_plot(hit_results,ax,col='mae',ylabel='MAE',valid_legend='Validation (=Test)')ax.set_ylim([0, 400])ax.set_xticks(np.linspace(0, 50, 11).astype(int));We can predict directly from the final model, and evaluate its per-formance on the test data. Before fitting, we call theeval()method ofhit_model. This tellstorchto effectively consider this model to be fitted,sothatwecanuseittopredictonnewdata.Forourmodelhere,thebiggestchange is that the dropout layers will be turned off, i.e. no weights will berandomly dropped in predicting on new data.In[31]:hit_model.eval()preds = hit_module(X_test_t)torch.abs(Y_test_t - preds).mean()Out[31]:tensor(229.5012, grad_fn=<MeanBackward0>)CleanupIn setting up our data module, we had initiated several worker processesthat will remain running. We delete all references to the torch objects toensure these processes will be killed. 444 10. Deep Learning In[32]: del(Hitters, hit_model, hit_dm, hit_logger, hit_test, hit_train, X, Y, X_test, X_train, Y_test, Y_train, X_test_t, Y_test_t, hit_trainer, hit_module) 10.9.2 Multilayer Network on the MNIST Digit Data Thetorchvision packagecomeswithanumberofexampledatasets,includ- ing the MNISTdigit data. Our first step is to retrieve the training and test data sets; the MNIST()function within torchvision.datasets is provided forMNIST()this purpose. The data will be downloaded the first time this function is executed, and stored in the directory data/MNIST . In[33]: (mnist_train, mnist_test)", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 499, "start_word": 159680, "end_word": 160080, "chunk_words": 400}}, "ISLP_website::c000500": {"text": "will be killed. 444 10. Deep Learning In[32]: del(Hitters, hit_model, hit_dm, hit_logger, hit_test, hit_train, X, Y, X_test, X_train, Y_test, Y_train, X_test_t, Y_test_t, hit_trainer, hit_module) 10.9.2 Multilayer Network on the MNIST Digit Data Thetorchvision packagecomeswithanumberofexampledatasets,includ- ing the MNISTdigit data. Our first step is to retrieve the training and test data sets; the MNIST()function within torchvision.datasets is provided forMNIST()this purpose. The data will be downloaded the first time this function is executed, and stored in the directory data/MNIST . In[33]: (mnist_train, mnist_test) = [MNIST(root= 'data', train=train, download=True, transform=ToTensor()) for train in [True, False]] mnist_train Out[33]: Dataset MNIST Number of datapoints: 60000 Root location: data Split: Train StandardTransform Transform: ToTensor() There are 60,000 images in the training data and 10,000 in the test data. The images are 28×28, and stored as a matrix of pixels. We need to transform each one into a vector. Neural networks are somewhat sensitive to the scale of the inputs, much as ridge and lasso regularization are affected by scaling. Here the inputs are eight-bit grayscale values between 0 and 255, so we rescale to the unit interval.26This transformation, along with some reordering of the axes, is performed by the ToTensor() transform from the torchvision.transforms package. As in our Hittersexample, we form a data module from the training and test datasets, setting aside 20% of the training images for validation. In[34]: mnist_dm = SimpleDataModule(mnist_train, mnist_test, validation=0.2, num_workers=max_num_workers, batch_size=256) 26Note: eight bits means 28, which equals 256. Since the convention is to start at 0, the possible values range from 0to255. 10.9 Lab: Deep Learning 445Let’s take a look at the data that will get fed into our network. We loopthrough the first few chunks of the test dataset, breaking after 2 batches:In[35]:for idx, (X_ ,Y_) in enumerate(mnist_dm.train_dataloader()):print('X: ',X _ . s h a p e )print('Y: ',Y _ . s h a p e )if idx >= 1:breakX: torch.Size([256, 1, 28, 28])Y: torch.Size([256])X: torch.Size([256, 1, 28, 28])Y: torch.Size([256])We see that theXfor each batch consists of 256 images of size1x28x28.Here the1indicates a single channel (greyscale). For RGB images such asCIFAR100below, we will see that the1in the size will be replaced by3forthe three RGB channels.Now we are ready to specify our neural network.In[36]:class MNISTModel(nn.Module):def __init__(self):super(MNISTModel, self).__init__()self.layer1 = nn.Sequential(nn.Flatten(),nn.Linear(28*28, 256),nn.ReLU(),nn.Dropout(0.4))self.layer2 = nn.Sequential(nn.Linear(256, 128),nn.ReLU(),nn.Dropout(0.3))self._forward = nn.Sequential(self.layer1,self.layer2,nn.Linear(128, 10))def forward(self, x):return self._forward(x)We see that in the first layer, each1x28x28image is flattened, thenmapped to 256 dimensions where we apply a ReLU activation with 40%dropout. A", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 500, "start_word": 160000, "end_word": 160400, "chunk_words": 400}}, "ISLP_website::c000501": {"text": "see that theXfor each batch consists of 256 images of size1x28x28.Here the1indicates a single channel (greyscale). For RGB images such asCIFAR100below, we will see that the1in the size will be replaced by3forthe three RGB channels.Now we are ready to specify our neural network.In[36]:class MNISTModel(nn.Module):def __init__(self):super(MNISTModel, self).__init__()self.layer1 = nn.Sequential(nn.Flatten(),nn.Linear(28*28, 256),nn.ReLU(),nn.Dropout(0.4))self.layer2 = nn.Sequential(nn.Linear(256, 128),nn.ReLU(),nn.Dropout(0.3))self._forward = nn.Sequential(self.layer1,self.layer2,nn.Linear(128, 10))def forward(self, x):return self._forward(x)We see that in the first layer, each1x28x28image is flattened, thenmapped to 256 dimensions where we apply a ReLU activation with 40%dropout. A second layer maps the first layer’s output down to 128 di-mensions, applying a ReLU activation with 30% dropout. Finally, the 128dimensions are mapped down to 10, the number of classes in theMNISTdata.In[37]:mnist_model = MNISTModel()We can check that the model produces output of expected size based onour existing batchX_above.In[38]:mnist_model(X_).size()Out[38]:torch.Size([256, 10])Let’s take a look at the summary of the model. Instead of aninput_sizewe can pass a tensor of correct shape. In this case, we pass through thefinal batchedX_from above. 446 10. Deep LearningIn[39]:summary(mnist_model,input_data=X_,col_names=['input_size','output_size','num_params'])Out[39]:=====================================================================Layer (type:depth-idx) Input Shape Output Shape Param#=====================================================================MNISTModel[256, 1, 28, 28] [256, 10] --Sequential: 1-1[256, 1, 28, 28] [256, 10] --Sequential: 2-1 [256, 1, 28, 28] [256, 256] --Flatten: 3-1 [256, 1, 28, 28] [256, 784] --Linear: 3-2 [256, 784] [256, 256] 200,960ReLU: 3-3 [256, 256] [256, 256] --Dropout: 3-4 [256, 256] [256, 256] --Sequential: 2-2 [256, 256] [256, 128] --Linear: 3-5 [256, 256] [256, 128] 32,896ReLU: 3-6 [256, 128] [256, 128] --Dropout: 3-7 [256, 128] [256, 128] --Linear: 2-3[256, 128] [256, 10] 1,290=====================================================================Total params: 235,146Trainable params: 235,146Having set up both the model and the data module, fitting this model isnow almost identical to theHittersexample. In contrast to our regressionmodel, here we will use theSimpleModule.classification()method whichSimpleModule.classifi-cation()uses the cross-entropy loss function instead of mean squared error.In[40]:mnist_module = SimpleModule.classification(mnist_model)mnist_logger = CSVLogger('logs',n a m e ='MNIST')Now we are ready to go. The final step is to supply training data, andfit the model.In[41]:mnist_trainer = Trainer(deterministic=True,max_epochs=30,logger=mnist_logger,callbacks=[ErrorTracker()])mnist_trainer.fit(mnist_module,datamodule=mnist_dm)We have suppressed the output here, which is a progress report on thefitting of the model, grouped by epoch. This is very useful, since on largedatasets fitting can take time. Fitting this model took 245 seconds on aMacBook Pro with an Apple M1 Pro chip with 10 cores and 16 GB ofRAM. Here we specified a validation split of 20%, so training is actuallyperformed on 80% of the 60,000 observations in the training set. This is analternativetoactuallysupplyingvalidationdata,likewedidfortheHittersdata. SGD uses batches of 256 observations in computing the gradient, anddoing the arithmetic, we", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 501, "start_word": 160320, "end_word": 160720, "chunk_words": 400}}, "ISLP_website::c000502": {"text": "on thefitting of the model, grouped by epoch. This is very useful, since on largedatasets fitting can take time. Fitting this model took 245 seconds on aMacBook Pro with an Apple M1 Pro chip with 10 cores and 16 GB ofRAM. Here we specified a validation split of 20%, so training is actuallyperformed on 80% of the 60,000 observations in the training set. This is analternativetoactuallysupplyingvalidationdata,likewedidfortheHittersdata. SGD uses batches of 256 observations in computing the gradient, anddoing the arithmetic, we see that an epoch corresponds to 188 gradientsteps.SimpleModule.classification()includes an accuracy metric by default.Other classification metrics can be added fromtorchmetrics. We will useoursummary_plot()function to display accuracy across epochs. 10.9 Lab: Deep Learning 447 In[42]: mnist_results = pd.read_csv(mnist_logger.experiment. metrics_file_path) fig, ax = subplots(1, 1, figsize=(6, 6)) summary_plot(mnist_results, ax, col='accuracy' , ylabel= 'Accuracy' ) ax.set_ylim([0.5, 1]) ax.set_ylabel( 'Accuracy' ) ax.set_xticks(np.linspace(0, 30, 7).astype(int)); Once again we evaluate the accuracy using the test()method of our trainer. This model achieves 97% accuracy on the test data. In[43]: mnist_trainer.test(mnist_module, datamodule=mnist_dm) Out[43]: [{'test_loss' :0 . 1 4 7 1 , 'test_accuracy' :0 . 9 6 8 1 } ] Table10.1also reports the error rates resulting from LDA (Chapter 4) and multiclass logistic regression. For LDA we refer the reader to Section 4.7.3. Although we could use the sklearnfunction LogisticRegression() to fit multiclass logistic regression, we are set up here to fit such a model with torch.Wejusthaveaninputlayerandanoutputlayer,andomitthehidden layers! In[44]: class MNIST_MLR(nn.Module): def __init__(self): super(MNIST_MLR, self).__init__() self.linear = nn.Sequential(nn.Flatten(), nn.Linear(784, 10)) def forward(self, x): return self.linear(x) mlr_model = MNIST_MLR() mlr_module = SimpleModule.classification(mlr_model) mlr_logger = CSVLogger( 'logs',n a m e = 'MNIST_MLR' ) In[45]: mlr_trainer = Trainer(deterministic=True, max_epochs=30, callbacks=[ErrorTracker()]) mlr_trainer.fit(mlr_module, datamodule=mnist_dm) We fit the model just as before and compute the test results. In[46]: mlr_trainer.test(mlr_module, datamodule=mnist_dm) Out[46]: [{'test_loss' :0 . 3 1 8 7 , 'test_accuracy' :0 . 9 2 4 1 } ] The accuracy is above 90% even for this pretty simple model. As in the Hitters example, we delete some of the objects we created above. In[47]: del(mnist_test, mnist_train, 448 10. Deep Learningmnist_model,mnist_dm,mnist_trainer,mnist_module,mnist_results,mlr_model,mlr_module,mlr_trainer)10.9.3 Convolutional Neural NetworksIn this section we fit a CNN to theCIFAR100data, which is available in thetorchvisionpackage. It is arranged in a similar fashion as theMNISTdata.In[48]:(cifar_train,cifar_test) = [CIFAR100(root=\"data\",train=train,download=True)for train in [True, False]]In[49]:transform = ToTensor()cifar_train_X = torch.stack([transform(x) for x incifar_train.data])cifar_test_X = torch.stack([transform(x) for x incifar_test.data])cifar_train = TensorDataset(cifar_train_X,torch.tensor(cifar_train.targets))cifar_test = TensorDataset(cifar_test_X,torch.tensor(cifar_test.targets))TheCIFAR100datasetconsistsof50,000trainingimages,eachrepresentedby a three-dimensional tensor: each three-color image is represented as aset of three channels, each of which consists of32×32eight-bit", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 502, "start_word": 160640, "end_word": 161040, "chunk_words": 400}}, "ISLP_website::c000503": {"text": "delete some of the objects we created above. In[47]: del(mnist_test, mnist_train, 448 10. Deep Learningmnist_model,mnist_dm,mnist_trainer,mnist_module,mnist_results,mlr_model,mlr_module,mlr_trainer)10.9.3 Convolutional Neural NetworksIn this section we fit a CNN to theCIFAR100data, which is available in thetorchvisionpackage. It is arranged in a similar fashion as theMNISTdata.In[48]:(cifar_train,cifar_test) = [CIFAR100(root=\"data\",train=train,download=True)for train in [True, False]]In[49]:transform = ToTensor()cifar_train_X = torch.stack([transform(x) for x incifar_train.data])cifar_test_X = torch.stack([transform(x) for x incifar_test.data])cifar_train = TensorDataset(cifar_train_X,torch.tensor(cifar_train.targets))cifar_test = TensorDataset(cifar_test_X,torch.tensor(cifar_test.targets))TheCIFAR100datasetconsistsof50,000trainingimages,eachrepresentedby a three-dimensional tensor: each three-color image is represented as aset of three channels, each of which consists of32×32eight-bit pixels. Westandardize as we did for the digits, but keep the array structure. This isaccomplished with theToTensor()transform.Creating the data module is similar to theMNISTexample.In[50]:cifar_dm = SimpleDataModule(cifar_train,cifar_test,validation=0.2,num_workers=max_num_workers,batch_size=128)We again look at the shape of typical batches in our data loaders.In[51]:for idx, (X_ ,Y_) in enumerate(cifar_dm.train_dataloader()):print('X: ',X _ . s h a p e )print('Y: ',Y _ . s h a p e )if idx >= 1:breakX: torch.Size([128, 3, 32, 32])Y: torch.Size([128])X: torch.Size([128, 3, 32, 32])Y: torch.Size([128]) 10.9 Lab: Deep Learning 449 Before we start, we look at some of the training images; similar code produced Figure 10.5on page406. The example below also illustrates that TensorDataset objects can be indexed with integers — we are choosing ran- domimagesfromthetrainingdatabyindexing cifar_train .Inordertodis- play correctly, we must reorder the dimensions by a call to np.transpose() . In[52]: fig, axes = subplots(5, 5, figsize=(10,10)) rng = np.random.default_rng(4) indices = rng.choice(np.arange(len(cifar_train)), 25, replace=False).reshape((5,5)) for i in range(5): for j in range(5): idx = indices[i,j] axes[i,j].imshow(np.transpose(cifar_train[idx][0], [1,2,0]), interpolation=None) axes[i,j].set_xticks([]) axes[i,j].set_yticks([]) Here the imshow() method recognizes from the shape of its argument that.imshow()it is a 3-dimensional array, with the last dimension indexing the three RGB color channels. We specify a moderately-sized CNN for demonstration purposes, simi- lar in structure to Figure 10.8. We use several layers, each consisting of convolution, ReLU, and max-pooling steps. We first define a module that defines one of these layers. As in our previous examples, we overwrite the __init__() andforward() methods of nn.Module . This user-defined module can now be used in ways just like nn.Linear() ornn.Dropout() . In[53]: class BuildingBlock(nn.Module): def __init__(self, in_channels, out_channels): super(BuildingBlock, self).__init__() self.conv = nn.Conv2d(in_channels=in_channels, out_channels=out_channels, kernel_size=(3,3), padding= 'same') self.activation = nn.ReLU() self.pool = nn.MaxPool2d(kernel_size=(2,2)) def forward(self, x): return self.pool(self.activation(self.conv(x))) Notice that we used the padding = \"same\" argument to nn.Conv2d() , which ensures that the output channels have the same dimension as the input channels. There are 32 channels in the first hidden layer, in contrast to the three", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 503, "start_word": 160960, "end_word": 161360, "chunk_words": 400}}, "ISLP_website::c000504": {"text": "user-defined module can now be used in ways just like nn.Linear() ornn.Dropout() . In[53]: class BuildingBlock(nn.Module): def __init__(self, in_channels, out_channels): super(BuildingBlock, self).__init__() self.conv = nn.Conv2d(in_channels=in_channels, out_channels=out_channels, kernel_size=(3,3), padding= 'same') self.activation = nn.ReLU() self.pool = nn.MaxPool2d(kernel_size=(2,2)) def forward(self, x): return self.pool(self.activation(self.conv(x))) Notice that we used the padding = \"same\" argument to nn.Conv2d() , which ensures that the output channels have the same dimension as the input channels. There are 32 channels in the first hidden layer, in contrast to the three channels in the input layer. We use a 3×3convolution fil- ter for each channel in all the layers. Each convolution is followed by a max-pooling layer over 2×2blocks. In forming our deep learning model for the CIFAR100 data, we use several of ourBuildingBlock() modules sequentially. This simple example illus- trates some of the power of torch. Users can define modules of their own, 450 10. Deep Learningwhich can be combined in other modules. Ultimately, everything is fit bya generic trainer.In[54]:class CIFARModel(nn.Module):def __init__(self):super(CIFARModel, self).__init__()sizes = [(3,32),(32,64),(64,128),(128,256)]self.conv = nn.Sequential(*[BuildingBlock(in_, out_)for in_, out_ in sizes])self.output = nn.Sequential(nn.Dropout(0.5),nn.Linear(2*2*256, 512),nn.ReLU(),nn.Linear(512, 100))def forward(self, x):val = self.conv(x)val = torch.flatten(val, start_dim=1)return self.output(val)We build the model and look at the summary. (We had created examplesofX_earlier.)In[55]:cifar_model = CIFARModel()summary(cifar_model,input_data=X_,col_names=['input_size','output_size','num_params'])Out[55]:======================================================================Layer (type:depth-idx) Input Shape Output Shape Param#======================================================================CIFARModel[128, 3, 32, 32] [128, 100]--Sequential: 1-1 [128, 3, 32, 32] [128, 256, 2, 2] --BuildingBlock: 2-1 [128, 3, 32, 32] [128, 32, 16, 16] --Conv2d: 3-1 [128, 3, 32, 32] [128, 32, 32, 32] 896ReLU: 3-2 [128, 32, 32, 32] [128, 32, 32, 32] --MaxPool2d: 3-3 [128, 32, 32, 32] [128, 32, 16, 16] --BuildingBlock: 2-2 [128, 32, 16, 16] [128, 64, 8, 8] --Conv2d: 3-4 [128, 32, 16, 16] [128, 64, 16, 16] 18,496ReLU: 3-5 [128, 64, 16, 16] [128, 64, 16, 16] --MaxPool2d: 3-6 [128, 64, 16, 16] [128, 64, 8, 8] --BuildingBlock: 2-3 [128, 64, 8, 8] [128, 128, 4, 4] --Conv2d: 3-7 [128, 64, 8, 8] [128, 128, 8, 8] 73,856ReLU: 3-8 [128, 128, 8, 8] [128, 128, 8, 8] --MaxPool2d: 3-9 [128, 128, 8, 8] [128, 128, 4, 4] --BuildingBlock: 2-4 [128, 128, 4, 4] [128, 256, 2, 2] --Conv2d: 3-10 [128, 128, 4, 4] [128, 256, 4, 4] 295,168ReLU: 3-11 [128, 256, 4, 4] [128, 256, 4, 4] --MaxPool2d: 3-12 [128, 256, 4, 4] [128, 256, 2, 2] --Sequential: 1-2 [128, 1024] [128, 100]--Dropout: 2-5 [128, 1024] [128, 1024] --Linear: 2-6 [128, 1024] [128, 512]524,800 10.9 Lab: Deep Learning 451ReLU:", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 504, "start_word": 161280, "end_word": 161680, "chunk_words": 400}}, "ISLP_website::c000505": {"text": "[128, 128, 8, 8] [128, 128, 8, 8] --MaxPool2d: 3-9 [128, 128, 8, 8] [128, 128, 4, 4] --BuildingBlock: 2-4 [128, 128, 4, 4] [128, 256, 2, 2] --Conv2d: 3-10 [128, 128, 4, 4] [128, 256, 4, 4] 295,168ReLU: 3-11 [128, 256, 4, 4] [128, 256, 4, 4] --MaxPool2d: 3-12 [128, 256, 4, 4] [128, 256, 2, 2] --Sequential: 1-2 [128, 1024] [128, 100]--Dropout: 2-5 [128, 1024] [128, 1024] --Linear: 2-6 [128, 1024] [128, 512]524,800 10.9 Lab: Deep Learning 451ReLU: 2-7 [128, 512][128, 512]--Linear: 2-8 [128, 512][128, 100]51,300======================================================================Total params: 964,516Trainable params: 964,516The total number of trainable parameters is 964,516. By studying the sizeof the parameters, we can see that the channels halve in both dimensionsafter each of these max-pooling operations. After the last of these we havea layer with 256 channels of dimension2×2. These are then flattened toa dense layer of size 1,024; in other words, each of the2×2matrices isturned into a4-vector, and put side-by-side in one layer. This is followedby a dropout regularization layer, then another dense layer of size 512, andfinally, the output layer.Uptonow,wehavebeenusingadefaultoptimizerinSimpleModule().Forthese data, experiments show that a smaller learning rate performs betterthan the default 0.01. We use a custom optimizer here with a learning rateof 0.001. Besides this, the logging and training follow a similar patternto our previous examples. The optimizer takes an argumentparamsthatinforms the optimizer which parameters are involved in SGD (stochasticgradient descent).We saw earlier that entries of a module’s parameters are tensors. Inpassing the parameters to the optimizer we are doing more than simplypassing arrays; part of the structure of the graph is encoded in the tensorsthemselves.In[56]:cifar_optimizer = RMSprop(cifar_model.parameters(), lr=0.001)cifar_module = SimpleModule.classification(cifar_model,optimizer=cifar_optimizer)cifar_logger = CSVLogger('logs',n a m e ='CIFAR100')In[57]:cifar_trainer = Trainer(deterministic=True,max_epochs=30,logger=cifar_logger,callbacks=[ErrorTracker()])cifar_trainer.fit(cifar_module,datamodule=cifar_dm)This model takes 10 minutes or more to run and achieves about 42%accuracy on the test data. Although this is not terrible for 100-class data(a random classifier gets 1% accuracy), searching the web we see resultsaround 75%. Typically it takes a lot of architecture carpentry, fiddling withregularization, and time, to achieve such results.Let’s take a look at the validation and training accuracy across epochs.In[58]:log_path = cifar_logger.experiment.metrics_file_pathcifar_results = pd.read_csv(log_path)fig, ax = subplots(1, 1, figsize=(6, 6))summary_plot(cifar_results,ax,col='accuracy',ylabel='Accuracy')ax.set_xticks(np.linspace(0, 10, 6).astype(int))ax.set_ylabel('Accuracy')ax.set_ylim([0, 1]); 452 10. Deep Learning Finally, we evaluate our model on our test data. In[59]: cifar_trainer.test(cifar_module, datamodule=cifar_dm) Out[59]: [{'test_loss' :2 . 4 2 3 8 'test_accuracy' :0 . 4 2 0 6 } ] Hardware Acceleration As deep learning has become ubiquitous in machine learning, hardware manufacturers have produced", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 505, "start_word": 161600, "end_word": 162000, "chunk_words": 400}}, "ISLP_website::c000506": {"text": "fiddling withregularization, and time, to achieve such results.Let’s take a look at the validation and training accuracy across epochs.In[58]:log_path = cifar_logger.experiment.metrics_file_pathcifar_results = pd.read_csv(log_path)fig, ax = subplots(1, 1, figsize=(6, 6))summary_plot(cifar_results,ax,col='accuracy',ylabel='Accuracy')ax.set_xticks(np.linspace(0, 10, 6).astype(int))ax.set_ylabel('Accuracy')ax.set_ylim([0, 1]); 452 10. Deep Learning Finally, we evaluate our model on our test data. In[59]: cifar_trainer.test(cifar_module, datamodule=cifar_dm) Out[59]: [{'test_loss' :2 . 4 2 3 8 'test_accuracy' :0 . 4 2 0 6 } ] Hardware Acceleration As deep learning has become ubiquitous in machine learning, hardware manufacturers have produced special libraries that can often speed up the gradient-descent steps. For instance, Mac OS devices with the M1 chip may have the Metalpro- gramming framework enabled, which can speed up the torchcomputations. We present an example of how to use this acceleration. The main changes are to the Trainer() call as well as to the metrics that will be evaluated on the data. These metrics must be told where the data will be located at evaluation time. This is accomplished with a call to the to()method of the metrics. In[60]: try: for name, metric in cifar_module.metrics.items(): cifar_module.metrics[name] = metric.to( 'mps') cifar_trainer_mps = Trainer(accelerator= 'mps', deterministic=True, max_epochs=30) cifar_trainer_mps.fit(cifar_module, datamodule=cifar_dm) cifar_trainer_mps.test(cifar_module, datamodule=cifar_dm) except: pass This yields approximately two- or three-fold acceleration for each epoch. We have protected this code block using try:andexcept: clauses; if it works, we get the speedup, if it fails, nothing happens. 10.9.4 Using Pretrained CNN Models We now show how to use a CNN pretrained on the imagenet database to classify natural images, and demonstrate how we produced Figure 10.10. We copied six JPEG images from a digital photo album into the direc- torybook_images . These images are available from the data section of www. statlearning.com , the ISLP book website. Download book_images.zip ; when clicked it creates the book_images directory. The pretrained network we use is called resnet50 ; specification details can be found on the web. We will read in the images, and convert them into the array format expected by the torchsoftware to match the specifications inresnet50 . The conversion involves a resize, a crop and then a predefined standardization for each of the three channels. We now read in the images and preprocess them. 10.9 Lab: Deep Learning 453 In[61]: resize = Resize((232,232)) crop = CenterCrop(224) normalize = Normalize([0.485,0.456,0.406], [0.229,0.224,0.225]) imgfiles = sorted([f for f in glob( 'book_images/*' )]) imgs = torch.stack([torch.div(crop(resize(read_image(f))), 255) for f in imgfiles]) imgs = normalize(imgs) imgs.size() Out[61]: torch.Size([6, 3,", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 506, "start_word": 161920, "end_word": 162320, "chunk_words": 400}}, "ISLP_website::c000507": {"text": "the array format expected by the torchsoftware to match the specifications inresnet50 . The conversion involves a resize, a crop and then a predefined standardization for each of the three channels. We now read in the images and preprocess them. 10.9 Lab: Deep Learning 453 In[61]: resize = Resize((232,232)) crop = CenterCrop(224) normalize = Normalize([0.485,0.456,0.406], [0.229,0.224,0.225]) imgfiles = sorted([f for f in glob( 'book_images/*' )]) imgs = torch.stack([torch.div(crop(resize(read_image(f))), 255) for f in imgfiles]) imgs = normalize(imgs) imgs.size() Out[61]: torch.Size([6, 3, 224, 224]) We now set up the trained network with the weights we read in code block 6. The model has 50 layers, with a fair bit of complexity. In[62]: resnet_model = resnet50(weights=ResNet50_Weights.DEFAULT) summary(resnet_model, input_data=imgs, col_names=[ 'input_size' , 'output_size' , 'num_params' ]) We set the mode to eval()to ensure that the model is ready to predict on new data. In[63]: resnet_model.eval() Inspecting the output above, we see that when setting up the resnet_model , the authors defined a Bottleneck , much like our BuildingBlock module. We now feed our six images through the fitted network. In[64]: img_preds = resnet_model(imgs) Let’s look at the predicted probabilities for each of the top 3 choices. First we compute the probabilities by applying the softmax to the logits inimg_preds . Note that we have had to call the detach() method on the tensorimg_preds in order to convert it to our a more familiar ndarray. In[65]: img_probs = np.exp(np.asarray(img_preds.detach())) img_probs /= img_probs.sum(1)[:,None] Inordertoseetheclasslabels,wemustdownloadtheindexfileassociated withimagenet .27 In[66]: labs = json.load(open( 'imagenet_class_index.json' )) class_labels = pd.DataFrame([(int(k), v[1]) for k, v in labs.items()], columns=[ 'idx','label' ]) class_labels = class_labels.set_index( 'idx') class_labels = class_labels.sort_index() We’ll now construct a data frame for each image file with the labels with the three highest probabilities as estimated by the model above. 27This is avalable from the book website and s3.amazonaws.com/deep-learning- models/image-models/imagenet_class_index.json . 454 10. Deep Learning In[67]: for i, imgfile in enumerate(imgfiles): img_df = class_labels.copy() img_df[ 'prob']=i m g _ p r o b s [ i ] img_df = img_df.sort_values(by= 'prob',a s c e n d i n g = F a l s e ) [ : 3 ] print(f 'Image: {imgfile}' ) print(img_df.reset_index().drop(columns=[ 'idx'])) Image: book_images/Cape_Weaver.jpg label prob 0j a c a m a r 0 . 2 8 7 2 8 3 1b e e _ e a t e r0 . 0 4 6 7 6 8 2b u l b u l 0 . 0 3", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 507, "start_word": 162240, "end_word": 162640, "chunk_words": 400}}, "ISLP_website::c000508": {"text": "o b s [ i ] img_df = img_df.sort_values(by= 'prob',a s c e n d i n g = F a l s e ) [ : 3 ] print(f 'Image: {imgfile}' ) print(img_df.reset_index().drop(columns=[ 'idx'])) Image: book_images/Cape_Weaver.jpg label prob 0j a c a m a r 0 . 2 8 7 2 8 3 1b e e _ e a t e r0 . 0 4 6 7 6 8 2b u l b u l 0 . 0 3 7 5 0 7 Image: book_images/Flamingo.jpg label prob 0f l a m i n g o 0 . 5 9 1 7 6 1 1s p o o n b i l l 0 . 0 1 2 3 8 6 2A m e r i c a n _ e g r e t0 . 0 0 2 1 0 5 Image: book_images/Hawk_Fountain.jpg label prob 0g r e a t _ g r e y _ o w l0 . 2 8 7 9 5 9 1 kite 0.039478 2f o u n t a i n 0 . 0 2 9 3 8 4 Image: book_images/Hawk_cropped.jpg label prob 0k i t e 0 . 3 0 1 8 3 0 1j a y 0 . 1 2 1 6 7 4 2m a g p i e0 . 0 1 5 5 1 3 Image: book_images/Lhasa_Apso.jpg label prob 0 Lhasa 0.151143 1 Shih-Tzu 0.129850 2T i b e t a n _ t e r r i e r0 . 1 0 2 3 5 8 Image: book_images/Sleeping_Cat.jpg label prob 0t a b b y 0 . 1 7 3 6 2 7 1t i g e r _ c a t0 . 1 1 0 4 1 4 2d o o r m a t 0 . 0 9 3 4 4 7 We see that the model is quite confident about Flamingo.jpg , but a little less so for the other images. We end this section with our usual cleanup. In[68]: del(cifar_test, cifar_train, cifar_dm, cifar_module, cifar_logger, cifar_optimizer, cifar_trainer) 10.9.5 IMDB Document Classification We now implement models for sentiment classification (Section 10.4) on theIMDBdataset. As mentioned above code block 8, we are using a prepro- cessed version of the IMDBdataset found in the keraspackage. As kerasuses 10.9 Lab: Deep Learning 455tensorflow, a different tensor and deep learning library, we have convertedthe data to be suitable fortorch. The", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 508, "start_word": 162560, "end_word": 162960, "chunk_words": 400}}, "ISLP_website::c000509": {"text": "less so for the other images. We end this section with our usual cleanup. In[68]: del(cifar_test, cifar_train, cifar_dm, cifar_module, cifar_logger, cifar_optimizer, cifar_trainer) 10.9.5 IMDB Document Classification We now implement models for sentiment classification (Section 10.4) on theIMDBdataset. As mentioned above code block 8, we are using a prepro- cessed version of the IMDBdataset found in the keraspackage. As kerasuses 10.9 Lab: Deep Learning 455tensorflow, a different tensor and deep learning library, we have convertedthe data to be suitable fortorch. The code used to convert fromkerasis available in the moduleISLP.torch._make_imdb. It requires some of thekeraspackages to run. These data use a dictionary of size 10,000.We have stored three different representations of the review data for thislab:•load_tensor(), a sparse tensor version usable bytorch;•load_sparse(), a sparse matrix version usable bysklearn, since wewill compare with a lasso fit;•load_sequential(), a padded version of the original sequence repre-sentation, limited to the last 500 words of each review.In[69]:(imdb_seq_train,imdb_seq_test) = load_sequential(root='data/IMDB')padded_sample = np.asarray(imdb_seq_train.tensors[0][0])sample_review = padded_sample[padded_sample > 0][:12]sample_review[:12]Out[69]:array([ 1, 14, 22, 16, 43, 530, 973, 1622, 1385,65, 458, 4468], dtype=int32)The datasetsimdb_seq_trainandimdb_seq_testare both instances of theclassTensorDataset. The tensors used to construct them can be found inthetensorsattribute, with the first tensor the featuresXand the secondthe outcomeY. We have taken the first row of features and stored it aspadded_sample. In the preprocessing used to form these data, sequenceswere padded with 0s in the beginning if they were not long enough, hencewe remove this padding by restricting to entries wherepadded_sample > 0.We then provide the first 12 words of the sample review.WecanfindthesewordsinthelookupdictionaryfromtheISLP.torch.imdbmodule.In[70]:lookup = load_lookup(root='data/IMDB')''.join(lookup[i] for i in sample_review)Out[70]:\"<START> this film was just brilliant casting location scenerystory direction everyone's\"For our first model, we have created a binary feature for each of the10,000 possible words in the dataset, with an entry of one in thei, jentryifwordjappearsinreviewi.Asmostreviewsarequiteshort,suchafeaturematrix has over 98% zeros. These data are accessed usingload_tensor()from theISLPlibrary.In[71]:max_num_workers=10(imdb_train,imdb_test) = load_tensor(root='data/IMDB')imdb_dm = SimpleDataModule(imdb_train,imdb_test,validation=2000,num_workers=min(6, max_num_workers),batch_size=512) 456 10. Deep Learning We’ll use a two-layer model for our first model. In[72]: class IMDBModel(nn.Module): def __init__(self, input_size): super(IMDBModel, self).__init__() self.dense1 = nn.Linear(input_size, 16) self.activation = nn.ReLU() self.dense2 = nn.Linear(16, 16) self.output = nn.Linear(16, 1) def forward(self, x): val = x for _map in [self.dense1, self.activation, self.dense2, self.activation, self.output]: val = _map(val) return torch.flatten(val) We now instantiate our model and look at a summary (not shown). In[73]: imdb_model = IMDBModel(imdb_test.tensors[0].size()[1]) summary(imdb_model, input_size=imdb_test.tensors[0].size(), col_names=[ 'input_size' , 'output_size' , 'num_params' ]) We’ll again use a smaller learning rate for these data, hence we pass an", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 509, "start_word": 162880, "end_word": 163280, "chunk_words": 400}}, "ISLP_website::c000510": {"text": "class IMDBModel(nn.Module): def __init__(self, input_size): super(IMDBModel, self).__init__() self.dense1 = nn.Linear(input_size, 16) self.activation = nn.ReLU() self.dense2 = nn.Linear(16, 16) self.output = nn.Linear(16, 1) def forward(self, x): val = x for _map in [self.dense1, self.activation, self.dense2, self.activation, self.output]: val = _map(val) return torch.flatten(val) We now instantiate our model and look at a summary (not shown). In[73]: imdb_model = IMDBModel(imdb_test.tensors[0].size()[1]) summary(imdb_model, input_size=imdb_test.tensors[0].size(), col_names=[ 'input_size' , 'output_size' , 'num_params' ]) We’ll again use a smaller learning rate for these data, hence we pass an optimizer to theSimpleModule . Since the reviews are classified into positive or negative sentiment, we use SimpleModule.binary_classification() .28 In[74]: imdb_optimizer = RMSprop(imdb_model.parameters(), lr=0.001) imdb_module = SimpleModule.binary_classification( imdb_model, optimizer=imdb_optimizer) Havingloadedthedatasetsintoadatamoduleandcreateda SimpleModule , the remaining steps are familiar. In[75]: imdb_logger = CSVLogger( 'logs',n a m e = 'IMDB') imdb_trainer = Trainer(deterministic=True, max_epochs=30, logger=imdb_logger, callbacks=[ErrorTracker()]) imdb_trainer.fit(imdb_module, datamodule=imdb_dm) Evaluating the test error yields roughly 86% accuracy. In[76]: test_results = imdb_trainer.test(imdb_module, datamodule=imdb_dm) test_results 28Our use of binary_classification() instead of classification() is due to some subtlety in how torchmetrics.Accuracy() works, as well as the data type of the targets. 10.9 Lab: Deep Learning 457 Out[76]: [{'test_loss' :1 . 0 8 6 3 , 'test_accuracy' :0 . 8 5 5 0 } ] Comparison to Lasso We now fit a lasso logistic regression model using LogisticRegression() fromsklearn. Sincesklearndoes not recognize the sparse tensors of torch, we use a sparse matrix that is recognized by sklearn. In[77]: ((X_train, Y_train), (X_valid, Y_valid), (X_test, Y_test)) = load_sparse(validation=2000, random_state=0, root='data/IMDB' ) Similar to what we did in Section 10.9.1, we construct a series of 50 values for the lasso reguralization parameter λ. In[78]: lam_max = np.abs(X_train.T * (Y_train - Y_train.mean())).max() lam_val = lam_max * np.exp(np.linspace(np.log(1), np.log(1e-4), 50)) WithLogisticRegression() the regularization parameter Cis specified as the inverse of λ. There are several solvers for logistic regression; here we useliblinear which works well with the sparse input format. In[79]: logit = LogisticRegression(penalty= 'l1', C=1/lam_max, solver= 'liblinear' , warm_start=True, fit_intercept=True) The path of 50 values takes approximately 40 seconds to run. In[80]: coefs = [] intercepts = [] for l in lam_val: logit.C = 1/l logit.fit(X_train, Y_train) coefs.append(logit.coef_.copy()) intercepts.append(logit.intercept_) The coefficient and intercepts have an extraneous dimension which can be removed by the np.squeeze() function. In[81]: coefs = np.squeeze(coefs) intercepts = np.squeeze(intercepts) We’ll now make a plot to compare our neural network results with the lasso. In[82]: %%capture fig, axes = subplots(1, 2, figsize=(16, 8), sharey=True) for ((X_, Y_), data_, color) in zip([(X_train, Y_train),", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 510, "start_word": 163200, "end_word": 163600, "chunk_words": 400}}, "ISLP_website::c000511": {"text": "values takes approximately 40 seconds to run. In[80]: coefs = [] intercepts = [] for l in lam_val: logit.C = 1/l logit.fit(X_train, Y_train) coefs.append(logit.coef_.copy()) intercepts.append(logit.intercept_) The coefficient and intercepts have an extraneous dimension which can be removed by the np.squeeze() function. In[81]: coefs = np.squeeze(coefs) intercepts = np.squeeze(intercepts) We’ll now make a plot to compare our neural network results with the lasso. In[82]: %%capture fig, axes = subplots(1, 2, figsize=(16, 8), sharey=True) for ((X_, Y_), data_, color) in zip([(X_train, Y_train), (X_valid, Y_valid), (X_test, Y_test)], 458 10. Deep Learning ['Training' ,'Validation' ,'Test'], ['black' ,'red','blue']): linpred_ = X_ * coefs.T + intercepts[None,:] label_ = np.array(linpred_ > 0) accuracy_ = np.array([np.mean(Y_ == l) for l in label_.T]) axes[0].plot(-np.log(lam_val / X_train.shape[0]), accuracy_, '.--', color=color, markersize=13, linewidth=2, label=data_) axes[0].legend() axes[0].set_xlabel( r'$-\\log(\\lambda)$' ,f o n t s i z e = 2 0 ) axes[0].set_ylabel( 'Accuracy' ,f o n t s i z e = 2 0 ) Noticethe useof %%capture ,whichsuppressesthe displayingof thepartially%%capturecompleted figure. This is useful when making a complex figure, since the steps can be spread across two or more cells. We now add a plot of the lasso accuracy, and display the composed figure by simply entering its name at the end of the cell. In[83]: imdb_results = pd.read_csv(imdb_logger.experiment.metrics_file_path) summary_plot(imdb_results, axes[1], col='accuracy' , ylabel= 'Accuracy' ) axes[1].set_xticks(np.linspace(0, 30, 7).astype(int)) axes[1].set_ylabel( 'Accuracy' ,f o n t s i z e = 2 0 ) axes[1].set_xlabel( 'Epoch' ,f o n t s i z e = 2 0 ) axes[1].set_ylim([0.5, 1]); axes[1].axhline(test_results[0][ 'test_accuracy' ], color='blue', linestyle= '--', linewidth=3) fig From the graphs we see that the accuracy of the lasso logistic regression peaks at about 0.88, as it does for the neural network. Once again, we end with a cleanup. In[84]: del(imdb_model, imdb_trainer, imdb_logger, imdb_dm, imdb_train, imdb_test) 10.9.6 Recurrent Neural Networks In this lab we fit the models illustrated in Section 10.5. Sequential Models for Document Classification Here we fit a simple LSTM RNN for sentiment prediction to the IMDb movie-review data, as discussed in Section 10.5.1. For an RNN we use 10.9 Lab: Deep Learning 459 the sequence of words in a document, taking their order into account. We loaded the preprocessed data at the beginning of Section 10.9.5. A script that details the preprocessing can be found in the ISLPlibrary. Notably, since more than 90% of the documents had fewer than 500 words, we set the document length to 500. For longer", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 511, "start_word": 163520, "end_word": 163920, "chunk_words": 400}}, "ISLP_website::c000512": {"text": "for sentiment prediction to the IMDb movie-review data, as discussed in Section 10.5.1. For an RNN we use 10.9 Lab: Deep Learning 459 the sequence of words in a document, taking their order into account. We loaded the preprocessed data at the beginning of Section 10.9.5. A script that details the preprocessing can be found in the ISLPlibrary. Notably, since more than 90% of the documents had fewer than 500 words, we set the document length to 500. For longer documents, we used the last 500 words, and for shorter documents, we padded the front with blanks. In[85]: imdb_seq_dm = SimpleDataModule(imdb_seq_train, imdb_seq_test, validation=2000, batch_size=300, num_workers=min(6, max_num_workers) ) The first layer of the RNN is an embedding layer of size 32, which will be learned during training. This layer one-hot encodes each document as a matrix of dimension 500×10,003, and then maps these 10,003dimensions downto32.29Sinceeachwordisrepresentedbyaninteger,thisiseffectively achieved by the creation of an embedding matrix of size 10,003×32; each of the 500 integers in the document are then mapped to the appropriate 32 real numbers by indexing the appropriate rows of this matrix. The second layer is an LSTM with 32 units, and the output layer is a singlelogitforthebinaryclassificationtask.Inthelastlineofthe forward() method below, we take the last 32-dimensional output of the LSTM and map it to our response. In[86]: class LSTMModel(nn.Module): def __init__(self, input_size): super(LSTMModel, self).__init__() self.embedding = nn.Embedding(input_size, 32) self.lstm = nn.LSTM(input_size=32, hidden_size=32, batch_first=True) self.dense = nn.Linear(32, 1) def forward(self, x): val, (h_n, c_n) = self.lstm(self.embedding(x)) return torch.flatten(self.dense(val[:,-1])) We instantiate and take a look at the summary of the model, using the first 10 documents in the corpus. In[87]: lstm_model = LSTMModel(X_test.shape[-1]) summary(lstm_model, input_data=imdb_seq_train.tensors[0][:10], col_names=[ 'input_size' , 'output_size' , 'num_params' ]) Out[87]: ==================================================================== Layer (type:depth-idx) Input Shape Output Shape Param # ==================================================================== LSTMModel [10, 500] [10] -- 29The extra 3 dimensions correspond to commonly occurring non-word entries in the reviews. 460 10. Deep Learning Embedding: 1-1 [10, 500] [10, 500, 32] 320,096 LSTM: 1-2 [10, 500, 32] [10, 500, 32] 8,448 Linear: 1-3 [10, 32] [10, 1] 33 ==================================================================== Total params: 328,577 Trainable params: 328,577 The 10,003 is suppressed in the summary, but we see it in the parameter count, since 10,003×32 = 320 ,096. In[88]: lstm_module = SimpleModule.binary_classification(lstm_model) lstm_logger = CSVLogger( 'logs',n a m e = 'IMDB_LSTM' ) In[89]: lstm_trainer = Trainer(deterministic=True, max_epochs=20, logger=lstm_logger, callbacks=[ErrorTracker()]) lstm_trainer.fit(lstm_module, datamodule=imdb_seq_dm) The rest is now similar to other networks we have fit. We track the test", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 512, "start_word": 163840, "end_word": 164240, "chunk_words": 400}}, "ISLP_website::c000513": {"text": "1-2 [10, 500, 32] [10, 500, 32] 8,448 Linear: 1-3 [10, 32] [10, 1] 33 ==================================================================== Total params: 328,577 Trainable params: 328,577 The 10,003 is suppressed in the summary, but we see it in the parameter count, since 10,003×32 = 320 ,096. In[88]: lstm_module = SimpleModule.binary_classification(lstm_model) lstm_logger = CSVLogger( 'logs',n a m e = 'IMDB_LSTM' ) In[89]: lstm_trainer = Trainer(deterministic=True, max_epochs=20, logger=lstm_logger, callbacks=[ErrorTracker()]) lstm_trainer.fit(lstm_module, datamodule=imdb_seq_dm) The rest is now similar to other networks we have fit. We track the test performance as the network is fit, and see that it attains 85% accuracy. In[90]: lstm_trainer.test(lstm_module, datamodule=imdb_seq_dm) Out[90]: [{'test_loss' :0 . 8 1 7 8 , 'test_accuracy' :0 . 8 4 7 6 } ] We once again show the learning progress, followed by cleanup. In[91]: lstm_results = pd.read_csv(lstm_logger.experiment.metrics_file_path) fig, ax = subplots(1, 1, figsize=(6, 6)) summary_plot(lstm_results, ax, col='accuracy' , ylabel= 'Accuracy' ) ax.set_xticks(np.linspace(0, 20, 5).astype(int)) ax.set_ylabel( 'Accuracy' ) ax.set_ylim([0.5, 1]) In[92]: del(lstm_model, lstm_trainer, lstm_logger, imdb_seq_dm, imdb_seq_train, imdb_seq_test) Time Series Prediction We now show how to fit the models in Section 10.5.2for time series pre- diction. We first load and standardize the data. In[93]: NYSE = load_data( 'NYSE') cols = [ 'DJ_return' ,'log_volume' ,'log_volatility' ] X=p d . D a t a F r a m e ( S t a n d a r d S c a l e r ( with_mean=True, with_std=True).fit_transform(NYSE[cols]), columns=NYSE[cols].columns, index=NYSE.index) 10.9 Lab: Deep Learning 461Next we set up the lagged versions of the data, dropping any rows withmissing values using thedropna()method.In[94]:for lag in range(1, 6):for col in cols:newcol = np.zeros(X.shape[0]) * np.nannewcol[lag:] = X[col].values[:-lag]X.insert(len(X.columns),\"{0}_{1}\".format(col, lag), newcol)X.insert(len(X.columns),'train',N Y S E ['train'])X=X . d r o p n a ( )Finally, we extract the response, training indicator, and drop the currentday’sDJ_returnandlog_volatilityto predict only from previous day’sdata.In[95]:Y, train = X['log_volume'], X['train']X=X . d r o p ( c o l u m n s = ['train']+c o l s )X.columnsOut[95]:Index(['DJ_return_1','log_volume_1','log_volatility_1','DJ_return_2','log_volume_2','log_volatility_2','DJ_return_3','log_volume_3','log_volatility_3','DJ_return_4','log_volume_4','log_volatility_4','DJ_return_5','log_volume_5','log_volatility_5'],dtype='object')We first fit a simple linear model and compute theR2on the test datausing thescore()method.In[96]:M=L i n e a r R e g r e s s i o n ( )M.fit(X[train], Y[train])M.score(X[∼train], Y[∼train])Out[96]:0.4129We refit this model, including the factor variableday_of_week. For a cate-gorical series inpandas, we can form the indicators using theget_dummies()method.In[97]:X_day = pd.merge(X,pd.get_dummies(NYSE['day_of_week']),on='date')Note that we do not have to reinstantiate the linear regression model as itsfit()method accepts a design matrix and a response directly.In[98]:M.fit(X_day[train], Y[train])M.score(X_day[∼train], Y[∼train])Out[98]:0.4595This model achieves anR2of about 46%.To fit the RNN, we must reshape", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 513, "start_word": 164160, "end_word": 164560, "chunk_words": 400}}, "ISLP_website::c000514": {"text": "compute theR2on the test datausing thescore()method.In[96]:M=L i n e a r R e g r e s s i o n ( )M.fit(X[train], Y[train])M.score(X[∼train], Y[∼train])Out[96]:0.4129We refit this model, including the factor variableday_of_week. For a cate-gorical series inpandas, we can form the indicators using theget_dummies()method.In[97]:X_day = pd.merge(X,pd.get_dummies(NYSE['day_of_week']),on='date')Note that we do not have to reinstantiate the linear regression model as itsfit()method accepts a design matrix and a response directly.In[98]:M.fit(X_day[train], Y[train])M.score(X_day[∼train], Y[∼train])Out[98]:0.4595This model achieves anR2of about 46%.To fit the RNN, we must reshape the data, as it will expect 5 laggedversions of each feature as indicated by theinput_shapeargument to thelayernn.RNN()below. We first ensure the columns of our data frame aresuch that a reshaped matrix will have the variables correctly lagged. Weuse thereindex()method to do this. 462 10. Deep LearningFor an input shape(5,3), each row represents a lagged version of thethree variables. Thenn.RNN()layer also expects the first row of each obser-vation to be earliest in time, so we must reverse the current order. Hencewe loop overrange(5,0,-1)below, which is an example of using aslice()to index iterable objects. The general notation isstart:end:step.In[99]:ordered_cols = []for lag in range(5,0,-1):for col in cols:ordered_cols.append('{0}_{1}'.format(col, lag))X=X . r e i n d e x ( c o l u m n s = o r d e r e d _ c o l s )X.columnsOut[99]:Index(['DJ_return_5','log_volume_5','log_volatility_5','DJ_return_4','log_volume_4','log_volatility_4','DJ_return_3','log_volume_3','log_volatility_3','DJ_return_2','log_volume_2','log_volatility_2','DJ_return_1','log_volume_1','log_volatility_1'],dtype='object')We now reshape the data.In[100]:X_rnn = X.to_numpy().reshape((-1,5,3))X_rnn.shapeOut[100]:(6046, 5, 3)By specifying the first size as -1,numpy.reshape()deduces its size based onthe remaining arguments.Now we are ready to proceed with the RNN, which uses 12 hidden units,and 10% dropout. After passing through the RNN, we extract the finaltime point asval[:,-1]inforward()below. This gets passed through a10% dropout and then flattened through a linear layer.In[101]:class NYSEModel(nn.Module):def __init__(self):super(NYSEModel, self).__init__()self.rnn = nn.RNN(3,12,batch_first=True)self.dense = nn.Linear(12, 1)self.dropout = nn.Dropout(0.1)def forward(self, x):val, h_n = self.rnn(x)val = self.dense(self.dropout(val[:,-1]))return torch.flatten(val)nyse_model = NYSEModel()We fit the model in a similar fashion to previous networks. We supplythefitfunction with test data as validation data, so that when we monitorits progress and plot the history function we can see the progress on thetest data. Of course we should not use this as a basis for early stopping,since then the test performance would be biased.We form the training dataset similar to ourHittersexample. 10.9 Lab: Deep Learning 463In[102]:datasets = []for mask in [train,∼train]:X_rnn_t = torch.tensor(X_rnn[mask].astype(np.float32))Y_t = torch.tensor(Y[mask].astype(np.float32))datasets.append(TensorDataset(X_rnn_t, Y_t))nyse_train, nyse_test = datasetsFollowing our usual pattern, we inspect the summary.In[103]:summary(nyse_model,input_data=X_rnn_t,col_names=['input_size','output_size','num_params'])Out[103]:====================================================================Layer (type:depth-idx) Input Shape Output Shape Param#====================================================================NYSEModel[1770, 5, 3] [1770]--RNN: 1-1[1770, 5, 3] [1770, 5, 12] 204Dropout: 1-2[1770,", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 514, "start_word": 164480, "end_word": 164880, "chunk_words": 400}}, "ISLP_website::c000515": {"text": "the history function we can see the progress on thetest data. Of course we should not use this as a basis for early stopping,since then the test performance would be biased.We form the training dataset similar to ourHittersexample. 10.9 Lab: Deep Learning 463In[102]:datasets = []for mask in [train,∼train]:X_rnn_t = torch.tensor(X_rnn[mask].astype(np.float32))Y_t = torch.tensor(Y[mask].astype(np.float32))datasets.append(TensorDataset(X_rnn_t, Y_t))nyse_train, nyse_test = datasetsFollowing our usual pattern, we inspect the summary.In[103]:summary(nyse_model,input_data=X_rnn_t,col_names=['input_size','output_size','num_params'])Out[103]:====================================================================Layer (type:depth-idx) Input Shape Output Shape Param#====================================================================NYSEModel[1770, 5, 3] [1770]--RNN: 1-1[1770, 5, 3] [1770, 5, 12] 204Dropout: 1-2[1770, 12] [1770, 12] --Linear: 1-3[1770, 12] [1770, 1] 13====================================================================Total params: 217Trainable params: 217We again put the two datasets into a data module, with a batch size of 64.In[104]:nyse_dm = SimpleDataModule(nyse_train,nyse_test,num_workers=min(4, max_num_workers),validation=nyse_test,batch_size=64)We run some data through our model to be sure the sizes match up cor-rectly.In[105]:for idx, (x, y) in enumerate(nyse_dm.train_dataloader()):out = nyse_model(x)print(y.size(), out.size())if idx >= 2:breaktorch.Size([64]) torch.Size([64])torch.Size([64]) torch.Size([64])torch.Size([64]) torch.Size([64])We follow our previous example for setting up a trainer for a regressionproblem, requesting theR2metric to be be computed at each epoch.In[106]:nyse_optimizer = RMSprop(nyse_model.parameters(),lr=0.001)nyse_module = SimpleModule.regression(nyse_model,optimizer=nyse_optimizer,metrics={'r2':R2Score()})Fitting the model should by now be familiar. The results on the test dataare very similar to the linear AR model. 464 10. Deep LearningIn[107]:nyse_trainer = Trainer(deterministic=True,max_epochs=200,callbacks=[ErrorTracker()])nyse_trainer.fit(nyse_module,datamodule=nyse_dm)nyse_trainer.test(nyse_module,datamodule=nyse_dm)Out[107]:[{'test_loss':0 . 6 1 4 1 ,'test_r2':0 . 4 1 7 2 } ]We could also fit a model without thenn.RNN()layer by just using ann.Flatten()layer instead. This would be a nonlinear AR model. If inaddition we excluded the hidden layer, this would be equivalent to ourearlier linear AR model.Instead we will fit a nonlinear AR model using the feature setX_daythatincludes theday_of_weekindicators. To do so, we must first create our testand training datasets and a corresponding data module. This may seem alittle burdensome, but is part of the general pipeline fortorch.In[108]:datasets = []for mask in [train,∼train]:X_day_t = torch.tensor(np.asarray(X_day[mask]).astype(np.float32))Y_t = torch.tensor(np.asarray(Y[mask]).astype(np.float32))datasets.append(TensorDataset(X_day_t, Y_t))day_train, day_test = datasetsCreating a data module follows a familiar pattern.In[109]:day_dm = SimpleDataModule(day_train,day_test,num_workers=min(4, max_num_workers),validation=day_test,batch_size=64)We build aNonLinearARModel()that takes as input the 20 features anda hidden layer with 32 units. The remaining steps are familiar.In[110]:class NonLinearARModel(nn.Module):def __init__(self):super(NonLinearARModel, self).__init__()self._forward = nn.Sequential(nn.Flatten(),nn.Linear(20, 32),nn.ReLU(),nn.Dropout(0.5),nn.Linear(32, 1))def forward(self, x):return torch.flatten(self._forward(x))In[111]:nl_model = NonLinearARModel()nl_optimizer = RMSprop(nl_model.parameters(),lr=0.001)nl_module = SimpleModule.regression(nl_model,optimizer=nl_optimizer,metrics={'r2':R2Score()}) 10.10 Exercises 465 We continue with the usual training steps, fit the model, and evaluate the test error. We see the test R2is a slight improvement over the linear AR model that also includes day_of_week . In[112]: nl_trainer = Trainer(deterministic=True, max_epochs=20, callbacks=[ErrorTracker()]) nl_trainer.fit(nl_module, datamodule=day_dm) nl_trainer.test(nl_module, datamodule=day_dm) Out[112]: [{'test_loss' :0 . 5 6 2 5 , 'test_r2' :0 . 4 6 6 2 }", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 515, "start_word": 164800, "end_word": 165200, "chunk_words": 400}}, "ISLP_website::c000516": {"text": "familiar.In[110]:class NonLinearARModel(nn.Module):def __init__(self):super(NonLinearARModel, self).__init__()self._forward = nn.Sequential(nn.Flatten(),nn.Linear(20, 32),nn.ReLU(),nn.Dropout(0.5),nn.Linear(32, 1))def forward(self, x):return torch.flatten(self._forward(x))In[111]:nl_model = NonLinearARModel()nl_optimizer = RMSprop(nl_model.parameters(),lr=0.001)nl_module = SimpleModule.regression(nl_model,optimizer=nl_optimizer,metrics={'r2':R2Score()}) 10.10 Exercises 465 We continue with the usual training steps, fit the model, and evaluate the test error. We see the test R2is a slight improvement over the linear AR model that also includes day_of_week . In[112]: nl_trainer = Trainer(deterministic=True, max_epochs=20, callbacks=[ErrorTracker()]) nl_trainer.fit(nl_module, datamodule=day_dm) nl_trainer.test(nl_module, datamodule=day_dm) Out[112]: [{'test_loss' :0 . 5 6 2 5 , 'test_r2' :0 . 4 6 6 2 } ] 10.10 Exercises Conceptual 1. Consider a neural network with two hidden layers: p=4input units, 2units in the first hidden layer, 3units in the second hidden layer, and a single output. (a) Draw a picture of the network, similar to Figures 10.1or10.4. (b) Write out an expression for f(X), assuming ReLU activation functions. Be as explicit as you can! (c) Now plug in some values for the coefficients and write out the value off(X). (d) How many parameters are there? 2. Consider the softmaxfunction in ( 10.13) (see also ( 4.13) on page 145) for modeling multinomial probabilities. (a) In (10.13), show that if we add a constant cto each of the z/lscript, then the probability is unchanged. (b) In (4.13), show that if we add constants cj,j=0,1,...,p, to eachofthecorrespondingcoefficientsforeachoftheclasses,then the predictions at any new point xare unchanged. This shows that the softmax function is over-parametrized . However,over- parametrized regularization and SGD typically constrain the solutions so that this is not a problem. 3. Show that the negative multinomial log-likelihood ( 10.14) is equiva- lent to the negative log of the likelihood expression ( 4.5) when there areM=2classes. 4. Consider a CNN that takes in 32×32grayscale images and has a single convolution layer with three 5×5convolution filters (without boundary padding). (a) Draw a sketch of the input and first hidden layer similar to Figure10.8. 466 10. Deep Learning (b) How many parameters are in this model? (c) Explain how this model can be thought of as an ordinary feed- forward neural network with the individual pixels as inputs, and with constraints on the weights in the hidden units. What are the constraints? (d) If there were no constraints, then how many weights would there be in the ordinary feed-forward neural network in (c)? 5. In Table 10.2on page 426, we see that the ordering of the three methods with respect to mean absolute error is different from the ordering with", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 516, "start_word": 165120, "end_word": 165520, "chunk_words": 400}}, "ISLP_website::c000517": {"text": "model can be thought of as an ordinary feed- forward neural network with the individual pixels as inputs, and with constraints on the weights in the hidden units. What are the constraints? (d) If there were no constraints, then how many weights would there be in the ordinary feed-forward neural network in (c)? 5. In Table 10.2on page 426, we see that the ordering of the three methods with respect to mean absolute error is different from the ordering with respect to test set R2. How can this be? Applied 6. Consider the simple function R(β) = sin( β)+β/10. (a) Draw a graph of this function over the range β∈[−6,6]. (b) What is the derivative of this function? (c) Given β0=2.3, run gradient descent to find a local minimum ofR(β)using a learning rate of ρ=0.1. Show each of β0,β1,... in your plot, as well as the final answer. (d) Repeat with β0=1.4. 7. Fit a neural network to the Defaultdata. Use a single hidden layer with10units,anddropoutregularization.HavealookatLabs 10.9.1– 10.9.2for guidance. Compare the classification performance of your model with that of linear logistic regression. 8. From your collection of personal photographs, pick 10 images of an- imals (such as dogs, cats, birds, farm animals, etc.). If the subject does not occupy a reasonable part of the image, then crop the image. Now use a pretrained image classification CNN as in Lab 10.9.4to predict the class of each of your images, and report the probabilities for the top five predicted classes for each image. 9. Fit a lag-5 autoregressive model to the NYSEdata, as described in the text and Lab 10.9.6. Refit the model with a 12-level factor repre- senting the month. Does this factor improve the performance of the model? 10. In Section 10.9.6, we showed how to fit a linear AR model to the NYSEdata using the LinearRegression() function. However, we also mentioned that we can “flatten” the short sequences produced for the RNN model in order to fit a linear AR model. Use this latter approach to fit a linear AR model to the NYSEdata. Compare the test R2of this linear AR model to that of the linear AR model that we fit in the lab. What are the advantages/disadvantages of each approach? 11. Repeat the previous exercise, but now fit a nonlinear AR model by “flattening” the short sequences produced for the RNN model. 10.10 Exercises 467 12. Consider", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 517, "start_word": 165440, "end_word": 165840, "chunk_words": 400}}, "ISLP_website::c000518": {"text": "for the RNN model in order to fit a linear AR model. Use this latter approach to fit a linear AR model to the NYSEdata. Compare the test R2of this linear AR model to that of the linear AR model that we fit in the lab. What are the advantages/disadvantages of each approach? 11. Repeat the previous exercise, but now fit a nonlinear AR model by “flattening” the short sequences produced for the RNN model. 10.10 Exercises 467 12. Consider the RNN fit to the NYSEdata in Section 10.9.6. Modify the code to allow inclusion of the variable day_of_week , and fit the RNN. Compute the test R2. 13. Repeat the analysis of Lab 10.9.5on theIMDbdata using a similarly structured neural network. We used 16 hidden units at each of two hidden layers. Explore the effect of increasing this to 32 and 64 units per layer, with and without 30% dropout regularization. 11 Survival Analysis and Censored Data In this chapter, we will consider the topics of survival analysis andcensoredsurvival analysisdata. These arise in the analysis of a unique kind of outcome variable: the censored datatime until an event occurs . For example, suppose that we have conducted a five-year medical study, in which patients have been treated for cancer. We would like to fit a model to predict patient survival time, using features such as baseline health mea- surements or type of treatment. At first pass, this may sound like a regres- sion problem of the kind discussed in Chapter 3. But there is an important complication: hopefully some or many of the patients have survived until theendofthestudy.Suchapatient’ssurvivaltimeissaidtobe censored:w e know that it is at least five years, but we do not know its true value. We do not want to discard this subset of surviving patients, as the fact that they survived at least five years amounts to valuable information. However, it is not clear how to make use of this information using the techniques covered thus far in this textbook. Though the phrase “survival analysis” evokes a medical study, the ap- plications of survival analysis extend far beyond medicine. For example, consider a company that wishes to model churn, the process by which cus- tomers cancel subscription to a service. The company might collect data on customers over some time period, in order to model each customer’s time to cancellation as a function of demographics or other", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 518, "start_word": 165760, "end_word": 166160, "chunk_words": 400}}, "ISLP_website::c000519": {"text": "use of this information using the techniques covered thus far in this textbook. Though the phrase “survival analysis” evokes a medical study, the ap- plications of survival analysis extend far beyond medicine. For example, consider a company that wishes to model churn, the process by which cus- tomers cancel subscription to a service. The company might collect data on customers over some time period, in order to model each customer’s time to cancellation as a function of demographics or other predictors. However, presumably not all customers will have canceled their subscription by the end of this time period; for such customers, the time to cancellation is censored. In fact, survival analysis is relevant even in application areas that are unrelatedtotime.Forinstance,supposewewishtomodelaperson’sweight as a function of some covariates, using a dataset with measurements for a large number of people. Unfortunately, the scale used to weigh those people is unable to report weights above a certain number. Then, any weights that © Springer Nature Switzerland AG 2023 G. James et al., An Introduction to Statistical Learning , Springer Texts in Statistics, https://doi.org/10.1007/978-3-031-38747-0_11 469 470 11. Survival Analysis and Censored Data exceed that number are censored. The survival analysis methods presented in this chapter could be used to analyze this dataset. Survival analysis is a very well-studied topic within statistics, due to its critical importance in a variety of applications, both in and out of medicine. However, it has received relatively little attention in the machine learning community. 11.1 Survival and Censoring Times For each individual, we suppose that there is a true survival time ,T, as wellsurvival timeas a true censoring time ,C. (The survival time is also known as the failurecensoring timetimeor theevent time .) The survival time represents the time at which the failure time event timeevent of interest occurs: for instance, the time at which the patient dies, or the customer cancels his or her subscription. By contrast, the censoring time is the time at which censoring occurs: for example, the time at which the patient drops out of the study or the study ends. We observe either the survival time Tor else the censoring time C. Specifically, we observe the random variable Y=min(T,C). (11.1) In other words, if the event occurs before censoring (i.e. T<C ) then we observe the true survival time T; however, if censoring occurs before the event (T>C ) then we observe the censoring time.", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 519, "start_word": 166080, "end_word": 166480, "chunk_words": 400}}, "ISLP_website::c000520": {"text": "time is the time at which censoring occurs: for example, the time at which the patient drops out of the study or the study ends. We observe either the survival time Tor else the censoring time C. Specifically, we observe the random variable Y=min(T,C). (11.1) In other words, if the event occurs before censoring (i.e. T<C ) then we observe the true survival time T; however, if censoring occurs before the event (T>C ) then we observe the censoring time. We also observe a status indicator, δ=/braceleftBigg 1ifT≤C 0ifT>C . Thus,δ=1 if we observe the true survival time, and δ=0 if we instead observe the censoring time. Now, suppose we observe n(Y,δ)pairs, which we denote as (y1,δ1),..., (yn,δn). Figure 11.1displays an example from a (fictitious) medical study in which we observe n=4 patients for a 365-day follow-up period. For patients 1 and 3, we observe the time to event (such as death or disease relapse) T=ti. Patient 2 was alive when the study ended, and patient 4 dropped out of the study, or was “lost to follow-up”; for these patients we observeC=ci. Therefore, y1=t1,y3=t3,y2=c2,y4=c4,δ1=δ3=1, andδ2=δ4=0. 11.2 A Closer Look at Censoring In order to analyze survival data, we need to make some assumptions about whycensoringhasoccurred.Forinstance,supposethatanumberofpatients dropoutofacancerstudyearlybecausetheyareverysick.Ananalysisthat does not take into consideration the reason why the patients dropped out will likely overestimate the true average survival time. Similarly, suppose that males who are very sick are more likely to drop out of the study than 11.2 A Closer Look at Censoring 471 01002003001234Time in DaysPatient FIGURE 11.1. Illustration of censored survival data. For patients 1 and 3, the event was observed. Patient 2 was alive when the study ended. Patient 4 dropped out of the study. females who are very sick. Then a comparison of male and female survival times may wrongly suggest that males survive longer than females. In general, we need to assume that the censoring mechanism is indepen- dent: conditional on the features, the event time Tis independent of the censoring time C. The two examples above violate the assumption of inde- pendent censoring. Typically, it is not possible to determine from the data itself whether the censoring mechanism is independent. Instead, one has to carefully consider the data collection process in order to determine whether independent censoring is a reasonable assumption. In the remainder of this chapter, we will assume that the censoring mechanism is independent.1 In", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 520, "start_word": 166400, "end_word": 166800, "chunk_words": 400}}, "ISLP_website::c000521": {"text": "dent: conditional on the features, the event time Tis independent of the censoring time C. The two examples above violate the assumption of inde- pendent censoring. Typically, it is not possible to determine from the data itself whether the censoring mechanism is independent. Instead, one has to carefully consider the data collection process in order to determine whether independent censoring is a reasonable assumption. In the remainder of this chapter, we will assume that the censoring mechanism is independent.1 In this chapter, we focus on right censoring , which occurs when T≥Y, i.e. the true event time Tis at least as large as the observed time Y. (Notice that T≥Yis a consequence of ( 11.1). Right censoring derives its name from the fact that time is typically displayed from left to right, as in Figure11.1.) However, other types of censoring are possible. For instance, inleft censoring , the true event time Tis less than or equal to the observed timeY. For example, in a study of pregnancy duration, suppose that we survey patients 250 days after conception, when some have already had their babies. Then we know that for those patients, pregnancy duration is less than 250 days. More generally, interval censoring refers to the setting in which we do not know the exact event time, but we know that it falls in some interval. For instance, this setting arises if we survey patients once per week in order to determine whether the event has occurred. While left censoring and interval censoring can be accommodated using variants of the ideas presented in this chapter, in what follows we focus specifically on right censoring. 1The assumption of independent censoring can be relaxed somewhat using the notion ofnon-informative censoring ; however, the definition of non-informative censoring is too technical for this book. 472 11. Survival Analysis and Censored Data 11.3 The Kaplan–Meier Survival Curve Thesurvival curve , orsurvival function , is defined assurvival curve survival functionS(t) = Pr( T>t ). (11.2) This decreasing function quantifies the probability of surviving past time t. For example, suppose that a company is interested in modeling customer churn. Let Trepresent the time that a customer cancels a subscription to thecompany’sservice.Then S(t)representstheprobabilitythatacustomer cancels later than time t. The larger the value of S(t), the less likely that the customer will cancel before time t. In this section, we will consider the task of estimating the survival curve.", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 521, "start_word": 166720, "end_word": 167120, "chunk_words": 400}}, "ISLP_website::c000522": {"text": "assurvival curve survival functionS(t) = Pr( T>t ). (11.2) This decreasing function quantifies the probability of surviving past time t. For example, suppose that a company is interested in modeling customer churn. Let Trepresent the time that a customer cancels a subscription to thecompany’sservice.Then S(t)representstheprobabilitythatacustomer cancels later than time t. The larger the value of S(t), the less likely that the customer will cancel before time t. In this section, we will consider the task of estimating the survival curve. Our investigation is motivated by the BrainCancer dataset, which contains the survival times for patients with primary brain tumors un- dergoing treatment with stereotactic radiation methods.2The predictors aregtv(gross tumor volume, in cubic centimeters); sex(male or female); diagnosis (meningioma, LG glioma, HG glioma, or other); loc(the tumor location: either infratentorial or supratentorial); ki(Karnofsky index); and stereo(stereotactic method: either stereotactic radiosurgery or fraction- ated stereotactic radiotherapy, abbreviated as SRS and SRT, respectively). Only 53 of the 88 patients were still alive at the end of the study. Now, we consider the task of estimating the survival curve ( 11.2) for these data. To estimate S(20) = Pr( T>20), the probability that a patient survives for at least t= 20 months, it is tempting to simply compute the proportion of patients who are known to have survived past 20 months, i.e. the proportion of patients for whom Y>20. This turns out to be 48/88, or approximately 55%. However, this does not seem quite right, since Y andTrepresent different quantities. In particular, 17 of the 40 patients who did not survive to 20months were actually censored, and this analysis implicitly assumes that T<20for all of those censored patients; of course, we do not know whether that is true. Alternatively, to estimate S(20), we could consider computing the pro- portion of patients for whom Y>20, out of the 71patients who were not censored by time t= 20 ; this comes out to 48/71, or approximately 68%. However, this is not quite right either, since it amounts to completely ig- noring the patients who were censored before time t= 20 , even though the timeat which they are censored is potentially informative. For instance, a patient who was censored at time t= 19 .9likely would have survived past t= 20 had he or she not been censored. We have seen that estimating S(t)is complicated by the presence of censoring. We now present an approach to overcome", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 522, "start_word": 167040, "end_word": 167440, "chunk_words": 400}}, "ISLP_website::c000523": {"text": "68%. However, this is not quite right either, since it amounts to completely ig- noring the patients who were censored before time t= 20 , even though the timeat which they are censored is potentially informative. For instance, a patient who was censored at time t= 19 .9likely would have survived past t= 20 had he or she not been censored. We have seen that estimating S(t)is complicated by the presence of censoring. We now present an approach to overcome these challenges. We letd1<d 2<···<d Kdenote the Kunique death times among the non- censored patients, and we let qkdenote the number of patients who died at timedk. Fork=1,...,K , we letrkdenote the number of patients alive 2This dataset is described in the following paper: Selingerová et al. (2016) Survival of patients with primary brain tumors: Comparison of two statistical approaches. PLoS One, 11(2):e0148733. 11.3 The Kaplan–Meier Survival Curve 473 and in the study just before dk; these are the at riskpatients. The set of patients that are at risk at a given time are referred to as the risk set.risk setBy the law of total probability,3 Pr(T>d k) = Pr( T>d k|T>d k−1) Pr( T>d k−1) + Pr( T>d k|T≤dk−1) Pr( T≤dk−1). The fact that dk−1<d kimplies that Pr(T>d k|T≤dk−1)=0 (it is impossible for a patient to survive past time dkif he or she did not survive until an earlier time dk−1). Therefore, S(dk) = Pr( T>d k) = Pr( T>d k|T>d k−1) Pr( T>d k−1). Plugging in ( 11.2) again, we see that S(dk) = Pr( T>d k|T>d k−1)S(dk−1). This implies that S(dk) = Pr( T>d k|T>d k−1)×···×Pr(T>d 2|T>d 1) Pr( T>d 1). We now must simply plug in estimates of each of the terms on the right- hand side of the previous equation. It is natural to use the estimator /hatwiderPr(T>d j|T>d j−1)=( rj−qj)/rj, which is the fraction of the risk set at time djwho survived past time dj. This leads to the Kaplan–Meier estimator of the survival curve:Kaplan– Meier estimator/hatwideS(dk)=k/productdisplay j=1/parenleftbiggrj−qj rj/parenrightbigg . (11.3) For times tbetween dkanddk+1, we set /hatwideS(t)=/hatwideS(dk). Consequently, the Kaplan–Meier survival curve has a step-like shape. The Kaplan–Meier survival curve for the BrainCancer data is displayed in Figure 11.2. Each point in the solid step-like curve shows the estimated probability of surviving past the time indicated on the horizontal axis. The estimated probability of survival past 20 months is 71%, which is quite", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 523, "start_word": 167360, "end_word": 167760, "chunk_words": 400}}, "ISLP_website::c000524": {"text": "dj. This leads to the Kaplan–Meier estimator of the survival curve:Kaplan– Meier estimator/hatwideS(dk)=k/productdisplay j=1/parenleftbiggrj−qj rj/parenrightbigg . (11.3) For times tbetween dkanddk+1, we set /hatwideS(t)=/hatwideS(dk). Consequently, the Kaplan–Meier survival curve has a step-like shape. The Kaplan–Meier survival curve for the BrainCancer data is displayed in Figure 11.2. Each point in the solid step-like curve shows the estimated probability of surviving past the time indicated on the horizontal axis. The estimated probability of survival past 20 months is 71%, which is quite a bit higher than the naive estimates of 55% and 68% presented earlier. The sequential construction of the Kaplan–Meier estimator — starting at time zero and mapping out the observed events as they unfold in time — is fundamental to many of the key techniques in survival analysis. These include the log-rank test of Section 11.4, and Cox’s proportional hazard model of Section 11.5.2. 3The law of total probability states that for any two events AandB,Pr(A)= Pr(A|B) Pr( B) + Pr( A|Bc) Pr( Bc), where Bcis the complement of the event B, i.e. it is the event that Bdoes not hold. 474 11. Survival Analysis and Censored Data 0204060800.0 0.2 0.4 0.6 0.8 1.0MonthsEstimated Probability of SurvivalFIGURE 11.2. For theBrainCancer data, we display the Kaplan–Meier survival curve (solid curve), along with standard error bands (dashed curves). 0204060800.0 0.2 0.4 0.6 0.8 1.0MonthsEstimated Probability of SurvivalFemaleMaleFIGURE 11.3. For the BrainCancer data, Kaplan–Meier survival curves for males and females are displayed. 11.4 The Log-Rank Test We now continue our analysis of the BrainCancer data introduced in Sec- tion11.3. We wish to compare the survival of males to that of females. Figure11.3shows the Kaplan–Meier survival curves for the two groups. Females seem to fare a little better up to about 50 months, but then the two curves both level off to about 50%. How can we carry out a formal test of equality of the two survival curves? At first glance, a two-sample t-test seems like an obvious choice: we could test whether the mean survival time among the females equals the mean survival time among the males. But the presence of censoring again creates acomplication.Toovercomethischallenge,wewillconducta log-rank test ,4 log-rank test 11.4 The Log-Rank Test 475 Group 1 Group 2 Total Died q1k q2k qk Survived r1k−q1kr2k−q2krk−qk Total r1k r2k rk TABLE 11.1. Among the set of patients at risk at time dk, the number of patients who died and survived in each", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 524, "start_word": 167680, "end_word": 168080, "chunk_words": 400}}, "ISLP_website::c000525": {"text": "t-test seems like an obvious choice: we could test whether the mean survival time among the females equals the mean survival time among the males. But the presence of censoring again creates acomplication.Toovercomethischallenge,wewillconducta log-rank test ,4 log-rank test 11.4 The Log-Rank Test 475 Group 1 Group 2 Total Died q1k q2k qk Survived r1k−q1kr2k−q2krk−qk Total r1k r2k rk TABLE 11.1. Among the set of patients at risk at time dk, the number of patients who died and survived in each of two groups is reported. which examines how the events in each group unfold sequentially in time. Recall from Section 11.3thatd1<d 2<···<d Kare the unique death times among the non-censored patients, rkis the number of patients at risk at time dk, andqkis the number of patients who died at time dk.W e further define r1kandr2kto be the number of patients in groups 1 and 2, respectively, who are at risk at time dk. Similarly, we define q1kandq2kto be the number of patients in groups 1 and 2, respectively, who died at time dk. Note that r1k+r2k=rkandq1k+q2k=qk. At each death time dk, we construct a 2×2table of counts of the form shown in Table 11.1. Note that if the death times are unique (i.e. no two individuals die at the same time), then one of q1kandq2kequals one, and the other equals zero. The main idea behind the log-rank test statistic is as follows. In order to testH0: E(X)= µfor some random variable X, one approach is to construct a test statistic of the form W=X−µ/radicalbig Var(X). (11.4) To construct the log-rank test statistic, we compute a quantity that takes exactly the form ( 11.4), withX=/summationtextK k=1q1k, whereq1kis given in the top left of Table 11.1. In greater detail, if there is no difference in survival between the two groups, and conditioning on the row and column totals in Table 11.1, the expected value of q1kis µk=r1k rkqk. (11.5) So the expected value of X=/summationtextK k=1q1kisµ=/summationtextK k=1r1k rkqk. Furthermore, it can be shown5that the variance of q1kis Var ( q1k)=qk(r1k/rk)(1−r1k/rk)(rk−qk) rk−1. (11.6) Thoughq11,...,q 1Kmay be correlated, we nonetheless estimate Var/parenleftBiggK/summationdisplay k=1q1k/parenrightBigg ≈K/summationdisplay k=1Var ( q1k)=K/summationdisplay k=1qk(r1k/rk)(1−r1k/rk)(rk−qk) rk−1. (11.7) 4The log-rank test is also known as the Mantel–Haenszel test orCochran–Mantel– Haenszel test . 5For details, see Exercise 7at the end of this chapter. 476 11. Survival Analysis and Censored Data Therefore, to compute the log-rank test statistic, we simply proceed as in (11.4),", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 525, "start_word": 168000, "end_word": 168400, "chunk_words": 400}}, "ISLP_website::c000526": {"text": "value of X=/summationtextK k=1q1kisµ=/summationtextK k=1r1k rkqk. Furthermore, it can be shown5that the variance of q1kis Var ( q1k)=qk(r1k/rk)(1−r1k/rk)(rk−qk) rk−1. (11.6) Thoughq11,...,q 1Kmay be correlated, we nonetheless estimate Var/parenleftBiggK/summationdisplay k=1q1k/parenrightBigg ≈K/summationdisplay k=1Var ( q1k)=K/summationdisplay k=1qk(r1k/rk)(1−r1k/rk)(rk−qk) rk−1. (11.7) 4The log-rank test is also known as the Mantel–Haenszel test orCochran–Mantel– Haenszel test . 5For details, see Exercise 7at the end of this chapter. 476 11. Survival Analysis and Censored Data Therefore, to compute the log-rank test statistic, we simply proceed as in (11.4), withX=/summationtextK k=1q1k, making use of ( 11.5) and (11.7). That is, we calculate W=/summationtextK k=1(q1k−µk)/radicalBig/summationtextK k=1Var ( q1k)=/summationtextK k=1/parenleftBig q1k−qk rkr1k/parenrightBig /radicalBig/summationtextK k=1qk(r1k/rk)(1−r1k/rk)(rk−qk) rk−1.(11.8) When the sample size is large, the log-rank test statistic Whas ap- proximately a standard normal distribution; this can be used to compute ap-value for the null hypothesis that there is no difference between the survival curves in the two groups.6 Comparing the survival times of females and males on the BrainCancer data gives a log-rank test statistic of W=1.2, which corresponds to a two- sidedp-value of 0.2using the theoretical null distribution, and a p-value of0.25using the permutation null distribution with 1,000 permutations. Thus,wecannotrejectthenullhypothesisofnodifferenceinsurvivalcurves between females and males. The log-rank test is closely related to Cox’s proportional hazards model, which we discuss in Section 11.5.2. 11.5 Regression Models With a Survival Response We now consider the task of fitting a regression model to survival data. As in Section 11.1, the observations are of the form (Y,δ), where Y= min( T,C)is the (possibly censored) survival time, and δis an indicator variable that equals 1ifT≤C. Furthermore, X∈Rpis a vector of p features. We wish to predict the true survival time T. Since the observed quantity Yis positive and may have a long right tail, we might be tempted to fit a linear regression of log(Y)onX. But as the reader will surely guess, censoring again creates a problem since we are actually interested in predicting Tand not Y. To overcome this difficulty, we instead make use of a sequential construction, similar to the constructions of the Kaplan–Meier survival curve in Section 11.3and the log-rank test in Section 11.4. 11.5.1 The Hazard Function Thehazard function orhazard rate — also known as the force of mortalityhazard function— is formally defined as h(t) = lim ∆t→0Pr(t<T ≤t+∆t|T>t ) ∆t, (11.9) 6Alternatively, we can estimate the p-value via permutations, using ideas that will be presented in Section 13.5. The permutation distribution is obtained", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 526, "start_word": 168320, "end_word": 168720, "chunk_words": 400}}, "ISLP_website::c000527": {"text": "overcome this difficulty, we instead make use of a sequential construction, similar to the constructions of the Kaplan–Meier survival curve in Section 11.3and the log-rank test in Section 11.4. 11.5.1 The Hazard Function Thehazard function orhazard rate — also known as the force of mortalityhazard function— is formally defined as h(t) = lim ∆t→0Pr(t<T ≤t+∆t|T>t ) ∆t, (11.9) 6Alternatively, we can estimate the p-value via permutations, using ideas that will be presented in Section 13.5. The permutation distribution is obtained by randomly swapping the labels for the observations in the two groups. 11.5 Regression Models With a Survival Response 477 whereTis the (unobserved) survival time. It is the death rate in the instant after time t, given survival past that time.7In (11.9), we take the limit as ∆tapproaches zero, so we can think of ∆tas being an extremely tiny number. Thus, more informally, ( 11.9) implies that h(t)≈Pr(t<T ≤t+∆t|T>t ) ∆t for some arbitrarily small ∆t. Why should we care about the hazard function? First of all, it is closely related to the survival curve ( 11.2), as we will see next. Second, it turns out that a key approach for modeling survival data as a function of covariates relies heavily on the hazard function; we will introduce this approach — Cox’s proportional hazards model — in Section 11.5.2. We now consider the hazard function h(t)in a bit more detail. Recall that for two events AandB, the probability of AgivenBcan be expressed asPr(A|B) = Pr( A∩B)/Pr(B), i.e. the probability that AandBboth occur divided by the probability that Boccurs. Furthermore, recall from (11.2) thatS(t) = Pr( T>t ). Thus, h(t) = lim ∆t→0Pr (( t<T ≤t+∆t)∩(T>t ))/∆t Pr(T>t ) = lim ∆t→0Pr(t<T ≤t+∆t)/∆t Pr(T>t ) =f(t) S(t), (11.10) where f(t) = lim ∆t→0Pr(t<T ≤t+∆t) ∆t(11.11) is theprobability density function associated with T, i.e. it is the instanta-probability density functionneous rate of death at time t. The second equality in ( 11.10) made use of the fact that if t<T ≤t+∆t, then it must be the case that T>t . Equation 11.10implies a relationship between the hazard function h(t), the survival function S(t), and the probability density function f(t). In fact, these are three equivalent ways8of describing the distribution of T. The likelihood associated with the ith observation is Li=/braceleftBigg f(yi)if theith observation is not censored S(yi)if theith observation is censored =f(yi)δiS(yi)1−δi. (11.12) The intuition behind ( 11.12) is as follows: if", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 527, "start_word": 168640, "end_word": 169040, "chunk_words": 400}}, "ISLP_website::c000528": {"text": "made use of the fact that if t<T ≤t+∆t, then it must be the case that T>t . Equation 11.10implies a relationship between the hazard function h(t), the survival function S(t), and the probability density function f(t). In fact, these are three equivalent ways8of describing the distribution of T. The likelihood associated with the ith observation is Li=/braceleftBigg f(yi)if theith observation is not censored S(yi)if theith observation is censored =f(yi)δiS(yi)1−δi. (11.12) The intuition behind ( 11.12) is as follows: if Y=yiand theith observation is not censored, then the likelihood is the probability of dying in a tiny in- terval around time yi. If theith observation is censored, then the likelihood 7Due to the ∆tin the denominator of ( 11.9), the hazard function is a rate of death, rather than a probability of death. However, higher values of h(t)directly correspond to a higher probability of death, just as higher values of a probability density function correspond to more likely outcomes for a random variable. In fact, h(t)is the probability density function for Tconditional on T>t . 8See Exercise 8. 478 11. Survival Analysis and Censored Data is the probability of surviving at least until time yi. Assuming that the n observations are independent, the likelihood for the data takes the form L=n/productdisplay i=1f(yi)δiS(yi)1−δi=n/productdisplay i=1h(yi)δiS(yi), (11.13) where the second equality follows from ( 11.10). Wenowconsiderthetaskofmodelingthesurvivaltimes.Ifweassumeex- ponential survival, i.e. that the probability density function of the survival timeTtakes the form f(t)=λexp(−λt), then estimating the parameter λ by maximizing the likelihood in ( 11.13) is straightforward.9Alternatively, we could assume that the survival times are drawn from a more flexible family of distributions, such as the Gamma or Weibull family. Another possibility is to model the survival times non-parametrically, as was done in Section 11.3using the Kaplan–Meier estimator. However, what we would really like to do is model the survival time as a function of the covariates . To do this, it is convenient to work directly with the hazard function, instead of the probability density function.10 One possible approach is to assume a functional form for the hazard func- tionh(t|xi), such as h(t|xi) = exp/parenleftBig β0+/summationtextp j=1βjxij/parenrightBig , where the exponent function guarantees that the hazard function is non-negative. Note that the exponential hazard function is special, in that it does not vary with time.11Givenh(t|xi), we could calculate S(t|xi). Plugging these equations into (11.13), we could then maximize the likelihood in order to estimate", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 528, "start_word": 168960, "end_word": 169360, "chunk_words": 400}}, "ISLP_website::c000529": {"text": "work directly with the hazard function, instead of the probability density function.10 One possible approach is to assume a functional form for the hazard func- tionh(t|xi), such as h(t|xi) = exp/parenleftBig β0+/summationtextp j=1βjxij/parenrightBig , where the exponent function guarantees that the hazard function is non-negative. Note that the exponential hazard function is special, in that it does not vary with time.11Givenh(t|xi), we could calculate S(t|xi). Plugging these equations into (11.13), we could then maximize the likelihood in order to estimate the parameter β=(β0,β1,...,βp)T. However, this approach is quite restric- tive, in the sense that it requires us to make a very stringent assumption on the form of the hazard function h(t|xi). In the next section, we will consider a much more flexible approach. 11.5.2 Proportional Hazards The Proportional Hazards Assumption Theproportional hazards assumption states thatproportional hazards assumptionh(t|xi)=h0(t) exp p/summationdisplay j=1xijβj , (11.14) whereh0(t)≥0is an unspecified function, known as the baseline hazard .baseline hazardIt is the hazard function for an individual with features xi1=···=xip= 0. The name “proportional hazards” arises from the fact that the hazard function for an individual with feature vector xiis some unknown function 9See Exercise 9. 10Given the close relationship between the hazard function h(t)and the density func- tionf(t)explored in Exercise 8, posing an assumption about the form of the hazard function is closely related to posing an assumption about the form of the density func- tion, as was done in the previous paragraph. 11The notation h(t|xi)indicates that we are now considering the hazard function for theith observation conditional on the values of the covariates, xi. 11.5 Regression Models With a Survival Response 479 0.5 1.0 1.5 2.0−3 −2 −1 0TimeLog Hazard0.5 1.0 1.5 2.00.0 0.2 0.4 0.6 0.8 1.0TimeSurvival Probability 0.5 1.0 1.5 2.0−4 −2 0 1 2TimeLog Hazard0.5 1.0 1.5 2.00.0 0.2 0.4 0.6 0.8 1.0TimeSurvival ProbabilityFIGURE 11.4. Top:In a simple example with p=1 and a binary covariate xi∈{0,1}, the log hazard and the survival function under the model (11.14) are shown (green for xi=0 and black for xi=1). Because of the proportional hazards assumption (11.14), the log hazard functions differ by a constant, and the survival functions do not cross. Bottom: Again we have a single binary covariate xi∈{0,1}. However, the proportional hazards assumption (11.14)does not hold. The log hazard functions cross, as do the survival functions. h0(t)times the factor exp/parenleftBig/summationtextp j=1xijβj/parenrightBig . The quantity exp/parenleftBig/summationtextp j=1xijβj/parenrightBig is called the relative risk for the", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 529, "start_word": 169280, "end_word": 169680, "chunk_words": 400}}, "ISLP_website::c000530": {"text": "function under the model (11.14) are shown (green for xi=0 and black for xi=1). Because of the proportional hazards assumption (11.14), the log hazard functions differ by a constant, and the survival functions do not cross. Bottom: Again we have a single binary covariate xi∈{0,1}. However, the proportional hazards assumption (11.14)does not hold. The log hazard functions cross, as do the survival functions. h0(t)times the factor exp/parenleftBig/summationtextp j=1xijβj/parenrightBig . The quantity exp/parenleftBig/summationtextp j=1xijβj/parenrightBig is called the relative risk for the feature vector xi=(xi1,...,x ip)T, relative to that for the feature vector xi= (0,...,0)T. What does it mean that the baseline hazard function h0(t)in (11.14) is unspecified? Basically, we make no assumptions about its functional form. We allow the instantaneous probability of death at time t, given that one has survived at least until time t, to take any form. This means that the hazard function is very flexible and can model a wide range of relationships between the covariates and survival time. Our only assumption is that a one-unit increase in xijcorresponds to an increase in h(t|xi)by a factor of exp(βj). An illustration of the proportional hazards assumption ( 11.14) is given in Figure11.4, in a simple setting with a single binary covariate xi∈{0,1}(so thatp=1). In the top row, the proportional hazards assumption ( 11.14) holds. Thus, the hazard functions of the two groups are a constant multiple of each other, so that on the log scale, the gap between them is constant. Furthermore, the survival curves never cross, and in fact the gap between the survival curves tends to (initially) increase over time. By contrast, in the bottom row, ( 11.14) does not hold. We see that the log hazard functions for the two groups cross, as do the survival curves. 480 11. Survival Analysis and Censored Data Cox’s Proportional Hazards Model Because the form of h0(t)in the proportional hazards assumption ( 11.14) is unknown, we cannot simply plug h(t|xi)into the likelihood ( 11.13) and then estimate β=(β1,...,βp)Tby maximum likelihood. The magic of Cox’s proportional hazards model lies in the fact that it is in fact possibleCox’s proportional hazards modelto estimate βwithout having to specify the form of h0(t). To accomplish this, we make use of the same “sequential in time” logic that we used to derive the Kaplan–Meier survival curve and the log-rank test. For simplicity, assume that there are no ties among the failure, or death, times:", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 530, "start_word": 169600, "end_word": 170000, "chunk_words": 400}}, "ISLP_website::c000531": {"text": "h(t|xi)into the likelihood ( 11.13) and then estimate β=(β1,...,βp)Tby maximum likelihood. The magic of Cox’s proportional hazards model lies in the fact that it is in fact possibleCox’s proportional hazards modelto estimate βwithout having to specify the form of h0(t). To accomplish this, we make use of the same “sequential in time” logic that we used to derive the Kaplan–Meier survival curve and the log-rank test. For simplicity, assume that there are no ties among the failure, or death, times: i.e. each failure occurs at a distinct time. Assume that δi= 1, i.e. the ith observation is uncensored, and thus yiis its failure time. Then the hazard function for the ith observation at time yiish(yi|xi)= h0(yi) exp/parenleftBig/summationtextp j=1xijβj/parenrightBig , and the total hazard at time yifor the at risk observations12is /summationdisplay i/prime:yi/prime≥yih0(yi) exp p/summationdisplay j=1xi/primejβj . Therefore, the probability that the ith observation is the one to fail at time yi(as opposed to one of the other observations in the risk set) is h0(yi) exp/parenleftBig/summationtextp j=1xijβj/parenrightBig /summationtext i/prime:yi/prime≥yih0(yi) exp/parenleftBig/summationtextp j=1xi/primejβj/parenrightBig=exp/parenleftBig/summationtextp j=1xijβj/parenrightBig /summationtext i/prime:yi/prime≥yiexp/parenleftBig/summationtextp j=1xi/primejβj/parenrightBig. (11.15) Notice that the unspecified baseline hazard function h0(yi)cancels out of the numerator and denominator! Thepartial likelihood is simply the product of these probabilities over allpartial likelihoodof the uncensored observations, PL(β)=/productdisplay i:δi=1exp/parenleftBig/summationtextp j=1xijβj/parenrightBig /summationtext i/prime:yi/prime≥yiexp/parenleftBig/summationtextp j=1xi/primejβj/parenrightBig. (11.16) Critically, the partial likelihood is valid regardless of the true value of h0(t), making the model very flexible and robust.13 To estimate β, we simply maximize the partial likelihood ( 11.16) with respect to β. As was the case for logistic regression in Chapter 4, no closed- form solution is available, and so iterative algorithms are required. In addition to estimating β, we can also obtain other model outputs that we saw in the context of least squares regression in Chapter 3and logistic regression in Chapter 4. For example, we can obtain p-values corresponding 12Recall that the “at risk” observations at time yiare those that are still at risk of failure, i.e. those that have not yet failed or been censored before time yi. 13In general, the partial likelihood is used in settings where it is difficult to compute the full likelihood for all of the parameters. Instead, we compute a likelihood for just the parameters of primary interest: in this case, β1,...,βp. It can be shown that maximizing (11.16) provides good estimates for these parameters. 11.5 Regression Models With a Survival Response 481 to particular null hypotheses (e.g.", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 531, "start_word": 169920, "end_word": 170320, "chunk_words": 400}}, "ISLP_website::c000532": {"text": "of failure, i.e. those that have not yet failed or been censored before time yi. 13In general, the partial likelihood is used in settings where it is difficult to compute the full likelihood for all of the parameters. Instead, we compute a likelihood for just the parameters of primary interest: in this case, β1,...,βp. It can be shown that maximizing (11.16) provides good estimates for these parameters. 11.5 Regression Models With a Survival Response 481 to particular null hypotheses (e.g. H0:βj=0), as well as confidence intervals associated with the coefficients. Connection With The Log-Rank Test Suppose we have just a single predictor ( p=1), which we assume to be binary, i.e. xi∈{0,1}. In order to determine whether there is a difference between the survival times of the observations in the group {i:xi=0} and those in the group {i:xi=1}, we can consider taking two possible approaches: Approach #1: Fit a Cox proportional hazards model, and test the null hypothesis H0:β=0. (Sincep=1,βis a scalar.) Approach #2: Perform a log-rank test to compare the two groups, as in Section 11.4. Which one should we prefer? In fact, there is a close relationship between these two approaches. In particular, when taking Approach #1, there are a number of possible ways to testH0. One way is known as a score test. It turns out that in the case of a single binary covariate, the score test for H0:β=0in Cox’s proportional hazards model is exactly equal to the log-rank test. In other words, it does not matter whether we take Approach #1 or Approach #2! Additional Details The discussion of Cox’s proportional hazards model glossed over a few subtleties: • There is no intercept in ( 11.14) nor in the equations that follow, because an intercept can be absorbed into the baseline hazard h0(t). • We have assumed that there are no tied failure times. In the case of ties, the exact form of the partial likelihood ( 11.16) is a bit more complicated, and a number of computational approximations must be used. •(11.16) is known as the partiallikelihood because it is not exactly a likelihood. That is, it does not correspond exactly to the probability of the data under the assumption ( 11.14). However, it is a very good approximation. • Wehavefocusedonlyonestimationofthecoefficients β=(β1,...,βp)T. However, at times we may also wish to estimate the baseline hazard h0(t),forinstancesothatwecanestimatethesurvivalcurve S(t|x)for an individual with feature vector x. The details", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 532, "start_word": 170240, "end_word": 170640, "chunk_words": 400}}, "ISLP_website::c000533": {"text": "likelihood ( 11.16) is a bit more complicated, and a number of computational approximations must be used. •(11.16) is known as the partiallikelihood because it is not exactly a likelihood. That is, it does not correspond exactly to the probability of the data under the assumption ( 11.14). However, it is a very good approximation. • Wehavefocusedonlyonestimationofthecoefficients β=(β1,...,βp)T. However, at times we may also wish to estimate the baseline hazard h0(t),forinstancesothatwecanestimatethesurvivalcurve S(t|x)for an individual with feature vector x. The details are beyond the scope of this book. Estimation of h0(t)is implemented in the lifelines package in Python, which we will see in Section 11.8. 482 11. Survival Analysis and Censored Data 11.5.3 Example: Brain Cancer Data Table11.2shows the result of fitting the proportional hazards model to theBrainCancer data, which was originally described in Section 11.3. The coefficient column displays ˆβj. The results indicate, for instance, that the estimated hazard for a male patient is e0.18=1.2times greater than for a female patient: in other words, with all other features held fixed, males have a 1.2 times greater chance of dying than females, at any point in time. However, the p-value is 0.61, which indicates that this difference between males and females is not significant. As another example, we also see that each one-unit increase in the Karnofsky index corresponds to a multiplier of exp(−0.05) = 0 .95in the instantaneous chance of dying. In other words, the higher the Karnofsky index, the lower the chance of dying at any given point in time. This effect is highly significant, with a p-value of 0.0027 . Coefficient Std. error z-statistic p-value sex[Male] 0.18 0.36 0.51 0.61 diagnosis[LG Glioma] 0.92 0.64 1.43 0.15 diagnosis[HG Glioma] 2.15 0.45 4.78 0.00 diagnosis[Other] 0.89 0.66 1.35 0.18 loc[Supratentorial] 0.44 0.70 0.63 0.53 ki -0.05 0.02 -3.00 <0.01 gtv 0.03 0.02 1.54 0.12 stereo[SRT] 0.18 0.60 0.30 0.77 TABLE 11.2. Results for Cox’s proportional hazards model fit to the BrainCancer data, which was first described in Section 11.3. The variable diagnosis is qualitative with four levels: meningioma, LG glioma, HG glioma, or other. The variables sex,loc, andstereoare binary. 11.5.4 Example: Publication Data Next, we consider the dataset Publication involving the time to publica- tion of journal papers reporting the results of clinical trials funded by the National Heart, Lung, and Blood Institute.14For 244 trials, the time in months until publication is recorded. Of the 244 trials, only 156 were", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 533, "start_word": 170560, "end_word": 170960, "chunk_words": 400}}, "ISLP_website::c000534": {"text": "BrainCancer data, which was first described in Section 11.3. The variable diagnosis is qualitative with four levels: meningioma, LG glioma, HG glioma, or other. The variables sex,loc, andstereoare binary. 11.5.4 Example: Publication Data Next, we consider the dataset Publication involving the time to publica- tion of journal papers reporting the results of clinical trials funded by the National Heart, Lung, and Blood Institute.14For 244 trials, the time in months until publication is recorded. Of the 244 trials, only 156 were pub- lished during the study period; the remaining studies were censored. The covariatesincludewhetherthetrialfocusedonaclinicalendpoint( clinend), whether the trial involved multiple centers ( multi), the funding mechanism withintheNationalInstitutesofHealth( mech),trialsamplesize( sampsize ), budget ( budget), impact ( impact, related to the number of citations), and whether the trial produced a positive (significant) result ( posres). The last covariate is particularly interesting, as a number of studies have suggested that positive trials have a higher publication rate. 14This dataset is described in the following paper: Gordon et al. (2013) Publication of trials funded by the National Heart, Lung, and Blood Institute. New England Journal of Medicine, 369(20):1926–1934. 11.5 Regression Models With a Survival Response 483 0 20 40 60 80 100 1200.0 0.2 0.4 0.6 0.8 1.0MonthsProbability of Not Being PublishedNegative ResultPositive Result FIGURE 11.5. Survival curves for time until publication for the Publication data described in Section 11.5.4, stratified by whether or not the study produced a positive result. Figure11.5showstheKaplan–Meiercurvesforthetimeuntilpublication, stratified by whether or not the study produced a positive result. We see slightevidencethattimeuntilpublicationislowerforstudieswithapositive result.However,thelog-ranktestyieldsaveryunimpressive p-valueof 0.36. We now consider a more careful analysis that makes use of all of the availablepredictors.TheresultsoffittingCox’sproportionalhazardsmodel using all of the available features are shown in Table 11.3. We find that the chance of publication of a study with a positive result is e0.55=1.74times higher than the chance of publication of a study with a negative result at any point in time, holding all other covariates fixed. The very small p-value associated with posresin Table 11.3indicates that this result is highly significant. This is striking, especially in light of our earlier finding that a log-rank test comparing time to publication for studies with positive versus negative results yielded a p-value of 0.36. How can we explain this discrepancy? The answer stems from the fact that the log-rank test did not consider any other covariates, whereas the results in Table 11.3are based on a Cox model using all of", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 534, "start_word": 170880, "end_word": 171280, "chunk_words": 400}}, "ISLP_website::c000535": {"text": "very small p-value associated with posresin Table 11.3indicates that this result is highly significant. This is striking, especially in light of our earlier finding that a log-rank test comparing time to publication for studies with positive versus negative results yielded a p-value of 0.36. How can we explain this discrepancy? The answer stems from the fact that the log-rank test did not consider any other covariates, whereas the results in Table 11.3are based on a Cox model using all of the available covariates. In other words, after we adjust for all of the other covariates, then whether or not the study yielded a positive result is highly predictive of the time to publication. In order to gain more insight into this result, in Figure 11.6we display estimates of the survival curves associated with positive and negative re- sults, adjusting for the other predictors. To produce these survival curves, we estimated the underlying baseline hazard h0(t). We also needed to se- lect representative values for the other predictors; we used the mean value for each predictor, except for the categorical predictor mech, for which we used the most prevalent category ( R01). Adjusting for the other predictors, we now see a clear difference in the survival curves between studies with positive versus negative results. Other interesting insights can be gleaned from Table 11.3. For example, studies with a clinical endpoint are more likely to be published at any given point in time than those with a non-clinical endpoint. The funding 484 11. Survival Analysis and Censored Data Coefficient Std. error z-statistic p-value posres[Yes] 0.55 0.18 3.02 0.00 multi[Yes] 0.15 0.31 0.47 0.64 clinend[Yes] 0.51 0.27 1.89 0.06 mech[K01] 1.05 1.06 1.00 0.32 mech[K23] -0.48 1.05 -0.45 0.65 mech[P01] -0.31 0.78 -0.40 0.69 mech[P50] 0.60 1.06 0.57 0.57 mech[R01] 0.10 0.32 0.30 0.76 mech[R18] 1.05 1.05 0.99 0.32 mech[R21] -0.05 1.06 -0.04 0.97 mech[R24,K24] 0.81 1.05 0.77 0.44 mech[R42] -14.78 3414.38 -0.00 1.00 mech[R44] -0.57 0.77 -0.73 0.46 mech[RC2] -14.92 2243.60 -0.01 0.99 mech[U01] -0.22 0.32 -0.70 0.48 mech[U54] 0.47 1.07 0.44 0.66 sampsize 0.00 0.00 0.19 0.85 budget 0.00 0.00 1.67 0.09 impact 0.06 0.01 8.23 0.00 TABLE 11.3. Results for Cox’s proportional hazards model fit to the Publication data, using all of the available features. The features posres,multi, andclinend are binary. The feature mechis qualitative with 14 levels; it is coded so that the baseline level is Contract . mechanism", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 535, "start_word": 171200, "end_word": 171600, "chunk_words": 400}}, "ISLP_website::c000536": {"text": "1.00 mech[R44] -0.57 0.77 -0.73 0.46 mech[RC2] -14.92 2243.60 -0.01 0.99 mech[U01] -0.22 0.32 -0.70 0.48 mech[U54] 0.47 1.07 0.44 0.66 sampsize 0.00 0.00 0.19 0.85 budget 0.00 0.00 1.67 0.09 impact 0.06 0.01 8.23 0.00 TABLE 11.3. Results for Cox’s proportional hazards model fit to the Publication data, using all of the available features. The features posres,multi, andclinend are binary. The feature mechis qualitative with 14 levels; it is coded so that the baseline level is Contract . mechanism did not appear to be significantly associated with time until publication. 11.6 Shrinkage for the Cox Model In this section, we illustrate that the shrinkage methods of Section 6.2 can be applied to the survival data setting. In particular, motivated by the “loss+penalty” formulation of Section 6.2, we consider minimizing a penalized version of the negative log partial likelihood in ( 11.16), −log /productdisplay i:δi=1exp/parenleftBig/summationtextp j=1xijβj/parenrightBig /summationtext i/prime:yi/prime≥yiexp/parenleftBig/summationtextp j=1xi/primejβj/parenrightBig +λP(β), (11.17) with respect to β=(β1,...,βp)T. We might take P(β)=/summationtextp j=1β2 j, which corresponds to a ridge penalty, or P(β)=/summationtextp j=1|βj|, which corresponds to a lasso penalty. In (11.17),λis a non-negative tuning parameter; typically we will mini- mize it over a range of values of λ. Whenλ=0, then minimizing ( 11.17) is equivalent to simply maximizing the usual Cox partial likelihood ( 11.16). However, when λ>0, then minimizing ( 11.17) yields a shrunken version of the coefficient estimates. When λis large, then using a ridge penalty will give small coefficients that are not exactly equal to zero. By contrast, for a 11.6 Shrinkage for the Cox Model 485 0 20 40 60 80 100 1200.0 0.2 0.4 0.6 0.8 1.0MonthsProbability of Not Being PublishedNegative ResultPositive Result FIGURE 11.6. For thePublication data, we display survival curves for time until publication, stratified by whether or not the study produced a positive result, after adjusting for all other covariates. sufficiently large value of λ, using a lasso penalty will give some coefficients that are exactly equal to zero. Wenowapplythelasso-penalizedCoxmodeltothe Publication data,de- scribed in Section 11.5.4. We first randomly split the 244 trials into equally- sized training and test sets. The cross-validation results from the training set are shown in Figure 11.7. The “partial likelihood deviance”, shown on they-axis, is twice the cross-validated negative log partial likelihood; it plays the role of the cross-validation error.15Note the “U-shape” of the partial likelihood deviance: just as we saw in previous chapters, the cross- validation error is minimized", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 536, "start_word": 171520, "end_word": 171920, "chunk_words": 400}}, "ISLP_website::c000537": {"text": "exactly equal to zero. Wenowapplythelasso-penalizedCoxmodeltothe Publication data,de- scribed in Section 11.5.4. We first randomly split the 244 trials into equally- sized training and test sets. The cross-validation results from the training set are shown in Figure 11.7. The “partial likelihood deviance”, shown on they-axis, is twice the cross-validated negative log partial likelihood; it plays the role of the cross-validation error.15Note the “U-shape” of the partial likelihood deviance: just as we saw in previous chapters, the cross- validation error is minimized for an intermediate level of model complexity. Specifically, this occurs when just two predictors, budgetandimpact, have non-zero estimated coefficients. Now, how do we apply this model to the test set? This brings up an important conceptual point: in essence, there is no simple way to compare predicted survival times and true survival times on the test set. The first problem is that some of the observations are censored, and so the true sur- vival times for those observations are unobserved. The second issue arises from the fact that in the Cox model, rather than predicting a single sur- vival time given a covariate vector x, we instead estimate an entire survival curve,S(t|x), as a function of t. Therefore, to assess the model fit, we must take a different approach, which involves stratifying the observations using the coefficient estimates. In particular, for each test observation, we compute the “risk” score budget i·ˆβbudget +impact i·ˆβimpact , whereˆβbudget andˆβimpact are the coefficient estimates for these two features from the training set. We then use these risk scores to categorize the obser- vations based on their “risk”. For instance, the high risk group consists of the observations for which budget i·ˆβbudget +impact i·ˆβimpact is largest; by 15Cross-validation for the Cox model is more involved than for linear or logistic re- gression, because the objective function is not a sum over the observations. 486 11. Survival Analysis and Censored Data 2e−04 5e−04 1e−03 2e−03 5e−03 1e−02 2e−02 5e−02 1e−01 2e−019.0 9.1 9.2 9.3 9.4 9.5 9.6 9.7Partial Likelihood Deviance/bardblˆβLλ/bardbl1/slashbig|ˆβ/bardbl1FIGURE 11.7. For thePublication data described in Section 11.5.4, cross-val- idation results for the lasso-penalized Cox model are shown. The y-axis displays the partial likelihood deviance, which plays the role of the cross-validation error. Thex-axis displays the /lscript1norm (that is, the sum of the absolute values) of the coefficients of the lasso-penalized Cox model with tuning parameter λ, divided by the/lscript1norm of the coefficients of the unpenalized", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 537, "start_word": 171840, "end_word": 172240, "chunk_words": 400}}, "ISLP_website::c000538": {"text": "1e−02 2e−02 5e−02 1e−01 2e−019.0 9.1 9.2 9.3 9.4 9.5 9.6 9.7Partial Likelihood Deviance/bardblˆβLλ/bardbl1/slashbig|ˆβ/bardbl1FIGURE 11.7. For thePublication data described in Section 11.5.4, cross-val- idation results for the lasso-penalized Cox model are shown. The y-axis displays the partial likelihood deviance, which plays the role of the cross-validation error. Thex-axis displays the /lscript1norm (that is, the sum of the absolute values) of the coefficients of the lasso-penalized Cox model with tuning parameter λ, divided by the/lscript1norm of the coefficients of the unpenalized Cox model. The dashed line indicates the minimum cross-validation error. (11.14), we see that these are the observations for which the instantaneous probability of being published at any moment in time is largest. In other words, the high risk group consists of the trials that are likely to be pub- lished sooner. On the Publication data, we stratify the observations into tertiles of low, medium, and high risk. The resulting survival curves for each of the three strata are displayed in Figure 11.8. We see that there is clear separation between the three strata, and that the strata are correctly ordered in terms of low, medium, and high risk of publication. 11.7 Additional Topics 11.7.1 Area Under the Curve for Survival Analysis InChapter 4,weintroducedtheareaundertheROCcurve—oftenreferred toasthe“AUC”—asawaytoquantifytheperformanceofatwo-classclas- sifier. Define the scorefor theith observation to be the classifier’s estimate ofPr(Y=1|X=xi). It turns out that if we consider all pairs consisting of one observation in Class 1 and one observation in Class 2, then the AUC is the fraction of pairs for which the score for the observation in Class 1 exceeds the score for the observation in Class 2. This suggests a way to generalize the notion of AUC to survival anal- ysis. We calculate an estimated risk score, ˆηi=ˆβ1xi1+···+ˆβpxip, for i=1,...,n , using the Cox model coefficients. If ˆηi/prime>ˆηi, then the model predicts that the i/primeth observation has a larger hazard than the ith obser- vation, and thus that the survival time tiwill begreaterthanti/prime. Thus, it is tempting to try to generalize AUC by computing the proportion of ob- servations for which ti>ti/primeandˆηi/prime>ˆηi. However, things are not quite so easy, because recall that we do not observe t1,...,t n; instead, we observe 11.7 Additional Topics 487 0 20 40 60 80 100 1200.0 0.2 0.4 0.6 0.8 1.0MonthsProbability of Not Being PublishedLow RiskMedium RiskHigh Risk FIGURE 11.8. For the Publication data introduced in Section 11.5.4, we compute tertiles of “risk” in the", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 538, "start_word": 172160, "end_word": 172560, "chunk_words": 400}}, "ISLP_website::c000539": {"text": "tiwill begreaterthanti/prime. Thus, it is tempting to try to generalize AUC by computing the proportion of ob- servations for which ti>ti/primeandˆηi/prime>ˆηi. However, things are not quite so easy, because recall that we do not observe t1,...,t n; instead, we observe 11.7 Additional Topics 487 0 20 40 60 80 100 1200.0 0.2 0.4 0.6 0.8 1.0MonthsProbability of Not Being PublishedLow RiskMedium RiskHigh Risk FIGURE 11.8. For the Publication data introduced in Section 11.5.4, we compute tertiles of “risk” in the test set using coefficients estimated on the training set. There is clear separation between the resulting survival curves. the (possibly-censored) times y1,...,y n, as well as the censoring indicators δ1,...,δn. Therefore, Harrell’s concordance index (orC-index) computes the pro-Harrell’s concordance indexportion of observation pairs for which ˆηi/prime>ˆηiandyi>yi/prime: C=/summationtext i,i/prime:yi>yi/primeI(ˆηi/prime>ˆηi)δi/prime /summationtext i,i/prime:yi>yi/primeδi/prime, where the indicator variable I(ˆηi/prime>ˆηi)equals one if ˆηi/prime>ˆηi, and equals zero otherwise. The numerator and denominator are multiplied by the sta- tus indicator δi/prime, since if the i/primeth observation is uncensored (i.e. if δi/prime=1), thenyi>y i/primeimplies that ti>ti/prime. By contrast, if δi/prime=0, thenyi>y i/prime does not imply that ti>ti/prime. We fit a Cox proportional hazards model on the training set of the Publication data, and computed the C-index on the test set. This yielded C=0.733. Roughly speaking, given two random papers from the test set, the model can predict with 73.3% accuracy which will be published first. 11.7.2 Choice of Time Scale In the examples considered thus far in this chapter, it has been fairly clear how to define time. For example, in the Publication example, time zero for each paper was defined to be the calendar time at the end of the study, and the failure time was defined to be the number of months that elapsed from the end of the study until the paper was published. However, in other settings, the definitions of time zero and failure time may be more subtle. For example, when examining the association between risk factors and disease occurrence in an epidemiological study, one might use the patient’s age to define time, so that time zero is the patient’s date of birth. With this choice, the association between age and survival cannot be measured; however, there is no need to adjust for age in the analysis. When examining covariates associated with disease-free survival (i.e. the 488 11. Survival Analysis and Censored Data amount of time elapsed between treatment and disease recurrence), one", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 539, "start_word": 172480, "end_word": 172880, "chunk_words": 400}}, "ISLP_website::c000540": {"text": "association between risk factors and disease occurrence in an epidemiological study, one might use the patient’s age to define time, so that time zero is the patient’s date of birth. With this choice, the association between age and survival cannot be measured; however, there is no need to adjust for age in the analysis. When examining covariates associated with disease-free survival (i.e. the 488 11. Survival Analysis and Censored Data amount of time elapsed between treatment and disease recurrence), one might use the date of treatment as time zero. 11.7.3 Time-Dependent Covariates A powerfulfeature of the proportional hazards model is its abilityto handle time-dependent covariates , predictors whose value may change over time. For example, suppose we measure a patient’s blood pressure every week over the course of a medical study. In this case, we can think of the blood pressure for the ith observation not as xi, but rather as xi(t)at timet. Because the partial likelihood in ( 11.16) is constructed sequentially in time, dealing with time-dependent covariates is straightforward. In partic- ular, we simply replace xijandxi/primejin (11.16) withxij(yi)andxi/primej(yi), respectively; these are the current values of the predictors at time yi. By contrast, time-dependent covariates would pose a much greater challenge within the context of a traditional parametric approach, such as ( 11.13). Oneexampleoftime-dependentcovariatesappearsintheanalysisofdata from the Stanford Heart Transplant Program. Patients in need of a heart transplant were put on a waiting list. Some patients received a transplant, but others died while still on the waiting list. The primary objective of the analysis was to determine whether a transplant was associated with longer patient survival. A naïve approach would use a fixed covariate to represent transplant status: that is, xi=1if theith patient ever received a transplant, and xi= 0otherwise. But this approach overlooks the fact that patients had to live long enough to get a transplant, and hence, on average, healthier patients receivedtransplants.Thisproblemcanbesolvedbyusingatime-dependent covariate for transplant: xi(t)=1 if the patient received a transplant by timet, andxi(t)=0 otherwise. 11.7.4 Checking the Proportional Hazards Assumption We have seen that Cox’s proportional hazards model relies on the propor- tional hazards assumption ( 11.14). While results from the Cox model tend to be fairly robust to violations of this assumption, it is still a good idea to check whether it holds. In the case of a qualitative feature, we can plot the log hazard function for each level of the feature. If (", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 540, "start_word": 172800, "end_word": 173200, "chunk_words": 400}}, "ISLP_website::c000541": {"text": "patient received a transplant by timet, andxi(t)=0 otherwise. 11.7.4 Checking the Proportional Hazards Assumption We have seen that Cox’s proportional hazards model relies on the propor- tional hazards assumption ( 11.14). While results from the Cox model tend to be fairly robust to violations of this assumption, it is still a good idea to check whether it holds. In the case of a qualitative feature, we can plot the log hazard function for each level of the feature. If ( 11.14) holds, then the log hazard functions should just differ by a constant, as seen in the top-left panel of Figure 11.4. In the case of a quantitative feature, we can take a similar approach by stratifying the feature. 11.7.5 Survival Trees InChapter 8,wediscussedflexibleandadaptivelearningproceduressuchas trees,randomforests,andboosting,whichweappliedinboththeregression and classification settings. Most of these approaches can be generalized to the survival analysis setting. For example, survival trees are a modificationsurvival treesofclassificationandregressiontreesthatuseasplitcriterionthatmaximizes 11.8 Lab: Survival Analysis 489 the difference between the survival curves in the resulting daughter nodes. Survival trees can then be used to create random survival forests. 11.8 Lab: Survival Analysis In this lab, we perform survival analyses on three separate data sets. In Section11.8.1we analyze the BrainCancer data that was first described in Section 11.3. In Section 11.8.2, we examine the Publication data from Section11.5.4. Finally, Section 11.8.3explores a simulated call-center data set. We begin by importing some of our libraries at this top level. This makes the code more readable, as scanning the first few lines of the notebook tell us what libraries are used in this notebook. In[1]: from matplotlib.pyplot import subplots import numpy as np import pandas as pd from ISLP.models import ModelSpec as MS from ISLP import load_data We also collect the new imports needed for this lab. In[2]: from lifelines import \\ (KaplanMeierFitter, CoxPHFitter) from lifelines.statistics import \\ (logrank_test, multivariate_logrank_test) from ISLP.survival import sim_time 11.8.1 Brain Cancer Data We begin with the BrainCancer data set, contained in the ISLPpackage. In[3]: BrainCancer = load_data( 'BrainCancer' ) BrainCancer.columns Out[3]: Index([ 'sex','diagnosis' ,'loc','ki','gtv','stereo' , 'status' ,'time'], dtype='object' ) The rows index the 88 patients, while the 8 columns contain the predictors and outcome variables. We first briefly examine the data. In[4]: BrainCancer[ 'sex'].value_counts() Out[4]: Female 45 Male 43 Name: sex, dtype: int64 In[5]: BrainCancer[ 'diagnosis' ].value_counts() 490 11. Survival Analysis and Censored Data Out[5]: Meningioma 42 HG glioma 22 Other 14 LG glioma 9 Name: diagnosis, dtype: int64 In[6]:", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 541, "start_word": 173120, "end_word": 173520, "chunk_words": 400}}, "ISLP_website::c000542": {"text": "in the ISLPpackage. In[3]: BrainCancer = load_data( 'BrainCancer' ) BrainCancer.columns Out[3]: Index([ 'sex','diagnosis' ,'loc','ki','gtv','stereo' , 'status' ,'time'], dtype='object' ) The rows index the 88 patients, while the 8 columns contain the predictors and outcome variables. We first briefly examine the data. In[4]: BrainCancer[ 'sex'].value_counts() Out[4]: Female 45 Male 43 Name: sex, dtype: int64 In[5]: BrainCancer[ 'diagnosis' ].value_counts() 490 11. Survival Analysis and Censored Data Out[5]: Meningioma 42 HG glioma 22 Other 14 LG glioma 9 Name: diagnosis, dtype: int64 In[6]: BrainCancer[ 'status' ].value_counts() Out[6]: 05 3 13 5 Name: status, dtype: int64 Before beginning an analysis, it is important to know how the status variable has been coded. Most software uses the convention that a status of 1 indicates an uncensored observation (often death), and a statusof 0 indicatesacensoredobservation.Butsomescientistsmightusetheopposite coding. For the BrainCancer data set 35 patients died before the end of the study, so we are using the conventional coding. To begin the analysis, we re-create the Kaplan-Meier survival curve shown in Figure 11.2. The main package we will use for survival analy- sis islifelines . The variable timecorresponds to yi, the time to the ithlifelinesevent (either censoring or death). The first argument to km.fitis the event time, and the second argument is the censoring variable, with a 1 indicat- ing an observed failure time. The plot()method produces a survival curve.plot()with pointwise confidence intervals. By default, these are 90% confidence intervals, but this can be changed by setting the alphaargument to one minus the desired confidence level. In[7]: fig, ax = subplots(figsize=(8,8)) km = KaplanMeierFitter() km_brain = km.fit(BrainCancer[ 'time'], BrainCancer[ 'status' ]) km_brain.plot(label= 'Kaplan Meier estimate' ,a x = a x ) Next we create Kaplan-Meier survival curves that are stratified by sex, in order to reproduce Figure 11.3. We do this using the groupby() method of.groupby()a dataframe. This method returns a generator that can be iterated over in theforloop. In this case, the items in the forloop are 2-tuples representing the groups: the first entry is the value of the grouping column sexwhile the second value is the dataframe consisting of all rows in the dataframe matching that value of sex. We will want to use this data below in the log- rank test, hence we store this information in the dictionary by_sex. Finally, we have also used the notion of string interpolation to automatically labelstring interpolationthe different lines in the plot. String interpolation is a powerful technique", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 542, "start_word": 173440, "end_word": 173840, "chunk_words": 400}}, "ISLP_website::c000543": {"text": "2-tuples representing the groups: the first entry is the value of the grouping column sexwhile the second value is the dataframe consisting of all rows in the dataframe matching that value of sex. We will want to use this data below in the log- rank test, hence we store this information in the dictionary by_sex. Finally, we have also used the notion of string interpolation to automatically labelstring interpolationthe different lines in the plot. String interpolation is a powerful technique to format strings — Pythonhas many ways to facilitate such operations. In[8]: fig, ax = subplots(figsize=(8,8)) by_sex = {} for sex, df in BrainCancer.groupby( 'sex'): by_sex[sex] = df km_sex = km.fit(df[ 'time'], df['status' ]) km_sex.plot(label= 'Sex=%s' %s e x ,a x = a x ) As discussed in Section 11.4, we can perform a log-rank test to compare the survival of males to females. We use the logrank_test() function fromlogrank_ test() 11.8 Lab: Survival Analysis 491thelifelines.statisticsmodule. The first two arguments are the eventtimes, with the second denoting the corresponding (optional) censoringindicators.In[9]:logrank_test(by_sex['Male']['time'],by_sex['Female']['time'],by_sex['Male']['status'],by_sex['Female']['status'])Out[9]:t_0-1null_distribution chi squareddegrees_of_freedom1test_name logrank_testtest_statistic p -log2(p)1.44 0.23 2.12The resultingp-value is0.23, indicating no evidence of a difference insurvival between the two sexes.Next, we use theCoxPHFitter()estimator fromlifelinesto fit CoxCoxPHFitter()proportional hazards models. To begin, we consider a model that usessexas the only predictor.In[10]:coxph = CoxPHFitter#s h o r t h a n dsex_df = BrainCancer[['time','status','sex']]model_df = MS(['time','status','sex'],intercept=False).fit_transform(sex_df)cox_fit = coxph().fit(model_df,'time','status')cox_fit.summary[['coef','se(coef)','p']]Out[10]:coef se(coef)pcovariatesex[Male] 0.407667 0.342004 0.233263The first argument tofitshould be a data frame containing at least theevent time (the second argumenttimein this case), as well as an op-tional censoring variable (the argumentstatusin this case). Note also thatthe Cox model does not include an intercept, which is why we used theintercept=Falseargument toModelSpecabove. Thesummary()method de-livers many columns; we chose to abbreviate its output here. It is possibleto obtain the likelihood ratio test comparing this model to the one with nofeatures as follows:In[11]:cox_fit.log_likelihood_ratio_test()Out[11]:null_distributionchi squareddegrees_freedom1test_name log-likelihood ratio testtest_statistic p -log2(p)1.44 0.23 2.12 492 11. Survival Analysis and Censored DataRegardless of which test we use, we see that there is no clear evidence fora difference in survival between males and females. As we learned in thischapter, the score test from the Cox model is exactly equal to the log ranktest statistic!Now we fit a model that makes use of additional predictors. We first notethat one of ourdiagnosisvalues is missing, hence we drop that observationbefore continuing.In[12]:cleaned = BrainCancer.dropna()all_MS = MS(cleaned.columns, intercept=False)all_df = all_MS.fit_transform(cleaned)fit_all = coxph().fit(all_df,'time','status')fit_all.summary[['coef','se(coef)','p']]Out[12]:coef se(coef)pcovariatesex[Male] 0.183748 0.360358 0.610119diagnosis[LG glioma] -1.239541 0.579557", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 543, "start_word": 173760, "end_word": 174160, "chunk_words": 400}}, "ISLP_website::c000544": {"text": "which test we use, we see that there is no clear evidence fora difference in survival between males and females. As we learned in thischapter, the score test from the Cox model is exactly equal to the log ranktest statistic!Now we fit a model that makes use of additional predictors. We first notethat one of ourdiagnosisvalues is missing, hence we drop that observationbefore continuing.In[12]:cleaned = BrainCancer.dropna()all_MS = MS(cleaned.columns, intercept=False)all_df = all_MS.fit_transform(cleaned)fit_all = coxph().fit(all_df,'time','status')fit_all.summary[['coef','se(coef)','p']]Out[12]:coef se(coef)pcovariatesex[Male] 0.183748 0.360358 0.610119diagnosis[LG glioma] -1.239541 0.579557 0.032454diagnosis[Meningioma] -2.154566 0.450524 0.000002diagnosis[Other] -1.268870 0.617672 0.039949loc[Supratentorial] 0.441195 0.703669 0.530664ki -0.054955 0.018314 0.002693gtv 0.034293 0.022333 0.124660stereo[SRT] 0.177778 0.601578 0.767597Thediagnosisvariable has been coded so that the baseline corresponds toHG glioma. The results indicate that the risk associated with HG gliomais more than eight times (i.e.e2.15=8.62) the risk associated with menin-gioma. In other words, after adjusting for the other predictors, patientswith HG glioma have much worse survival compared to those with menin-gioma. In addition, larger values of the Karnofsky index,ki, are associatedwith lower risk, i.e. longer survival.Finally, we plot estimated survival curves for each diagnosis category,adjusting for the other predictors. To make these plots, we set the values ofthe other predictors equal to the mean for quantitative variables and equalto the mode for categorical. To do this, we use theapply()method acrossrows (i.e.axis=0) with a functionrepresentativethat checks if a columnis categorical or not.In[13]:levels = cleaned['diagnosis'].unique()def representative(series):if hasattr(series.dtype,'categories'):return pd.Series.mode(series)else:return series.mean()modal_data = cleaned.apply(representative, axis=0)We make four copies of the column means and assign thediagnosiscolumn to be the four different diagnoses.In[14]:modal_df = pd.DataFrame([modal_data.iloc[0] for _ in range(len(levels))])modal_df['diagnosis']=l e v e l smodal_df 11.8 Lab: Survival Analysis 493 Out[14]: sex diagnosis loc ki gtv stereo ... Female Meningioma Supratentorial 80.920 8.687 SRT ... Female HG glioma Supratentorial 80.920 8.687 SRT ... Female LG glioma Supratentorial 80.920 8.687 SRT ... Female Other Supratentorial 80.920 8.687 SRT ... We then construct the model matrix based on the model specification all_MSused to fit the model, and name the rows according to the levels of diagnosis . In[15]: modal_X = all_MS.transform(modal_df) modal_X.index = levels modal_X We can use the predict_survival_function() method to obtain the esti-.predict_ survival_ function()mated survival function. In[16]: predicted_survival = fit_all.predict_survival_function(modal_X) predicted_survival Out[16]: Meningioma HG glioma LG glioma Other 0.070 0.998 0.982 0.995 0.995 1.180 0.998 0.982 0.995 0.995 1.410 0.996 0.963 0.989 0.990 1.540 0.996 0.963 0.989 0.990 ... ... ... ... ... 67.380 0.689 0.040 0.394 0.405 73.740 0.689 0.040 0.394 0.405 78.750 0.689 0.040 0.394 0.405", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 544, "start_word": 174080, "end_word": 174480, "chunk_words": 400}}, "ISLP_website::c000545": {"text": "to the levels of diagnosis . In[15]: modal_X = all_MS.transform(modal_df) modal_X.index = levels modal_X We can use the predict_survival_function() method to obtain the esti-.predict_ survival_ function()mated survival function. In[16]: predicted_survival = fit_all.predict_survival_function(modal_X) predicted_survival Out[16]: Meningioma HG glioma LG glioma Other 0.070 0.998 0.982 0.995 0.995 1.180 0.998 0.982 0.995 0.995 1.410 0.996 0.963 0.989 0.990 1.540 0.996 0.963 0.989 0.990 ... ... ... ... ... 67.380 0.689 0.040 0.394 0.405 73.740 0.689 0.040 0.394 0.405 78.750 0.689 0.040 0.394 0.405 82.560 0.689 0.040 0.394 0.405 85 rows × 4 columns This returns a data frame, whose plot methods yields the different survival curves. To avoid clutter in the plots, we do not display confidence intervals. In[17]: fig, ax = subplots(figsize=(8, 8)) predicted_survival.plot(ax=ax); 11.8.2 Publication Data ThePublication data presented in Section 11.5.4can be found in the ISLPpackage. We first reproduce Figure 11.5by plotting the Kaplan-Meier curves stratified on the posresvariable, which records whether the study had a positive or negative result. In[18]: fig, ax = subplots(figsize=(8,8)) Publication = load_data( 'Publication' ) by_result = {} for result, df in Publication.groupby( 'posres' ): by_result[result] = df km_result = km.fit(df[ 'time'], df['status' ]) km_result.plot(label= 'Result=%d' %r e s u l t ,a x = a x ) As discussed previously, the p-values from fitting Cox’s proportional haz- ards model to the posresvariable are quite large, providing no evidence of a difference in time-to-publication between studies with positive versus negative results. 494 11. Survival Analysis and Censored Data In[19]: posres_df = MS([ 'posres' , 'time', 'status' ], intercept=False).fit_transform(Publication) posres_fit = coxph().fit(posres_df, 'time', 'status' ) posres_fit.summary[[ 'coef','se(coef)' ,'p']] Out[19]: coef se(coef) p covariate posres 0.148076 0.161625 0.359578 However, the results change dramatically when we include other predic- tors in the model. Here we exclude the funding mechanism variable. In[20]: model = MS(Publication.columns.drop( 'mech'), intercept=False) coxph().fit(model.fit_transform(Publication), 'time', 'status' ).summary[[ 'coef','se(coef)' ,'p']] Out[20]: coef se(coef) p covariate posres 0.570774 0.175960 1.179606e-03 multi -0.040863 0.251194 8.707727e-01 clinend 0.546180 0.262001 3.710099e-02 sampsize 0.000005 0.000015 7.506978e-01 budget 0.004386 0.002464 7.511276e-02 impact 0.058318 0.006676 2.426779e-18 We see that there are a number of statistically significant variables, in- cluding whether the trial focused on a clinical endpoint, the impact of the study, and whether the study had positive or negative results. 11.8.3 Call Center Data Inthissection,wewillsimulatesurvivaldatausingtherelationshipbetween cumulative hazard and the survival function explored in Exercise 8. Our simulated data will represent the observed wait times (in seconds) for 2,000 customers who have phoned", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 545, "start_word": 174400, "end_word": 174800, "chunk_words": 400}}, "ISLP_website::c000546": {"text": "3.710099e-02 sampsize 0.000005 0.000015 7.506978e-01 budget 0.004386 0.002464 7.511276e-02 impact 0.058318 0.006676 2.426779e-18 We see that there are a number of statistically significant variables, in- cluding whether the trial focused on a clinical endpoint, the impact of the study, and whether the study had positive or negative results. 11.8.3 Call Center Data Inthissection,wewillsimulatesurvivaldatausingtherelationshipbetween cumulative hazard and the survival function explored in Exercise 8. Our simulated data will represent the observed wait times (in seconds) for 2,000 customers who have phoned a call center. In this context, censoring occurs if a customer hangs up before his or her call is answered. Therearethreecovariates: Operators (thenumberofcallcenteroperators available at the time of the call, which can range from 5to15),Center (either A, B, or C), and Timeof day (Morning, Afternoon, or Evening). We generate data for these covariates so that all possibilities are equally likely: for instance, morning, afternoon and evening calls are equally likely, and any number of operators from 5to15is equally likely. In[21]: rng = np.random.default_rng(10) N=2 0 0 0 Operators = rng.choice(np.arange(5, 16), N, replace=True) 11.8 Lab: Survival Analysis 495 Center = rng.choice([ 'A','B','C'], N, replace=True) Time = rng.choice([ 'Morn.' ,'After.' ,'Even.' ], N, replace=True) D=p d . D a t a F r a m e ( { 'Operators' :O p e r a t o r s , 'Center' :p d . C a t e g o r i c a l ( C e n t e r ) , 'Time':p d . C a t e g o r i c a l ( T i m e ) } ) We then build a model matrix (omitting the intercept) In[22]: model = MS([ 'Operators' , 'Center' , 'Time'], intercept=False) X=m o d e l . f i t _ t r a n s f o r m ( D ) It is worthwhile to take a peek at the model matrix X, so that we can be sure that we understand how the variables have been coded. By default, the levels of categorical variables are sorted and, as usual, the first column of the one-hot encoding of the variable is dropped. In[23]: X[:5] Out[23]: Operators Center[B] Center[C] Time[Even.] Time[Morn.] 0 13 0.0 1.0 0.0 0.0 1 15 0.0 0.0 1.0 0.0 2 71 . 00 . 0 0.0 1.0 3 70 . 01 . 0 0.0 1.0 4 13 0.0 1.0 1.0 0.0 Next, we", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 546, "start_word": 174720, "end_word": 175120, "chunk_words": 400}}, "ISLP_website::c000547": {"text": "can be sure that we understand how the variables have been coded. By default, the levels of categorical variables are sorted and, as usual, the first column of the one-hot encoding of the variable is dropped. In[23]: X[:5] Out[23]: Operators Center[B] Center[C] Time[Even.] Time[Morn.] 0 13 0.0 1.0 0.0 0.0 1 15 0.0 0.0 1.0 0.0 2 71 . 00 . 0 0.0 1.0 3 70 . 01 . 0 0.0 1.0 4 13 0.0 1.0 1.0 0.0 Next, we specify the coefficients and the hazard function. In[24]: true_beta = np.array([0.04, -0.3, 0, 0.2, -0.2]) true_linpred = X.dot(true_beta) hazard = lambda t: 1e-5 * t Here, we have set the coefficient associated with Operators to equal 0.04; in other words, each additional operator leads to a e0.04=1.041-fold in- crease in the “risk” that the call will be answered, given the Centerand Timecovariates. This makes sense: the greater the number of operators at hand, the shorter the wait time! The coefficient associated with Center == Bis−0.3, andCenter == A is treated as the baseline. This means that the risk of a call being answered at Center B is 0.74 times the risk that it will be answered at Center A; in other words, the wait times are a bit longer at Center B. Recall from Section 2.3.7the use of lambdafor creating short functions on the fly. We use the function sim_time() from the ISLP.survival pack-sim_time()age. This function uses the relationship between the survival function and cumulative hazard S(t) = exp(−H(t))and the specific form of the cumu- lative hazard function in the Cox model to simulate data based on values of the linear predictor true_linpred and the cumulative hazard. We need to provide the cumulative hazard function, which we do here. In[25]: cum_hazard = lambda t: 1e-5 * t**2 / 2 496 11. Survival Analysis and Censored DataWe are now ready to generate data under the Cox proportional hazardsmodel. We truncate the maximum time to 1000 seconds to keep simulatedwait times reasonable. The functionsim_time()takes a linear predictor, acumulative hazard function and a random number generator.In[26]:W=n p . a r r a y ( [ s i m _ t i m e ( l ,c u m _ h a z a r d ,r n g )for l in true_linpred])D['Wait time']=n p . c l i p ( W ,0 ,1 0 0 0 )We now simulate our censoring variable, for", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 547, "start_word": 175040, "end_word": 175440, "chunk_words": 400}}, "ISLP_website::c000548": {"text": "maximum time to 1000 seconds to keep simulatedwait times reasonable. The functionsim_time()takes a linear predictor, acumulative hazard function and a random number generator.In[26]:W=n p . a r r a y ( [ s i m _ t i m e ( l ,c u m _ h a z a r d ,r n g )for l in true_linpred])D['Wait time']=n p . c l i p ( W ,0 ,1 0 0 0 )We now simulate our censoring variable, for which we assume 90% ofcalls were answered (Failed==1) before the customer hung up (Failed==0).In[27]:D['Failed']=r n g . c h o i c e ( [ 1 ,0 ] ,N,p=[0.9, 0.1])D[:5]Out[27]:Operators Center Time Wait time Failed013 C After. 525.064979 1115 A Even. 254.677835 127B M o r n . 4 8 7 . 7 3 9 2 2 4 137C M o r n . 3 0 8 . 5 8 0 2 9 2 1413 C Even. 154.174608 1In[28]:D['Failed'].mean()Out[28]:0.8985We now plot Kaplan-Meier survival curves. First, we stratify byCenter.In[29]:fig, ax = subplots(figsize=(8,8))by_center = {}for center, df in D.groupby('Center'):by_center[center] = dfkm_center = km.fit(df['Wait time'], df['Failed'])km_center.plot(label='Center=%s'%c e n t e r ,a x = a x )ax.set_title(\"Probability of Still Being on Hold\")Next, we stratify byTime.In[30]:fig, ax = subplots(figsize=(8,8))by_time = {}for time, df in D.groupby('Time'):by_time[time] = dfkm_time = km.fit(df['Wait time'], df['Failed'])km_time.plot(label='Time=%s'%t i m e ,a x = a x )ax.set_title(\"Probability of Still Being on Hold\")It seems that calls at Call Center B take longer to be answered than callsat Centers A and C. Similarly, it appears that wait times are longest in themorning and shortest in the evening hours. We can use a log-rank test todetermine whether these differences are statistically significant using thefunctionmultivariate_logrank_test().In[31]:multivariate_logrank_test(D['Wait time'],D['Center'],D['Failed']) 11.8 Lab: Survival Analysis 497Out[31]:t_0-1null_distributionchi squareddegrees_of_freedom2test_name multivariate_logrank_testtest_statistic p -log2(p)20.30 <0.005 14.65Next, we consider the effect ofTime.In[32]:multivariate_logrank_test(D['Wait time'],D['Time'],D['Failed'])Out[32]:t_0-1null_distributionchi squareddegrees_of_freedom2test_name multivariate_logrank_testtest_statistic p -log2(p)49.90 <0.005 35.99As in the case of a categorical variable with 2 levels, these results aresimilartothelikelihoodratiotestfromtheCoxproportionalhazardsmodel.First, we look at the results forCenter.In[33]:X=M S ( ['Wait time','Failed','Center'],intercept=False).fit_transform(D)F=c o x p h ( ) . f i t ( X ,'Wait time','Failed')F.log_likelihood_ratio_test()Out[33]:null_distributionchi squareddegrees_freedom2test_name log-likelihood ratio testtest_statistic p -log2(p)20.58 <0.005 14.85Next, we look at the results forTime.In[34]:X=M S ( ['Wait time','Failed','Time'],intercept=False).fit_transform(D)F=c o x p h ( ) . f i t ( X ,'Wait time','Failed')F.log_likelihood_ratio_test()Out[34]:null_distributionchi squareddegrees_freedom2test_name log-likelihood ratio testtest_statistic p -log2(p)48.12 <0.005 34.71We find that differences between centers are highly significant, as aredifferences between times of day.Finally, we fit Cox’s proportional hazards", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 548, "start_word": 175360, "end_word": 175760, "chunk_words": 400}}, "ISLP_website::c000549": {"text": "the results forCenter.In[33]:X=M S ( ['Wait time','Failed','Center'],intercept=False).fit_transform(D)F=c o x p h ( ) . f i t ( X ,'Wait time','Failed')F.log_likelihood_ratio_test()Out[33]:null_distributionchi squareddegrees_freedom2test_name log-likelihood ratio testtest_statistic p -log2(p)20.58 <0.005 14.85Next, we look at the results forTime.In[34]:X=M S ( ['Wait time','Failed','Time'],intercept=False).fit_transform(D)F=c o x p h ( ) . f i t ( X ,'Wait time','Failed')F.log_likelihood_ratio_test()Out[34]:null_distributionchi squareddegrees_freedom2test_name log-likelihood ratio testtest_statistic p -log2(p)48.12 <0.005 34.71We find that differences between centers are highly significant, as aredifferences between times of day.Finally, we fit Cox’s proportional hazards model to the data. 498 11. Survival Analysis and Censored DataIn[35]:X=M S ( D . c o l u m n s ,intercept=False).fit_transform(D)fit_queuing = coxph().fit(X,'Wait time','Failed')fit_queuing.summary[['coef','se(coef)','p']]Out[35]:coef se(coef)pcovariateOperators 0.043934 0.007520 5.143677e-09Center[B] -0.236059 0.058113 4.864734e-05Center[C] 0.012231 0.057518 8.316083e-01Time[Even.] 0.268845 0.057797 3.294914e-06Time[Morn.] -0.148215 0.057334 9.734378e-03Thep-values for Center B and evening time are very small. It is alsoclear that the hazard — that is, the instantaneous risk that a call will beanswered — increases with the number of operators. Since we generatedthe data ourselves, we know that the true coefficients forOperators,Center=B,Center = C,Time = Even.andTime = Morn.are0.04,−0.3,0,0.2, and−0.2, respectively. The coefficient estimates from the fitted Cox model arefairly accurate.11.9 ExercisesConceptual1. For each example, state whether or not the censoring mechanism isindependent. Justify your answer.(a) In a study of disease relapse, due to a careless research scientist,all patients whose phone numbers begin with the number “2”are lost to follow up.(b) In a study of longevity, a formatting error causes all patient agesthat exceed 99 years to be lost (i.e. we know that those patientsare more than 99 years old, but we do not know their exactages).(c) Hospital A conducts a study of longevity. However, very sickpatients tend to be transferred to Hospital B, and are lost tofollow up.(d) In a study of unemployment duration, the people who find workearlier are less motivated to stay in touch with study investiga-tors, and therefore are more likely to be lost to follow up.(e) In a study of pregnancy duration, women who deliver their ba-bies pre-term are more likely to do so away from their usualhospital, and thus are more likely to be censored, relative towomen who deliver full-term babies. 11.9 Exercises 499 (f) A researcher wishes to model the number of years of education of the residents of a small town. Residents who enroll in college out of town are more likely to be lost to follow up, and are also more likely to attend graduate school, relative", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 549, "start_word": 175680, "end_word": 176080, "chunk_words": 400}}, "ISLP_website::c000550": {"text": "duration, women who deliver their ba-bies pre-term are more likely to do so away from their usualhospital, and thus are more likely to be censored, relative towomen who deliver full-term babies. 11.9 Exercises 499 (f) A researcher wishes to model the number of years of education of the residents of a small town. Residents who enroll in college out of town are more likely to be lost to follow up, and are also more likely to attend graduate school, relative to those who attend college in town. (g) Researchers conduct a study of disease-free survival (i.e. time until disease relapse following treatment). Patients who have not relapsed within five years are considered to be cured, and thus their survival time is censored at five years. (h) Wewishtomodelthefailuretimeforsomeelectricalcomponent. This component can be manufactured in Iowa or in Pittsburgh, with no difference in quality. The Iowa factory opened five years ago, and so components manufactured in Iowa are censored at fiveyears.ThePittsburghfactoryopenedtwoyearsago,sothose components are censored at two years. (i) We wish to model the failure time of an electrical component made in two different factories, one of which opened before the other. We have reason to believe that the components manufac- tured in the factory that opened earlier are of higher quality. 2. We conduct a study with n=4participants who have just purchased cell phones, in order to model the time until phone replacement. The first participant replaces her phone after 1.2 years. The second par- ticipant still has not replaced her phone at the end of the two-year study period. The third participant changes her phone number and is lost to follow up (but has not yet replaced her phone) 1.5 years into the study. The fourth participant replaces her phone after 0.2 years. For each of the four participants ( i=1,...,4), answer the following questions using the notation introduced in Section 11.1: (a) Is the participant’s cell phone replacement time censored? (b) Is the value of ciknown, and if so, then what is it? (c) Is the value of tiknown, and if so, then what is it? (d) Is the value of yiknown, and if so, then what is it? (e) Is the value of δiknown, and if so, then what is it? 3. For the example in Exercise 2, report the values of K,d1,...,d K, r1,...,r K, andq1,...,q K, where this notation was defined in Sec- tion11.3. 4. This problem", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 550, "start_word": 176000, "end_word": 176400, "chunk_words": 400}}, "ISLP_website::c000551": {"text": "(b) Is the value of ciknown, and if so, then what is it? (c) Is the value of tiknown, and if so, then what is it? (d) Is the value of yiknown, and if so, then what is it? (e) Is the value of δiknown, and if so, then what is it? 3. For the example in Exercise 2, report the values of K,d1,...,d K, r1,...,r K, andq1,...,q K, where this notation was defined in Sec- tion11.3. 4. This problem makes use of the Kaplan-Meier survival curve displayed in Figure 11.9. The raw data that went into plotting this survival curve is given in Table 11.4. The covariate column of that table is not needed for this problem. (a) What is the estimated probability of survival past 50 days? 500 11. Survival Analysis and Censored Data Observation ( Y) Censoring Indicator ( δ) Covariate ( X) 26.5 1 0.1 37.2 1 11 57.3 1 -0.3 90.8 0 2.8 20.2 0 1.8 89.8 0 0.4 TABLE 11.4. Data used in Exercise 4. (b) Write out an analytical expression for the estimated survival function. For instance, your answer might be something along the lines of /hatwideS(t)=  0.8 ift<31 0.5 if31≤t<77 0.22 if77≤t. (The previous equation is for illustration only: it is not the cor- rect answer!) 5. Sketch the survival function given by the equation /hatwideS(t)=  0.8 ift<31 0.5 if31≤t<77 0.22 if77≤t. Your answer should look something like Figure 11.9. 0204060800.0 0.2 0.4 0.6 0.8 1.0Time in DaysEstimated Probability of SurvivalFIGURE 11.9. A Kaplan-Meier survival curve used in Exercise 4. 6. This problem makes use of the data displayed in Figure 11.1. In completing this problem, you can refer to the observation times as y1,...,y 4. The ordering of these observation times can be seen from Figure11.1; their exact values are not required. (a) Report the values of δ1,...,δ4,K,d1,...,d K,r1,...,r K, and q1,...,q K. The relevant notation is defined in Sections 11.1and 11.3. 11.9 Exercises 501 (b) Sketch the Kaplan-Meier survival curve corresponding to this data set. (You do not need to use any software to do this — you can sketch it by hand using the results obtained in (a).) (c) Based on the survival curve estimated in (b), what is the proba- bility that the event occurs within 200days? What is the prob- ability that the event does not occur within 310 days? (d) Write out an expression", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 551, "start_word": 176320, "end_word": 176720, "chunk_words": 400}}, "ISLP_website::c000552": {"text": "Sections 11.1and 11.3. 11.9 Exercises 501 (b) Sketch the Kaplan-Meier survival curve corresponding to this data set. (You do not need to use any software to do this — you can sketch it by hand using the results obtained in (a).) (c) Based on the survival curve estimated in (b), what is the proba- bility that the event occurs within 200days? What is the prob- ability that the event does not occur within 310 days? (d) Write out an expression for the estimated survival curve from (b). 7. In this problem, we will derive ( 11.5) and (11.6), which are needed for the construction of the log-rank test statistic ( 11.8). Recall the notation in Table 11.1. (a) Assumethatthereisnodifferencebetweenthesurvivalfunctions of the two groups. Then we can think of q1kas the number of failures if we draw r1kobservations, without replacement, from a risk set of rkobservations that contains a total of qkfailures. Argue that q1kfollows a hypergeometric distribution . Write thehyper- geometric distributionparameters of this distribution in terms of r1k,rk, andqk. (b) Given your previous answer, and the properties of the hyper- geometric distribution, what are the mean and variance of q1k? Compare your answer to ( 11.5) and (11.6). 8. Recall that the survival function S(t), the hazard function h(t), and the density function f(t)are defined in ( 11.2), (11.9), and (11.11), respectively. Furthermore, define F(t)=1 −S(t). Show that the following relationships hold: f(t)= dF(t)/dt S(t) = exp/parenleftbigg −/integraldisplayt 0h(u)du/parenrightbigg . 9. In this exercise, we will explore the consequences of assuming that the survival times follow an exponential distribution. (a) Suppose that a survival time follows an Exp (λ)distribution, so that its density function is f(t)= λexp(−λt). Using the relationships provided in Exercise 8, show that S(t) = exp( −λt). (b) Now suppose that each of nindependent survival times follows an Exp(λ)distribution. Write out an expression for the likeli- hood function ( 11.13). (c) Show that the maximum likelihood estimator for λis ˆλ=n/summationdisplay i=1δi/n/summationdisplay i=1yi. (d) Use your answer to (c) to derive an estimator of the mean sur- vival time. Hint: For (d), recall that the mean of an Exp( λ)random variable is 1/λ. 502 11. Survival Analysis and Censored Data Applied 10. This exercise focuses on the brain tumor data, which is included in theISLPlibrary. (a) Plot the Kaplan-Meier survival curve with ±1standard error bands,usingthe KaplanMeierFitter() estimatorinthe lifelines package. (b) Draw a bootstrap sample of size n=", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 552, "start_word": 176640, "end_word": 177040, "chunk_words": 400}}, "ISLP_website::c000553": {"text": "estimator for λis ˆλ=n/summationdisplay i=1δi/n/summationdisplay i=1yi. (d) Use your answer to (c) to derive an estimator of the mean sur- vival time. Hint: For (d), recall that the mean of an Exp( λ)random variable is 1/λ. 502 11. Survival Analysis and Censored Data Applied 10. This exercise focuses on the brain tumor data, which is included in theISLPlibrary. (a) Plot the Kaplan-Meier survival curve with ±1standard error bands,usingthe KaplanMeierFitter() estimatorinthe lifelines package. (b) Draw a bootstrap sample of size n= 88 from the pairs (yi,δi), and compute the resulting Kaplan-Meier survival curve. Repeat thisprocess B= 200 times.Usetheresultstoobtainanestimate of the standard error of the Kaplan-Meier survival curve at each timepoint. Compare this to the standard errors obtained in (a). (c) Fit a Cox proportional hazards model that uses all of the pre- dictors to predict survival. Summarize the main findings. (d) Stratify the data by the value of ki. (Since only one observation haski==40,youcangroupthatobservationtogetherwiththeob- servations that have ki==60.) Plot Kaplan-Meier survival curves for each of the five strata, adjusted for the other predictors. 11. This exercise makes use of the data in Table 11.4. (a) Create two groups of observations. In Group 1, X<2, whereas in Group 2, X≥2. Plot the Kaplan-Meier survival curves corre- sponding to the two groups. Be sure to label the curves so that it is clear which curve corresponds to which group. By eye, does there appear to be a difference between the two groups’ survival curves? (b) Fit Cox’s proportional hazards model, using the group indicator as a covariate. What is the estimated coefficient? Write a sen- tence providing the interpretation of this coefficient, in terms of the hazard or the instantaneous probability of the event. Is there evidence that the true coefficient value is non-zero? (c) Recall from Section 11.5.2that in the case of a single binary covariate, the log-ran k test statistic should be identical to the score statistic for the Cox model. Conduct a log-rank test to de- termine whether there is a difference between the survival curves for the two groups. How does the p-value for the log-rank test statistic compare to the p-value for the score statistic for the Cox model from (b)? 12 Unsupervised Learning Most of this book concerns supervised learning methods such as regressionandclassification.Inthesupervisedlearningsetting,wetypically have access to a set of pfeatures X1,X2,...,X p, measured on nobser- vations, and a response Yalso measured on those same nobservations. The", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 553, "start_word": 176960, "end_word": 177360, "chunk_words": 400}}, "ISLP_website::c000554": {"text": "Conduct a log-rank test to de- termine whether there is a difference between the survival curves for the two groups. How does the p-value for the log-rank test statistic compare to the p-value for the score statistic for the Cox model from (b)? 12 Unsupervised Learning Most of this book concerns supervised learning methods such as regressionandclassification.Inthesupervisedlearningsetting,wetypically have access to a set of pfeatures X1,X2,...,X p, measured on nobser- vations, and a response Yalso measured on those same nobservations. The goal is then to predict YusingX1,X2,...,X p. This chapter will instead focus on unsupervised learning , a set of sta- tistical tools intended for the setting in which we have only a set of fea- turesX1,X2,...,X pmeasured on nobservations. We are not interested in prediction, because we do not have an associated response variable Y. Rather, the goal is to discover interesting things about the measurements onX1,X2,...,X p. Is there an informative way to visualize the data? Can we discover subgroups among the variables or among the observations? Unsupervised learning refers to a diverse set of techniques for answering questions such as these. In this chapter, we will focus on two particu- lar types of unsupervised learning: principal components analysis , a tool used for data visualization or data pre-processing before supervised tech- niques are applied, and clustering , a broad class of methods for discovering unknown subgroups in data. 12.1 The Challenge of Unsupervised Learning Supervised learning is a well-understood area. In fact, if you have read the preceding chapters in this book, then you should by now have a good grasp of supervised learning. For instance, if you are asked to predict a binary outcome from a data set, you have a very well developed set of tools at your disposal (such as logistic regression, linear discriminant analysis, classification trees, support vector machines, and more) as well as a clear © Springer Nature Switzerland AG 2023 G. James et al., An Introduction to Statistical Learning , Springer Texts in Statistics, https://doi.org/10.1007/978-3-031-38747-0_12 503 504 12. Unsupervised Learning understanding of how to assess the quality of the results obtained (using cross-validation, validation on an independent test set, and so forth). In contrast, unsupervised learning is often much more challenging. The exercise tends to be more subjective, and there is no simple goal for the analysis, such as prediction of a response. Unsupervised learning is often performed as part of an", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 554, "start_word": 177280, "end_word": 177680, "chunk_words": 400}}, "ISLP_website::c000555": {"text": "et al., An Introduction to Statistical Learning , Springer Texts in Statistics, https://doi.org/10.1007/978-3-031-38747-0_12 503 504 12. Unsupervised Learning understanding of how to assess the quality of the results obtained (using cross-validation, validation on an independent test set, and so forth). In contrast, unsupervised learning is often much more challenging. The exercise tends to be more subjective, and there is no simple goal for the analysis, such as prediction of a response. Unsupervised learning is often performed as part of an exploratory data analysis . Furthermore, it can beexploratory data analysishard to assess the results obtained from unsupervised learning methods, since there is no universally accepted mechanism for performing cross- validation or validating results on an independent data set. The reason for this difference is simple. If we fit a predictive model using a supervised learning technique, then it is possible to check our work by seeing how well our model predicts the response Yon observations not used in fitting the model. However, in unsupervised learning, there is no way to check our workbecause wedon’t knowthe trueanswer—theproblemis unsupervised. Techniques for unsupervised learning are of growing importance in a number of fields. A cancer researcher might assay gene expression levels in 100 patients with breast cancer. He or she might then look for subgroups among the breast cancer samples, or among the genes, in order to obtain a better understanding of the disease. An online shopping site might try to identify groups of shoppers with similar browsing and purchase histo- ries, as well as items that are of particular interest to the shoppers within each group. Then an individual shopper can be preferentially shown the items in which he or she is particularly likely to be interested, based on the purchase histories of similar shoppers. A search engine might choose which search results to display to a particular individual based on the click histories of other individuals with similar search patterns. These statistical learningtasks,and manymore, canbeperformed viaunsupervised learning techniques. 12.2 Principal Components Analysis Principal components are discussed in Section 6.3.1in the context of principal components regression. When faced with a large set of corre- lated variables, principal components allow us to summarize this set with a smaller number of representative variables that collectively explain most of the variability in the original set. The principal component directions are presented in Section 6.3.1as directions in feature space along which the original data are highly", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 555, "start_word": 177600, "end_word": 178000, "chunk_words": 400}}, "ISLP_website::c000556": {"text": "statistical learningtasks,and manymore, canbeperformed viaunsupervised learning techniques. 12.2 Principal Components Analysis Principal components are discussed in Section 6.3.1in the context of principal components regression. When faced with a large set of corre- lated variables, principal components allow us to summarize this set with a smaller number of representative variables that collectively explain most of the variability in the original set. The principal component directions are presented in Section 6.3.1as directions in feature space along which the original data are highly variable . These directions also define lines and subspaces that are as close as possible to the data cloud. To perform principal components regression, we simply use principal components as predictors in a regression model in place of the original larger set of vari- ables. Principal components analysis (PCA)referstotheprocessbywhichprin-principal components analysiscipal components are computed, and the subsequent use of these compo- nents in understanding the data. PCA is an unsupervised approach, since it involves only a set of features X1,X2,...,X p, and no associated response Y. Apart from producing derived variables for use in supervised learning problems, PCA also serves as a tool for data visualization (visualization of 12.2 Principal Components Analysis 505the observations or visualization of the variables). It can also be used as atool for data imputation — that is, for filling in missing values in a datamatrix.We now discuss PCA in greater detail, focusing on the use of PCA asa tool for unsupervised data exploration, in keeping with the topic of thischapter.12.2.1 What Are Principal Components?Suppose that we wish to visualizenobservations with measurements on aset ofpfeatures,X1,X2,...,Xp, as part of an exploratory data analysis.We could do this by examining two-dimensional scatterplots of the data,each of which contains thenobservations’ measurements on two of thefeatures.However,there are/parenleftbigp2/parenrightbig=p(p−1)/2suchscatterplots; for example,withp= 10there are 45 plots! Ifpis large, then it will certainly not bepossible to look at all of them; moreover, most likely none of them willbe informative since they each contain just a small fraction of the totalinformation present in the data set. Clearly, a better method is required tovisualize thenobservations whenpis large. In particular, we would like tofind a low-dimensional representation of the data that captures as much oftheinformationaspossible.Forinstance,ifwecanobtainatwo-dimensionalrepresentation of the data that captures most of the information, then wecan plot the observations in this low-dimensional space.PCA provides a tool to do just this. It finds a low-dimensional represen-tation of a data set that contains as much as possible of the variation.", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 556, "start_word": 177920, "end_word": 178320, "chunk_words": 400}}, "ISLP_website::c000557": {"text": "small fraction of the totalinformation present in the data set. Clearly, a better method is required tovisualize thenobservations whenpis large. In particular, we would like tofind a low-dimensional representation of the data that captures as much oftheinformationaspossible.Forinstance,ifwecanobtainatwo-dimensionalrepresentation of the data that captures most of the information, then wecan plot the observations in this low-dimensional space.PCA provides a tool to do just this. It finds a low-dimensional represen-tation of a data set that contains as much as possible of the variation. Theidea is that each of thenobservations lives inp-dimensional space, but notall of these dimensions are equally interesting. PCA seeks a small numberof dimensions that are as interesting as possible, where the concept ofin-terestingis measured by the amount that the observations vary along eachdimension. Each of the dimensions found by PCA is a linear combinationof thepfeatures. We now explain the manner in which these dimensions,orprincipal components, are found.Thefirst principal componentof a set of featuresX1,X2,...,Xpis thenormalized linear combination of the featuresZ1=φ11X1+φ21X2+···+φp1Xp(12.1)that has the largest variance. Bynormalized, we mean that/summationtextpj=1φ2j1=1.We refer to the elementsφ11,...,φp1as theloadingsof the first principalloadingcomponent; together, the loadings make up the principal component load-ing vector,φ1=(φ11φ21...φp1)T. We constrain the loadings so thattheir sum of squares is equal to one, since otherwise setting these elementsto be arbitrarily large in absolute value could result in an arbitrarily largevariance.Given ann×pdata setX, how do we compute the first principal com-ponent? Since we are only interested in variance, we assume that each ofthe variables inXhas been centered to have mean zero (that is, the col-umn means ofXare zero). We then look for the linear combination of thesample feature values of the formzi1=φ11xi1+φ21xi2+···+φp1xip(12.2) 506 12. Unsupervised Learning thathaslargestsamplevariance,subjecttotheconstraintthat/summationtextp j=1φ2 j1=1. In other words, the first principal component loading vector solves the op- timization problem maximize φ11,...,φp1  1 nn/summationdisplay i=1 p/summationdisplay j=1φj1xij 2  subject top/summationdisplay j=1φ2 j1=1. (12.3) From (12.2) we can write the objective in ( 12.3) as1 n/summationtextn i=1z2 i1. Since 1 n/summationtextn i=1xij=0, the average of the z11,...,z n1will be zero as well. Hence the objective that we are maximizing in ( 12.3) is just the sample variance of thenvalues of zi1. We refer to z11,...,z n1as thescoresof the first princi-score pal component. Problem ( 12.3) can be solved via an eigen decomposition ,eigen decom- positiona standard technique in linear algebra, but the details are outside of the scope of this book.1 There is a nice geometric interpretation of the first principal component.", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 557, "start_word": 178240, "end_word": 178640, "chunk_words": 400}}, "ISLP_website::c000558": {"text": "the average of the z11,...,z n1will be zero as well. Hence the objective that we are maximizing in ( 12.3) is just the sample variance of thenvalues of zi1. We refer to z11,...,z n1as thescoresof the first princi-score pal component. Problem ( 12.3) can be solved via an eigen decomposition ,eigen decom- positiona standard technique in linear algebra, but the details are outside of the scope of this book.1 There is a nice geometric interpretation of the first principal component. The loading vector φ1with elements φ11,φ21,...,φp1defines a direction in feature space along which the data vary the most. If we project the ndata pointsx1,...,x nonto this direction, the projected values are the princi- pal component scores z11,...,z n1themselves. For instance, Figure 6.14on page254displays the first principal component loading vector (green solid line) on an advertising data set. In these data, there are only two features, and so the observations as well as the first principal component loading vector can be easily displayed. As can be seen from ( 6.19), in that data set φ11=0.839andφ21=0.544. After the first principal component Z1of the features has been deter- mined, we can find the second principal component Z2. The second princi- pal component is the linear combination of X1,...,X pthat has maximal variance out of all linear combinations that are uncorrelated withZ1. The second principal component scores z12,z22,...,z n2take the form zi2=φ12xi1+φ22xi2+···+φp2xip, (12.4) whereφ2is the second principal component loading vector, with elements φ12,φ22,...,φp2. It turns out that constraining Z2to be uncorrelated with Z1is equivalent to constraining the direction φ2to be orthogonal (perpen- dicular) to the direction φ1. In the example in Figure 6.14, the observations lie in two-dimensional space (since p=2), and so once we have found φ1, there is only one possibility for φ2, which is shown as a blue dashed line. (From Section 6.3.1, we know that φ12=0.544andφ22=−0.839.) But in a larger data set with p>2variables, there are multiple distinct principal components, and they are defined in a similar manner. To find φ2, we solve a problem similar to ( 12.3) withφ2replacing φ1, and with the additional constraint that φ2is orthogonal to φ1.2 1As an alternative to the eigen decomposition, a related technique called the singular value decomposition can be used. This will be explored in the lab at the end of this chapter. 2On a technical note, the principal component directions φ1,φ2,φ3,...are given by the ordered sequence of eigenvectors of the", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 558, "start_word": 178560, "end_word": 178960, "chunk_words": 400}}, "ISLP_website::c000559": {"text": "and they are defined in a similar manner. To find φ2, we solve a problem similar to ( 12.3) withφ2replacing φ1, and with the additional constraint that φ2is orthogonal to φ1.2 1As an alternative to the eigen decomposition, a related technique called the singular value decomposition can be used. This will be explored in the lab at the end of this chapter. 2On a technical note, the principal component directions φ1,φ2,φ3,...are given by the ordered sequence of eigenvectors of the matrix XTX, and the variances of the components are the eigenvalues. There are at most min( n−1,p)principal components. 12.2 Principal Components Analysis 507 −3 −2 −1 0123−3 −2 −1 0123 First Principal ComponentSecond Principal ComponentAlabamaAlaskaArizona ArkansasCaliforniaColoradoConnecticutDelawareFloridaGeorgiaHawaii IdahoIllinoisIndianaIowaKansasKentuckyLouisianaMaineMarylandMassachusettsMichiganMinnesota MississippiMissouriMontanaNebraskaNevadaNew HampshireNew Jersey New MexicoNew York North CarolinaNorth DakotaOhioOklahomaOregonPennsylvaniaRhode Island South CarolinaSouth DakotaTennesseeTexasUtah VermontVirginiaWashington West VirginiaWisconsinWyoming−0.50.00.5 −0.50.00.5 MurderAssaultUrbanPop Rape FIGURE 12.1.The first two principal components for theUSArrestsdata. Theblue state names represent the scores for the first two principal components. Theorange arrows indicate the first two principal component loading vectors (with axeson the top and right). For example, the loading forRapeon the first componentis0.54, and its loading on the second principal component0.17(the wordRapeis centered at the point(0.54,0.17)). This figure is known as a biplot, because itdisplays both the principal component scores and the principal component loadings.Once we have computed the principal components, we can plot themagainst each other in order to produce low-dimensional views of the data.For instance, we can plot the score vectorZ1againstZ2,Z1againstZ3,Z2againstZ3, and so forth. Geometrically, this amounts to projecting theoriginal data down onto the subspace spanned byφ1,φ2, andφ3, andplotting the projected points.We illustrate the use of PCA on theUSArrestsdata set. For each of the50 states in the United States, the data set contains the number of arrestsper100,000residents for each of three crimes:Assault,Murder, andRape.We also recordUrbanPop(the percent of the population in each state livingin urban areas). The principal component score vectors have lengthn= 50,and the principal component loading vectors have lengthp=4. PCA wasperformedafterstandardizingeachvariabletohavemeanzeroandstandard 508 12. Unsupervised Learning PC1 PC2 Murder 0.5358995 −0.4181809 Assault 0.5831836 −0.1879856 UrbanPop 0.2781909 0.8728062 Rape 0.5434321 0.1673186 TABLE 12.1. The principal component loading vectors, φ1andφ2, for the USArrests data. These are also displayed in Figure 12.1. deviation one. Figure 12.1plots the first two principal components of these data. The figure represents both the principal component scores and the loading vectors in a single biplotdisplay. The loadings are also given inbiplotTable12.2.1. In Figure 12.1, we see that the first", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 559, "start_word": 178880, "end_word": 179280, "chunk_words": 400}}, "ISLP_website::c000560": {"text": "wasperformedafterstandardizingeachvariabletohavemeanzeroandstandard 508 12. Unsupervised Learning PC1 PC2 Murder 0.5358995 −0.4181809 Assault 0.5831836 −0.1879856 UrbanPop 0.2781909 0.8728062 Rape 0.5434321 0.1673186 TABLE 12.1. The principal component loading vectors, φ1andφ2, for the USArrests data. These are also displayed in Figure 12.1. deviation one. Figure 12.1plots the first two principal components of these data. The figure represents both the principal component scores and the loading vectors in a single biplotdisplay. The loadings are also given inbiplotTable12.2.1. In Figure 12.1, we see that the first loading vector places approximately equal weight on Assault,Murder, andRape, but with much less weight on UrbanPop .Hencethiscomponentroughlycorrespondstoameasureofoverall rates of serious crimes. The second loading vector places most of its weight onUrbanPop and much less weight on the other three features. Hence, this component roughly corresponds to the level of urbanization of the state. Overall, we see that the crime-related variables ( Murder,Assault, andRape) arelocatedclosetoeachother,andthatthe UrbanPop variableisfarfromthe other three. This indicates that the crime-related variables are correlated with each other—states with high murder rates tend to have high assault and rape rates—and that the UrbanPop variable is less correlated with the other three. We can examine differences between the states via the two principal com- ponent score vectors shown in Figure 12.1. Our discussion of the loading vectors suggests that states with large positive scores on the first compo- nent, such as California, Nevada and Florida, have high crime rates, while states like North Dakota, with negative scores on the first component, have low crime rates. California also has a high score on the second component, indicating a high level of urbanization, while the opposite is true for states like Mississippi. States close to zero on both components, such as Indiana, have approximately average levels of both crime and urbanization. 12.2.2 Another Interpretation of Principal Components The first two principal component loading vectors in a simulated three- dimensional data set are shown in the left-hand panel of Figure 12.2; these two loading vectors span a plane along which the observations have the highest variance. In the previous section, we describe the principal component loading vec- tors as the directions in feature space along which the data vary the most, and the principal component scores as projections along these directions. However, an alternative interpretation of principal components can also be 12.2 Principal Components Analysis 509 First principal componentSecond principal component−1.0 −0.5 0.0 0.5 1.0−1.0 −0.5 0.0 0.5 1.0•••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••• FIGURE 12.2. Ninety observations", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 560, "start_word": 179200, "end_word": 179600, "chunk_words": 400}}, "ISLP_website::c000561": {"text": "loading vectors span a plane along which the observations have the highest variance. In the previous section, we describe the principal component loading vec- tors as the directions in feature space along which the data vary the most, and the principal component scores as projections along these directions. However, an alternative interpretation of principal components can also be 12.2 Principal Components Analysis 509 First principal componentSecond principal component−1.0 −0.5 0.0 0.5 1.0−1.0 −0.5 0.0 0.5 1.0•••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••• FIGURE 12.2. Ninety observations simulated in three dimensions. The obser- vations are displayed in color for ease of visualization. Left:the first two principal component directions span the plane that best fits the data. The plane is positioned to minimize the sum of squared distances to each point. Right:the first two prin- cipal component score vectors give the coordinates of the projection of the 90 observations onto the plane. useful: principal components provide low-dimensional linear surfaces that areclosestto the observations. We expand upon that interpretation here.3 The first principal component loading vector has a very special property: it is the line in p-dimensional space that is closestto thenobservations (using average squared Euclidean distance as a measure of closeness). This interpretation can be seen in the left-hand panel of Figure 6.15; the dashed lines indicate the distance between each observation and the line defined by the first principal component loading vector. The appeal of this inter- pretation is clear: we seek a single dimension of the data that lies as close as possible to all of the data points, since such a line will likely provide a good summary of the data. The notion of principal components as the dimensions that are clos- est to the nobservations extends beyond just the first principal com- ponent. For instance, the first two principal components of a data set span the plane that is closest to the nobservations, in terms of average squared Euclidean distance. An example is shown in the left-hand panel of Figure 12.2. The first three principal components of a data set span the three-dimensional hyperplane that is closest to the nobservations, and so forth. Using this interpretation, together the first Mprincipal component score vectors and the first Mprincipal component loading vectors provide the bestM-dimensional approximation (in terms of Euclidean distance) to 3In this section, we continue to assume that each column of the data matrix Xhas been centered to have mean zero—that is, the column", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 561, "start_word": 179520, "end_word": 179920, "chunk_words": 400}}, "ISLP_website::c000562": {"text": "in the left-hand panel of Figure 12.2. The first three principal components of a data set span the three-dimensional hyperplane that is closest to the nobservations, and so forth. Using this interpretation, together the first Mprincipal component score vectors and the first Mprincipal component loading vectors provide the bestM-dimensional approximation (in terms of Euclidean distance) to 3In this section, we continue to assume that each column of the data matrix Xhas been centered to have mean zero—that is, the column mean has been subtracted from each column. 510 12. Unsupervised Learning theith observation xij. This representation can be written as xij≈M/summationdisplay m=1zimφjm. (12.5) We can state this more formally by writing down an optimization prob- lem. Suppose the data matrix Xis column-centered. Out of all approxima- tions of the form xij≈/summationtextM m=1aimbjm, we could ask for the one with the smallest residual sum of squares: minimize A∈Rn×M,B∈Rp×M  p/summationdisplay j=1n/summationdisplay i=1/parenleftBigg xij−M/summationdisplay m=1aimbjm/parenrightBigg2  . (12.6) Here,Ais ann×Mmatrix whose (i, m)element is aim, andBis ap×M element whose (j, m)element is bjm. It can be shown that for any value of M, the columns of the matrices ˆAandˆBthat solve ( 12.6) are in fact the first Mprincipal components score and loading vectors. In other words, if ˆAandˆBsolve (12.6), then ˆaim=zimandˆbjm=φjm.4This means that the smallest possible value of the objective in ( 12.6) is p/summationdisplay j=1n/summationdisplay i=1/parenleftBigg xij−M/summationdisplay m=1zimφjm/parenrightBigg2 . (12.7) In summary, together the Mprincipal component score vectors and M principal component loading vectors can give a good approximation to the data when Mis sufficiently large. When M= min( n−1,p), then the representation is exact: xij=/summationtextM m=1zimφjm. 12.2.3 The Proportion of Variance Explained In Figure 12.2, we performed PCA on a three-dimensional data set (left- hand panel) and projected the data onto the first two principal component loading vectors in order to obtain a two-dimensional view of the data (i.e. the principal component score vectors; right-hand panel). We see that this two-dimensional representation of the three-dimensional data does success- fully capture the major pattern in the data: the orange, green, and cyan observations that are near each other in three-dimensional space remain nearby in the two-dimensional representation. Similarly, we have seen on theUSArrests data set that we can summarize the 50 observations and 4 variables using just the first two principal component score vectors and the first two principal component loading vectors. We can now ask a natural question: how much", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 562, "start_word": 179840, "end_word": 180240, "chunk_words": 400}}, "ISLP_website::c000563": {"text": "two-dimensional representation of the three-dimensional data does success- fully capture the major pattern in the data: the orange, green, and cyan observations that are near each other in three-dimensional space remain nearby in the two-dimensional representation. Similarly, we have seen on theUSArrests data set that we can summarize the 50 observations and 4 variables using just the first two principal component score vectors and the first two principal component loading vectors. We can now ask a natural question: how much of the information in a given data set is lost by projecting the observations onto the first few principal components? That is, how much of the variance in the data is not contained in the first few principal components? More generally, we are interested in knowing the proportion of variance explained (PVE) by eachproportion of variance explained 4Technically, the solution to ( 12.6) is not unique. Thus, it is more precise to state that any solution to ( 12.6) can be easily transformed to yield the principal components. 12.2 Principal Components Analysis 511 principal component. The total variance present in a data set (assuming that the variables have been centered to have mean zero) is defined as p/summationdisplay j=1Var(Xj)=p/summationdisplay j=11 nn/summationdisplay i=1x2 ij, (12.8) and the variance explained by the mth principal component is 1 nn/summationdisplay i=1z2 im=1 nn/summationdisplay i=1 p/summationdisplay j=1φjmxij 2 . (12.9) Therefore, the PVE of the mth principal component is given by /summationtextn i=1z2 im/summationtextp j=1/summationtextn i=1x2 ij=/summationtextn i=1/parenleftBig/summationtextp j=1φjmxij/parenrightBig2 /summationtextp j=1/summationtextn i=1x2 ij. (12.10) The PVE of each principal component is a positive quantity. In order to compute the cumulative PVE of the first Mprincipal components, we can simply sum ( 12.10) over each of the first MPVEs. In total, there are min( n−1,p)principal components, and their PVEs sum to one. In Section 12.2.2, we showed that the first Mprincipal component load- ing and score vectors can be interpreted as the best M-dimensional approx- imation to the data, in terms of residual sum of squares. It turns out that the variance of the data can be decomposed into the variance of the first M principal components plus the mean squared error of this M-dimensional approximation, as follows: p/summationdisplay j=11 nn/summationdisplay i=1x2 ij /bracehtipupleft/bracehtipdownright/bracehtipdownleft /bracehtipupright Var. of data=M/summationdisplay m=11 nn/summationdisplay i=1z2 im /bracehtipupleft/bracehtipdownright/bracehtipdownleft /bracehtipupright Var. of first MPCs+1 np/summationdisplay j=1n/summationdisplay i=1/parenleftBigg xij−M/summationdisplay m=1zimφjm/parenrightBigg2 /bracehtipupleft /bracehtipdownright/bracehtipdownleft /bracehtipupright MSE of M-dimensional approximation(12.11) The three terms in this decomposition", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 563, "start_word": 180160, "end_word": 180560, "chunk_words": 400}}, "ISLP_website::c000564": {"text": "to the data, in terms of residual sum of squares. It turns out that the variance of the data can be decomposed into the variance of the first M principal components plus the mean squared error of this M-dimensional approximation, as follows: p/summationdisplay j=11 nn/summationdisplay i=1x2 ij /bracehtipupleft/bracehtipdownright/bracehtipdownleft /bracehtipupright Var. of data=M/summationdisplay m=11 nn/summationdisplay i=1z2 im /bracehtipupleft/bracehtipdownright/bracehtipdownleft /bracehtipupright Var. of first MPCs+1 np/summationdisplay j=1n/summationdisplay i=1/parenleftBigg xij−M/summationdisplay m=1zimφjm/parenrightBigg2 /bracehtipupleft /bracehtipdownright/bracehtipdownleft /bracehtipupright MSE of M-dimensional approximation(12.11) The three terms in this decomposition are discussed in ( 12.8), (12.9), and (12.7), respectively. Since the first term is fixed, we see that by maximizing the variance of the first Mprincipal components, we minimize the mean squarederrorofthe M-dimensionalapproximation,andviceversa.Thisex- plains why principal components can be equivalently viewed as minimizing the approximation error (as in Section 12.2.2) or maximizing the variance (as in Section 12.2.1). Moreover, we can use ( 12.11) to see that the PVE defined in ( 12.10) equals 1−/summationtextp j=1/summationtextn i=1/parenleftBig xij−/summationtextM m=1zimφjm/parenrightBig2 /summationtextp j=1/summationtextn i=1x2 ij=1−RSS TSS, where TSS represents the total sum of squared elements of X, and RSS represents the residual sum of squares of the M-dimensional approxima- tion given by the principal components. Recalling the definition of R2from (3.17), this means that we can interpret the PVE as the R2of the approx- imation for Xgiven by the first Mprincipal components. 512 12. Unsupervised Learning 1.0 1.5 2.0 2.5 3.0 3.5 4.00.0 0.2 0.4 0.6 0.8 1.0Principal ComponentProp. Variance Explained1.0 1.5 2.0 2.5 3.0 3.5 4.00.0 0.2 0.4 0.6 0.8 1.0Principal ComponentCumulative Prop. Variance ExplainedFIGURE 12.3. Left:a scree plot depicting the proportion of variance explained by each of the four principal components in the USArrests data.Right:the cu- mulative proportion of variance explained by the four principal components in the USArrests data. In theUSArrests data, the first principal component explains 62.0% of the variance in the data, and the next principal component explains 24.7% ofthevariance.Together,thefirsttwoprincipalcomponentsexplainalmost 87% of the variance in the data, and the last two principal components explain only 13% of the variance. This means that Figure 12.1provides a pretty accurate summary of the data using just two dimensions. The PVE of each principal component, as well as the cumulative PVE, is shown in Figure 12.3. The left-hand panel is known as a scree plot , and will bescree plotdiscussed later in this chapter. 12.2.4 More on PCA Scaling the Variables We have already mentioned that before PCA is performed, the", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 564, "start_word": 180480, "end_word": 180880, "chunk_words": 400}}, "ISLP_website::c000565": {"text": "and the last two principal components explain only 13% of the variance. This means that Figure 12.1provides a pretty accurate summary of the data using just two dimensions. The PVE of each principal component, as well as the cumulative PVE, is shown in Figure 12.3. The left-hand panel is known as a scree plot , and will bescree plotdiscussed later in this chapter. 12.2.4 More on PCA Scaling the Variables We have already mentioned that before PCA is performed, the variables should be centered to have mean zero. Furthermore, the results obtained when we perform PCA will also depend on whether the variables have been individually scaled (each multiplied by a different constant). This is in contrast to some other supervised and unsupervised learning techniques, such as linear regression, in which scaling the variables has no effect. (In linear regression, multiplying a variable by a factor of cwill simply lead to multiplication of the corresponding coefficient estimate by a factor of 1/c, and thus will have no substantive effect on the model obtained.) For instance, Figure 12.1was obtained after scaling each of the variables to have standard deviation one. This is reproduced in the left-hand plot in Figure12.4. Why does it matter that we scaled the variables? In these data, the variables are measured in different units; Murder,Rape, andAssaultare reported as the number of occurrences per 100,000people, and UrbanPop is the percentage of the state’s population that lives in an urban area. These four variables have variances of 18.97,87.73,6945 .16, and209.5, respec- tively. Consequently, if we perform PCA on the unscaled variables, then 12.2 Principal Components Analysis 513 −3 −2 −1 0 1 2 3−3 −2 −1 0 1 2 3First Principal ComponentSecond Principal Component*************************************** ***********−0.5 0.0 0.5 −0.5 0.0 0.5MurderAssaultUrbanPopRapeScaled −100 −50 0 50 100 150−100 −50 0 50 100 150First Principal ComponentSecond Principal Component**************************************************−0.5 0.0 0.5 1.0 −0.5 0.0 0.5 1.0MurderAssaultUrbanPopRapeUnscaled FIGURE 12.4. Two principal component biplots for the USArrests data.Left: the same as Figure 12.1, with the variables scaled to have unit standard deviations. Right:principal components using unscaled data. Assault has by far the largest loading on the first principal component because it has the highest variance among the four variables. In general, scaling the variables to have standard deviation one is recommended. the first principal component loading vector will have a very large loading forAssault, since that variable has by far the highest variance. The right-", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 565, "start_word": 180800, "end_word": 181200, "chunk_words": 400}}, "ISLP_website::c000566": {"text": "the USArrests data.Left: the same as Figure 12.1, with the variables scaled to have unit standard deviations. Right:principal components using unscaled data. Assault has by far the largest loading on the first principal component because it has the highest variance among the four variables. In general, scaling the variables to have standard deviation one is recommended. the first principal component loading vector will have a very large loading forAssault, since that variable has by far the highest variance. The right- hand plot in Figure 12.4displays the first two principal components for the USArrests data set, without scaling the variables to have standard devia- tion one. As predicted, the first principal component loading vector places almost all of its weight on Assault, while the second principal component loading vector places almost all of its weight on UrbanPop . Comparing this to the left-hand plot, we see that scaling does indeed have a substantial effect on the results obtained. However, this result is simply a consequence of the scales on which the variables were measured. For instance, if Assaultwere measured in units of the number of occurrences per 100people (rather than number of oc- currences per 100,000people), then this would amount to dividing all of the elements of that variable by 1,000. Then the variance of the variable would be tiny, and so the first principal component loading vector would have a very small value for that variable. Because it is undesirable for the principal components obtained to depend on an arbitrary choice of scaling, we typically scale each variable to have standard deviation one before we perform PCA. In certain settings, however, the variables may be measured in the same units. In this case, we might not wish to scale the variables to have stan- dard deviation one before performing PCA. For instance, suppose that the variables in a given data set correspond to expression levels for pgenes. Then since expression is measured in the same “units” for each gene, we might choose not to scale the genes to each have standard deviation one. 514 12. Unsupervised Learning Uniqueness of the Principal Components While in theory the principal components need not be unique, in almost all practical settings they are (up to sign flips). This means that two different software packages will yield the same principal component loading vectors, although the signs of those loading vectors may differ. The signs may", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 566, "start_word": 181120, "end_word": 181520, "chunk_words": 400}}, "ISLP_website::c000567": {"text": "is measured in the same “units” for each gene, we might choose not to scale the genes to each have standard deviation one. 514 12. Unsupervised Learning Uniqueness of the Principal Components While in theory the principal components need not be unique, in almost all practical settings they are (up to sign flips). This means that two different software packages will yield the same principal component loading vectors, although the signs of those loading vectors may differ. The signs may differ because each principal component loading vector specifies a direction in p- dimensional space: flipping the sign has no effect as the direction does not change. (Consider Figure 6.14—the principal component loading vector is a line that extends in either direction, and flipping its sign would have no effect.) Similarly, the score vectors are unique up to a sign flip, since the variance of Zis the same as the variance of −Z. It is worth noting that when we use ( 12.5) to approximate xijwe multiply zimbyφjm. Hence, if the sign is flipped on both the loading and score vectors, the final product of the two quantities is unchanged. Deciding How Many Principal Components to Use In general, an n×pdata matrix Xhasmin( n−1,p)distinct principal components. However, we usually are not interested in all of them; rather, we would like to use just the first few principal components in order to visualize or interpret the data. In fact, we would like to use the smallest numberofprincipalcomponentsrequiredtogeta goodunderstandingofthe data. How many principal components are needed? Unfortunately, there is no single (or simple!) answer to this question. We typically decide on the number of principal components required to visualize the data by examining a scree plot , such as the one shown in the left-hand panel of Figure 12.3. We choose the smallest number of principal components that are required in order to explain a sizable amount of the variation in the data. This is done by eyeballing the scree plot, and looking for a point at which the proportion of variance explained by each subsequent principal component drops off. This drop is often referred to as anelbowin the scree plot. For instance, by inspection of Figure 12.3, one might conclude that a fair amount of variance is explained by the first two principal components, and that there is an elbow after the second component. After all, the third principal component explains less", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 567, "start_word": 181440, "end_word": 181840, "chunk_words": 400}}, "ISLP_website::c000568": {"text": "This is done by eyeballing the scree plot, and looking for a point at which the proportion of variance explained by each subsequent principal component drops off. This drop is often referred to as anelbowin the scree plot. For instance, by inspection of Figure 12.3, one might conclude that a fair amount of variance is explained by the first two principal components, and that there is an elbow after the second component. After all, the third principal component explains less than ten percent of the variance in the data, and the fourth principal component explains less than half that and so is essentially worthless. However, this type of visual analysis is inherently ad hoc. Unfortunately, there is no well-accepted objective way to decide how many principal com- ponents are enough. In fact, the question of how many principal compo- nents are enough is inherently ill-defined, and will depend on the specific area of application and the specific data set. In practice, we tend to look at the first few principal components in order to find interesting patterns in the data. If no interesting patterns are found in the first few principal components, then further principal components are unlikely to be of inter- est. Conversely, if the first few principal components are interesting, then we typically continue to look at subsequent principal components until no further interesting patterns are found. This is admittedly a subjective ap- 12.3 Missing Values and Matrix Completion 515 proach, and is reflective of the fact that PCA is generally used as a tool for exploratory data analysis. On the other hand, if we compute principal components for use in a supervised analysis, such as the principal components regression presented in Section 6.3.1, then there is a simple and objective way to determine how many principal components to use: we can treat the number of principal component score vectors to be used in the regression as a tuning parameter to be selected via cross-validation or a related approach. The comparative simplicity of selecting the number of principal components for a supervised analysis is one manifestation of the fact that supervised analyses tend to be more clearly defined and more objectively evaluated than unsupervised analyses. 12.2.5 Other Uses for Principal Components We saw in Section 6.3.1that we can perform regression using the principal component score vectors as features. In fact, many statistical techniques, such as regression, classification, and", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 568, "start_word": 181760, "end_word": 182160, "chunk_words": 400}}, "ISLP_website::c000569": {"text": "tuning parameter to be selected via cross-validation or a related approach. The comparative simplicity of selecting the number of principal components for a supervised analysis is one manifestation of the fact that supervised analyses tend to be more clearly defined and more objectively evaluated than unsupervised analyses. 12.2.5 Other Uses for Principal Components We saw in Section 6.3.1that we can perform regression using the principal component score vectors as features. In fact, many statistical techniques, such as regression, classification, and clustering, can be easily adapted to use then×Mmatrix whose columns are the first M/lessmuchpprincipal com- ponent score vectors, rather than using the full n×pdata matrix. This can lead to less noisy results, since it is often the case that the signal (as opposed to the noise) in a data set is concentrated in its first few principal components. 12.3 Missing Values and Matrix Completion Often datasets have missing values, which can be a nuisance. For example, suppose that we wish to analyze the USArrests data, and discover that 20 of the 200 values have been randomly corrupted and marked as missing. Unfortunately, the statistical learning methods that we have seen in this book cannot handle missing values. How should we proceed? We could remove the rows that contain missing observations and per- form our data analysis on the complete rows. But this seems wasteful, and depending on the fraction missing, unrealistic. Alternatively, if xijis miss- ing, then we could replace it by the mean of the jth column (using the non-missing entries to compute the mean). Although this is a common and convenient strategy, often we can do better by exploiting the correlation between the variables. In this section we show how principal components can be used to imputeimpute imputationthe missing values, through a process known as matrix completion . The matrix completioncompleted matrix can then be used in a statistical learning method, such as linear regression or LDA. Thisapproachforimputingmissingdataisappropriateifthemissingness israndom.Forexample,itissuitableifapatient’sweightismissingbecausemissing at randomthe battery of the electronic scale was flat at the time of his exam. By contrast, if the weight is missing because the patient was too heavy to climb on the scale, then this is not missing at random; the missingness is 516 12. Unsupervised Learning informative, and the approach described here for handling missing data is not suitable. Sometimes data is missing by necessity. For example, if we form a matrix of the ratings (on a scale", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 569, "start_word": 182080, "end_word": 182480, "chunk_words": 400}}, "ISLP_website::c000570": {"text": "israndom.Forexample,itissuitableifapatient’sweightismissingbecausemissing at randomthe battery of the electronic scale was flat at the time of his exam. By contrast, if the weight is missing because the patient was too heavy to climb on the scale, then this is not missing at random; the missingness is 516 12. Unsupervised Learning informative, and the approach described here for handling missing data is not suitable. Sometimes data is missing by necessity. For example, if we form a matrix of the ratings (on a scale from 1to5) thatncustomers have given to the entire Netflix catalog of pmovies, then most of the matrix will be missing, since no customer will have seen and rated more than a tiny fraction of the catalog. If we can impute the missing values well, then we will have an idea of what each customer will think of movies they have not yet seen. Hence matrix completion can be used to power recommender systems .recommender systems Principal Components with Missing Values In Section 12.2.2, we showed that the first Mprincipal component score and loading vectors provide the “best” approximation to the data matrix X, in the sense of ( 12.6). Suppose that some of the observations xijare missing. We now show how one can both impute the missing values and solve the principal component problem at the same time. We return to a modified form of the optimization problem ( 12.6), minimize A∈Rn×M,B∈Rp×M  /summationdisplay (i,j)∈O/parenleftBigg xij−M/summationdisplay m=1aimbjm/parenrightBigg2  , (12.12) whereOis the set of all observed pairs of indices (i, j), a subset of the possible n×ppairs. Once we solve this problem: • we can estimate a missing observation xijusingˆxij=/summationtextM m=1ˆaimˆbjm, whereˆaimandˆbjmare the(i, m)and(j, m)elements, respectively, of the matrices ˆAandˆBthat solve ( 12.12); and • we can (approximately) recover the Mprincipal component scores and loadings, as we did when the data were complete. It turns out that solving ( 12.12) exactly is difficult, unlike in the case of complete data: the eigen decomposition no longer applies. But the sim- ple iterative approach in Algorithm 12.1, which is demonstrated in Sec- tion12.5.2, typically provides a good solution.56 We illustrate Algorithm 12.1on theUSArrests data. There are p=4 variables and n= 50 observations (states). We first standardized the data so each variable has mean zero and standard deviation one. We then ran- domly selected 20 of the 50 states, and then for each of these we randomly set one of the four variables", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 570, "start_word": 182400, "end_word": 182800, "chunk_words": 400}}, "ISLP_website::c000571": {"text": "the eigen decomposition no longer applies. But the sim- ple iterative approach in Algorithm 12.1, which is demonstrated in Sec- tion12.5.2, typically provides a good solution.56 We illustrate Algorithm 12.1on theUSArrests data. There are p=4 variables and n= 50 observations (states). We first standardized the data so each variable has mean zero and standard deviation one. We then ran- domly selected 20 of the 50 states, and then for each of these we randomly set one of the four variables to be missing. Thus, 10% of the elements of the data matrix were missing. We applied Algorithm 12.1withM=1principal component. Figure 12.5shows that the recovery of the missing elements 5This algorithm is referred to as “Hard-Impute” in Mazumder, Hastie, and Tibshi- rani (2010) “Spectral regularization algorithms for learning large incomplete matrices”, published in Journal of Machine Learning Research , pages 2287–2322. 6Each iteration of Step 2 of this algorithm decreases the objective ( 12.14). However, the algorithm is not guaranteed to achieve the global optimum of ( 12.12). 12.3 Missing Values and Matrix Completion 517 Algorithm 12.1 Iterative Algorithm for Matrix Completion 1. Create a complete data matrix ˜Xof dimension n×pof which the (i, j)element equals ˜xij=/braceleftbiggxijif(i, j)∈O ¯xjif(i, j)/∈O, where¯xjis the average of the observed values for the jth variable in the incomplete data matrix X. Here,Oindexes the observations that are observed in X. 2. Repeat steps (a)–(c) until the objective ( 12.14) fails to decrease: (a) Solve minimize A∈Rn×M,B∈Rp×M  p/summationdisplay j=1n/summationdisplay i=1/parenleftBigg ˜xij−M/summationdisplay m=1aimbjm/parenrightBigg2  (12.13) by computing the principal components of ˜X. (b) For each element (i, j)/∈O, set˜xij←/summationtextM m=1ˆaimˆbjm. (c) Compute the objective /summationdisplay (i,j)∈O/parenleftBigg xij−M/summationdisplay m=1ˆaimˆbjm/parenrightBigg2 . (12.14) 3. Return the estimated missing entries ˜xij,(i, j)/∈O. is pretty accurate. Over 100 random runs of this experiment, the average correlation between the true and imputed values of the missing elements is 0.63, with a standard deviation of 0.11. Is this good performance? To answer this question, we can compare this correlation to what we would have gotten if we had estimated these 20 values using the complete data — that is, if we had simply computed ˆxij=zi1φj1, wherezi1andφj1are elements of the first principal component score and loading vectors of the complete data.7Using the complete data in this way results in an average correlation of 0.79 between the true and estimated values for these 20 el- ements, with a standard deviation of 0.08. Thus, our imputation method", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 571, "start_word": 182720, "end_word": 183120, "chunk_words": 400}}, "ISLP_website::c000572": {"text": "we can compare this correlation to what we would have gotten if we had estimated these 20 values using the complete data — that is, if we had simply computed ˆxij=zi1φj1, wherezi1andφj1are elements of the first principal component score and loading vectors of the complete data.7Using the complete data in this way results in an average correlation of 0.79 between the true and estimated values for these 20 el- ements, with a standard deviation of 0.08. Thus, our imputation method does worse than the method that uses all of the data ( 0.63±0.11versus 0.79±0.08), but its performance is still pretty good. (And of course, the method that uses all of the data cannot be applied in a real-world setting with missing data.) Figure12.6further indicates that Algorithm 12.1performs fairly well on this dataset. 7This is an unattainable gold standard, in the sense that with missing data, we of course cannot compute the principal components of the complete data. 518 12. Unsupervised Learning FIGURE 12.5. Missing value imputation on the USArrests data. Twenty values (10% of the total number of matrix elements) were artificially set to be missing, and then imputed via Algorithm 12.1withM=1. The figure displays the true valuexijand the imputed value ˆxijfor all twenty missing values. For each of the twenty missing values, the color indicates the variable, and the label indicates the state. The correlation between the true and imputed values is around 0.63. We close with a few observations: • TheUSArrests data has only four variables, which is on the low end for methods like Algorithm 12.1to work well. For this reason, for this demonstration we randomly set at most one variable per state to be missing, and only used M=1principal component. • In general, in order to apply Algorithm 12.1, we must select M, the number of principal components to use for the imputation. One ap- proach is to randomly leave out a few additional elements from the matrix, and select Mbased on how well those known values are re- covered. This is closely related to the validation-set approach seen in Chapter 5. Recommender Systems Digital streaming services like Netflix and Amazon use data about the con- tent that a customer has viewed in the past, as well as data from other customers, to suggest other content for the customer. As a concrete ex- ample, some years back, Netflix had customers rate each movie that they had", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 572, "start_word": 183040, "end_word": 183440, "chunk_words": 400}}, "ISLP_website::c000573": {"text": "the matrix, and select Mbased on how well those known values are re- covered. This is closely related to the validation-set approach seen in Chapter 5. Recommender Systems Digital streaming services like Netflix and Amazon use data about the con- tent that a customer has viewed in the past, as well as data from other customers, to suggest other content for the customer. As a concrete ex- ample, some years back, Netflix had customers rate each movie that they had seen with a score from 1–5. This resulted in a very big n×pmatrix for which the (i, j)element is the rating given by the ith customer to the−1.5 −1.0 −0.5 0.0 0.5 1.0 1.5−1.5 −1.0 −0.5 0.0 0.5 1.0 1.5 Original ValueImputed Value/uni25CF/uni25CF/uni25CF /uni25CF/uni25CF/uni25CF /uni25CF /uni25CF/uni25CF /uni25CF/uni25CF/uni25CF /uni25CF/uni25CF/uni25CF /uni25CF/uni25CF /uni25CF/uni25CF/uni25CFORWATN PAMOIDMD VAALTX WYMNAK UTGA MTMANY /uni25CF/uni25CF/uni25CF/uni25CFMurderAssaultUrbanPopRape 12.3 Missing Values and Matrix Completion 519 FIGURE 12.6. As described in the text, in each of 100 trials, we left out 20 elements of the USArrests dataset. In each trial, we applied Algorithm 12.1with M=1 to impute the missing elements and compute the principal com ponents. Left:For each of the 50 states, the imputed first principal component scores (averaged over 100 trials, and displayed with a standard deviation bar) are plotted against the first principal component scores computed using all the data. Right: The imputed principal component loadings (averaged over 100 trials, and displayed with a standard deviation bar) are plotted against the true principal component loadings. jth movie. One specific early example of this matrix had n= 480 ,189cus- tomersand p= 17 ,770movies.However,onaverageeachcustomerhadseen around 200 movies, so 99% of the matrix had missing elements. Table 12.2 illustrates the setup. In order to suggest a movie that a particular customer might like, Netflix neededawaytoimputethemissingvaluesofthisdatamatrix.Thekeyidea is as follows: the set of movies that the ith customer has seen will overlap with those that other customers have seen. Furthermore, some of those other customers will have similar movie preferences to the ith customer. Thus, it should be possible to use similar customers’ ratings of movies that theith customer has not seen to predict whether the ith customer will like those movies. More concretely, by applying Algorithm 12.1, we can predict the ith cus- tomer’s rating for the jth movie using ˆxij=/summationtextM m=1ˆaimˆbjm. Furthermore, we can interpret the Mcomponents in terms of “cliques” and “genres”: •ˆaimrepresents the strength with which the ith user belongs to the", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 573, "start_word": 183360, "end_word": 183760, "chunk_words": 400}}, "ISLP_website::c000574": {"text": "have similar movie preferences to the ith customer. Thus, it should be possible to use similar customers’ ratings of movies that theith customer has not seen to predict whether the ith customer will like those movies. More concretely, by applying Algorithm 12.1, we can predict the ith cus- tomer’s rating for the jth movie using ˆxij=/summationtextM m=1ˆaimˆbjm. Furthermore, we can interpret the Mcomponents in terms of “cliques” and “genres”: •ˆaimrepresents the strength with which the ith user belongs to the mth clique, where a cliqueis a group of customers that enjoys movies of themth genre; •ˆbjmrepresents the strength with which the jth movie belongs to the mthgenre. Examples of genres include Romance, Western, and Action. Principal component models similar to Algorithm 12.1are at the heart of many recommender systems. Although the data m atrices involved are−3−2−10 1 2 3−3−2−10 1 2 3 True First Principal ComponentImputed First Principal Component/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF/uni25CF 2468 1 0 1 22468 1 0 1 2True PC VariancesImputed PC Variances/uni25CF /uni25CF/uni25CF/uni25CF 520 12. Unsupervised LearningJerry MaguireOceansRoad to PerditionA Fortunate ManCatch Me If You CanDriving Miss DaisyThe Two PopesThe LaundromatCode 8The Social Network···Customer 1••••4••••• · · ·Customer 2••3•••3••3···Customer 3•2•4••••2•· · ·Customer 43••••••••• · · ·Customer 551••4••••• · · ·Customer 6•••••24••• · · ·Customer 7••5••••3•• · · ·Customer 8•••••••••• · · ·Customer 93•••5••1•• · · ·....................................TABLE 12.2.Excerpt of the Netflix movie rating data. The movies are ratedfrom 1 (worst) to 5 (best). The symbol•represents a missing value: a movie thatwas not rated by the corresponding customer.typically massive, algorithms have been developed that can exploit the highlevel of missingness in order to perform efficient computations.12.4 Clustering MethodsClusteringrefers to a very broad set of techniques for findingsubgroups, orclusteringclusters, in a data set. When we cluster the observations of a data set, weseek to partition them into distinct groups so that the observations withineach group are quite similar to each other, while observations in differentgroups are quite different from each other. Of course, to make this concrete,we must define what it means for two or more observations to besimilarordifferent. Indeed, this is often a domain-specific consideration that mustbe made based on knowledge of the data being studied.For instance, suppose that we have a set ofnobservations, each withpfeatures.Thenobservationscouldcorrespondtotissuesamplesforpatientswith breast cancer, and thepfeatures could correspond to measurementscollected for each tissue sample; these could be clinical measurements, suchas tumor stage or grade, or they could be gene expression measurements.We may have a reason to believe that", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 574, "start_word": 183680, "end_word": 184080, "chunk_words": 400}}, "ISLP_website::c000575": {"text": "to make this concrete,we must define what it means for two or more observations to besimilarordifferent. Indeed, this is often a domain-specific consideration that mustbe made based on knowledge of the data being studied.For instance, suppose that we have a set ofnobservations, each withpfeatures.Thenobservationscouldcorrespondtotissuesamplesforpatientswith breast cancer, and thepfeatures could correspond to measurementscollected for each tissue sample; these could be clinical measurements, suchas tumor stage or grade, or they could be gene expression measurements.We may have a reason to believe that there is some heterogeneity amongthentissue samples; for instance, perhaps there are a few differentun-knownsubtypes of breast cancer. Clustering could be used to find thesesubgroups. This is an unsupervised problem because we are trying to dis-cover structure—in this case, distinct clusters—on the basis of a data set.The goal in supervised problems, on the other hand, is to try to predictsome outcome vector such as survival time or response to drug treatment.Both clustering and PCA seek to simplify the data via a small numberof summaries, but their mechanisms are different: 12.4 Clustering Methods 521 • PCA looks to find a low-dimensional representation of the observa- tions that explain a good fraction of the variance; • Clustering looks to find homogeneous subgroups among the observa- tions. Another application of clustering arises in marketing. We may have ac- cess to a large number of measurements (e.g. median household income, occupation, distance from nearest urban area, and so forth) for a large number of people. Our goal is to perform market segmentation by identify- ing subgroups of people who might be more receptive to a particular form of advertising, or more likely to purchase a particular product. The task of performing market segmentation amounts to clustering the people in the data set. Since clustering is popular in many fields, there exist a great num- ber of clustering methods. In this section we focus on perhaps the two best-known clustering approaches: K-means clustering andhierarchicalK-means clusteringclustering . InK-means clustering, we seek to partition the observations hierarchical clusteringinto a pre-specified number of clusters. On the other hand, in hierarchical clustering, we do not know in advance how many clusters we want; in fact, we end up with a tree-like visual representation of the observations, called adendrogram , that allows us to view at once the clusterings obtained fordendrogrameach possible number of clusters, from 1ton. There are advantages and disadvantages to each of these clustering approaches, which we highlight", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 575, "start_word": 184000, "end_word": 184400, "chunk_words": 400}}, "ISLP_website::c000576": {"text": "InK-means clustering, we seek to partition the observations hierarchical clusteringinto a pre-specified number of clusters. On the other hand, in hierarchical clustering, we do not know in advance how many clusters we want; in fact, we end up with a tree-like visual representation of the observations, called adendrogram , that allows us to view at once the clusterings obtained fordendrogrameach possible number of clusters, from 1ton. There are advantages and disadvantages to each of these clustering approaches, which we highlight in this chapter. In general, we can cluster observations on the basis of the features in order to identify subgroups among the observations, or we can cluster fea- tures on the basis of the observations in order to discover subgroups among the features. In what follows, for simplicity we will discuss clustering obser- vations on the basis of the features, though the converse can be performed by simply transposing the data matrix. 12.4.1K-Means Clustering K-means clustering is a simple and elegant approach for partitioning a data set into Kdistinct, non-overlapping clusters. To perform K-means clustering, we must first specify the desired number of clusters K; then the K-means algorithm will assign each observation to exactly one of the K clusters. Figure 12.7shows the results obtained from performing K-means clustering on a simulated example consisting of 150observations in two dimensions, using three different values of K. TheK-means clustering procedure results from a simple and intuitive mathematicalproblem.Webeginbydefiningsomenotation.Let C1,...,C K denote sets containing the indices of the observations in each cluster. These sets satisfy two properties: 1.C1∪C2∪···∪CK={1,...,n }. In other words, each observation belongs to at least one of the Kclusters. 2.Ck∩Ck/prime=∅for allk/negationslash=k/prime. In other words, the clusters are non- overlapping: no observation belongs to more than one cluster. 522 12. Unsupervised LearningK=2K=3K=4 FIGURE 12.7. A simulated data set with 150 observations in two-dimensional space. Panels show the results of applying K-means clustering with different values ofK, the number of clusters. The color of each observation indicates the cluster to which it was assigned using the K-means clustering algorithm. Note that there is no ordering of the clusters, so the cluster coloring is arbitrary. These cluster labels were not used in clustering; instead, they are the outputs of the clustering procedure. For instance, if the ith observation is in the kth cluster, then i∈Ck. The ideabehind K-meansclusteringisthata goodclusteringisoneforwhichthe within-cluster variation is as small as possible. The within-cluster variation for cluster Ckis a measure", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 576, "start_word": 184320, "end_word": 184720, "chunk_words": 400}}, "ISLP_website::c000577": {"text": "of each observation indicates the cluster to which it was assigned using the K-means clustering algorithm. Note that there is no ordering of the clusters, so the cluster coloring is arbitrary. These cluster labels were not used in clustering; instead, they are the outputs of the clustering procedure. For instance, if the ith observation is in the kth cluster, then i∈Ck. The ideabehind K-meansclusteringisthata goodclusteringisoneforwhichthe within-cluster variation is as small as possible. The within-cluster variation for cluster Ckis a measure W(Ck)of the amount by which the observations within a cluster differ from each other. Hence we want to solve the problem minimize C1,...,C K/braceleftBiggK/summationdisplay k=1W(Ck)/bracerightBigg . (12.15) In words, this formula says that we want to partition the observations into Kclusters such that the total within-cluster variation, summed over all K clusters, is as small as possible. Solving ( 12.15) seems like a reasonable idea, but in order to make it actionable we need to define the within-cluster variation. There are many possible ways to define this concept, but by far the most common choice involves squared Euclidean distance . That is, we define W(Ck)=1 |Ck|/summationdisplay i,i/prime∈Ckp/summationdisplay j=1(xij−xi/primej)2, (12.16) where|Ck|denotes the number of observations in the kth cluster. In other words, the within-cluster variation for the kth cluster is the sum of all of the pairwise squared Euclidean distances between the observations in the kth cluster, divided by the total number of observations in the kth cluster. Combining ( 12.15) and (12.16) gives the optimization problem that defines 12.4 Clustering Methods 523 K-means clustering, minimize C1,...,C K  K/summationdisplay k=11 |Ck|/summationdisplay i,i/prime∈Ckp/summationdisplay j=1(xij−xi/primej)2  . (12.17) Now, we would like to find an algorithm to solve ( 12.17)—that is, a methodtopartitiontheobservationsinto Kclusterssuchthattheobjective of (12.17) is minimized. This is in fact a very difficult problem to solve precisely,since there are almost Knwaysto partition nobservations into K clusters. This is a huge number unless Kandnare tiny! Fortunately, a very simple algorithm can be shown to provide a local optimum—a pretty good solution—to the K-means optimization problem ( 12.17). This approach is laid out in Algorithm 12.2. Algorithm 12.2 K-Means Clustering 1. Randomly assign a number, from 1toK, to each of the observations. These serve as initial cluster assignments for the observations. 2. Iterate until the cluster assignments stop changing: (a) For each of the Kclusters, compute the cluster centroid. The kth cluster centroid is the vector of the pfeature means for the", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 577, "start_word": 184640, "end_word": 185040, "chunk_words": 400}}, "ISLP_website::c000578": {"text": "be shown to provide a local optimum—a pretty good solution—to the K-means optimization problem ( 12.17). This approach is laid out in Algorithm 12.2. Algorithm 12.2 K-Means Clustering 1. Randomly assign a number, from 1toK, to each of the observations. These serve as initial cluster assignments for the observations. 2. Iterate until the cluster assignments stop changing: (a) For each of the Kclusters, compute the cluster centroid. The kth cluster centroid is the vector of the pfeature means for the observations in the kth cluster. (b) Assign each observation to the cluster whose centroid is closest (whereclosestis defined using Euclidean distance). Algorithm 12.2isguaranteedtodecreasethevalueoftheobjective( 12.17) at each step. To understand why, the following identity is illuminating: 1 |Ck|/summationdisplay i,i/prime∈Ckp/summationdisplay j=1(xij−xi/primej)2=2/summationdisplay i∈Ckp/summationdisplay j=1(xij−¯xkj)2, (12.18) where¯xkj=1 |Ck|/summationtext i∈Ckxijis the mean for feature jin cluster Ck. In Step 2(a) the cluster means for each feature are the constants that minimize the sum-of-squared deviations, and in Step 2(b), reallocating the observations can only improve ( 12.18). This means that as the algorithm is run, the clustering obtained will continually improve until the result no longer changes; the objective of ( 12.17) will never increase. When the result no longer changes, a local optimum has been reached. Figure 12.8shows the progression of the algorithm on the toy example from Figure 12.7. K-means clustering derives its name from the fact that in Step 2(a), the cluster centroids are computed as the mean of the observations assigned to each cluster. Because the K-means algorithm finds a local rather than a global opti- mum, the results obtained will depend on the initial (random) cluster as- signment of each observation in Step 1 of Algorithm 12.2. For this reason, it is important to run the algorithm multiple times from different random 524 12. Unsupervised LearningDataStep 1Iteration 1, Step 2a Iteration 1, Step 2bIteration 2, Step 2aFinal Results FIGURE 12.8. The progress of the K-means algorithm on the example of Figure12.7withK=3.Top left: the observations are shown. Top center: in Step 1 of the algorithm, each observation is randomly assigned to a cluster. Top right:in Step 2(a), the cluster centroids are computed. These are shown as large colored disks. Initially the centroids are almost completely overlapping because the initial cluster assignments were chosen at random. Bottom left: in Step 2(b), each observation is assigned to the nearest centroid. Bottom center: Step 2(a) is once again performed, leading to new cluster centroids. Bottom", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 578, "start_word": 184960, "end_word": 185360, "chunk_words": 400}}, "ISLP_website::c000579": {"text": "left: the observations are shown. Top center: in Step 1 of the algorithm, each observation is randomly assigned to a cluster. Top right:in Step 2(a), the cluster centroids are computed. These are shown as large colored disks. Initially the centroids are almost completely overlapping because the initial cluster assignments were chosen at random. Bottom left: in Step 2(b), each observation is assigned to the nearest centroid. Bottom center: Step 2(a) is once again performed, leading to new cluster centroids. Bottom right: the results obtained after ten iterations. initial configurations. Then one selects the bestsolution, i.e. that for which the objective ( 12.17) is smallest. Figure 12.9shows the local optima ob- tained by running K-means clustering six times using six different initial cluster assignments, using the toy data from Figure 12.7. In this case, the best clustering is the one with an objective value of 235.8. As we have seen, to perform K-means clustering, we must decide how many clusters we expect in the data. The problem of selecting Kis far from simple. This issue, along with other practical considerations that arise in performing K-means clustering, is addressed in Section 12.4.3. 12.4 Clustering Methods 525320.9235.8235.8 235.8235.8310.9 FIGURE 12.9. K-means clustering performed six times on the data from Figure12.7withK=3, each time with a different random assignment of the observations in Step 1 of the K-means algorithm. Above each plot is the value of the objective ( 12.17). Three different local optima were obtained, one of which resulted in a smaller value of the objective and provides better separation between the clusters. Those labeled in red all achieved the same best solution, with an objective value of 235.8. 12.4.2 Hierarchical Clustering One potential disadvantage of K-means clustering is that it requires us to pre-specify the number of clusters K.Hierarchical clustering is an alter- native approach which does not require that we commit to a particular choice of K. Hierarchical clustering has an added advantage over K-means clustering in that it results in an attractive tree-based representation of the observations, called a dendrogram . In this section, we describe bottom-up oragglomerative clustering.bottom-up agglomerativeThis is the most common type of hierarchical clustering, and refers to the fact that a dendrogram (generally depicted as an upside-down tree; see Figure12.11) is built starting from the leaves and combining clusters up to thetrunk.Wewillbeginwithadiscussionofhowtointerpretadendrogram 526 12. Unsupervised Learning −6 −4 −202−2024 X1X2 FIGURE 12.10. Forty-five observations generated in two-dimensional", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 579, "start_word": 185280, "end_word": 185680, "chunk_words": 400}}, "ISLP_website::c000580": {"text": "advantage over K-means clustering in that it results in an attractive tree-based representation of the observations, called a dendrogram . In this section, we describe bottom-up oragglomerative clustering.bottom-up agglomerativeThis is the most common type of hierarchical clustering, and refers to the fact that a dendrogram (generally depicted as an upside-down tree; see Figure12.11) is built starting from the leaves and combining clusters up to thetrunk.Wewillbeginwithadiscussionofhowtointerpretadendrogram 526 12. Unsupervised Learning −6 −4 −202−2024 X1X2 FIGURE 12.10. Forty-five observations generated in two-dimensional space. In reality there are three distinct classes, shown in separate colors. However, we will treat these class labels as unknown and will seek to cluster the observations in order to discover the classes from the data. and then discuss how hierarchical clustering is actually performed—that is, how the dendrogram is built. Interpreting a Dendrogram We begin with the simulated data set shown in Figure 12.10, consisting of 45observations in two-dimensional space. The data were generated from a three-class model; the true class labels for each observation are shown in distinct colors. However, suppose that the data were observed without the class labels, and that we wanted to perform hierarchical clustering of the data. Hierarchical clustering (with complete linkage, to be discussed later) yields the result shown in the left-hand panel of Figure 12.11. How can we interpret this dendrogram? In the left-hand panel of Figure 12.11, eachleafof the dendrogram rep- resents one of the 45observations in Figure 12.10. However, as we move up the tree, some leaves begin to fuseinto branches. These correspond to observations that are similar to each other. As we move higher up the tree, branches themselves fuse, either with leaves or other branches. The earlier (lower in the tree) fusions occur, the more similar the groups of observa- tions are to each other. On the other hand, observations that fuse later (near the top of the tree) can be quite different. In fact, this statement can be made precise: for any two observations, we can look for the point in the tree where branches containing those two observations are first fused. The height of this fusion, as measured on the vertical axis, indicates how different the two observations are. Thus, observations that fuse at the very bottom of the tree are quite similar to each other, whereas observations that fuse close to the top of the tree will tend to be quite different. This highlights", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 580, "start_word": 185600, "end_word": 186000, "chunk_words": 400}}, "ISLP_website::c000581": {"text": "can be made precise: for any two observations, we can look for the point in the tree where branches containing those two observations are first fused. The height of this fusion, as measured on the vertical axis, indicates how different the two observations are. Thus, observations that fuse at the very bottom of the tree are quite similar to each other, whereas observations that fuse close to the top of the tree will tend to be quite different. This highlights a very important point in interpreting dendrograms that is often misunderstood. Consider the left-hand panel of Figure 12.12, which shows a simple dendrogram obtained from hierarchically clustering nine 12.4 Clustering Methods 5270246810 0246810 0246810 FIGURE 12.11. Left:dendrogram obtained from hierarchically clustering the data from Figure 12.10with complete linkage and Euclidean distance. Center:the dendrogram from the left-hand panel, cut at a height of nine (indicated by the dashed line). This cut results in two distinct clusters, shown in different colors. Right:the dendrogram from the left-hand panel, now cut at a height of five. This cut results in three distinct clusters, shown in different colors. Note that the colors were not used in clustering, but are simply used for display purposes in this figure. observations. One can see that observations 5and7are quite similar to each other, since they fuse at the lowest point on the dendrogram. Obser- vations1and6are also quite similar to each other. However, it is tempting but incorrect to conclude from the figure that observations 9and2are quite similar to each other on the basis that they are located near each other on the dendrogram. In fact, based on the information contained in the dendrogram, observation 9is no more similar to observation 2than it is to observations 8,5,and7. (This can be seen from the right-hand panel of Figure 12.12, in which the raw data are displayed.) To put it mathe- matically, there are 2n−1possible reorderings of the dendrogram, where n is the number of leaves. This is because at each of the n−1points where fusions occur, the positions of the two fused branches could be swapped without affecting the meaning of the dendrogram. Therefore, we cannot draw conclusions about the similarity of two observations based on their proximity along the horizontal axis . Rather, we draw conclusions about the similarity of two observations based on the location on the vertical axis where branches containing those two observations first are fused. Now", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 581, "start_word": 185920, "end_word": 186320, "chunk_words": 400}}, "ISLP_website::c000582": {"text": "the number of leaves. This is because at each of the n−1points where fusions occur, the positions of the two fused branches could be swapped without affecting the meaning of the dendrogram. Therefore, we cannot draw conclusions about the similarity of two observations based on their proximity along the horizontal axis . Rather, we draw conclusions about the similarity of two observations based on the location on the vertical axis where branches containing those two observations first are fused. Now that we understand how to interpret the left-hand panel of Fig- ure12.11, we can move on to the issue of identifying clusters on the basis of a dendrogram. In order to do this, we make a horizontal cut across the dendrogram, as shown in the center and right-hand panels of Figure 12.11. The distinct sets of observations beneath the cut can be interpreted as clus- ters.InthecenterpanelofFigure 12.11,cuttingthedendrogramataheight of nine results in two clusters, shown in distinct colors. In the right-hand panel, cutting the dendrogram at a height of five results in three clusters. Further cuts can be made as one descends the dendrogram in order to ob- tain any number of clusters, between 1 (corresponding to no cut) and n 528 12. Unsupervised Learning3416928570.0 0.5 1.0 1.5 2.0 2.5 3.0123456789 −1.5 −1.0 −0.5 0.0 0.5 1.0−1.5 −1.0 −0.5 0.0 0.5X1X2 FIGURE 12.12. An illustration of how to properly interpret a dendrogram with nine observations in two-dimensional space. Left:a dendrogram generated using Euclidean distance and complete linkage. Observations 5and7are quite similar to each other, as are observations 1and6. However, observation 9isno more similar to observation 2than it is to observations 8,5,and7, even though observations 9and2are close together in terms of horizontal distance. This is because observations 2,8,5,and7all fuse with observation 9at the same height, approximately 1.8.Right:the raw data used to generate the dendrogram can be used to confirm that indeed, observation 9is no more similar to observation 2 than it is to observations 8,5,and7. (corresponding to a cut at height 0, so that each observation is in its own cluster). In other words, the height of the cut to the dendrogram serves the same role as the KinK-means clustering: it controls the number of clusters obtained. Figure12.11therefore highlights a very attractive aspect of hierarchical clustering: one single dendrogram can be used to obtain any number of clusters. In practice, people often look at the dendrogram and select by eye a sensible", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 582, "start_word": 186240, "end_word": 186640, "chunk_words": 400}}, "ISLP_website::c000583": {"text": "to observations 8,5,and7. (corresponding to a cut at height 0, so that each observation is in its own cluster). In other words, the height of the cut to the dendrogram serves the same role as the KinK-means clustering: it controls the number of clusters obtained. Figure12.11therefore highlights a very attractive aspect of hierarchical clustering: one single dendrogram can be used to obtain any number of clusters. In practice, people often look at the dendrogram and select by eye a sensible number of clusters, based on the heights of the fusion and the number of clusters desired. In the case of Figure 12.11, one might choose to select either two or three clusters. However, often the choice of where to cut the dendrogram is not so clear. The term hierarchical refers to the fact that clusters obtained by cutting the dendrogram at a given height are necessarily nested within the clusters obtained by cutting the dendrogram at any greater height. However, on an arbitrary data set, this assumption of hierarchical structure might be unrealistic. For instance, suppose that our observations correspond to a group of men and women, evenly split among Americans, Japanese, and French. We can imagine a scenario in which the best division into two groups might split these people by gender, and the best division into three groups might split them by nationality. In this case, the true clusters are not nested, in the sense that the best division into three groups does not result from taking the best division into two groups and splitting up one of those groups. Consequently, this situation could not be well-represented by hierarchical clustering. Due to situations such as this one, hierarchical clustering can sometimes yield worse(i.e. less accurate) results than K- means clustering for a given number of clusters. 12.4 Clustering Methods 529 Algorithm 12.3 Hierarchical Clustering 1. Begin with nobservations and a measure (such as Euclidean dis- tance) of all the/parenleftbign 2/parenrightbig =n(n−1)/2pairwise dissimilarities. Treat each observation as its own cluster. 2. Fori=n, n−1,...,2: (a) Examine all pairwise inter-cluster dissimilarities among the i clusters and identify the pair of clusters that are least dissimilar (that is, most similar). Fuse these two clusters. The dissimilarity between these two clusters indicates the height in the dendro- gram at which the fusion should be placed. (b) Compute the new pairwise inter-cluster dissimilarities among thei−1remaining clusters. The Hierarchical Clustering Algorithm The hierarchical clustering dendrogram", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 583, "start_word": 186560, "end_word": 186960, "chunk_words": 400}}, "ISLP_website::c000584": {"text": "the/parenleftbign 2/parenrightbig =n(n−1)/2pairwise dissimilarities. Treat each observation as its own cluster. 2. Fori=n, n−1,...,2: (a) Examine all pairwise inter-cluster dissimilarities among the i clusters and identify the pair of clusters that are least dissimilar (that is, most similar). Fuse these two clusters. The dissimilarity between these two clusters indicates the height in the dendro- gram at which the fusion should be placed. (b) Compute the new pairwise inter-cluster dissimilarities among thei−1remaining clusters. The Hierarchical Clustering Algorithm The hierarchical clustering dendrogram is obtained via an extremely simple algorithm.Webeginbydefiningsomesortof dissimilarity measurebetween each pair of observations. Most often, Euclidean distance is used; we will discuss the choice of dissimilarity measure later in this chapter. The algo- rithm proceeds iteratively. Starting out at the bottom of the dendrogram, each of the nobservations is treated as its own cluster. The two clusters that are most similar to each other are then fusedso that there now are n−1clusters. Next the two clusters that are most similar to each other are fused again, so that there now are n−2clusters. The algorithm proceeds in this fashion until all of the observations belong to one single cluster, and the dendrogram is complete. Figure 12.13depicts the first few steps of the algorithm, for the data from Figure 12.12. To summarize, the hierarchical clustering algorithm is given in Algorithm 12.3. This algorithm seems simple enough, but one issue has not been ad- dressed. Consider the bottom right panel in Figure 12.13. How did we determine that the cluster {5,7}should be fused with the cluster {8}? We have a concept of the dissimilarity between pairs of observations, but how do we define the dissimilarity between two clusters if one or both of the clusters contains multiple observations? The concept of dissimilarity between a pair of observations needs to be extended to a pair of groups of observations . This extension is achieved by developing the notion of linkage, which defines the dissimilarity between two groups of observa-linkagetions. The four most common types of linkage— complete ,average,single, andcentroid—are briefly described in Table 12.3. Average, complete, and single linkage are most popular among statisticians. Average and complete linkage are generally preferred over single linkage, as they tend to yield more balanced dendrograms. Centroid linkage is often used in genomics, but suffers from a major drawback in that an inversion can occur, wherebyinversiontwo clusters are fused at a height beloweither of the individual clusters in", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 584, "start_word": 186880, "end_word": 187280, "chunk_words": 400}}, "ISLP_website::c000585": {"text": "between two groups of observa-linkagetions. The four most common types of linkage— complete ,average,single, andcentroid—are briefly described in Table 12.3. Average, complete, and single linkage are most popular among statisticians. Average and complete linkage are generally preferred over single linkage, as they tend to yield more balanced dendrograms. Centroid linkage is often used in genomics, but suffers from a major drawback in that an inversion can occur, wherebyinversiontwo clusters are fused at a height beloweither of the individual clusters in thedendrogram.Thiscanleadtodifficultiesinvisualizationaswellasinin- terpretation of the dendrogram. The dissimilarities computed in Step 2(b) 530 12. Unsupervised Learning Linkage Description CompleteMaximal intercluster dissimilarity. Compute all pairwise dissimilarities between the observations in cluster A and the observations in cluster B, and record the largestof these dis- similarities. SingleMinimal intercluster dissimilarity. Compute all pairwise dis- similarities between the observations in cluster A and the observations in cluster B, and record the smallest of these dissimilarities. Single linkage can result in extended, trailing clustersinwhichsingleobservationsarefusedone-at-a-time. AverageMean intercluster dissimilarity. Compute all pairwise dis- similarities between the observations in cluster A and the observations in cluster B, and record the averageof these dissimilarities. CentroidDissimilarity between the centroid for cluster A (a mean vector of length p) and the centroid for cluster B. Centroid linkage can result in undesirable inversions . TABLE 12.3. A summary of the four most commonly-used types of linkage in hierarchical clustering. of the hierarchical clustering algorithm will depend on the type of linkage used, as well as on the choice of dissimilarity measure. Hence, the resulting dendrogram typically depends quite strongly on the type of linkage used, as is shown in Figure 12.14. Choice of Dissimilarity Measure Thus far, the examples in this chapter have used Euclidean distance as the dissimilarity measure. But sometimes other dissimilarity measures might be preferred. For example, correlation-based distance considers two obser- vations to be similar if their features are highly correlated, even though the observed values may be far apart in terms of Euclidean distance. This is an unusual use of correlation, which is normally computed between vari- ables; here it is computed between the observation profiles for each pair of observations. Figure 12.15illustrates the difference between Euclidean and correlation-based distance. Correlation-based distance focuses on the shapes of observation profiles rather than their magnitudes. The choice of dissimilarity measure is very important, as it has a strong effect on the resulting dendrogram. In general, careful attention should be paid", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 585, "start_word": 187200, "end_word": 187600, "chunk_words": 400}}, "ISLP_website::c000586": {"text": "apart in terms of Euclidean distance. This is an unusual use of correlation, which is normally computed between vari- ables; here it is computed between the observation profiles for each pair of observations. Figure 12.15illustrates the difference between Euclidean and correlation-based distance. Correlation-based distance focuses on the shapes of observation profiles rather than their magnitudes. The choice of dissimilarity measure is very important, as it has a strong effect on the resulting dendrogram. In general, careful attention should be paid to the type of data being clustered and the scientific question at hand. These considerations should determine what type of dissimilarity measure is used for hierarchical clustering. For instance, consider an online retailer interested in clustering shoppers based on their past shopping histories. The goal is to identify subgroups ofsimilarshoppers, so that shoppers within each subgroup can be shown items and advertisements that are particularly likely to interest them. Sup- pose the data takes the form of a matrix where the rows are the shoppers and the columns are the items available for purchase; the elements of the data matrix indicate the number of times a given shopper has purchased a 12.4 Clustering Methods 531 123456789 −1.5 −1.0 −0.5 0.0 0.5 1.0−1.5 −1.0 −0.5 0.0 0.5123456789 −1.5 −1.0 −0.5 0.0 0.5 1.0−1.5 −1.0 −0.5 0.0 0.5 123456789 −1.5 −1.0 −0.5 0.0 0.5 1.0−1.5 −1.0 −0.5 0.0 0.5123456789 −1.5 −1.0 −0.5 0.0 0.5 1.0−1.5 −1.0 −0.5 0.0 0.5X1X1X1X1X2X2 X2X2 FIGURE 12.13. An illustration of the first few steps of the hierarchical clustering algorithm, using the data from Figure 12.12, with complete linkage and Euclidean distance. Top Left: initially, there are nine distinct clusters, {1},{2},...,{9}.Top Right: the two clusters that are closest together, {5}and {7}, are fused into a single cluster. Bottom Left: the two clusters that are closest together, {6}and{1}, are fused into a single cluster. Bottom Right: the two clus- ters that are closest together using complete linkage ,{8}and the cluster {5,7}, are fused into a single cluster. given item (i.e. a 0if the shopper has never purchased this item, a 1if the shopper has purchased it once, etc.) What type of dissimilarity measure should be used to cluster the shoppers? If Euclidean distance is used, then shoppers who have bought very few items overall (i.e. infrequent users of the online shopping site) will be clustered together. This may not be desir- able.Ontheotherhand,ifcorrelation-baseddistanceisused,thenshoppers with similar preferences (e.g. shoppers who have", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 586, "start_word": 187520, "end_word": 187920, "chunk_words": 400}}, "ISLP_website::c000587": {"text": "cluster {5,7}, are fused into a single cluster. given item (i.e. a 0if the shopper has never purchased this item, a 1if the shopper has purchased it once, etc.) What type of dissimilarity measure should be used to cluster the shoppers? If Euclidean distance is used, then shoppers who have bought very few items overall (i.e. infrequent users of the online shopping site) will be clustered together. This may not be desir- able.Ontheotherhand,ifcorrelation-baseddistanceisused,thenshoppers with similar preferences (e.g. shoppers who have bought items A and B but never items C or D) will be clustered together, even if some shoppers with these preferences are higher-volume shoppers than others. Therefore, for this application, correlation-based distance may be a better choice. Inadditiontocarefullyselectingthedissimilaritymeasureused,onemust also consider whether or not the variables should be scaled to have stan- darddeviationonebeforethedissimilaritybetweentheobservationsiscom- puted. To illustrate this point, we continue with the online shopping ex- 532 12. Unsupervised LearningAverage LinkageComplete LinkageSingle Linkage FIGURE 12.14. Average, complete, and single linkage applied to an example data set. Average and complete linkage tend to yield more balanced clusters. ample just described. Some items may be purchased more frequently than others; for instance, a shopper might buy ten pairs of socks a year, but a computer very rarely. High-frequency purchases like socks therefore tend to have a much larger effect on the inter-shopper dissimilarities, and hence on the clustering ultimately obtained, than rare purchases like computers. This may not be desirable. If the variables are scaled to have standard de- viation one before the inter-observation dissimilarities are computed, then each variable will in effect be given equal importance in the hierarchical clustering performed. We might also want to scale the variables to have standard deviation one if they are measured on different scales; otherwise, the choice of units (e.g. centimeters versus kilometers) for a particular vari- able will greatly affect the dissimilarity measure obtained. It should come as no surprise that whether or not it is a good decision to scale the variables before computing the dissimilarity measure depends on the application at hand. An example is shown in Figure 12.16. We note that the issue of whether or not to scale the variables before performing clustering applies toK-means clustering as well. 12.4.3 Practical Issues in Clustering Clustering can be a very useful tool for data analysis in the unsupervised setting. However, there are a number of issues that arise in performing clustering. We", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 587, "start_word": 187840, "end_word": 188240, "chunk_words": 400}}, "ISLP_website::c000588": {"text": "it is a good decision to scale the variables before computing the dissimilarity measure depends on the application at hand. An example is shown in Figure 12.16. We note that the issue of whether or not to scale the variables before performing clustering applies toK-means clustering as well. 12.4.3 Practical Issues in Clustering Clustering can be a very useful tool for data analysis in the unsupervised setting. However, there are a number of issues that arise in performing clustering. We describe some of these issues here. Small Decisions with Big Consequences In order to perform clustering, some decisions must be made. 12.4 Clustering Methods 533 510152005 10 15 20 Variable IndexObservation 1Observation 2Observation 3 123FIGURE 12.15.Three observations with measurements on 20 variables areshown. Observations 1 and 3 have similar values for each variable and so thereis a small Euclidean distance between them. But they are very weakly correlated,so they have a large correlation-based distance. On the other hand, observations1 and 2 have quite different values for each variable, and so there is a largeEuclidean distance between them. But they are highly correlated, so there is asmall correlation-based distance between them.• Shouldtheobservationsorfeaturesfirstbestandardizedinsomeway?For instance, maybe the variables should be scaled to have standarddeviation one.• In the case of hierarchical clustering,–What dissimilarity measure should be used?–What type of linkage should be used?–Whereshouldwecutthedendrograminordertoobtainclusters?• In the case ofK-means clustering, how many clusters should we lookfor in the data?Each of these decisions can have a strong impact on the results obtained.In practice, we try several different choices, and look for the one withthe most useful or interpretable solution. With these methods, there is nosingle right answer—any solution that exposes some interesting aspects ofthe data should be considered.Validating the Clusters ObtainedAny time clustering is performed on a data set we will find clusters. But wereally want to know whether the clusters that have been found representtrue subgroups in the data, or whether they are simply a result ofclusteringthe noise. For instance, if we were to obtain an independent set of observa-tions, then would those observations also display the same set of clusters?This is a hard question to answer. There exist a number of techniques forassigning a p-value to a cluster in order to assess whether there is more 534 12. Unsupervised Learning Socks Computers0 2 4 6 8 10Socks Computers0.0 0.2 0.4 0.6 0.8 1.0 1.2Socks Computers0500 1000 1500FIGURE 12.16. An eclectic online retailer sells two items:", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 588, "start_word": 188160, "end_word": 188560, "chunk_words": 400}}, "ISLP_website::c000589": {"text": "ofclusteringthe noise. For instance, if we were to obtain an independent set of observa-tions, then would those observations also display the same set of clusters?This is a hard question to answer. There exist a number of techniques forassigning a p-value to a cluster in order to assess whether there is more 534 12. Unsupervised Learning Socks Computers0 2 4 6 8 10Socks Computers0.0 0.2 0.4 0.6 0.8 1.0 1.2Socks Computers0500 1000 1500FIGURE 12.16. An eclectic online retailer sells two items: socks and computers. Left:the number of pairs of socks, and computers, purchased by eight online shop- pers is displayed. Each shopper is shown in a different color. If inter-observation dissimilarities are computed using Euclidean distance on the raw variables, then the number of socks purchased by an individual will drive the dissimilarities ob- tained, and the number of computers purchased will have little effect. This might be undesirable, since (1) computers are more expensive than socks and so the online retailer may be more interested in encouraging shoppers to buy computers than socks, and (2) a large difference in the number of socks purchased by two shoppers may be less informative about the shoppers’ overall shopping preferences than a small difference in the number of computers purchased. Center:the same data are shown, after scaling each variable by its standard deviation. Now the two products will have a comparable effect on the inter-observation dissimilarities obtained. Right:the same data are displayed, but now the y-axis represents the number of dollars spent by each online shopper on socks and on computers. Since computers are much more expensive than socks, now computer purchase history will drive the inter-observation dissimilarities obtained. evidence for the cluster than one would expect due to chance. However, there has been no consensus on a single best approach. More details can be found in ESL.8 Other Considerations in Clustering BothK-means and hierarchical clustering will assign each observation to a cluster. However, sometimes this might not be appropriate. For instance, suppose that most of the observations truly belong to a small number of (unknown) subgroups, and a small subset of the observations are quite different from each other and from all other observations. Then since K- means and hierarchical clustering force everyobservation into a cluster, the clusters found may be heavily distorted due to the presence of outliers that do not belong to any cluster. Mixture models are an attractive approach", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 589, "start_word": 188480, "end_word": 188880, "chunk_words": 400}}, "ISLP_website::c000590": {"text": "However, sometimes this might not be appropriate. For instance, suppose that most of the observations truly belong to a small number of (unknown) subgroups, and a small subset of the observations are quite different from each other and from all other observations. Then since K- means and hierarchical clustering force everyobservation into a cluster, the clusters found may be heavily distorted due to the presence of outliers that do not belong to any cluster. Mixture models are an attractive approach for accommodating the presence of such outliers. These amount to a soft version of K-means clustering, and are described in ESL. 8ESL:The Elements of Statistical Learning by Hastie, Tibshirani and Friedman. 12.5 Lab: Unsupervised Learning 535In addition, clustering methods generally are not very robust to pertur-bations to the data. For instance, suppose that we clusternobservations,and then cluster the observations again after removing a subset of thenobservations at random. One would hope that the two sets of clusters ob-tained would be quite similar, but often this is not the case!A Tempered Approach to Interpreting the Results of ClusteringWe have described some of the issues associated with clustering. However,clustering can be a very useful and valid statistical tool if used properly. Wementioned that small decisions in how clustering is performed, such as howthe data are standardized and what type of linkage is used, can have a largeeffect on the results. Therefore, we recommend performing clustering withdifferent choices of these parameters, and looking at the full set of resultsin order to see what patterns consistently emerge. Since clustering can benon-robust, we recommend clustering subsets of the data in order to get asense of the robustness of the clusters obtained. Most importantly, we mustbe careful about how the results of a clustering analysis are reported. Theseresults should not be taken as the absolute truth about a data set. Rather,they should constitute a starting point for the development of a scientifichypothesis and further study, preferably on an independent data set.12.5 Lab: Unsupervised LearningIn this lab we demonstrate PCA and clustering on several datasets. As inother labs, we import some of our libraries at this top level. This makesthe code more readable, as scanning the first few lines of the notebook tellus what libraries are used in this notebook.In[1]:import numpy as npimport pandas as pdimport matplotlib.pyplot as pltfrom statsmodels.datasets import get_rdatasetfrom sklearn.decomposition import PCAfrom sklearn.preprocessing import StandardScalerfrom ISLP import load_dataWe also collect the new imports needed", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 590, "start_word": 188800, "end_word": 189200, "chunk_words": 400}}, "ISLP_website::c000591": {"text": "on an independent data set.12.5 Lab: Unsupervised LearningIn this lab we demonstrate PCA and clustering on several datasets. As inother labs, we import some of our libraries at this top level. This makesthe code more readable, as scanning the first few lines of the notebook tellus what libraries are used in this notebook.In[1]:import numpy as npimport pandas as pdimport matplotlib.pyplot as pltfrom statsmodels.datasets import get_rdatasetfrom sklearn.decomposition import PCAfrom sklearn.preprocessing import StandardScalerfrom ISLP import load_dataWe also collect the new imports needed for this lab.In[2]:from sklearn.cluster import \\(KMeans,AgglomerativeClustering)from scipy.cluster.hierarchy import \\(dendrogram,cut_tree)from ISLP.cluster import compute_linkage12.5.1 Principal Components AnalysisIn this lab, we perform PCA onUSArrests, a data set in theRcomputingenvironment. We retrieve the data usingget_rdataset(), which can fetchget_rdataset() 536 12. Unsupervised Learningdata from many standardRpackages.The rows of the data set contain the 50 states, in alphabetical order.In[3]:USArrests = get_rdataset('USArrests').dataUSArrestsOut[3]:Murder Assault UrbanPop RapeAlabama 13.223658 21.2Alaska 10.026348 44.5Arizona 8.129480 31.0... ............Wisconsin 2.65366 10.8Wyoming 6.816160 15.6The columns of the data set contain the four variables.In[4]:USArrests.columnsOut[4]:Index(['Murder','Assault','UrbanPop','Rape'],dtype='object')We first briefly examine the data. We notice that the variables havevastly different means.In[5]:USArrests.mean()Out[5]:Murder 7.788Assault 170.760UrbanPop 65.540Rape21.232dtype: float64Dataframeshaveseveralusefulmethodsforcomputingcolumn-wisesum-maries. We can also examine the variance of the four variables using thevar()method.In[6]:USArrests.var()Out[6]:Murder 18.970465Assault 6945.165714UrbanPop 209.518776Rape87.729159dtype: float64Not surprisingly, the variables also have vastly different variances. TheUrbanPopvariable measures the percentage of the population in each stateliving in an urban area, which is not a comparable number to the number ofrapes in each state per 100,000 individuals. PCA looks for derived variablesthat account for most of the variance in the data set. If we do not scale thevariables before performing PCA, then the principal components wouldmostly be driven by theAssaultvariable, since it has by far the largestvariance. So if the variables are measured in different units or vary widelyin scale, it is recommended to standardize the variables to have standarddeviation one before performing PCA. Typically we set the means to zeroas well. 12.5 Lab: Unsupervised Learning 537This scaling can be done via theStandardScaler()transform importedabove. We firstfitthe scaler, which computes the necessary means andstandard deviations and then apply it to our data using thetransformmethod. As before, we combine these steps using thefit_transform()method.In[7]:scaler = StandardScaler(with_std=True,with_mean=True)USArrests_scaled = scaler.fit_transform(USArrests)Having scaled the data, we can then perform principal components analysisusing thePCA()transform from thesklearn.decompositionpackage.PCA()In[8]:pcaUS = PCA()(By default, thePCA()transform centers the variables to have mean zerothough it does not scale them.) The transformpcaUScan be used to findthe PCAscoresreturned byfit(). Once thefitmethod has been called,thepcaUSobject also contains a number of useful quantities.In[9]:pcaUS.fit(USArrests_scaled)After fitting, themean_attribute corresponds to", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 591, "start_word": 189120, "end_word": 189520, "chunk_words": 400}}, "ISLP_website::c000592": {"text": "computes the necessary means andstandard deviations and then apply it to our data using thetransformmethod. As before, we combine these steps using thefit_transform()method.In[7]:scaler = StandardScaler(with_std=True,with_mean=True)USArrests_scaled = scaler.fit_transform(USArrests)Having scaled the data, we can then perform principal components analysisusing thePCA()transform from thesklearn.decompositionpackage.PCA()In[8]:pcaUS = PCA()(By default, thePCA()transform centers the variables to have mean zerothough it does not scale them.) The transformpcaUScan be used to findthe PCAscoresreturned byfit(). Once thefitmethod has been called,thepcaUSobject also contains a number of useful quantities.In[9]:pcaUS.fit(USArrests_scaled)After fitting, themean_attribute corresponds to the means of the vari-ables. In this case, since we centered and scaled the data withscaler()themeans will all be 0.In[10]:pcaUS.mean_Out[10]:array([-0., 0., -0., 0.])The scores can be computed using thetransform()method ofpcaUSafterit has been fit.In[11]:scores = pcaUS.transform(USArrests_scaled)We will plot these scores a bit further down. Thecomponents_attributeprovides the principal component loadings: each row ofpcaUS.components_contains the corresponding principal component loading vector.In[12]:pcaUS.components_Out[12]:array([[ 0.53589947, 0.58318363, 0.27819087, 0.54343209],[0 . 4 1 8 1 8 0 8 7 , 0 . 1 8 7 9 8 5 6,- 0 . 8 7 2 8 0 6 1 9 ,- 0 . 1 6 7 3 1 8 6 4 ] ,[-0.34123273, -0.26814843, -0.37801579, 0.81777791],[0 . 6 4 9 2 2 7 8,- 0 . 7 4 3 4 0 7 4 8 , 0 . 1 3 3 8 7 7 7 3 , 0 . 0 8 9 0 2 4 3 2 ] ] )Thebiplotis a common visualization method used with PCA. It is notbuilt in as a standard part ofsklearn, though there are python packagesthat do produce such plots. Here we make a simple biplot manually.In[13]:i, j = 0, 1#w h i c hc o m p o n e n t sfig, ax = plt.subplots(1, 1, figsize=(8, 8))ax.scatter(scores[:,0], scores[:,1])ax.set_xlabel('PC%d'%( i + 1 ) )ax.set_ylabel('PC%d'%( j + 1 ) )for k in range(pcaUS.components_.shape[1]): 538 12. Unsupervised Learning ax.arrow(0, 0, pcaUS.components_[i,k], pcaUS.components_[j,k]) ax.text(pcaUS.components_[i,k], pcaUS.components_[j,k], USArrests.columns[k]) Notice that this figure is a reflection of Figure 12.1through the y-axis. Recall that the principal components are only unique up to a sign change, so we can reproduce that figure by flipping the signs of the second set of scores and loadings. We also increase the length of the arrows to emphasize the loadings. In[14]: scale_arrow = s_ = 2 scores[:,1] *= -1 pcaUS.components_[1] *= -1 #f l i pt h ey - a x i s fig, ax = plt.subplots(1, 1, figsize=(8, 8)) ax.scatter(scores[:,0], scores[:,1]) ax.set_xlabel( 'PC%d' %( i", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 592, "start_word": 189440, "end_word": 189840, "chunk_words": 400}}, "ISLP_website::c000593": {"text": "y-axis. Recall that the principal components are only unique up to a sign change, so we can reproduce that figure by flipping the signs of the second set of scores and loadings. We also increase the length of the arrows to emphasize the loadings. In[14]: scale_arrow = s_ = 2 scores[:,1] *= -1 pcaUS.components_[1] *= -1 #f l i pt h ey - a x i s fig, ax = plt.subplots(1, 1, figsize=(8, 8)) ax.scatter(scores[:,0], scores[:,1]) ax.set_xlabel( 'PC%d' %( i + 1 ) ) ax.set_ylabel( 'PC%d' %( j + 1 ) ) for k in range(pcaUS.components_.shape[1]): ax.arrow(0, 0, s_*pcaUS.components_[i,k], s_*pcaUS.components_[ j,k]) ax.text(s_*pcaUS.components_[i,k], s_*pcaUS.components_[j,k], USArrests.columns[k]) The standard deviations of the principal component scores are as follows: In[15]: scores.std(0, ddof=1) Out[15]: array([1.5909, 1.0050, 0.6032, 0.4207]) Thevarianceofeachscorecanbeextracteddirectlyfromthe pcaUSobject via theexplained_variance_ attribute. In[16]: pcaUS.explained_variance_ Out[16]: array([2.5309, 1.01 , 0.3638, 0.177 ]) The proportion of variance explained by each principal component (PVE) is stored as explained_variance_ratio_ : In[17]: pcaUS.explained_variance_ratio_ Out[17]: array([0.6201, 0.2474, 0.0891, 0.0434]) We see that the first principal component explains 62.0% of the variance in the data, the next principal component explains 24.7% of the variance, and so forth. We can plot the PVE explained by each component, as well as the cumulative PVE. We first plot the proportion of variance explained. In[18]: %%capture fig, axes = plt.subplots(1, 2, figsize=(15, 6)) ticks = np.arange(pcaUS.n_components_)+1 ax = axes[0] ax.plot(ticks, pcaUS.explained_variance_ratio_, marker= 'o') 12.5 Lab: Unsupervised Learning 539 ax.set_xlabel( 'Principal Component' ); ax.set_ylabel( 'Proportion of Variance Explained' ) ax.set_ylim([0,1]) ax.set_xticks(ticks) Noticethe useof %%capture ,whichsuppressesthe displayingof thepartially completed figure. In[19]: ax = axes[1] ax.plot(ticks, pcaUS.explained_variance_ratio_.cumsum(), marker= 'o') ax.set_xlabel( 'Principal Component' ) ax.set_ylabel( 'Cumulative Proportion of Variance Explained' ) ax.set_ylim([0, 1]) ax.set_xticks(ticks) fig The result is similar to that shown in Figure 12.3. Note that the method cumsum() computes the cumulative sum of the elements of a numeric vector.cumsum()For instance: In[20]: a=n p . a r r a y ( [ 1 , 2 , 8 , - 3 ] ) np.cumsum(a) Out[20]: array([ 1, 3, 11, 8]) 12.5.2 Matrix Completion We now re-create the analysis carried out on the USArrests data in Sec- tion12.3. We saw in Section 12.2.2that solving the optimization problem ( 12.6) on a centered data matrix Xis equivalent to computing the first Mprincipal components of the data. We use our scaled and centered USArrests data as Xbelow. The singular value decomposition (SVD) is a general algorithmsingular value de- composition svd()for solving (", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 593, "start_word": 189760, "end_word": 190160, "chunk_words": 400}}, "ISLP_website::c000594": {"text": "- 3 ] ) np.cumsum(a) Out[20]: array([ 1, 3, 11, 8]) 12.5.2 Matrix Completion We now re-create the analysis carried out on the USArrests data in Sec- tion12.3. We saw in Section 12.2.2that solving the optimization problem ( 12.6) on a centered data matrix Xis equivalent to computing the first Mprincipal components of the data. We use our scaled and centered USArrests data as Xbelow. The singular value decomposition (SVD) is a general algorithmsingular value de- composition svd()for solving ( 12.6). In[21]: X=U S A r r e s t s _ s c a l e d U, D, V = np.linalg.svd(X, full_matrices=False) U.shape, D.shape, V.shape Out[21]: ((50, 4), (4,), (4, 4)) Thenp.linalg.svd() function returns three components, U,DandV. Thenp.linalg. svd() matrixVis equivalent to the loading matrix from principal components (up to an unimportant sign flip). Using the full_matrices=False option ensures that for a tall matrix the shape of Uis the same as the shape of X. In[22]: V Out[22]: array([[-0.53589947, -0.58318363, -0.27819087, -0.54343209], [0 . 4 1 8 1 8 0 8 7 , 0 . 1 8 7 9 8 5 6,- 0 . 8 7 2 8 0 6 1 9 ,- 0 . 1 6 7 3 1 8 6 4 ] , [-0.34123273, -0.26814843, -0.37801579, 0.81777791], [0 . 6 4 9 2 2 7 8,- 0 . 7 4 3 4 0 7 4 8 , 0 . 1 3 3 8 7 7 7 3 , 0 . 0 8 9 0 2 4 3 2 ] ] ) 540 12. Unsupervised Learning In[23]: pcaUS.components_ Out[23]: array([[ 0.53589947, 0.58318363, 0.27819087, 0.54343209], [0 . 4 1 8 1 8 0 8 7 , 0 . 1 8 7 9 8 5 6,- 0 . 8 7 2 8 0 6 1 9 ,- 0 . 1 6 7 3 1 8 6 4 ] , [-0.34123273, -0.26814843, -0.37801579, 0.81777791], [0 . 6 4 9 2 2 7 8,- 0 . 7 4 3 4 0 7 4 8 , 0 . 1 3 3 8 7 7 7 3 , 0 . 0 8 9 0 2 4 3 2 ] ] ) Thematrix Ucorrespondstoa standardized versionofthePCAscorematrix (eachcolumnstandardizedtohavesum-of-squaresone).Ifwemultiplyeach column of Uby the corresponding element of D, we recover the PCA scores exactly (up to a meaningless sign flip). In[24]: (U * D[None,:])[:3] Out[24]: array([[-0.9856, 1.1334, -0.4443, 0.1563], [-1.9501, 1.0732, 2.04 , -0.4386], [-1.7632, -0.746 ,", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 594, "start_word": 190080, "end_word": 190480, "chunk_words": 400}}, "ISLP_website::c000595": {"text": "2 7 8,- 0 . 7 4 3 4 0 7 4 8 , 0 . 1 3 3 8 7 7 7 3 , 0 . 0 8 9 0 2 4 3 2 ] ] ) Thematrix Ucorrespondstoa standardized versionofthePCAscorematrix (eachcolumnstandardizedtohavesum-of-squaresone).Ifwemultiplyeach column of Uby the corresponding element of D, we recover the PCA scores exactly (up to a meaningless sign flip). In[24]: (U * D[None,:])[:3] Out[24]: array([[-0.9856, 1.1334, -0.4443, 0.1563], [-1.9501, 1.0732, 2.04 , -0.4386], [-1.7632, -0.746 , 0.0548, -0.8347]]) In[25]: scores[:3] Out[25]: array([[ 0.9856, -1.1334, -0.4443, 0.1563], [1 . 9 5 0 1 ,- 1 . 0 7 3 2 , 2 . 0 4 ,- 0 . 4 3 8 6 ] , [1 . 7 6 3 2 , 0 . 7 4 6, 0 . 0 5 4 8 ,- 0 . 8 3 4 7 ] ] ) While it would be possible to carry out this lab using the PCA()estimator, here we use the np.linalg.svd() function in order to illustrate its use. We now omit 20 entries in the 50×4data matrix at random. We do so by first selecting 20 rows (states) at random, and then selecting one of the four entries in each row at random. This ensures that every row has at least three observed values. In[26]: n_omit = 20 np.random.seed(15) r_idx = np.random.choice(np.arange(X.shape[0]), n_omit, replace=False) c_idx = np.random.choice(np.arange(X.shape[1]), n_omit, replace=True) Xna = X.copy() Xna[r_idx, c_idx] = np.nan Here the array r_idxcontains 20 integers from 0 to 49; this represents the states (rows of X) that are selected to contain missing values. And c_idx contains 20 integers from 0 to 3, representing the features (columns in X) that contain the missing values for each of the selected states. We now write some code to implement Algorithm 12.1. We first write a functionthattakesinamatrix,andreturnsanapproximationtothematrix using the svd()function. This will be needed in Step 2 of Algorithm 12.1. In[27]: def low_rank(X, M=1): U, D, V = np.linalg.svd(X) L=U [ : , : M ]*D [ N o n e , : M ] return L.dot(V[:M]) 12.5 Lab: Unsupervised Learning 541 To conduct Step 1 of the algorithm, we initialize Xhat— this is ˜Xin Algorithm 12.1— by replacing the missing values with the column means of the non-missing entries. These are stored in Xbarbelow after running np.nanmean() over the row axis. We make a copy so that when we assignnp.nanmean()values to Xhatbelow we do", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 595, "start_word": 190400, "end_word": 190800, "chunk_words": 400}}, "ISLP_website::c000596": {"text": "D, V = np.linalg.svd(X) L=U [ : , : M ]*D [ N o n e , : M ] return L.dot(V[:M]) 12.5 Lab: Unsupervised Learning 541 To conduct Step 1 of the algorithm, we initialize Xhat— this is ˜Xin Algorithm 12.1— by replacing the missing values with the column means of the non-missing entries. These are stored in Xbarbelow after running np.nanmean() over the row axis. We make a copy so that when we assignnp.nanmean()values to Xhatbelow we do not also overwrite the values in Xna. In[28]: Xhat = Xna.copy() Xbar = np.nanmean(Xhat, axis=0) Xhat[r_idx, c_idx] = Xbar[c_idx] Before we begin Step 2, we set ourselves up to measure the progress of our iterations: In[29]: thresh = 1e-7 rel_err = 1 count = 0 ismiss = np.isnan(Xna) mssold = np.mean(Xhat[ ∼ismiss]**2) mss0 = np.mean(Xna[ ∼ismiss]**2) Hereismissis a logical matrix with the same dimensions as Xna; a given elementis Trueifthecorrespondingmatrixelementismissing.Thenotation ∼ismissnegates this boolean vector. This is useful because it allows us to access both the missing and non-missing entries. We store the mean of the squared non-missing elements in mss0. We store the mean squared error of the non-missing elements of the old version of Xhatinmssold(which currently agrees with mss0). We plan to store the mean squared error of the non-missing elements of the current version of Xhatinmss, and will then iterate Step 2 of Algorithm 12.1until the relative error , defined as (mssold - mss) / mss0 , falls below thresh = 1e-7 .9 In Step 2(a) of Algorithm 12.1, we approximate Xhatusinglow_rank() ; we call this Xapp. In Step 2(b), we use Xappto update the estimates for elements in Xhatthat are missing in Xna. Finally, in Step 2(c), we compute the relative error. These three steps are contained in the following while loop: In[30]: while rel_err > thresh: count += 1 #S t e p2 ( a ) Xapp = low_rank(Xhat, M=1) #S t e p2 ( b ) Xhat[ismiss] = Xapp[ismiss] #S t e p2 ( c ) mss = np.mean(((Xna - Xapp)[ ∼ismiss])**2) rel_err = (mssold - mss) / mss0 mssold = mss print(\"Iteration: {0}, MSS:{1:.3f}, Rel.Err {2:.2e}\" .format(count, mss, rel_err)) 9Algorithm 12.1tells us to iterate Step 2 until ( 12.14) is no longer decreasing. Deter- mining whether ( 12.14) is decreasing requires us only to keep track of mssold - mss . However, in practice, we keep track of (mssold - mss) / mss0 instead:", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 596, "start_word": 190720, "end_word": 191120, "chunk_words": 400}}, "ISLP_website::c000597": {"text": ") Xhat[ismiss] = Xapp[ismiss] #S t e p2 ( c ) mss = np.mean(((Xna - Xapp)[ ∼ismiss])**2) rel_err = (mssold - mss) / mss0 mssold = mss print(\"Iteration: {0}, MSS:{1:.3f}, Rel.Err {2:.2e}\" .format(count, mss, rel_err)) 9Algorithm 12.1tells us to iterate Step 2 until ( 12.14) is no longer decreasing. Deter- mining whether ( 12.14) is decreasing requires us only to keep track of mssold - mss . However, in practice, we keep track of (mssold - mss) / mss0 instead: this makes it so that the number of iterations required for Algorithm 12.1to converge does not depend on whether we multiplied the raw data Xby a constant factor. 542 12. Unsupervised Learning Iteration: 1, MSS:0.395, Rel.Err 5.99e-01 Iteration: 2, MSS:0.382, Rel.Err 1.33e-02 Iteration: 3, MSS:0.381, Rel.Err 1.44e-03 Iteration: 4, MSS:0.381, Rel.Err 1.79e-04 Iteration: 5, MSS:0.381, Rel.Err 2.58e-05 Iteration: 6, MSS:0.381, Rel.Err 4.22e-06 Iteration: 7, MSS:0.381, Rel.Err 7.65e-07 Iteration: 8, MSS:0.381, Rel.Err 1.48e-07 Iteration: 9, MSS:0.381, Rel.Err 2.95e-08 We see that after eight iterations, the relative error has fallen below thresh = 1e-7 , and so the algorithm terminates. When this happens, the mean squared error of the non-missing elements equals 0.381. Finally, we compute the correlation between the 20 imputed values and the actual values: In[31]: np.corrcoef(Xapp[ismiss], X[ismiss])[0,1] Out[31]: 0.711 In this lab, we implemented Algorithm 12.1ourselves for didactic pur- poses. However, a reader who wishes to apply matrix completion to their data might look to more specialized Pythonimplementations. 12.5.3 Clustering K-Means Clustering The estimator sklearn.cluster.KMeans() performs K-means clustering inKmeans()Python. We begin with a simple simulated example in which there truly are two clusters in the data: the first 25 observations have a mean shift relative to the next 25 observations. In[32]: np.random.seed(0); X=n p . r a n d o m . s t a n d a r d _ n o r m a l ( ( 5 0 , 2 ) ) ; X[:25,0] += 3; X[:25,1] -= 4; We now perform K-means clustering with K=2. In[33]: kmeans = KMeans(n_clusters=2, random_state=2, n_init=20).fit(X) We specify random_state to make the results reproducible. The cluster as- signments of the 50 observations are contained in kmeans.labels_ . In[34]: kmeans.labels_ Out[34]: array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 597, "start_word": 191040, "end_word": 191440, "chunk_words": 400}}, "ISLP_website::c000598": {"text": "X[:25,1] -= 4; We now perform K-means clustering with K=2. In[33]: kmeans = KMeans(n_clusters=2, random_state=2, n_init=20).fit(X) We specify random_state to make the results reproducible. The cluster as- signments of the 50 observations are contained in kmeans.labels_ . In[34]: kmeans.labels_ Out[34]: array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], dtype=int32) TheK-means clustering perfectly separated the observations into two clus- ters even though we did not supply any group information to KMeans() .W e can plot the data, with each observation colored according to its cluster assignment. 12.5 Lab: Unsupervised Learning 543 In[35]: fig, ax = plt.subplots(1, 1, figsize=(8,8)) ax.scatter(X[:,0], X[:,1], c=kmeans.labels_) ax.set_title( \"K-Means Clustering Results with K=2\" ); Heretheobservationscanbeeasilyplottedbecausetheyaretwo-dimensio- nal. If there were more than two variables then we could instead perform PCA and plot the first two principal component score vectors to represent the clusters. In this example, we knew that there really were two clusters because we generated the data. However, for real data, we do not know the true number of clusters, nor whether they exist in any precise way. We could instead have performed K-means clustering on this example with K=3. In[36]: kmeans = KMeans(n_clusters=3, random_state=3, n_init=20).fit(X) fig, ax = plt.subplots(figsize=(8,8)) ax.scatter(X[:,0], X[:,1], c=kmeans.labels_) ax.set_title( \"K-Means Clustering Results with K=3\" ); WhenK=3,K-means clustering splits up the two clusters. We have used then_initargumenttorunthe K-meanswith20initialclusterassignments (the default is 10). If a value of n_initgreater than one is used, then K- means clustering will be performed using multiple random assignments in Step 1 of Algorithm 12.2, and the KMeans() function will report only the best results. Here we compare using n_init=1 ton_init=20 . In[37]: kmeans1 = KMeans(n_clusters=3, random_state=3, n_init=1).fit(X) kmeans20 = KMeans(n_clusters=3, random_state=3, n_init=20).fit(X); kmeans1.inertia_, kmeans20.inertia_ Out[37]: (78.06, 75.04) Note that kmeans.inertia_ is the total within-cluster sum of squares, which we seek to minimize by performing K-means clustering ( 12.17). Westronglyrecommend always running K-means clustering with a large value of n_init, such as 20 or 50, since otherwise an undesirable local optimum may be obtained. When performing K-means clustering, in addition to using multiple ini- tial cluster assignments, it is also important to set a random seed using the random_state argument to KMeans() . This way, the initial", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 598, "start_word": 191360, "end_word": 191760, "chunk_words": 400}}, "ISLP_website::c000599": {"text": "75.04) Note that kmeans.inertia_ is the total within-cluster sum of squares, which we seek to minimize by performing K-means clustering ( 12.17). Westronglyrecommend always running K-means clustering with a large value of n_init, such as 20 or 50, since otherwise an undesirable local optimum may be obtained. When performing K-means clustering, in addition to using multiple ini- tial cluster assignments, it is also important to set a random seed using the random_state argument to KMeans() . This way, the initial cluster assign- ments in Step 1 can be replicated, and the K-means output will be fully reproducible. Hierarchical Clustering TheAgglomerativeClustering() class from the sklearn.clustering pack-Agglomerative Clustering()age implements hierarchical clustering. As its name is long, we use the short hand HClustforhierarchical clustering . Note that this will not change 544 12. Unsupervised Learningthe return type when using this method, so instances will still be of classAgglomerativeClustering. In the following example we use the data fromthe previous lab to plot the hierarchical clustering dendrogram using com-plete, single, and average linkage clustering with Euclidean distance as thedissimilarity measure. We begin by clustering observations using completelinkage.In[38]:HClust = AgglomerativeClusteringhc_comp = HClust(distance_threshold=0,n_clusters=None,linkage='complete')hc_comp.fit(X)This computes the entire dendrogram. We could just as easily performhierarchical clustering with average or single linkage instead:In[39]:hc_avg = HClust(distance_threshold=0,n_clusters=None,linkage='average');hc_avg.fit(X)hc_sing = HClust(distance_threshold=0,n_clusters=None,linkage='single');hc_sing.fit(X);To use a precomputed distance matrix, we provide an additional argu-mentmetric=\"precomputed\".Inthecodebelow,thefirstfourlinescomputesthe50×50pairwise-distance matrix.In[40]:D=n p . z e r o s ( ( X . s h a p e [ 0 ] ,X . s h a p e [ 0 ] ) ) ;for i in range(X.shape[0]):x_ = np.multiply.outer(np.ones(X.shape[0]), X[i])D[i] = np.sqrt(np.sum((X - x_)**2, 1));hc_sing_pre = HClust(distance_threshold=0,n_clusters=None,metric='precomputed',linkage='single')hc_sing_pre.fit(D)We usedendrogram()fromscipy.cluster.hierarchyto plot the dendro-dendrogram()gram.However,dendrogram()expects a so-calledlinkage-matrix representa-tionof the clustering, which is not provided byAgglomerativeClustering(),but can be computed. The functioncompute_linkage()in theISLP.clustercompute_linkage()ISLP.clusterpackage is provided for this purpose.We can now plot the dendrograms. The numbers at the bottom of theplot identify each observation. Thedendrogram()function has a defaultmethod to color different branches of the tree that suggests a pre-definedcut of the tree at a particular depth. We prefer to overwrite this default bysetting this threshold to be infinite. Since we want this behavior for manydendrograms, we store these values in a dictionarycargsand pass this askeyword arguments using the notation**cargs.In[41]:cargs = {'color_threshold':-np.inf,'above_threshold_color':'black'}linkage_comp = compute_linkage(hc_comp)fig, ax = plt.subplots(1, 1, figsize=(8, 8)) 12.5 Lab: Unsupervised Learning 545 dendrogram(linkage_comp, ax=ax, **cargs); We may want to color branches of the tree above and below a cut- thresholddifferently.Thiscanbeachievedbychangingthe color_threshold . Let’scutthetreeataheightof4,coloringlinksthatmergeabove4inblack. In[42]: fig, ax = plt.subplots(1, 1,", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 599, "start_word": 191680, "end_word": 192080, "chunk_words": 400}}, "ISLP_website::c000600": {"text": "tree at a particular depth. We prefer to overwrite this default bysetting this threshold to be infinite. Since we want this behavior for manydendrograms, we store these values in a dictionarycargsand pass this askeyword arguments using the notation**cargs.In[41]:cargs = {'color_threshold':-np.inf,'above_threshold_color':'black'}linkage_comp = compute_linkage(hc_comp)fig, ax = plt.subplots(1, 1, figsize=(8, 8)) 12.5 Lab: Unsupervised Learning 545 dendrogram(linkage_comp, ax=ax, **cargs); We may want to color branches of the tree above and below a cut- thresholddifferently.Thiscanbeachievedbychangingthe color_threshold . Let’scutthetreeataheightof4,coloringlinksthatmergeabove4inblack. In[42]: fig, ax = plt.subplots(1, 1, figsize=(8, 8)) dendrogram(linkage_comp, ax=ax, color_threshold=4, above_threshold_color= 'black' ); To determine the cluster labels for each observation associated with a given cut of the dendrogram, we can use the cut_tree() function fromcut_tree()scipy.cluster.hierarchy : In[43]: cut_tree(linkage_comp, n_clusters=4).T Out[43]: array([[0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 2, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 2, 0, 2, 2, 3, 2, 3, 3, 3, 3, 2, 3, 3, 3, 3, 2, 3, 3, 3, 3, 2, 3, 3, 3, 3, 3, 3, 3, 3]]) Thiscanalsobeachievedbyprovidinganargument n_clusters toHClust() ; however each cut would require recomputing the clustering. Similarly, trees may be cut by distance threshold with an argument of distance_threshold toHClust() orheighttocut_tree() . In[44]: cut_tree(linkage_comp, height=5) Out[44]: array([[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 2, 1, 2, 2, 2, 2, 1, 2, 2, 2, 2, 1, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2]]) To scale the variables before performing hierarchical clustering of the observations, we use StandardScaler() as in our PCA example: In[45]: scaler = StandardScaler() X_scale = scaler.fit_transform(X) hc_comp_scale = HClust(distance_threshold=0, n_clusters=None, linkage= 'complete' ).fit(X_scale) linkage_comp_scale = compute_linkage(hc_comp_scale) fig, ax = plt.subplots(1, 1, figsize=(8, 8)) dendrogram(linkage_comp_scale, ax=ax, **cargs) ax.set_title( \"Hierarchical Clustering with Scaled Features\" ); Correlation-based distances between observations can be used for clus- tering. The correlation between two observations measures the similarity of their feature values.10Withnobservations, the n×ncorrelation matrix 10Suppose each observation has pfeatures, each a single numerical value. We measure the similarity of two such observations by computing the correlation of these ppairs of numbers. 546 12. Unsupervised Learningcan then be used as a similarity (or affinity) matrix, i.e. so that one minusthe correlation matrix is the dissimilarity matrix used for clustering.Note that using correlation only makes sense for data with at least threefeatures since the absolute correlation between any two observations", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 600, "start_word": 192000, "end_word": 192400, "chunk_words": 400}}, "ISLP_website::c000601": {"text": "their feature values.10Withnobservations, the n×ncorrelation matrix 10Suppose each observation has pfeatures, each a single numerical value. We measure the similarity of two such observations by computing the correlation of these ppairs of numbers. 546 12. Unsupervised Learningcan then be used as a similarity (or affinity) matrix, i.e. so that one minusthe correlation matrix is the dissimilarity matrix used for clustering.Note that using correlation only makes sense for data with at least threefeatures since the absolute correlation between any two observations withmeasurements on two features is always one. Hence, we will cluster a three-dimensional data set.In[46]:X=n p . r a n d o m . s t a n d a r d _ n o r m a l ( ( 3 0 ,3 ) )corD = 1 - np.corrcoef(X)hc_cor = HClust(linkage='complete',distance_threshold=0,n_clusters=None,metric='precomputed')hc_cor.fit(corD)linkage_cor = compute_linkage(hc_cor)fig, ax = plt.subplots(1, 1, figsize=(8, 8))dendrogram(linkage_cor, ax=ax, **cargs)ax.set_title(\"Complete Linkage with Correlation-Based Dissimilarity\");12.5.4 NCI60 Data ExampleUnsupervised techniques are often used in the analysis of genomic data.In particular, PCA and hierarchical clustering are popular tools. We illus-trate these techniques on theNCI60cancer cell line microarray data, whichconsists of 6830 gene expression measurements on 64 cancer cell lines.In[47]:NCI60 = load_data('NCI60')nci_labs = NCI60['labels']nci_data = NCI60['data']Each cell line is labeled with a cancer type. We do not make use of thecancer types in performing PCA and clustering, as these are unsupervisedtechniques. But after performing PCA and clustering, we will check tosee the extent to which these cancer types agree with the results of theseunsupervised techniques.The data has 64 rows and 6830 columns.In[48]:nci_data.shapeOut[48]:(64, 6830)We begin by examining the cancer types for the cell lines.In[49]:nci_labs.value_counts()Out[49]:labelNSCLC9RENAL9MELANOMA 8BREAST7COLON7LEUKEMIA 6OVARIAN 6 12.5 Lab: Unsupervised Learning 547 CNS 5 PROSTATE 2 K562A-repro 1 K562B-repro 1 MCF7A-repro 1 MCF7D-repro 1 UNKNOWN 1 dtype: int64 PCA on the NCI60 Data WefirstperformPCAonthedataafterscalingthevariables(genes)tohave standard deviation one, although here one could reasonably argue that it is better not to scale the genes as they are measured in the same units. In[50]: scaler = StandardScaler() nci_scaled = scaler.fit_transform(nci_data) nci_pca = PCA() nci_scores = nci_pca.fit_transform(nci_scaled) We now plot the first few principal component score vectors, in order to visualize the data. The observations (cell lines) corresponding to a given cancer type will be plotted in the same color, so that we can see to what extent the observations within a cancer type are similar to each other. In[51]: cancer_types = list(np.unique(nci_labs)) nci_groups = np.array([cancer_types.index(lab) for lab in nci_labs.values]) fig, axes = plt.subplots(1, 2, figsize=(15,6)) ax", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 601, "start_word": 192320, "end_word": 192720, "chunk_words": 400}}, "ISLP_website::c000602": {"text": "StandardScaler() nci_scaled = scaler.fit_transform(nci_data) nci_pca = PCA() nci_scores = nci_pca.fit_transform(nci_scaled) We now plot the first few principal component score vectors, in order to visualize the data. The observations (cell lines) corresponding to a given cancer type will be plotted in the same color, so that we can see to what extent the observations within a cancer type are similar to each other. In[51]: cancer_types = list(np.unique(nci_labs)) nci_groups = np.array([cancer_types.index(lab) for lab in nci_labs.values]) fig, axes = plt.subplots(1, 2, figsize=(15,6)) ax = axes[0] ax.scatter(nci_scores[:,0], nci_scores[:,1], c=nci_groups, marker= 'o', s=50) ax.set_xlabel( 'PC1'); ax.set_ylabel( 'PC2') ax = axes[1] ax.scatter(nci_scores[:,0], nci_scores[:,2], c=nci_groups, marker= 'o', s=50) ax.set_xlabel( 'PC1'); ax.set_ylabel( 'PC3'); The resulting plots are shown in Figure 12.17. On the whole, cell lines corresponding to a single cancer type do tend to have similar values on the first few principal component score vectors. This indicates that cell lines from the same cancer type tend to have pretty similar gene expression levels. We can also plot the percent variance explained by the principal compo- nents as well as the cumulative percent variance explained. This is similar to the plots we made earlier for the USArrests data. In[52]: fig, axes = plt.subplots(1, 2, figsize=(15,6)) ax = axes[0] ticks = np.arange(nci_pca.n_components_)+1 548 12. Unsupervised Learning −40 −20 0 20 40 60−60 −40 −20 0 20−40 −20 0 20 40 60−40 −20 0 20 40Z1Z1Z2 Z3 FIGURE 12.17. Projections of the NCI60cancer cell lines onto the first three principal components (in other words, the scores for the first three principal com- ponents). On the whole, observations belonging to a single cancer type tend to lie near each other in this low-dimensional space. It would not have been possible to visualize the data without using a dimension reduction method such as PCA, since based on the full data set there are/parenleftbig6,830 2/parenrightbig possible scatterplots, none of which would have been particularly informative. ax.plot(ticks, nci_pca.explained_variance_ratio_, marker= 'o') ax.set_xlabel( 'Principal Component' ); ax.set_ylabel( 'PVE') ax = axes[1] ax.plot(ticks, nci_pca.explained_variance_ratio_.cumsum(), marker= 'o'); ax.set_xlabel( 'Principal Component' ) ax.set_ylabel( 'Cumulative PVE' ); The resulting plots are shown in Figure 12.18. Weseethattogether,thefirstsevenprincipalcomponentsexplainaround 40% of the variance in the data. This is not a huge amount of the variance. However, looking at the scree plot, we see that while each of the first seven principal components explain a substantial amount of variance, there is a markeddecreaseinthevarianceexplainedbyfurtherprincipalcomponents. That is, there is an elbowin the plot after approximately the", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 602, "start_word": 192640, "end_word": 193040, "chunk_words": 400}}, "ISLP_website::c000603": {"text": "ax.set_ylabel( 'PVE') ax = axes[1] ax.plot(ticks, nci_pca.explained_variance_ratio_.cumsum(), marker= 'o'); ax.set_xlabel( 'Principal Component' ) ax.set_ylabel( 'Cumulative PVE' ); The resulting plots are shown in Figure 12.18. Weseethattogether,thefirstsevenprincipalcomponentsexplainaround 40% of the variance in the data. This is not a huge amount of the variance. However, looking at the scree plot, we see that while each of the first seven principal components explain a substantial amount of variance, there is a markeddecreaseinthevarianceexplainedbyfurtherprincipalcomponents. That is, there is an elbowin the plot after approximately the seventh princi- pal component. This suggests that there may be little benefit to examining more than seven or so principal components (though even examining seven principal components may be difficult). Clustering the Observations of the NCI60 Data We now perform hierarchical clustering of the cell lines in the NCI60data using complete, single, and average linkage. Once again, the goal is to find out whether or not the observations cluster into distinct types of cancer. Euclidean distance is used as the dissimilarity measure. We first write a short function to produce the three dendrograms. 12.5 Lab: Unsupervised Learning 549 0 10 20 30 40 50 600 2 4 6 8 10Principal ComponentPVE 0 10 20 30 40 50 6020 40 60 80 100Principal ComponentCumulative PVEFIGURE 12.18. The PVE of the principal components of the NCI60cancer cell line microarray data set. Left:the PVE of each principal component is shown. Right:the cumulative PVE of the principal components is shown. Together, all principal components explain 100,% of the variance. In[53]: def plot_nci(linkage, ax, cut=-np.inf): cargs = { 'above_threshold_color' :'black' , 'color_threshold' :cut} hc = HClust(n_clusters=None, distance_threshold=0, linkage=linkage.lower()).fit(nci_scaled) linkage_ = compute_linkage(hc) dendrogram(linkage_, ax=ax, labels=np.asarray(nci_labs), leaf_font_size=10, **cargs) ax.set_title( '%s Linkage' %l i n k a g e ) return hc Let’s plot our results. In[54]: fig, axes = plt.subplots(3, 1, figsize=(15,30)) ax = axes[0]; hc_comp = plot_nci( 'Complete' ,a x ) ax = axes[1]; hc_avg = plot_nci( 'Average' ,a x ) ax = axes[2]; hc_sing = plot_nci( 'Single' ,a x ) The results are shown in Figure 12.19. We see that the choice of linkage certainly does affect the results obtained. Typically, single linkage will tend to yieldtrailingclusters: very large clusters onto which individual observa- tions attach one-by-one. On the other hand, complete and average linkage tend to yield more balanced, attractive clusters. For this reason, complete and average linkage are generally preferred to single linkage. Clearly cell lines within a single cancer type do tend", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 603, "start_word": 192960, "end_word": 193360, "chunk_words": 400}}, "ISLP_website::c000604": {"text": "plot_nci( 'Single' ,a x ) The results are shown in Figure 12.19. We see that the choice of linkage certainly does affect the results obtained. Typically, single linkage will tend to yieldtrailingclusters: very large clusters onto which individual observa- tions attach one-by-one. On the other hand, complete and average linkage tend to yield more balanced, attractive clusters. For this reason, complete and average linkage are generally preferred to single linkage. Clearly cell lines within a single cancer type do tend to cluster together, although the clustering is not perfect. We will use complete linkage hierarchical cluster- ing for the analysis that follows. 550 12. Unsupervised LearningBREASTBREASTCNSCNSRENALBREASTNSCLCRENALMELANOMAOVARIANOVARIANNSCLCOVARIANCOLONCOLONOVARIANPROSTATENSCLCNSCLCNSCLCPROSTATENSCLCMELANOMARENALRENALRENALOVARIANUNKNOWNOVARIANNSCLCCNSCNSCNSNSCLCRENALRENALRENALRENALNSCLCMELANOMAMELANOMAMELANOMAMELANOMAMELANOMAMELANOMABREASTBREASTCOLONCOLONCOLONCOLONCOLONBREASTMCF7A−reproBREASTMCF7D−reproLEUKEMIALEUKEMIALEUKEMIALEUKEMIAK562B−reproK562A−reproLEUKEMIALEUKEMIA40 80 120 160Complete LinkageLEUKEMIALEUKEMIALEUKEMIALEUKEMIALEUKEMIALEUKEMIAK562B−reproK562A−reproRENALNSCLCBREASTNSCLCBREASTMCF7A−reproBREASTMCF7D−reproCOLONCOLONCOLONRENALMELANOMAMELANOMABREASTBREASTMELANOMAMELANOMAMELANOMAMELANOMAMELANOMAOVARIANOVARIANNSCLCOVARIANUNKNOWNOVARIANNSCLCMELANOMACNSCNSCNSRENALRENALRENALRENALRENALRENALRENALPROSTATENSCLCNSCLCNSCLCNSCLCOVARIANPROSTATENSCLCCOLONCOLONOVARIANCOLONCOLONCNSCNSBREASTBREAST40 60 80 100 120Average LinkageLEUKEMIARENALBREASTLEUKEMIALEUKEMIACNSLEUKEMIALEUKEMIAK562B−reproK562A−reproNSCLCLEUKEMIAOVARIANNSCLCCNSBREASTNSCLCOVARIANCOLONBREASTMELANOMARENALMELANOMABREASTBREASTMELANOMAMELANOMAMELANOMAMELANOMAMELANOMABREASTOVARIANCOLONMCF7A−reproBREASTMCF7D−reproUNKNOWNOVARIANNSCLCNSCLCPROSTATEMELANOMACOLONOVARIANNSCLCRENALCOLONPROSTATECOLONOVARIANCOLONCOLONNSCLCNSCLCRENALNSCLCRENALRENALRENALRENALRENALCNSCNSCNS40 60 80 100Single Linkage FIGURE 12.19.TheNCI60cancer cell line microarray data, clustered withaverage, complete, and single linkage, and using Euclidean distance as the dissim-ilarity measure. Complete and average linkage tend to yield evenly sized clusterswhereas single linkage tends to yield extended clusters to which single leaves arefused one by one. 12.5 Lab: Unsupervised Learning 551 We can cut the dendrogram at the height that will yield a particular number of clusters, say four: In[55]: linkage_comp = compute_linkage(hc_comp) comp_cut = cut_tree(linkage_comp, n_clusters=4).reshape(-1) pd.crosstab(nci_labs[ 'label' ], pd.Series(comp_cut.reshape(-1), name= 'Complete' )) There are some clear patterns. All the leukemia cell lines fall in one cluster, while the breast cancer cell lines are spread out over three different clusters. We can plot a cut on the dendrogram that produces these four clusters: In[56]: fig, ax = plt.subplots(figsize=(10,10)) plot_nci( 'Complete' ,a x ,c u t = 1 4 0 ) ax.axhline(140, c= 'r',l i n e w i d t h = 4 ) ; Theaxhline() function draws a horizontal line line on top of any existing set of axes. The argument 140plots a horizontal line at height 140 on the dendrogram; this is a height that results in four distinct clusters. It is easy to verify that the resulting clusters are the same as the ones we obtained incomp_cut . We claimed earlier in Section 12.4.2thatK-means clustering and hier- archical clustering with the dendrogram cut to obtain the same number of clusters can yield very different results. How do these NCI60hierarchical clusteringresultscomparetowhat wegetifweperform K-meansclustering withK=4? In[57]: nci_kmeans = KMeans(n_clusters=4, random_state=0, n_init=20).fit(nci_scaled) pd.crosstab(pd.Series(comp_cut, name= 'HClust' ), pd.Series(nci_kmeans.labels_, name= 'K-means' )) Out[57]: K-means 0 1 2 3 HClust 02 8 3 9 0 17 0 0 0 20 0 0 8 30", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 604, "start_word": 193280, "end_word": 193680, "chunk_words": 400}}, "ISLP_website::c000605": {"text": "are the same as the ones we obtained incomp_cut . We claimed earlier in Section 12.4.2thatK-means clustering and hier- archical clustering with the dendrogram cut to obtain the same number of clusters can yield very different results. How do these NCI60hierarchical clusteringresultscomparetowhat wegetifweperform K-meansclustering withK=4? In[57]: nci_kmeans = KMeans(n_clusters=4, random_state=0, n_init=20).fit(nci_scaled) pd.crosstab(pd.Series(comp_cut, name= 'HClust' ), pd.Series(nci_kmeans.labels_, name= 'K-means' )) Out[57]: K-means 0 1 2 3 HClust 02 8 3 9 0 17 0 0 0 20 0 0 8 30 9 0 0 We see that the four clusters obtained using hierarchical clustering and K-means clustering are somewhat different. First we note that the labels in the two clusterings are arbitrary. That is, swapping the identifier of the cluster does not change the clustering. We see here Cluster 3 in K-means clustering is identical to cluster 2 in hierarchical clustering. However, the other clusters differ: for instance, cluster 0 in K-means clustering contains a portion of the observations assigned to cluster 0 by hierarchical cluster- ing, as well as all of the observations assigned to cluster 1 by hierarchical clustering. Rather than performing hierarchical clustering on the entire data ma- trix, we can also perform hierarchical clustering on the first few principal component score vectors, regarding these first few components as a less noisy version of the data. 552 12. Unsupervised Learning In[58]: hc_pca = HClust(n_clusters=None, distance_threshold=0, linkage= 'complete' ).fit(nci_scores[:,:5]) linkage_pca = compute_linkage(hc_pca) fig, ax = plt.subplots(figsize=(8,8)) dendrogram(linkage_pca, labels=np.asarray(nci_labs), leaf_font_size=10, ax=ax, **cargs) ax.set_title( \"Hier. Clust. on First Five Score Vectors\" ) pca_labels = pd.Series(cut_tree(linkage_pca, n_clusters=4).reshape(-1), name='Complete-PCA' ) pd.crosstab(nci_labs[ 'label' ], pca_labels) 12.6 Exercises Conceptual 1. This problem involves the K-means clustering algorithm. (a) Prove ( 12.18). (b) On the basis of this identity, argue that theK-means clusteringalgorithm (Algorithm12.2) decreases the objective (12.17) ateach iteration.2. Suppose that we have four observations, for which we compute adissimilarity matrix, given by0.30.40.70.30.50.80.40.50.450.70.80.45.For instance, the dissimilarity between the first and second obser-vations is 0.3, and the dissimilarity between the second and fourthobservations is 0.8.(a) On the basis of this dissimilarity matrix, sketch the dendrogramthat results from hierarchically clustering these four observa-tions using complete linkage. Be sure to indicate on the plot theheight at which each fusion occurs, as well as the observationscorresponding to each leaf in the dendrogram.(b) Repeat (a), this time using single linkage clustering.(c) Suppose that we cut the dendrogram obtained in (a) such thattwo clusters result. Which observations are in each cluster?(d)", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 605, "start_word": 193600, "end_word": 194000, "chunk_words": 400}}, "ISLP_website::c000606": {"text": "the dissimilarity between the second and fourthobservations is 0.8.(a) On the basis of this dissimilarity matrix, sketch the dendrogramthat results from hierarchically clustering these four observa-tions using complete linkage. Be sure to indicate on the plot theheight at which each fusion occurs, as well as the observationscorresponding to each leaf in the dendrogram.(b) Repeat (a), this time using single linkage clustering.(c) Suppose that we cut the dendrogram obtained in (a) such thattwo clusters result. Which observations are in each cluster?(d) Suppose that we cut the dendrogram obtained in (b) such thattwo clusters result. Which observations are in each cluster? 12.6 Exercises 553 (e) It is mentioned in this chapter that at each fusion in the den- drogram, the position of the two clusters being fused can be swappedwithoutchangingthemeaningofthedendrogram.Draw a dendrogram that is equivalent to the dendrogram in (a), for which two or more of the leaves are repositioned, but for which the meaning of the dendrogram is the same. 3. In this problem, you will perform K-means clustering manually, with K=2, on a small example with n=6 observations and p=2 features. The observations are as follows. Obs.X1X2 114 213 304 451 562 640 (a) Plot the observations. (b) Randomlyassignaclusterlabeltoeachobservation.Youcanuse thenp.random.choice() function to do this. Report the cluster labels for each observation. (c) Compute the centroid for each cluster. (d) Assign each observation to the centroid to which it is closest, in terms of Euclidean distance. Report the cluster labels for each observation. (e) Repeat (c) and (d) until the answers obtained stop changing. (f) In your plot from (a), color the observations according to the cluster labels obtained. 4. Suppose that for a particular data set, we perform hierarchical clus- tering using single linkage and using complete linkage. We obtain two dendrograms. (a) At a certain point on the single linkage dendrogram, the clus- ters{1,2,3}and{4,5}fuse. On the complete linkage dendro- gram, the clusters {1,2,3}and{4,5}also fuse at a certain point. Which fusion will occur higher on the tree, or will they fuse at the same height, or is there not enough information to tell? (b) At a certain point on the single linkage dendrogram, the clusters {5}and{6}fuse. On the complete linkage dendrogram, the clus- ters{5}and{6}also fuse at a certain point. Which fusion will occur higher on the tree, or will they fuse at the same height, or is there not enough information to tell? 5. In words, describe the results that", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 606, "start_word": 193920, "end_word": 194320, "chunk_words": 400}}, "ISLP_website::c000607": {"text": "fusion will occur higher on the tree, or will they fuse at the same height, or is there not enough information to tell? (b) At a certain point on the single linkage dendrogram, the clusters {5}and{6}fuse. On the complete linkage dendrogram, the clus- ters{5}and{6}also fuse at a certain point. Which fusion will occur higher on the tree, or will they fuse at the same height, or is there not enough information to tell? 5. In words, describe the results that you would expect if you performed K-means clustering of the eight shoppers in Figure 12.16, on the basis of their sock and computer purchases, with K=2. Give three answers, one for each of the variable scalings displayed. Explain. 554 12. Unsupervised Learning 6. We saw in Section 12.2.2that the principal component loading and score vectors provide an approximation to a matrix, in the sense of (12.5).Specifically,theprincipalcomponentscoreandloadingvectors solve the optimization problem given in ( 12.6). Now,supposethatthe Mprincipalcomponentscorevectors zim,m= 1,...,M , are known. Using ( 12.6), explain that each of the first M principal component loading vectors φjm,m=1,...,M , can be ob- tained by performing pseparate least squares linear regressions. In each regression, the principal component score vectors are the pre- dictors, and one of the features of the data matrix is the response. Applied 7. In this chapter, we mentioned the use of correlation-based distance andEuclidean distance as dissimilaritymeasures for hierarchicalclus- tering. It turns out that these two measures are almost equivalent: if each observation has been centered to have mean zero and standard deviation one, and if we let rijdenote the correlation between the ith andjth observations, then the quantity 1−rijis proportional to the squared Euclidean distance between the ith andjth observations. On the USArrests data, show that this proportionality holds. Hint: The Euclidean distance can be calculated using the pairwise_distances() function from the sklearn.metrics module, andpairwise_ distances() correlations can be calculated using the np.corrcoef() function. 8. In Section 12.2.3, a formula for calculating PVE was given in Equa- tion12.10. We also saw that the PVE can be obtained using the explained_variance_ratio_ attribute of a fitted PCA()estimator. On the USArrests data, calculate PVE in two ways: (a) Using the explained_variance_ratio_ output of the fitted PCA() estimator, as was done in Section 12.2.3. (b) By applying Equation 12.10directly. The loadings are stored as thecomponents_ attribute of the fitted PCA()estimator. Use those loadings in Equation 12.10to obtain the PVE. These two approaches", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 607, "start_word": 194240, "end_word": 194640, "chunk_words": 400}}, "ISLP_website::c000608": {"text": "a formula for calculating PVE was given in Equa- tion12.10. We also saw that the PVE can be obtained using the explained_variance_ratio_ attribute of a fitted PCA()estimator. On the USArrests data, calculate PVE in two ways: (a) Using the explained_variance_ratio_ output of the fitted PCA() estimator, as was done in Section 12.2.3. (b) By applying Equation 12.10directly. The loadings are stored as thecomponents_ attribute of the fitted PCA()estimator. Use those loadings in Equation 12.10to obtain the PVE. These two approaches should give the same results. Hint: You will only obtain the same results in (a) and (b) if the same data is used in both cases. For instance, if in (a) you performed PCA() using centered and scaled variables, then you must center and scale the variables before applying Equation 12.10in (b). 9. Consider the USArrests data. We will now perform hierarchical clus- tering on the states. (a) Using hierarchical clustering with complete linkage and Euclidean distance, cluster the states. (b) Cut the dendrogram at a height that results in three distinct clusters. Which states belong to which clusters? 12.6 Exercises 555(c) Hierarchically cluster the states using complete linkage and Eu-clidean distance,after scaling the variables to have standard de-viation one.(d) What effect does scaling the variables have on the hierarchicalclustering obtained? In your opinion, should the variables bescaled before the inter-observation dissimilarities are computed?Provide a justification for your answer.10. In this problem, you will generate simulated data, and then performPCA andK-means clustering on the data.(a) Generate a simulated data set with 20 observations in each ofthree classes (i.e. 60 observations total), and 50 variables.Hint: There are a number of functions inPythonthat you canuse to generate data. One example is thenormal()method oftherandom()function innumpy; theuniform()method is anotheroption. Be sure to add a mean shift to the observations in eachclass so that there are three distinct classes.(b) Perform PCA on the 60 observations and plot the first two prin-cipal component score vectors. Use a different color to indicatethe observations in each of the three classes. If the three classesappear separated in this plot, then continue on to part (c). Ifnot, then return to part (a) and modify the simulation so thatthere is greater separation between the three classes. Do notcontinue to part (c) until the three classes show at least someseparation in the first two principal component score vectors.(c) PerformK-means clustering of the observations withK=3.How well do the clusters that you obtained inK-means", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 608, "start_word": 194560, "end_word": 194960, "chunk_words": 400}}, "ISLP_website::c000609": {"text": "a different color to indicatethe observations in each of the three classes. If the three classesappear separated in this plot, then continue on to part (c). Ifnot, then return to part (a) and modify the simulation so thatthere is greater separation between the three classes. Do notcontinue to part (c) until the three classes show at least someseparation in the first two principal component score vectors.(c) PerformK-means clustering of the observations withK=3.How well do the clusters that you obtained inK-means cluster-ing compare to the true class labels?Hint: You can use thepd.crosstab()function inPythonto com-pare the true class labels to the class labels obtained by cluster-ing. Be careful how you interpret the results:K-means clusteringwill arbitrarily number the clusters, so you cannot simply checkwhether the true class labels and clustering labels are the same.(d) PerformK-means clustering withK=2. Describe your results.(e) Now performK-means clustering withK=4, and describe yourresults.(f) Now performK-means clustering withK=3on the first twoprincipal component score vectors, rather than on the raw data.That is, performK-means clustering on the60×2matrix ofwhich the first column is the first principal component scorevector,andthesecondcolumnisthesecondprincipalcomponentscore vector. Comment on the results.(g) Using theStandardScaler()estimator, performK-means clus-tering withK=3on the dataafter scaling each variable to havestandard deviation one. How do these results compare to thoseobtained in (b)? Explain. 556 12. Unsupervised Learning 11. Write a Pythonfunction to perform matrix completion as in Algo- rithm12.1, and as outlined in Section 12.5.2. In each iteration, the function should keep track of the relative error, as well as the itera- tion count. Iterations should continue until the relative error is small enough or until some maximum number of iterations is reached (set a default value for this maximum number). Furthermore, there should be an option to print out the progress in each iteration. Test your function on the Bostondata. First, standardize the features to have mean zero and standard deviation one using the StandardScaler() function. Run an experiment where you randomly leave out an increasing (and nested) number of observations from 5% to 30%, in steps of 5%. Apply Algorithm 12.1withM=1,2,...,8. Display the approximation error as a function of the fraction of ob- servations that are missing, and the value of M, averaged over 10 repetitions of the experiment. 12. In Section 12.5.2, Algorithm 12.1was implemented using the svd()function from the np.linalg module. However, given the con- nection between the svd()function and the PCA()estimator high- lighted in the lab, we could have instead implemented the algorithm usingPCA().", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 609, "start_word": 194880, "end_word": 195280, "chunk_words": 400}}, "ISLP_website::c000610": {"text": "number of observations from 5% to 30%, in steps of 5%. Apply Algorithm 12.1withM=1,2,...,8. Display the approximation error as a function of the fraction of ob- servations that are missing, and the value of M, averaged over 10 repetitions of the experiment. 12. In Section 12.5.2, Algorithm 12.1was implemented using the svd()function from the np.linalg module. However, given the con- nection between the svd()function and the PCA()estimator high- lighted in the lab, we could have instead implemented the algorithm usingPCA(). WriteafunctiontoimplementAlgorithm 12.1thatmakesuseof PCA() rather than svd(). 13. On the book website, www.statlearning.com , there is a gene expres- sion data set ( Ch12Ex13.csv ) that consists of 40 tissue samples with measurements on 1,000 genes. The first 20 samples are from healthy patients, while the second 20 are from a diseased group. (a) Load in the data using pd.read_csv() . You will need to select header = None . (b) Apply hierarchical clustering to the samples using correlation- based distance, and plot the dendrogram. Do the genes separate the samples into the two groups? Do your results depend on the type of linkage used? (c) Your collaborator wants to know which genes differ the most across the two groups. Suggest a way to answer this question, and apply it here. 13 Multiple Testing Thus far, this textbook has mostly focused on estimation and its close cousin,prediction . In this chapter, we instead focus on hypothesis testing, which is key to conducting inference . We remind the reader that inference was briefly discussed in Chapter 2. While Section 13.1provides a brief review of null hypotheses, p-values, test statistics, and other key ideas in hypothesis testing, this chapter as- sumes that the reader has had previous exposure to these topics. In par- ticular, we will not focus on whyorhowto conduct a hypothesis test — a topic on which entire books can be (and have been) written! Instead, we will assume that the reader is interested in testing some particular set of null hypotheses, and has a specific plan in mind for how to conduct the tests and obtain p-values. Muchoftheemphasisinclassicalstatisticsfocusesontestingasinglenull hypothesis, such as H0: the expected blood pressure of mice in the control group equals the expected blood pressure of mice in the treatment group . Of course,wewouldprobablyliketodiscoverthatthere isadifferencebetween themeanbloodpressureinthetwogroups.Butforreasonsthatwillbecome clear, we construct a null hypothesis corresponding to no difference. In contemporary settings, we are often faced with huge amounts of data,", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 610, "start_word": 195200, "end_word": 195600, "chunk_words": 400}}, "ISLP_website::c000611": {"text": "reader is interested in testing some particular set of null hypotheses, and has a specific plan in mind for how to conduct the tests and obtain p-values. Muchoftheemphasisinclassicalstatisticsfocusesontestingasinglenull hypothesis, such as H0: the expected blood pressure of mice in the control group equals the expected blood pressure of mice in the treatment group . Of course,wewouldprobablyliketodiscoverthatthere isadifferencebetween themeanbloodpressureinthetwogroups.Butforreasonsthatwillbecome clear, we construct a null hypothesis corresponding to no difference. In contemporary settings, we are often faced with huge amounts of data, and consequently may wish to test a great many null hypotheses. For instance, rather than simply testing H0, we might want to test m null hypotheses, H01,...,H 0m, whereH0j: the expected value of the jth biomarker among mice in the control group equals the expected value of the jthbiomarker among mice in the treatment group . When conducting mul- tiple testing , we need to be very careful about how we interpret the results, in order to avoid erroneously rejecting far too many null hypotheses. This chapter discusses classical as well as more contemporary ways to conduct multiple testing in a big-data setting. In Section 13.2, we highlight the challenges associated with multiple testing. Classical solutions to these © Springer Nature Switzerland AG 2023 G. James et al., An Introduction to Statistical Learning , Springer Texts in Statistics, https://doi.org/10.1007/978-3-031-38747-0_13 557 558 13. Multiple Testing challenges are presented in Section 13.3, and more contemporary solutions in Sections 13.4and13.5. In particular, Section 13.4focuses on the false discovery rate. The no- tion of the false discovery rate dates back to the 1990s. It quickly rose in popularity in the early 2000s, when large-scale data sets began to come out of genomics. These datasets were unique not only because of their large size,1but also because they were typically collected for exploratory pur- poses: researchers collected these datasets in order to test a huge number of null hypotheses, rather than just a very small number of pre-specified null hypotheses. Today, of course, huge datasets are collected without a pre-specified null hypothesis across virtually all fields. As we will see, the false discovery rate is perfectly-suited for this modern-day reality. This chapter naturally centers upon the classical statistical technique of p-values, used to quantify the results of hypothesis tests. At the time of writing of this book (2020), p-values have recently been the topic of exten- sive commentary in the social science research community, to the", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 611, "start_word": 195520, "end_word": 195920, "chunk_words": 400}}, "ISLP_website::c000612": {"text": "of pre-specified null hypotheses. Today, of course, huge datasets are collected without a pre-specified null hypothesis across virtually all fields. As we will see, the false discovery rate is perfectly-suited for this modern-day reality. This chapter naturally centers upon the classical statistical technique of p-values, used to quantify the results of hypothesis tests. At the time of writing of this book (2020), p-values have recently been the topic of exten- sive commentary in the social science research community, to the extent that some social science journals have gone so far as to ban the use of p-values altogether! We will simply comment that when properly under- stood and applied, p-values provide a powerful tool for drawing inferential conclusions from our data. 13.1 A Quick Review of Hypothesis Testing Hypothesis tests provide a rigorous statistical framework for answering simple “yes-or-no” questions about data, such as the following: 1. Is the true coefficient βjin a linear regression of YontoX1,...,X p equal to zero?2 2. Is there a difference in the expected blood pressure of laboratory mice in the control group and laboratory mice in the treatment group?3 In Section 13.1.1, we briefly review the steps involved in hypothesis test- ing. Section 13.1.2discusses the different types of mistakes, or errors, that can occur in hypothesis testing. 13.1.1 Testing a Hypothesis Conducting a hypothesis test typically proceeds in four steps. First, we de- fine the null and alternative hypotheses. Next, we construct a test statistic that summarizes the strength of evidence against the null hypothesis. We then compute a p-value that quantifies the probability of having obtained 1Microarraydatawasviewedas“bigdata”atthetime,althoughbytoday’sstandards, this label seems quaint: a microarray dataset can be (and typically was) stored in a Microsoft Excel spreadsheet! 2This hypothesis test was discussed on page 76of Chapter 3. 3The “treatment group” refers to the set of mice that receive an experimental treat- ment, and the “control group” refers to those that do not. 13.1 A Quick Review of Hypothesis Testing 559 a comparable or more extreme value of the test statistic under the null hypothesis. Finally, based on the p-value, we decide whether to reject the null hypothesis. We now briefly discuss each of these steps in turn. Step 1: Define the Null and Alternative Hypotheses In hypothesis testing, we divide the world into two possibilities: the null hypothesis and thealternative hypothesis . The null hypothesis, denoted H0,null hypothesis alternative hypothesisis the default state of belief", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 612, "start_word": 195840, "end_word": 196240, "chunk_words": 400}}, "ISLP_website::c000613": {"text": "Review of Hypothesis Testing 559 a comparable or more extreme value of the test statistic under the null hypothesis. Finally, based on the p-value, we decide whether to reject the null hypothesis. We now briefly discuss each of these steps in turn. Step 1: Define the Null and Alternative Hypotheses In hypothesis testing, we divide the world into two possibilities: the null hypothesis and thealternative hypothesis . The null hypothesis, denoted H0,null hypothesis alternative hypothesisis the default state of belief about the world.4For instance, null hypotheses associatedwiththetwoquestionsposedearlierinthischapterareasfollows: 1. The true coefficient βjin a linear regression of YontoX1,...,X p equals zero. 2. There is no difference between the expected blood pressure of mice in the control and treatment groups. The null hypothesis is boring by construction: it may well be true, but we might hope that our data will tell us otherwise. The alternative hypothesis, denoted Ha, represents something different and unexpected: for instance, that there isa difference between the ex- pected blood pressure of the mice in the two groups. Typically, the alter- native hypothesis simply posits that the null hypothesis does not hold: if the null hypothesis states that there is no difference between A and B , then the alternative hypothesis states that there is a difference between A and B. It is important to note that the treatment of H0andHais asymmetric. H0is treated as the default state of the world, and we focus on using data to reject H0. If we reject H0, then this provides evidence in favor of Ha.W e can think of rejecting H0as making a discovery about our data: namely, we are discovering that H0does not hold! By contrast, if we fail to reject H0, then our findings are more nebulous: we will not know whether we failed to reject H0because our sample size was too small (in which case testing H0again on a larger or higher-quality dataset might lead to rejection), or whether we failed to reject H0becauseH0really holds. Step 2: Construct the Test Statistic Next, we wish to use our data in order to find evidence for or against the null hypothesis. In order to do this, we must compute a test statistic ,test statisticdenoted T, which summarizes the extent to which our data are consistent withH0. The way in which we construct Tdepends on the nature of the null hypothesis that we are testing. To make things concrete, let xt", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 613, "start_word": 196160, "end_word": 196560, "chunk_words": 400}}, "ISLP_website::c000614": {"text": "whether we failed to reject H0becauseH0really holds. Step 2: Construct the Test Statistic Next, we wish to use our data in order to find evidence for or against the null hypothesis. In order to do this, we must compute a test statistic ,test statisticdenoted T, which summarizes the extent to which our data are consistent withH0. The way in which we construct Tdepends on the nature of the null hypothesis that we are testing. To make things concrete, let xt 1,...,xt ntdenote the blood pressure mea- surementsforthe ntmiceinthetreatmentgroup,andlet xc 1,...,xc ncdenote the blood pressure measurements for the ncmice in the control group, and µt= E( Xt),µc= E( Xc).TotestH0:µt=µc,wemakeuseofa two-sample t-statistic ,5defined astwo-sample t-statistic 4H0is pronounced “H naught” or “H zero”. 560 13. Multiple Testing −4−20240.0 0.1 0.2 0.3 0.4Value of Test StatisticProbability Density FunctionT=2.33 FIGURE 13.1. The density function for the N(0,1)distribution, with the ver- tical line indicating a value of 2.33. 1% of the area under the curve falls to the right of the vertical line, so there is only a 2% chance of observing a N(0,1)value that is greater than 2.33or less than −2.33. Therefore, if a test statistic has a N(0,1)null distribution, then an observed test statistic of T=2.33leads to a p-value of 0.02. T=ˆµt−ˆµc s/radicalBig 1 nt+1 nc(13.1) whereˆµt=1 nt/summationtextnt i=1xt i,ˆµc=1 nc/summationtextnc i=1xc i, and s=/radicalBigg (nt−1)s2 t+(nc−1)s2c nt+nc−2(13.2) is an estimator of the pooled standard deviation of the two samples.6Here, s2 tands2 care unbiased estimators of the variance of the blood pressure in the treatment and control groups, respectively. A large (absolute) value of Tprovides evidence against H0:µt=µc, and hence evidence in support ofHa:µt/negationslash=µc. Step 3: Compute the p-Value In the previous section, we noted that a large (absolute) value of a two- samplet-statisticprovidesevidenceagainst H0.Thisbegsthequestion: how large is large? In other words, how much evidence against H0is provided by a given value of the test statistic? The notion of a p-valueprovides us with a way to formalize as well asp-valueanswer this question. The p-value is defined as the probability of observing a test statistic equal to or more extreme than the observed statistic, under the assumption that H0is in fact true . Therefore, a small p-value provides evidence againstH0. 5Thet-statistic derives its name from the fact that, under H0, it follows a t- distribution. 6Note that ( 13.2) assumes that the control and treatment groups have equal variance. Without this assumption, ( 13.2) would", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 614, "start_word": 196480, "end_word": 196880, "chunk_words": 400}}, "ISLP_website::c000615": {"text": "way to formalize as well asp-valueanswer this question. The p-value is defined as the probability of observing a test statistic equal to or more extreme than the observed statistic, under the assumption that H0is in fact true . Therefore, a small p-value provides evidence againstH0. 5Thet-statistic derives its name from the fact that, under H0, it follows a t- distribution. 6Note that ( 13.2) assumes that the control and treatment groups have equal variance. Without this assumption, ( 13.2) would take a slightly different form. 13.1 A Quick Review of Hypothesis Testing 561 To make this concrete, suppose that T=2.33for the test statistic in (13.1). Then, we can ask: what is the probability of having observed such a large value of T, if indeed H0holds? It turns out that under H0, the distribution of Tin (13.1) follows approximately a N(0,1)distribution7— that is, a normal distribution with mean 0and variance 1. This distribution is displayed in Figure 13.1. We see that the vast majority — 98% — of the N(0,1)distribution falls between −2.33and2.33. This means that under H0, we would expect to see such a large value of |T|only 2% of the time. Therefore, the p-value corresponding to T=2.33is0.02. The distribution of the test statistic under H0(also known as the test statistic’s null distribution ) will depend on the details of what type ofnull distributionnull hypothesis is being tested, and what type of test statistic is used. In general, most commonly-used test statistics follow a well-known statistical distribution under the null hypothesis — such as a normal distribution, at-distribution, a χ2-distribution, or an F-distribution — provided that the sample size is sufficiently large and that some other assumptions hold. Typically, the Rfunction that is used to compute a test statistic will make use of this null distribution in order to output a p-value. In Section 13.5, we will see an approach to estimate the null distribution of a test statistic using re-sampling; in many contemporary settings, this is a very attractive option, as it exploits the availability of fast computers in order to avoid having to make potentially problematic assumptions about the data. Thep-value is perhaps one of the most used and abused notions in all of statistics.Inparticular,itissometimessaidthatthe p-valueistheprobabil- ity thatH0holds, i.e., that the null hypothesis is true. This is not correct! The one and only correct interpretation of the p-value is as the fraction of the time that we would", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 615, "start_word": 196800, "end_word": 197200, "chunk_words": 400}}, "ISLP_website::c000616": {"text": "re-sampling; in many contemporary settings, this is a very attractive option, as it exploits the availability of fast computers in order to avoid having to make potentially problematic assumptions about the data. Thep-value is perhaps one of the most used and abused notions in all of statistics.Inparticular,itissometimessaidthatthe p-valueistheprobabil- ity thatH0holds, i.e., that the null hypothesis is true. This is not correct! The one and only correct interpretation of the p-value is as the fraction of the time that we would expect to see such an extreme value of the test statistic8if we repeated the experiment many many times, provided H0 holds. In Step 2 we computed a test statistic, and noted that a large (absolute) value of the test statistic provides evidence against H0. In Step 3 the test statistic was converted to a p-value, with small p-values providing evidence againstH0. What, then, did we accomplish by converting the test statistic from Step 2 into a p-value in Step 3? To answer this question, suppose a data analyst conducts a statistical test, and reports a test statistic of T= 17 .3. Does this provide strong evidence against H0? It’s impossible to know, without more information: in particular, we would need to know 7More precisely, assuming that the observations are drawn from a normal distribution, thenTfollows a t-distribution with nt+nc−2degrees of freedom. Provided that nt+ nc−2is larger than around 40, this is very well-approximated by a N(0,1)distribution. In Section 13.5, we will see an alternative and often more attractive way to approximate the null distribution of T, which avoids making stringent assumptions about the data. 8Aone-sided p-value is the probability of seeing such an extreme value of the test statistic; e.g. the probability of seeing a test statistic greater than or equal to T=2.33. Atwo-sided p-value is the probability of seeing such an extreme value of the absolute test statistic; e.g. the probability of seeing a test statistic greater than or equal to 2.33 or less than or equal to −2.33. The default recommendation is to report a two-sided p-value rather than a one-sided p-value, unless there is a clear and compelling reason that only one direction of the test statistic is of scientific interest. 562 13. Multiple Testing Truth H0 Ha DecisionRejectH0 Type I Error Correct Do Not Reject H0 Correct Type II Error TABLE 13.1. A summary of the possible scenarios associated with testing the null hypothesis H0. Type", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 616, "start_word": 197120, "end_word": 197520, "chunk_words": 400}}, "ISLP_website::c000617": {"text": "equal to 2.33 or less than or equal to −2.33. The default recommendation is to report a two-sided p-value rather than a one-sided p-value, unless there is a clear and compelling reason that only one direction of the test statistic is of scientific interest. 562 13. Multiple Testing Truth H0 Ha DecisionRejectH0 Type I Error Correct Do Not Reject H0 Correct Type II Error TABLE 13.1. A summary of the possible scenarios associated with testing the null hypothesis H0. Type I errors are also known as false positives, and Type II errors as false negatives. whatvalueoftheteststatisticshouldbeexpected,under H0.Thisisexactly what ap-value gives us. In other words, a p-value allows us to transform our test statistic, which is measured on some arbitrary and uninterpretable scale, into a number between 0and1that can be more easily interpreted. Step 4: Decide Whether to Reject the Null Hypothesis Once we have computed a p-value corresponding to H0, it remains for us to decide whether or not to reject H0. (We do not usually talk about “accepting” H0: instead, we talk about “failing to reject” H0.) A small p- value indicates that such a large value of the test statistic is unlikely to occur under H0, and thereby provides evidence against H0. If thep-value is sufficiently small, then we will want to reject H0(and, therefore, make a “discovery”). But how small is small enough to reject H0? It turns out that the answer to this question is very much in the eyes of the beholder, or more specifically, the data analyst. The smaller the p- value, the stronger the evidence against H0. In some fields, it is typical to rejectH0if thep-value is below 0.05; this means that, if H0holds, we would expect to see such a small p-value no more than 5% of the time.9However, in other fields, a much higher burden of proof is required: for example, in some areas of physics, it is typical to reject H0only if the p-value is below 10−9! In the example displayed in Figure 13.1, if we use a threshold of 0.05as our cut-off for rejecting the null hypothesis, then we will reject the null. By contrast, if we use a threshold of 0.01, then we will fail to reject the null. These ideas are formalized in the next section. 13.1.2 Type I and Type II Errors If the null hypothesis holds, then we say that it is a true null", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 617, "start_word": 197440, "end_word": 197840, "chunk_words": 400}}, "ISLP_website::c000618": {"text": "H0only if the p-value is below 10−9! In the example displayed in Figure 13.1, if we use a threshold of 0.05as our cut-off for rejecting the null hypothesis, then we will reject the null. By contrast, if we use a threshold of 0.01, then we will fail to reject the null. These ideas are formalized in the next section. 13.1.2 Type I and Type II Errors If the null hypothesis holds, then we say that it is a true null hypothesis ;true null hypothesisotherwise, it is a false null hypothesis . For instance, if we test H0:µt=µc false null hypothesisas in Section 13.1.1, and there is indeed no difference in the population mean blood pressure for mice in the treatment group and mice in the control group, then H0is true; otherwise, it is false. Of course, we do not knowa prioriwhether H0is true or whether it is false: this is why we need to conduct a hypothesis test! 9Though a threshold of 0.05to reject H0is ubiquitous in some areas of science, we advise against blind adherence to this arbitrary choice. Furthermore, a data analyst should typically report the p-value itself, rather than just whether or not it exceeds a specified threshold value. 13.2 The Challenge of Multiple Testing 563 Table13.1summarizes the possible scenarios associated with testing the null hypothesis H0.10Once the hypothesis test is performed, the rowof the table is known (based on whether or not we have rejected H0); however, it is impossible for us to know which columnwe are in. If we reject H0when H0is false (i.e., when Hais true), or if we do not reject H0when it is true, then we arrived at the correct result. However, if we erroneously reject H0 whenH0is in fact true, then we have committed a Type I error . TheType IType I errorerror rate is defined as the probability of making a Type I error given thatType I error rateH0holds, i.e., the probability of incorrectly rejecting H0. Alternatively, if we do not reject H0whenH0is in fact false, then we have committed a Type II error . Thepowerof the hypothesis test is defined as the probabilityType II error powerof not making a Type II error given that Haholds, i.e., the probability of correctly rejecting H0. Ideally we would like both the Type I and Type II error rates to be small. But in practice, this is hard to achieve! There typically is", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 618, "start_word": 197760, "end_word": 198160, "chunk_words": 400}}, "ISLP_website::c000619": {"text": "the probability of incorrectly rejecting H0. Alternatively, if we do not reject H0whenH0is in fact false, then we have committed a Type II error . Thepowerof the hypothesis test is defined as the probabilityType II error powerof not making a Type II error given that Haholds, i.e., the probability of correctly rejecting H0. Ideally we would like both the Type I and Type II error rates to be small. But in practice, this is hard to achieve! There typically is a trade-off: we can make the Type I error small by only rejecting H0if we are quite sure that it doesn’t hold; however, this will result in an increase in the Type II error. Alternatively, we can make the Type II error small by rejecting H0 in the presence of even modest evidence that it does not hold, but this will cause the Type I error to be large. In practice, we typically view Type I errors as more “serious” than Type II errors, because the former involves declaring a scientific finding that is not correct. Hence, when we perform hypothesis testing, we typically require a low Type I error rate — e.g., at most α=0.05— while trying to make the Type II error small (or, equivalently, the power large). It turns out that there is a direct correspondence between the p-value threshold that causes us to reject H0, and the Type I error rate. By only rejecting H0when the p-value is below α, we ensure that the Type I error rate will be less than or equal to α. 13.2 The Challenge of Multiple Testing In the previous section, we saw that rejecting H0if thep-value is below (say)0.01provides us with a simple way to control the Type I error for H0 at level0.01: ifH0is true, then there is no more than a 1% probability that we will reject it. But now suppose that we wish to test mnull hypotheses, H01,...,H 0m. Will it do to simply reject all null hypotheses for which the corresponding p-value falls below (say) 0.01? Stated another way, if we reject all null hypotheses for which the p-value falls below 0.01, then how many Type I errors should we expect to make? As a first step towards answering this question, consider a stockbroker who wishes to drum up new clients by convincing them of her trading 10There are parallels between Table 13.1and Table 4.6, which", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 619, "start_word": 198080, "end_word": 198480, "chunk_words": 400}}, "ISLP_website::c000620": {"text": "H01,...,H 0m. Will it do to simply reject all null hypotheses for which the corresponding p-value falls below (say) 0.01? Stated another way, if we reject all null hypotheses for which the p-value falls below 0.01, then how many Type I errors should we expect to make? As a first step towards answering this question, consider a stockbroker who wishes to drum up new clients by convincing them of her trading 10There are parallels between Table 13.1and Table 4.6, which has to do with the output of a binary classifier. In particular, recall from Table 4.6that a false positive results from predicting a positive (non-null) label when the true label is in fact negative (null). This is closely related to a Type I error, which results from rejecting the null hypothesis when in fact the null hypothesis holds. 564 13. Multiple Testing acumen. She tells 1,024 ( 1,024 = 210) potential new clients that she can correctlypredictwhetherApple’sstockpricewillincreaseordecreasefor10 days running. There are 210possibilities for how Apple’s stock price might change over the course of these 10 days. Therefore, she emails each client one of these 210possibilities. The vast majority of her potential clients will find that the stockbroker’s predictions are no better than chance (and many will find them to be even worse than chance). But a broken clock is right twice a day, and one of her potential clients will be really impressed to find that her predictions were correct for all 10 of the days! And so the stockbroker gains a new client. What happened here? Does the stockbroker have any actual insight into whether Apple’s stock price will increase or decrease? No. How, then, did she manage to predict Apple’s stock price perfectly for 10 days running? The answer is that she made a lot of guesses, and one of them happened to be exactly right. How does this relate to multiple testing? Suppose that we flip 1,024 fair coins11ten times each. Then we would expect (on average) one coin to come up all tails. (There’s a 1/210=1/1,024chance that any single coin will come up all tails. So if we flip 1,024coins, then we expect one coin to come up all tails, on average.) If one of our coins comes up all tails, then we might therefore conclude that this particular coin is not fair. In fact, a standard hypothesis test for the null hypothesis that this particular", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 620, "start_word": 198400, "end_word": 198800, "chunk_words": 400}}, "ISLP_website::c000621": {"text": "fair coins11ten times each. Then we would expect (on average) one coin to come up all tails. (There’s a 1/210=1/1,024chance that any single coin will come up all tails. So if we flip 1,024coins, then we expect one coin to come up all tails, on average.) If one of our coins comes up all tails, then we might therefore conclude that this particular coin is not fair. In fact, a standard hypothesis test for the null hypothesis that this particular coin is fair would lead to a p-value below 0.002!12But it would be incorrect to conclude that the coin is not fair: in fact, the null hypothesis holds, and we just happen to have gotten ten tails in a row by chance. These examples illustrate the main challenge of multiple testing : whenmultiple testingtesting a huge number of null hypotheses, we are bound to get some very smallp-valuesbychance.Ifwemakeadecisionaboutwhethertorejecteach null hypothesis without accounting for the fact that we have performed a very large number of tests, then we may end up rejecting a great number of true null hypotheses — that is, making a large number of Type I errors. How severe is the problem? Recall from the previous section that if we reject a single null hypothesis, H0, if itsp-value is less than, say, α=0.01, then there is a 1% chance of making a false rejection if H0is in fact true. Nowwhat if wetest mnullhypotheses, H01,...,H 0m,all of whicharetrue? There’s a 1% chance of rejecting any individual null hypothesis; therefore, we expect to falsely reject approximately 0.01×mnull hypotheses. If m= 10,000, then that means that we expect to falsely reject 100null hypotheses by chance! That is a lotof Type I errors. Thecruxoftheissueisasfollows:rejectinganullhypothesisifthe p-value is below αcontrols the probability of falsely rejecting that null hypothesis at levelα. However, if we do this for mnull hypotheses, then the chance of falsely rejecting at least one of the mnull hypotheses is quite a bit higher! 11Afair coin is one that has an equal chance of landing heads or tails. 12Recall that the p-value is the probability of observing data at least this extreme, under the null hypothesis. If the coin is fair, then the probability of observing at least ten tails is (1/2)10=1/1,024<0.001. Thep-value is therefore 2/1,024<0.002, since this is the probability of observing ten heads or ten tails. 13.3 The Family-Wise Error Rate 565 H0is True H0is False Total RejectH0 V S", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 621, "start_word": 198720, "end_word": 199120, "chunk_words": 400}}, "ISLP_website::c000622": {"text": "bit higher! 11Afair coin is one that has an equal chance of landing heads or tails. 12Recall that the p-value is the probability of observing data at least this extreme, under the null hypothesis. If the coin is fair, then the probability of observing at least ten tails is (1/2)10=1/1,024<0.001. Thep-value is therefore 2/1,024<0.002, since this is the probability of observing ten heads or ten tails. 13.3 The Family-Wise Error Rate 565 H0is True H0is False Total RejectH0 V S R Do Not Reject H0 U W m−R Total m0 m−m0 m TABLE 13.2. A summary of the results of testing mnull hypotheses. A given null hypothesis is either true or false, and a test of that null hypothesis can either reject or fail to reject it. In practice, the individual values of V,S,U, andWare unknown. However, we do have access to V+S=RandU+W=m−R, which are the numbers of null hypotheses rejected and not rejected, respectively. We will investigate this issue in greater detail, and pose a solution to it, in Section13.3. 13.3 The Family-Wise Error Rate In the following sections, we will discuss testing multiple hypotheses while controlling the probability of making at least one Type I error. 13.3.1 What is the Family-Wise Error Rate? Recall that the Type I error rate is the probability of rejecting H0ifH0is true. The family-wise error rate (FWER) generalizes this notion to the set-family-wise error rateting ofmnull hypotheses, H01,...,H 0m, and is defined as the probability of making at least one Type I error. To state this idea more formally, con- sider Table 13.2, which summarizes the possible outcomes when performing mhypothesis tests. Here, Vrepresents the number of Type I errors (also known as false positives or false discoveries), Sthe number of true posi- tives,Uthe number of true negatives, and Wthe number of Type II errors (also known as false negatives). Then the family-wise error rate is given by FWER= Pr( V≥1). (13.3) A strategy of rejecting any null hypothesis for which the p-value is below α(i.e. controlling the Type I error for each null hypothesis at level α) leads to a FWER of FWER(α)=1 −Pr(V= 0) =1 −Pr(do not falsely reject any null hypotheses ) =1 −Pr/parenleftBig/intersectiontextm j=1{do not falsely reject H0j}/parenrightBig . (13.4) Recall from basic probability that if two events AandBare independent, thenPr(A∩B) = Pr( A) Pr( B). Therefore, if we make the additional rather strong assumptions that the mtests are", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 622, "start_word": 199040, "end_word": 199440, "chunk_words": 400}}, "ISLP_website::c000623": {"text": "strategy of rejecting any null hypothesis for which the p-value is below α(i.e. controlling the Type I error for each null hypothesis at level α) leads to a FWER of FWER(α)=1 −Pr(V= 0) =1 −Pr(do not falsely reject any null hypotheses ) =1 −Pr/parenleftBig/intersectiontextm j=1{do not falsely reject H0j}/parenrightBig . (13.4) Recall from basic probability that if two events AandBare independent, thenPr(A∩B) = Pr( A) Pr( B). Therefore, if we make the additional rather strong assumptions that the mtests are independent and that all mnull hypotheses are true, then FWER(α)=1 −m/productdisplay j=1(1−α)=1 −(1−α)m. (13.5) 566 13. Multiple Testing FIGURE 13.2. The family-wise error rate, as a function of the number of hypotheses tested (displayed on the log scale), for three values of α:α=0.05 (orange), α=0.01(blue), and α=0.001(purple). The dashed line indicates 0.05. For example, in order to control the FWER at 0.05when testing m= 50 null hypotheses, we must control the Type I error for each null hypothesis at level α=0.001. Hence, if we test only one null hypothesis, then FWER (α)=1 −(1−α)1= α,sotheTypeIerrorrateandtheFWERareequal.However,ifweperform m= 100 independent tests, then FWER (α)=1 −(1−α)100. For instance, takingα=0.05leads to a FWER of 1−(1−0.05)100=0.994. In other words, we are virtually guaranteed to make at least one Type I error! Figure13.2displays ( 13.5) for various values of m, the number of hy- potheses, and α, the Type I error. We see that setting α=0.05results in a high FWER even for moderate m. Withα=0.01, we can test no more than five null hypotheses before the FWER exceeds 0.05. Only for very small values, such as α=0.001, do we manage to ensure a small FWER, at least for moderately-sized m. We now briefly return to the example in Section 13.1.1, in which we consider testing a single null hypothesis of the form H0:µt=µcusing a two-sample t-statistic. Recall from Figure 13.1that in order to guarantee that the Type I error does not exceed 0.02, we decide whether or not to rejectH0using a cutpoint of 2.33(i.e. we reject H0if|T|≥2.33). Now, what if we wish to test 10 null hypotheses using two-sample t-statistics, instead of just one? We will see in Section 13.3.2that we can guarantee that the FWER does not exceed 0.02by rejecting only null hypotheses for which the p-value falls below 0.002. This corresponds to a much more stringent cutpoint of 3.09(i.e. we should reject H0jonly if its test statistic |Tj|≥3.09, forj=1,...,10). In other words, controlling the FWER", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 623, "start_word": 199360, "end_word": 199760, "chunk_words": 400}}, "ISLP_website::c000624": {"text": "not to rejectH0using a cutpoint of 2.33(i.e. we reject H0if|T|≥2.33). Now, what if we wish to test 10 null hypotheses using two-sample t-statistics, instead of just one? We will see in Section 13.3.2that we can guarantee that the FWER does not exceed 0.02by rejecting only null hypotheses for which the p-value falls below 0.002. This corresponds to a much more stringent cutpoint of 3.09(i.e. we should reject H0jonly if its test statistic |Tj|≥3.09, forj=1,...,10). In other words, controlling the FWER at levelαamounts to a much higher bar, in terms of evidence required to reject any given null hypothesis, than simply controlling the Type I error for each null hypothesis at level α.1 2 5 10 20 50 100 200 5000.0 0.2 0.4 0.6 0.8 1.0Number of HypothesesFamily−Wise Error Rateα=0.05α=0.01α=0.001 13.3 The Family-Wise Error Rate 567 Manager Mean,¯xStandard Deviation, st-statistic p-value One 3.0 7.4 2.86 0.006 Two -0.1 6.9 -0.10 0.918 Three 2.8 7.5 2.62 0.012 Four 0.5 6.7 0.53 0.601 Five 0.3 6.8 0.31 0.756 TABLE 13.3. The first two columns correspond to the sample mean and sample standard deviation of the percentage excess return, over n= 50 months, for the first five managers in the Funddataset. The last two columns provide the t-statistic (√n·¯X/S) and associated p-value for testing H0j:µj=0, the null hypothesis that the (population) mean return for the jth hedge fund manager equals zero. 13.3.2 Approaches to Control the Family-Wise Error Rate In this section, we briefly survey some approaches to control the FWER. We will illustrate these approaches on the Funddataset, which records the monthly percentage excess returns for 2,000 fund managers over n= 50 months.13Table13.3provides relevant summary statistics for the first five managers. We first present the Bonferroni method and Holm’s step-down proce- dure, which are very general-purpose approaches for controlling the FWER that can be applied whenever mp-values have been computed, regardless of the form of the null hypotheses, the choice of test statistics, or the (in)dependence of the p-values. We then briefly discuss Tukey’s method and Scheffé’s method in order to illustrate the fact that, in certain sit- uations, more specialized approaches for controlling the FWER may be preferable. The Bonferroni Method As in the previous section, suppose we wish to test H01,...,H 0m. LetAj denote the event that we make a Type I error for the jth null hypothesis, forj=1,...,m . Then FWER= Pr( falsely reject at least one null hypothesis )", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 624, "start_word": 199680, "end_word": 200080, "chunk_words": 400}}, "ISLP_website::c000625": {"text": "or the (in)dependence of the p-values. We then briefly discuss Tukey’s method and Scheffé’s method in order to illustrate the fact that, in certain sit- uations, more specialized approaches for controlling the FWER may be preferable. The Bonferroni Method As in the previous section, suppose we wish to test H01,...,H 0m. LetAj denote the event that we make a Type I error for the jth null hypothesis, forj=1,...,m . Then FWER= Pr( falsely reject at least one null hypothesis ) = Pr( ∪m j=1Aj) ≤m/summationdisplay j=1Pr(Aj). (13.6) In (13.6), the inequality results from the fact that for any two events A andB,Pr(A∪B)≤Pr(A) + Pr( B), regardless of whether AandBare independent. The Bonferroni method , orBonferroni correction , sets the threshold for rejecting each hypothesis test to α/m, so that Pr(Aj)≤α/m. Equation 13.6implies that FWER(α/m)≤m×α m=α, 13Excessreturnscorrespondtotheadditionalreturnthefundmanagerachievesbeyond the market’s overall return. So if the market increases by 5%during a given period and the fund manager achieves a 7%return, their excess return would be 7%−5% = 2% . 568 13. Multiple Testing so this procedure controls the FWER at level α. For instance, in order to control the FWER at level 0.1while testing m= 100 null hypotheses, the Bonferroni procedure requires us to control the Type I error for each null hypothesis at level 0.1/100 = 0 .001, i.e. to reject all null hypotheses for which the p-value is below 0.001. We now consider the Funddataset in Table 13.3. If we control the Type I error at level α=0.05for each fund manager separately, then we will conclude that the first and third managers have significantly non-zero ex- cess returns; in other words, we will reject H01:µ1=0andH03:µ3=0. However, as discussed in previous sections, this procedure does not account for the fact that we have tested multiple hypotheses, and therefore it will lead to a FWER greater than 0.05. If we instead wish to control the FWER at level0.05, then, using a Bonferroni correction, we must control the Type I error for each individual manager at level α/m=0.05/5=0 .01. Conse- quently, we will reject the null hypothesis only for the first manager, since thep-values for all other managers exceed 0.01. The Bonferroni correction gives us peace of mind that we have not falsely rejected too many null hypotheses, but for a price: we reject few null hypotheses, and thus will typically make quite a few Type II errors. The Bonferroni correction is by far", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 625, "start_word": 200000, "end_word": 200400, "chunk_words": 400}}, "ISLP_website::c000626": {"text": "we must control the Type I error for each individual manager at level α/m=0.05/5=0 .01. Conse- quently, we will reject the null hypothesis only for the first manager, since thep-values for all other managers exceed 0.01. The Bonferroni correction gives us peace of mind that we have not falsely rejected too many null hypotheses, but for a price: we reject few null hypotheses, and thus will typically make quite a few Type II errors. The Bonferroni correction is by far the best-known and most commonly- used multiplicity correction in all of statistics. Its ubiquity is due in large part to the fact that it is very easy to understand and simple to implement, and also from the fact that it successfully controls Type I error regardless of whether the mhypothesis tests are independent. However, as we will see, it is typically neither the most powerful nor the best approach for multiple testing correction. In particular, the Bonferroni correction can be quite conservative, in the sense that the true FWER is often quite a bit lower than the nominal (or target) FWER; this results from the inequality in (13.6). By contrast, a less conservative procedure might allow us to control the FWER while rejecting more null hypotheses, and therefore making fewer Type II errors. Holm’s Step-Down Procedure Holm’s method , also known as Holm’s step-down procedure or the Holm–Holm’s methodBonferroni method, is an alternative to the Bonferroni procedure. Holm’s method controls the FWER, but it is less conservative than Bonferroni, in thesensethatitwillrejectmorenullhypotheses,typicallyresultinginfewer Type II errors and hence greater power. The procedure is summarized in Algorithm 13.1. The proof that this method controls the FWER is similar to, but slightly more complicated than, the argument in ( 13.6) that the Bonferroni method controls the FWER. It is worth noting that in Holm’s procedure, the threshold that we use to reject each null hypothesis — p(L) in Step 5 — actually depends on the values of allmof thep-values. (See the definition of Lin (13.7).) This is in contrast to the Bonferroni procedure, in which to control the FWER at level α, we reject any null hypotheses for which the p-value is below α/m, regardless of the other p-values. Holm’s method makes no independence assumptions about the mhypothesis tests, and is uniformly more powerful than the Bonferroni method — it will 13.3 The Family-Wise Error Rate 569 Algorithm 13.1 Holm’s Step-Down Procedure to Control", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 626, "start_word": 200320, "end_word": 200720, "chunk_words": 400}}, "ISLP_website::c000627": {"text": "the values of allmof thep-values. (See the definition of Lin (13.7).) This is in contrast to the Bonferroni procedure, in which to control the FWER at level α, we reject any null hypotheses for which the p-value is below α/m, regardless of the other p-values. Holm’s method makes no independence assumptions about the mhypothesis tests, and is uniformly more powerful than the Bonferroni method — it will 13.3 The Family-Wise Error Rate 569 Algorithm 13.1 Holm’s Step-Down Procedure to Control the FWER 1. Specify α, the level at which to control the FWER. 2. Compute p-values,p1,...,p m, for the mnull hypotheses H01,...,H 0m. 3. Order the mp-values so that p(1)≤p(2)≤···≤p(m). 4. Define L= min/braceleftbigg j:p(j)>α m+1−j/bracerightbigg . (13.7) 5. Reject all null hypotheses H0jfor which pj<p(L). always reject at least as many null hypotheses as Bonferroni — and so it should always be preferred. We now consider applying Holm’s method to the first five fund managers in theFunddataset in Table 13.3, while controlling the FWER at level 0.05. The ordered p-values are p(1)=0.006,p(2)=0.012,p(3)=0.601,p(4)= 0.756 andp(5)=0.918. The Holm procedure rejects the first two null hypotheses, because p(1)=0.006<0.05/(5 + 1 −1) = 0 .01andp(2)= 0.012<0.05/(5 + 1 −2) = 0 .0125 , butp(3)=0.601>0.05/(5 + 1 −3) = 0.0167 , which implies that L=3. We note that, in this setting, Holm is more powerful than Bonferroni: the former rejects the null hypotheses for the first and third managers, whereas the latter rejects the null hypothesis only for the first manager. Figure13.3provides an illustration of the Bonferroni and Holm methods on three simulated data sets in a setting involving m= 10 hypothesis tests, of which m0=2 of the null hypotheses are true. Each panel displays the ten corresponding p-values, ordered from smallest to largest, and plotted on a log scale. The eight red points represent the false null hypotheses, and the two black points represent the true null hypotheses. We wish to control the FWER at level 0.05. The Bonferroni procedure requires us to reject all null hypotheses for which the p-value is below 0.005; this is represented by the black horizontal line. The Holm procedure requires us to reject all null hypotheses that fall below the blue line. The blue line always lies above the black line, so Holm will always reject more tests than Bonferroni; the region between the two lines corresponds to the hypotheses that are only rejected by Holm. In", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 627, "start_word": 200640, "end_word": 201040, "chunk_words": 400}}, "ISLP_website::c000628": {"text": "FWER at level 0.05. The Bonferroni procedure requires us to reject all null hypotheses for which the p-value is below 0.005; this is represented by the black horizontal line. The Holm procedure requires us to reject all null hypotheses that fall below the blue line. The blue line always lies above the black line, so Holm will always reject more tests than Bonferroni; the region between the two lines corresponds to the hypotheses that are only rejected by Holm. In the left-hand panel, both Bonferroni and Holm successfully reject seven of the eight false null hypotheses. In the center panel, Holm successfully rejects all eight of the false null hypotheses, while Bonferroni fails to reject one. In the right-hand panel, Bonferroni only rejects three of the false null hypotheses, while Holm rejects all eight. Neither Bonferroni nor Holm makes any Type I errors in these examples. Two Special Cases: Tukey’s Method and Scheffé’s Method Bonferroni’s method and Holm’s method can be used in virtually any set- ting in which we wish to control the FWER for mnull hypotheses: they 570 13. Multiple Testing 2 4 6 8 101e−05 1e−04 1e−03 1e−02 1e−01Ordering of p−valuesp−values (log scale)2 4 6 8 101e−07 1e−05 1e−03 1e−01Ordering of p−valuesp−values (log scale)2 4 6 8 101e−05 1e−04 1e−03 1e−02 1e−01Ordering of p−valuesp−values (log scale)FIGURE 13.3. Each panel displays, for a separate simulation, the sorted p-values for tests of m= 10 null hypotheses. The p-values corresponding to them0=2 true null hypotheses are displayed in black, and the rest are in red. When controlling the FWER at level 0.05, the Bonferroni procedure rejects all null hypotheses that fall below the black line, and the Holm procedure rejects all null hypotheses that fall below the blue line. The region between the blue and black lines indicates null hypotheses that are rejected using the Holm procedure but not using the Bonferroni procedure. In the center panel, the Holm procedure rejects one more null hypothesis than the Bonferroni procedure. In the right-hand panel, it rejects five more null hypotheses. make no assumptions about the nature of the null hypotheses, the type of test statistic used, or the (in)dependence of the p-values. However, in certain very specific settings, we can achieve higher power by controlling the FWER using approaches that are more tailored to the task at hand. Tukey’s method and Scheffé’s method provide two such examples. Table13.3indicates that for the", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 628, "start_word": 200960, "end_word": 201360, "chunk_words": 400}}, "ISLP_website::c000629": {"text": "rejects one more null hypothesis than the Bonferroni procedure. In the right-hand panel, it rejects five more null hypotheses. make no assumptions about the nature of the null hypotheses, the type of test statistic used, or the (in)dependence of the p-values. However, in certain very specific settings, we can achieve higher power by controlling the FWER using approaches that are more tailored to the task at hand. Tukey’s method and Scheffé’s method provide two such examples. Table13.3indicates that for the Funddataset, Managers One and Two have the greatest difference in their sample mean returns. This finding might motivate us to test the null hypothesis H0:µ1=µ2, whereµjis the (population) mean return for the jth fund manager. A two-sample t-test (13.1) forH0yields ap-value of 0.0349 , suggesting modest evidence against H0. However, this p-value is misleading, since we decided to compare the average returns of Managers One and Two only after having examined the returns for all five managers; this essentially amounts to having performed m=5×(5−1)/2 = 10 hypothesis tests, and selecting the one with the smallest p-value. This suggests that in order to control the FWER at level 0.05, we should make a Bonferroni correction for m= 10 hypothesis tests, and therefore should only reject a null hypothesis for which the p-value is below 0.005. If we do this, then we will be unable to reject the null hypothesis that Managers One and Two have identical performance. However, in this setting, a Bonferroni correction is actually a bit too stringent, since it fails to consider the fact that the m= 10 hypothesis tests are all somewhat related: for instance, Managers Two and Five have similar mean returns, as do Managers Two and Four; this guarantees that the mean returns of Managers Four and Five are similar. Stated another way, the mp-values for the mpairwise comparisons are notindependent. Therefore, it should be possible to control the FWER in a way that is 13.3 The Family-Wise Error Rate 571 2 4 6 8 10 12 141e−04 1e−03 1e−02 1e−01 1e+00Ordering of p−valuesp−values (log scale)2 4 6 8 10 12 141e−06 1e−04 1e−02 1e+00Ordering of p−valuesp−values (log scale)2 4 6 8 10 12 141e−04 1e−03 1e−02 1e−01 1e+00Ordering of p−valuesp−values (log scale)FIGURE 13.4. Each panel displays, for a separate simulation, the sorted p-values for tests of m= 15 hypotheses, corresponding to pairwise tests for the equality of G=6means. The m0= 10 true null hypotheses", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 629, "start_word": 201280, "end_word": 201680, "chunk_words": 400}}, "ISLP_website::c000630": {"text": "13.3 The Family-Wise Error Rate 571 2 4 6 8 10 12 141e−04 1e−03 1e−02 1e−01 1e+00Ordering of p−valuesp−values (log scale)2 4 6 8 10 12 141e−06 1e−04 1e−02 1e+00Ordering of p−valuesp−values (log scale)2 4 6 8 10 12 141e−04 1e−03 1e−02 1e−01 1e+00Ordering of p−valuesp−values (log scale)FIGURE 13.4. Each panel displays, for a separate simulation, the sorted p-values for tests of m= 15 hypotheses, corresponding to pairwise tests for the equality of G=6means. The m0= 10 true null hypotheses are displayed in black, and the rest are in red. When controlling the FWER at level 0.05, the Bonferroni procedure rejects all null hypotheses that fall below the black line, whereas Tukey rejects all those that fall below the blue line. Thus, Tukey’s method has slightly higher power than Bonferroni’s method. Controlling the Type I error without adjusting for multiple testing involves rejecting all those that fall below the green line. less conservative. This is exactly the idea behind Tukey’s method : whenTukey’s methodperforming m=G(G−1)/2pairwise comparisons of Gmeans, it allows us to control the FWER at level αwhile rejecting all null hypotheses for which the p-value falls below αT, for some αT>α/m. Figure13.4illustrates Tukey’s method on three simulated data sets in a setting with G=6means, with µ1=µ2=µ3=µ4=µ5/negationslash=µ6. Therefore, of them=G(G−1)/2 = 15 null hypotheses of the form H0:µj=µk, ten are true and five are false. In each panel, the true null hypotheses are displayed in black, and the false ones are in red. The horizontal lines indicate that Tukey’s method always results in at least as many rejections as Bonferroni’s method. In the left-hand panel, Tukey correctly rejects two more null hypotheses than Bonferroni. Now, suppose that we once again examine the data in Table 13.3, and no- ticethatManagersOneandThreehavehighermeanreturnsthanManagers Two, Four, and Five. This might motivate us to test the null hypothesis H0:1 2(µ1+µ3)=1 3(µ2+µ4+µ5). (13.8) (Recall that µjis the population mean return for the jth hedge fund man- ager.) It turns out that we could test ( 13.8) using a variant of the two- samplet-test presented in ( 13.1), leading to a p-value of 0.004. This sug- gests strong evidence of a difference between Managers One and Three compared to Managers Two, Four, and Five. However, there is a problem: we decided to test the null hypothesis in ( 13.8) only after peeking at the data in Table 13.3. In a sense, this means that we have conducted multiple", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 630, "start_word": 201600, "end_word": 202000, "chunk_words": 400}}, "ISLP_website::c000631": {"text": "It turns out that we could test ( 13.8) using a variant of the two- samplet-test presented in ( 13.1), leading to a p-value of 0.004. This sug- gests strong evidence of a difference between Managers One and Three compared to Managers Two, Four, and Five. However, there is a problem: we decided to test the null hypothesis in ( 13.8) only after peeking at the data in Table 13.3. In a sense, this means that we have conducted multiple testing. In this setting, using Bonferroni to control the FWER at level α 572 13. Multiple Testing would require a p-value threshold of α/m, for an extremely large value of m14. Scheffé’s method is designed for exactly this setting. It allows us to com-Scheffé’s methodpute a value αSsuch that rejecting the null hypothesis H0in (13.8) if the p-value is below αSwill control the Type I error at level α. It turns out that for theFundexample, in order to control the Type I error at level α=0.05, we must set αS=0.002. Therefore, we are unable to reject H0in (13.8), de- spite the apparently very small p-value of 0.004. An important advantage of Scheffé’s method is that we can use this same threshold of αS=0.002in or- der to perform a pairwise comparison of any split of the managers into two groups: for instance, we could also test H0:1 3(µ1+µ2+µ3)=1 2(µ4+µ5) andH0:1 4(µ1+µ2+µ3+µ4)= µ5using the same threshold of 0.002, without needing to further adjust for multiple testing. To summarize, Holm’s procedure and Bonferroni’s procedure are very general approaches for multiple testing correction that can be applied un- der all circumstances. However, in certain special cases, more powerful pro- cedures for multiple testing correction may be available, in order to control the FWER while achieving higher power (i.e. committing fewer Type II errors) than would be possible using Holm or Bonferroni. In this section, we have illustrated two such examples. 13.3.3 Trade-Off Between the FWER and Power Ingeneral,thereisatrade-offbetweentheFWERthresholdthatwechoose, and our powerto reject the null hypotheses. Recall that power is defined as the number of false null hypotheses that we reject divided by the total number of false null hypotheses, i.e. S/(m−m0)using the notation of Ta- ble13.2. Figure13.5illustrates the results of a simulation setting involving mnull hypotheses, of which 90% are true and the remaining 10% are false; power is displayed as a function of the FWER. In this particular simulation setting, when m= 10", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 631, "start_word": 201920, "end_word": 202320, "chunk_words": 400}}, "ISLP_website::c000632": {"text": "FWER and Power Ingeneral,thereisatrade-offbetweentheFWERthresholdthatwechoose, and our powerto reject the null hypotheses. Recall that power is defined as the number of false null hypotheses that we reject divided by the total number of false null hypotheses, i.e. S/(m−m0)using the notation of Ta- ble13.2. Figure13.5illustrates the results of a simulation setting involving mnull hypotheses, of which 90% are true and the remaining 10% are false; power is displayed as a function of the FWER. In this particular simulation setting, when m= 10 , a FWER of 0.05corresponds to power of approxi- mately 60%. However, as mincreases, the power decreases. With m= 500 , the power is below 0.2at a FWER of 0.05, so that we successfully reject only 20% of the false null hypotheses. Figure13.5indicates that it is reasonable to control the FWER when m takes on a small value, like 5or10. However, for m= 100 orm=1,000, attempting to control the FWER will make it almost impossible to reject anyofthefalsenullhypotheses.Inotherwords,thepowerwillbeextremely low. Why is this the case? Recall that, using the notation in Table 13.2, the FWER is defined as Pr(V≥1)(13.3). In other other words, controlling the FWER at level αguarantees that the data analyst is very unlikely (with probability no more than α) to reject anytrue null hypotheses, i.e. to have any false positives. In order to make good on this guarantee when mis large, the data analyst may be forced to reject very few null hypotheses, or perhaps even none at all (since if R=0then also V=0; see Table 13.2). 14In fact, calculating the “correct” value of mis quite technical, and outside the scope of this book. 13.4 The False Discovery Rate 573 0.00.20.40.60.81.00.0 0.2 0.4 0.6 0.8 1.0Family−Wise Error RatePowerm = 10m = 100m = 500FIGURE 13.5. In a simulation setting in which 90% of the mnull hypotheses are true, we display the power (the fraction of false null hypotheses that we successfully reject) as a function of the family-wise error rate. The curves correspond to m= 10 (orange) ,m= 100 (blue), andm= 500 (purple). As the value of m increases, the power decreases. The vertical dashed line indicates a FWER of 0.05. This is scientifically uninteresting, and typically results in very low power, as in Figure 13.5. In practice, when mis large, we may be willing to tolerate a few false positives, in the interest of making more discoveries, i.e. more rejections of the null hypothesis. This is the", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 632, "start_word": 202240, "end_word": 202640, "chunk_words": 400}}, "ISLP_website::c000633": {"text": "error rate. The curves correspond to m= 10 (orange) ,m= 100 (blue), andm= 500 (purple). As the value of m increases, the power decreases. The vertical dashed line indicates a FWER of 0.05. This is scientifically uninteresting, and typically results in very low power, as in Figure 13.5. In practice, when mis large, we may be willing to tolerate a few false positives, in the interest of making more discoveries, i.e. more rejections of the null hypothesis. This is the motivation behind the false discovery rate, which we present next. 13.4 The False Discovery Rate 13.4.1 Intuition for the False Discovery Rate As we just discussed, when mis large, then trying to prevent anyfalse positives (as in FWER control) is simply too stringent. Instead, we might try to make sure that the ratio of false positives ( V) to total positives ( V+ S=R) is sufficiently low, so that most of the rejected null hypotheses are not false positives. The ratio V/Ris known as the false discovery proportionfalse discovery proportion(FDP). It might be tempting to ask the data analyst to control the FDP: to make sure that no more than, say, 20% of the rejected null hypotheses are false positives. However, in practice, controlling the FDP is an impossible task for the data analyst, since she has no way to be certain, on any par- ticular dataset, which hypotheses are true and which are false. This is very similar to the fact that the data analyst can control the FWER, i.e. she can guarantee that Pr(V≥1)≤αfor any pre-specified α, but she cannot guarantee that V=0 on any particular dataset (short of failing to reject any null hypotheses, i.e. setting R=0). 574 13. Multiple Testing Therefore, we instead control the false discovery rate (FDR)15, definedfalse discovery rateas FDR= E( FDP) = E( V/R). (13.9) When we control the FDR at (say) level q= 20% , we are rejecting as many null hypotheses as possible while guaranteeing that no more than 20% of those rejected null hypotheses are false positives, on average . In the definition of the FDR in ( 13.9), the expectation is taken over the population from which the data are generated. For instance, suppose we control the FDR for mnull hypotheses at q=0.2. This means that if we repeat this experiment a huge number of times, and each time control the FDRatq=0.2,thenweshouldexpectthat,onaverage,20%oftherejected null hypotheses will be false positives.", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 633, "start_word": 202560, "end_word": 202960, "chunk_words": 400}}, "ISLP_website::c000634": {"text": "hypotheses as possible while guaranteeing that no more than 20% of those rejected null hypotheses are false positives, on average . In the definition of the FDR in ( 13.9), the expectation is taken over the population from which the data are generated. For instance, suppose we control the FDR for mnull hypotheses at q=0.2. This means that if we repeat this experiment a huge number of times, and each time control the FDRatq=0.2,thenweshouldexpectthat,onaverage,20%oftherejected null hypotheses will be false positives. On a given dataset, the fraction of false positives among the rejected hypotheses may be greater than or less than 20%. Thus far, we have motivated the use of the FDR from a pragmatic per- spective, by arguing that when mis large, controlling the FWER is simply too stringent, and will not lead to “enough” discoveries. An additional mo- tivation for the use of the FDR is that it aligns well with the way that data are often collected in contemporary applications. As datasets continue to grow in size across a variety of fields, it is increasingly common to conduct a huge number of hypothesis tests for exploratory, rather than confirmatory, purposes. For instance, a genomic researcher might sequence the genomes of individuals with and without some particular medical condition, and then, for each of 20,000 genes, test whether sequence variants in that gene are associated with the medical condition of interest. This amounts to per- formingm= 20 ,000hypothesis tests. The analysis is exploratory in nature, in the sense that the researcher does not have any particular hypothesis in mind; instead she wishes to see whether there is modest evidence for the association between each gene and the disease, with a plan to further investigate any genes for which there is such evidence. She is likely willing to tolerate some number of false positives in the set of genes that she will investigate further; thus, the FWER is not an appropriate choice. How- ever, some correction for multiple testing is required: it would not be a good idea for her to simply investigate allgenes with p-values less than (say) 0.05, since we would expect 1,000 genes to have such small p-values simply by chance, even if no genes are associated with the disease (since 0.05×20,000 = 1 ,000). Controlling the FDR for her exploratory analysis at 20% guarantees that — on average — no more than 20% of the genes", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 634, "start_word": 202880, "end_word": 203280, "chunk_words": 400}}, "ISLP_website::c000635": {"text": "appropriate choice. How- ever, some correction for multiple testing is required: it would not be a good idea for her to simply investigate allgenes with p-values less than (say) 0.05, since we would expect 1,000 genes to have such small p-values simply by chance, even if no genes are associated with the disease (since 0.05×20,000 = 1 ,000). Controlling the FDR for her exploratory analysis at 20% guarantees that — on average — no more than 20% of the genes that she investigates further are false positives. It is worth noting that unlike p-values, for which a threshold of 0.05 is typically viewed as the minimum standard of evidence for a “positive” result, and a threshold of 0.01 or even 0.001 is viewed as much more com- pelling, there is no standard accepted threshold for FDR control. Instead, thechoiceofFDRthresholdistypicallycontext-dependent,orevendataset- dependent. For instance, the genomic researcher in the previous example might seek to control the FDR at a threshold of 10% if the planned follow- 15IfR=0, then we replace the ratio V/R with0, to avoid computing 0/0. Formally, FDR= E( V/R|R>0) Pr( R>0). 13.4 The False Discovery Rate 575 up analysis is time-consuming or expensive. Alternatively, a much larger threshold of 30% might be suitable if she plans an inexpensive follow-up analysis. 13.4.2 The Benjamini–Hochberg Procedure We now focus on the task of controlling the FDR: that is, deciding which null hypotheses to reject while guaranteeing that the FDR, E(V/R), is less than or equal to some pre-specified value q. In order to do this, we need some way to connect the p-values,p1,...,p m, from the mnull hypotheses to the desired FDR value, q. It turns out that a very simple procedure, outlined in Algorithm 13.2, can be used to control the FDR. Algorithm 13.2 Benjamini–Hochberg Procedure to Control the FDR 1. Specify q, the level at which to control the FDR. 2. Compute p-values,p1,...,p m, for the mnull hypotheses H01,...,H 0m. 3. Order the mp-values so that p(1)≤p(2)≤···≤p(m). 4. Define L= max {j:p(j)< qj/m }. (13.10) 5. Reject all null hypotheses H0jfor which pj≤p(L). Algorithm 13.2is known as the Benjamini–Hochberg procedure . The cruxBenjamini– Hochberg procedureof this procedure lies in ( 13.10). For example, consider again the first five managers in the Funddataset, presented in Table 13.3. (In this example, m=5, although typically we control the FDR in settings involving a much greater number of null hypotheses.) We see that", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 635, "start_word": 203200, "end_word": 203600, "chunk_words": 400}}, "ISLP_website::c000636": {"text": "0m. 3. Order the mp-values so that p(1)≤p(2)≤···≤p(m). 4. Define L= max {j:p(j)< qj/m }. (13.10) 5. Reject all null hypotheses H0jfor which pj≤p(L). Algorithm 13.2is known as the Benjamini–Hochberg procedure . The cruxBenjamini– Hochberg procedureof this procedure lies in ( 13.10). For example, consider again the first five managers in the Funddataset, presented in Table 13.3. (In this example, m=5, although typically we control the FDR in settings involving a much greater number of null hypotheses.) We see that p(1)=0.006<0.05×1/5, p(2)=0.012 <0.05×2/5,p(3)=0.601 >0.05×3/5,p(4)=0.756 > 0.05×4/5, andp(5)=0.918>0.05×5/5. Therefore, to control the FDR at5%, we reject the null hypotheses that the first and third fund managers perform no better than chance. As long as the mp-values are independent or only mildly dependent, then the Benjamini–Hochberg procedure guarantees16that FDR≤q. In other words, this procedure ensures that, on average, no more than a fractionqof the rejected null hypotheses are false positives. Remarkably, this holds regardless of how many null hypotheses are true, and regardless of the distribution of the p-values for the null hypotheses that are false. Therefore, the Benjamini–Hochberg procedure gives us a very easy way to determine, given a set of mp-values, which null hypotheses to reject in order to control the FDR at any pre-specified level q. 16However, the proof is well beyond the scope of this book. 576 13. Multiple Testing α=0.05 α=0.1 α=0.3 1 5 50 5001e−051e−031e−01 IndexP−Value 1 5 50 5001e−051e−031e−01 IndexP−Value 1 5 50 5001e−051e−031e−01 IndexP−Value FIGURE 13.6. Each panel displays the same set of m=2,000orderedp-values for theFunddata. The green lines indicate the p-value thresholds corresponding to FWER control, via the Bonferroni procedure, at levels α=0.05(left),α=0.1 (center), andα=0.3(right). The orange lines indicate the p-value thresholds corresponding to FDR control, via Benjamini–Hochberg, at levels q=0.05(left), q=0.1(center), andq=0.3(right). When the FDR is controlled at level q=0.1, 146 null hypotheses are rejected (center); the corresponding p-values are shown in blue. When the FDR is controlled at level q=0.3, 279 null hypotheses are rejected (right); the corresponding p-values are shown in blue. There is a fundamental difference between the Bonferroni procedure of Section13.3.2and the Benjamini–Hochberg procedure. In the Bonferroni procedure, in order to control the FWER for mnull hypotheses at level α, we must simply reject null hypotheses for which the p-value is below α/m. This threshold of α/mdoes not depend on anything about the data (beyond the value of m), and certainly does not depend on the p-values themselves.", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 636, "start_word": 203520, "end_word": 203920, "chunk_words": 400}}, "ISLP_website::c000637": {"text": "null hypotheses are rejected (right); the corresponding p-values are shown in blue. There is a fundamental difference between the Bonferroni procedure of Section13.3.2and the Benjamini–Hochberg procedure. In the Bonferroni procedure, in order to control the FWER for mnull hypotheses at level α, we must simply reject null hypotheses for which the p-value is below α/m. This threshold of α/mdoes not depend on anything about the data (beyond the value of m), and certainly does not depend on the p-values themselves. By contrast, the rejection threshold used in the Benjamini– Hochberg procedure is more complicated: we reject all null hypotheses for which the p-value is less than or equal to the Lth smallest p-value, where Lis itself a function of all mp-values, as in ( 13.10). Therefore, when con- ducting the Benjamini–Hochberg procedure, we cannot plan out in advance what threshold we will use to reject p-values; we need to first see our data. For instance, in the abstract, there is no way to know whether we will reject a null hypothesis corresponding to a p-value of 0.01 when using an FDR threshold of 0.1withm= 100 ; the answer depends on the values of the otherm−1p-values. This property of the Benjamini–Hochberg procedure is shared by the Holm procedure, which also involves a data-dependent p-value threshold. Figure13.6displaystheresultsofapplyingtheBonferroniandBenjamini– Hochberg procedures on the Funddata set, using the full set of m=2,000 fund managers, of which the first five were displayed in Table 13.3. When the FWER is controlled at level 0.3using Bonferroni, only one null hypoth- esis is rejected; that is, we can conclude only that a single fund manager is beating the market. This is despite the fact that a substantial portion of 13.5 A Re-Sampling Approach top-Values and False Discovery Rates 577them=2,000fund managers appear to have beaten the market withoutperforming correction for multiple testing — for instance, 13 of them havep-values below0.001. By contrast, when the FDR is controlled at level0.3,we can conclude that 279 fund managers are beating the market: we expectthatnomorethanaround279×0.3 = 83.7ofthesefundmanagershadgoodperformance only due to chance. Thus, we see that FDR control is muchmilder — and more powerful — than FWER control, in the sense that itallows us to reject many more null hypotheses, with a cost of substantiallymore false positives.The Benjamini–Hochberg procedure has been around since the mid-1990s.Whileagreatmanypapershavebeenpublishedsincethenproposingalternative approaches for FDR control that can perform better in partic-ular scenarios, the Benjamini–Hochberg procedure remains a very usefuland widely-applicable approach.13.5", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 637, "start_word": 203840, "end_word": 204240, "chunk_words": 400}}, "ISLP_website::c000638": {"text": "conclude that 279 fund managers are beating the market: we expectthatnomorethanaround279×0.3 = 83.7ofthesefundmanagershadgoodperformance only due to chance. Thus, we see that FDR control is muchmilder — and more powerful — than FWER control, in the sense that itallows us to reject many more null hypotheses, with a cost of substantiallymore false positives.The Benjamini–Hochberg procedure has been around since the mid-1990s.Whileagreatmanypapershavebeenpublishedsincethenproposingalternative approaches for FDR control that can perform better in partic-ular scenarios, the Benjamini–Hochberg procedure remains a very usefuland widely-applicable approach.13.5 A Re-Sampling Approach top-Values andFalse Discovery RatesThus far, the discussion in this chapter has assumed that we are interestedin testing a particular null hypothesisH0using a test statisticT, whichhas some known (or assumed) distribution underH0, such as a normaldistribution, at-distribution, aχ2-distribution, or anF-distribution. Thisis referred to as thetheoretical null distribution. We typically rely upontheoreticalnulldistributionthe availability of a theoretical null distribution in order to obtain ap-value associated with our test statistic. Indeed, for most of the types ofnull hypotheses that we might be interested in testing, a theoretical nulldistribution is available, provided that we are willing to make stringentassumptions about our data.However, if our null hypothesisH0or test statisticTis somewhat un-usual, then it may be the case that no theoretical null distribution is avail-able. Alternatively, even if a theoretical null distribution exists, then wemay be wary of relying upon it, perhaps because some assumption that isrequired for it to hold is violated. For instance, maybe the sample size istoo small.In this section, we present a framework for performing inference in thissetting, which exploits the availability of fast computers in order to approx-imate the null distribution ofT, and thereby to obtain ap-value. While thisframework is very general, it must be carefully instantiated for a specificproblem of interest. Therefore, in what follows, we consider a specific ex-ample in which we wish to test whether the means of two random variablesare equal, using a two-samplet-test.The discussion in this section is more challenging than the precedingsections in this chapter, and can be safely skipped by a reader who iscontent to use the theoretical null distribution to computep-values for hisor her test statistics. 578 13. Multiple Testing 13.5.1 A Re-Sampling Approach to the p-Value WereturntotheexampleofSection 13.1.1,inwhichwewishtotestwhether the mean of a random variable Xequals the mean of a random variable Y, i.e.H0: E(X) = E( Y), against the alternative Ha: E(X)/negationslash= E( Y). Given nXindependent observations from XandnYindependent observations fromY, the two-sample t-statistic takes the form T=ˆµX−ˆµY s/radicalBig 1", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 638, "start_word": 204160, "end_word": 204560, "chunk_words": 400}}, "ISLP_website::c000639": {"text": "this chapter, and can be safely skipped by a reader who iscontent to use the theoretical null distribution to computep-values for hisor her test statistics. 578 13. Multiple Testing 13.5.1 A Re-Sampling Approach to the p-Value WereturntotheexampleofSection 13.1.1,inwhichwewishtotestwhether the mean of a random variable Xequals the mean of a random variable Y, i.e.H0: E(X) = E( Y), against the alternative Ha: E(X)/negationslash= E( Y). Given nXindependent observations from XandnYindependent observations fromY, the two-sample t-statistic takes the form T=ˆµX−ˆµY s/radicalBig 1 nX+1 nY(13.11) whereˆµX=1 nX/summationtextnX i=1xi,ˆµY=1 nY/summationtextnY i=1yi,s=/radicalBig (nX−1)s2 X+(nY−1)s2 Y nX+nY−2, ands2 Xands2 Yare unbiased estimators of the variances in the two groups. A large (absolute) value of Tprovides evidence against H0. IfnXandnYare large, then Tin (13.11) approximately follows a N(0,1) distribution. But if nXandnYare small, then in the absence of a strong assumption about the distribution of XandY, we do not know the the- oretical null distribution of T.17In this case, it turns out that we can approximate the null distribution of Tusing are-sampling approach, orre-samplingmore specifically, a permutation approach.permutationTodothis,weconductathoughtexperiment.If H0holds,sothat E(X)= E(Y), and we make the stronger assumption that the distributions of X andYare the same, then the distribution of Tis invariant under swapping observations of Xwith observations of Y. That is, if we randomly swap some of the observations in Xwith the observations in Y, thenthe test statistic Tin(13.11)computed based on this swapped data has the same distribution as Tbased on the original data. This is true only if H0holds, and the distributions of XandYare the same. This suggests that in order to approximate the null distribution of T, we can take the following approach. We randomly permute the nX+nY observations Btimes, for some large value of B, and each time we compute (13.11). We let T∗1,...,T∗Bdenote the values of ( 13.11) on the permuted data. These can be viewed as an approximation of the null distribution ofTunderH0. Recall that by definition, a p-value is the probability of observing a test statistic at least this extreme under H0. Therefore, to compute a p-value for T, we can simply compute p-value=/summationtextB b=11(|T∗b|≥|T|) B, (13.12) the fraction of permuted datasets for which the value of the test statistic is at least as extreme as the value observed on the original data. This procedure is summarized in Algorithm 13.3. 17If we assume that XandYare normally distributed, then Tin (13.11) follows a t-distribution with nX+nY−2degrees of freedom under H0. However, in", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 639, "start_word": 204480, "end_word": 204880, "chunk_words": 400}}, "ISLP_website::c000640": {"text": "of observing a test statistic at least this extreme under H0. Therefore, to compute a p-value for T, we can simply compute p-value=/summationtextB b=11(|T∗b|≥|T|) B, (13.12) the fraction of permuted datasets for which the value of the test statistic is at least as extreme as the value observed on the original data. This procedure is summarized in Algorithm 13.3. 17If we assume that XandYare normally distributed, then Tin (13.11) follows a t-distribution with nX+nY−2degrees of freedom under H0. However, in practice, the distribution of random variables is rarely known, and so it can be preferable to perform a re-sampling approach instead of making strong and unjustified assumptions. If the results of the re-sampling approach disagree with the results of assuming a theoretical null distribution, then the results of the re-sampling approach are more trustworthy. 13.5 A Re-Sampling Approach to p-Values and False Discovery Rates 579 Algorithm 13.3 Re-Sampling p-Value for a Two-Sample t-Test 1. Compute T, defined in ( 13.11), on the original data x1,...,x nXand y1,...,y nY. 2. Forb=1,...,B , whereBis a large number (e.g. B= 10 ,000): (a) Permute the nX+nYobservations at random. Call the first nX permuted observations x∗ 1,...,x∗ nX, and call the remaining nY observations y∗ 1,...,y∗ nY. (b) Compute ( 13.11) on the permuted data x∗ 1,...,x∗ nXand y∗ 1,...,y∗ nY, and call the result T∗b. 3. Thep-value is given by/summationtextB b=11(|T∗b|≥|T|) B. We try out this procedure on the Khandataset, which consists of expres- sion measurements for 2,308genes in four sub-types of small round blood cell tumors, a type of cancer typically seen in children. This dataset is part of theISLR2package. We restrict our attention to the two sub-types for which the most observations are available: rhabdomyosarcoma ( nX= 29 ) and Burkitt’s lymphoma ( nY= 25 ). A two-sample t-test for the null hypothesis that the 11th gene’s mean expression values are equal in the two groups yields T=−2.09. Using the theoretical null distribution, which is a t52distribution (since nX+ nY−2 = 52 ), we obtain a p-value of 0.041. (Note that a t52distribution is virtually indistinguishable from a N(0,1)distribution.) If we instead apply Algorithm 13.3withB= 10 ,000, then we obtain a p-value of 0.042. Figure13.7displays the theoretical null distribution, the re-sampling null distribution, and the actual value of the test statistic ( T=−2.09) for this gene. In this example, we see very little difference between the p-values obtained using the theoretical", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 640, "start_word": 204800, "end_word": 205200, "chunk_words": 400}}, "ISLP_website::c000641": {"text": "null distribution, which is a t52distribution (since nX+ nY−2 = 52 ), we obtain a p-value of 0.041. (Note that a t52distribution is virtually indistinguishable from a N(0,1)distribution.) If we instead apply Algorithm 13.3withB= 10 ,000, then we obtain a p-value of 0.042. Figure13.7displays the theoretical null distribution, the re-sampling null distribution, and the actual value of the test statistic ( T=−2.09) for this gene. In this example, we see very little difference between the p-values obtained using the theoretical null distribution and the re-sampling null distribution. By contrast, Figure 13.8shows an analogous set of results for the 877th gene. In this case, there is a substantial difference between the theoretical and re-sampling null distributions, which results in a difference between theirp-values. In general, in settings with a smaller sample size or a more skewed data distribution (so that the theoretical null distribution is less accurate), the difference between the re-sampling and theoretical p-values will tend to be more pronounced. In fact, the substantial difference between the re- sampling and theoretical null distributions in Figure 13.8is due to the fact that a single observation in the 877th gene is very far from the other observations, leading to a very skewed distribution. 13.5.2 A Re-Sampling Approach to the False Discovery Rate Now, suppose that we wish to control the FDR for mnull hypotheses, H01,...,H 0m, in a setting in which either no theoretical null distribution is available, or else we simply prefer to avoid the use of a theoretical null 580 13. Multiple Testing Null Distribution of Test Statistic for 11th Gene−4−20240 100 200 300 400T=−2.0936 FIGURE 13.7. The11th gene in the Khandataset has a test statistic of T=−2.09. Its theoretical and re-sampling null distributions are almost identical. The theoretical p-value equals 0.041and the re-sampling p-value equals 0.042. FIGURE 13.8. The877th gene in the Khandataset has a test statistic of T=−0.57. Its theoretical and re-sampling null distributions are quite different. The theoretical p-value equals 0.571, and the re-sampling p-value equals 0.673. distribution.AsinSection 13.5.1,wemakeuseofatwo-sample t-statisticfor each hypothesis, leading to the test statistics T1,...,T m. We could simply compute a p-value for each of the mnull hypotheses, as in Section 13.5.1, and then apply the Benjamini–Hochberg procedure of Section 13.4.2to thesep-values. However, it turns out that we can do this in a more direct way, without even needing to compute p-values. Recall from Section 13.4that the FDR is defined as E(V/R), using the", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 641, "start_word": 205120, "end_word": 205520, "chunk_words": 400}}, "ISLP_website::c000642": {"text": "theoretical p-value equals 0.571, and the re-sampling p-value equals 0.673. distribution.AsinSection 13.5.1,wemakeuseofatwo-sample t-statisticfor each hypothesis, leading to the test statistics T1,...,T m. We could simply compute a p-value for each of the mnull hypotheses, as in Section 13.5.1, and then apply the Benjamini–Hochberg procedure of Section 13.4.2to thesep-values. However, it turns out that we can do this in a more direct way, without even needing to compute p-values. Recall from Section 13.4that the FDR is defined as E(V/R), using the notation in Table 13.2. In order to estimate the FDR via re-sampling, we first make the following approximation: FDR=E/parenleftbiggV R/parenrightbigg ≈E(V) R. (13.13) Now suppose we reject any null hypothesis for which the test statistic exceedscin absolute value. Then computing Rin the denominator on the right-hand side of ( 13.13) is straightforward: R=/summationtextm j=11(|Tj|≥c).Null Distribution of Test Statistic for 877th Gene−4−20240 100 200 300 400T=−0.5696 13.5 A Re-Sampling Approach to p-Values and False Discovery Rates 581 However, the numerator E(V)on the right-hand side of ( 13.13) is more challenging. This is the expected number of false positives associated with rejecting any null hypothesis for which the test statistic exceeds cin abso- lute value. At the risk of stating the obvious, estimating Vis challenging because we do not know which of H01,...,H 0mare really true, and so we do not know which rejected hypotheses are false positives. To overcome this problem, we take a re-sampling approach, in which we simulate data under H01,...,H 0m, and then compute the resulting test statistics. The number of re-sampled test statistics that exceed cprovides an estimate of V. In greater detail, in the case of a two-sample t-statistic ( 13.11) for each of the null hypotheses H01,...,H 0m, we can estimate E(V)as follows. Let x(j) 1,...,x(j) nXandy(j) 1,...,y(j) nYdenote the data associated with the jth null hypothesis, j=1,...,m . We permute these nX+nYobservations at random, and then compute the t-statistic on the permuted data. For this permuted data, we know that all of the null hypotheses H01,...,H 0mhold; therefore,thenumberofpermuted t-statisticsthatexceedthethreshold cin absolute value provides an estimate for E(V). This estimate can be further improved by repeating the permutation process Btimes, for a large value ofB, and averaging the results. Algorithm 13.4details this procedure.18It provides what is known as a plug-inestimate oftheFDR,becausetheapproximationin( 13.13)allowsus to estimate the FDR by plugging Rinto the denominator and an estimate forE(V)into the numerator. We apply the re-sampling approach to the FDR", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 642, "start_word": 205440, "end_word": 205840, "chunk_words": 400}}, "ISLP_website::c000643": {"text": "this permuted data, we know that all of the null hypotheses H01,...,H 0mhold; therefore,thenumberofpermuted t-statisticsthatexceedthethreshold cin absolute value provides an estimate for E(V). This estimate can be further improved by repeating the permutation process Btimes, for a large value ofB, and averaging the results. Algorithm 13.4details this procedure.18It provides what is known as a plug-inestimate oftheFDR,becausetheapproximationin( 13.13)allowsus to estimate the FDR by plugging Rinto the denominator and an estimate forE(V)into the numerator. We apply the re-sampling approach to the FDR from Algorithm 13.4, as well as the Benjamini–Hochberg approach from Algorithm 13.2using theoretical p-values, to the m=2,308genes in the Khandataset. Results are showninFigure 13.9.Weseethatforagivennumberofrejectedhypotheses, the estimated FDRs are almost identical for the two methods. We began this section by noting that in order to control the FDR for m hypothesis tests using a re-sampling approach, we could simply compute m re-sampling p-values as in Section 13.5.1, and then apply the Benjamini– Hochberg procedure of Section 13.4.2to thesep-values. It turns out that if we define the jth re-sampling p-value as pj=/summationtextm j/prime=1/summationtextB b=11(|T∗b j/prime|≥|Tj|) Bm(13.14) forj=1,...,m , instead of as in ( 13.12), then applying the Benjamini– Hochberg procedure to these re-sampled p-values is exactlyequivalent to Algorithm 13.4. Note that ( 13.14) is an alternative to ( 13.12) that pools the information across all mhypothesis tests in approximating the null distribution. 13.5.3 When Are Re-Sampling Approaches Useful? In Sections 13.5.1and13.5.2, we considered testing null hypotheses of the formH0: E(X) = E( Y)using a two-sample t-statistic ( 13.11), for which we 18To implement Algorithm 13.4efficiently, the same set of permutations in Step 2(b)i. should be used for all mnull hypotheses. 582 13. Multiple Testing Algorithm 13.4 Plug-In FDR for a Two-Sample T-Test 1. Select a threshold c, wherec>0. 2. Forj=1,...,m : (a) Compute T(j), the two-sample t-statistic ( 13.11) for the null hypothesis H0jon the basis of the original data, x(j) 1,...,x(j) nX andy(j) 1,...,y(j) nY. (b) Forb=1,...,B , whereBis a large number (e.g. B= 10 ,000): i. Permute the nX+nYobservations at random. Call the first nXobservations x∗(j) 1,...,x∗(j) nX, and call the remaining ob- servations y∗(j) 1,...,y∗(j) nY. ii. Compute ( 13.11) on the permuted data x∗(j) 1,...,x∗(j) nXand y∗(j) 1,...,y∗(j) nY, and call the result T(j),∗b. 3. Compute R=/summationtextm j=11(|T(j)|≥c). 4. Compute /hatwideV=/summationtextB b=1/summationtextm j=11(|T(j),∗b|≥c) B. 5. The estimated FDR associated with the threshold cis/hatwideV /R. approximatedthenulldistributionviaare-samplingapproach.Wesawthat using the re-sampling approach gave us substantially different results from usingthetheoretical p-valueapproachinFigure 13.8,butnotinFigure", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 643, "start_word": 205760, "end_word": 206160, "chunk_words": 400}}, "ISLP_website::c000644": {"text": "number (e.g. B= 10 ,000): i. Permute the nX+nYobservations at random. Call the first nXobservations x∗(j) 1,...,x∗(j) nX, and call the remaining ob- servations y∗(j) 1,...,y∗(j) nY. ii. Compute ( 13.11) on the permuted data x∗(j) 1,...,x∗(j) nXand y∗(j) 1,...,y∗(j) nY, and call the result T(j),∗b. 3. Compute R=/summationtextm j=11(|T(j)|≥c). 4. Compute /hatwideV=/summationtextB b=1/summationtextm j=11(|T(j),∗b|≥c) B. 5. The estimated FDR associated with the threshold cis/hatwideV /R. approximatedthenulldistributionviaare-samplingapproach.Wesawthat using the re-sampling approach gave us substantially different results from usingthetheoretical p-valueapproachinFigure 13.8,butnotinFigure 13.7. In general, there are two settings in which a re-sampling approach is particularly useful: 1. Perhaps no theoretical null distribution is available. This may be the case if you are testing an unusual null hypothesis H0, or using an unsual test statistic T. 2. Perhaps a theoretical null distribution isavailable, but the assump- tions required for its validity do not hold. For instance, the two- samplet-statistic in ( 13.11) follows a tnX+nY−2distribution only if the observations are normally distributed. Furthermore, it follows a N(0,1)distribution only if nXandnYare quite large. If the data are non-normal and nXandnYare small, then p-values that make use of the theoretical null distribution will not be valid (i.e. they will not properly control the Type I error). In general, if you can come up with a way to re-sample or permute your observations in order to generate data that follow the null distribu- tion, then you can compute p-values or estimate the FDR using variants of Algorithms 13.3and13.4. In many real-world settings, this provides a powerfultoolforhypothesistestingwhennoout-of-boxhypothesistestsare available, or when the key assumptions underlying those out-of-box tests are violated. 13.6 Lab: Multiple Testing 583 0500 1000 1500 20000.0 0.2 0.4 0.6 0.8 1.0Number of RejectionsFalse Discovery RateFIGURE 13.9. Forj=1,...,m =2,308, we tested the null hypothesis that for thejth gene in the Khandataset, the meanexpression in Burkitt’s lymphoma equals themeanexpressioninrhabdomyosarcoma.Foreachvalueof kfrom1to2,308,the y-axis displays the estimated FDR associated with rejecting the null hypotheses corresponding to the ksmallest p-values. The orange dashed curve shows the FDR obtained using the Benjamini–Hochberg procedure, whereas the blue solid curve shows the FDR obtained using the re-sampling approach of Algorithm 13.4, withB= 10 ,000. There is very little difference between the two FDR estimates. According to either estimate, rejecting the null hypothesis for the 500 genes with the smallest p-values corresponds to an FDR of around 17.7%. 13.6 Lab: Multiple Testing We include our usual imports seen in earlier labs. In[1]: import numpy", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 644, "start_word": 206080, "end_word": 206480, "chunk_words": 400}}, "ISLP_website::c000645": {"text": "The orange dashed curve shows the FDR obtained using the Benjamini–Hochberg procedure, whereas the blue solid curve shows the FDR obtained using the re-sampling approach of Algorithm 13.4, withB= 10 ,000. There is very little difference between the two FDR estimates. According to either estimate, rejecting the null hypothesis for the 500 genes with the smallest p-values corresponds to an FDR of around 17.7%. 13.6 Lab: Multiple Testing We include our usual imports seen in earlier labs. In[1]: import numpy as np import pandas as pd import matplotlib.pyplot as plt import statsmodels.api as sm from ISLP import load_data We also collect the new imports needed for this lab. In[2]: from scipy.stats import \\ (ttest_1samp, ttest_rel, ttest_ind, ta st _ d b n ) from statsmodels.stats.multicomp import \\ pairwise_tukeyhsd from statsmodels.stats.multitest import \\ multipletests as mult_test 13.6.1 Review of Hypothesis Tests We begin by performing some one-sample t-tests. First we create 100 vari- ables, each consisting of 10 observations. The first 50 variables have mean 0.5and variance 1, while the others have mean 0and variance 1. In[3]: rng = np.random.default_rng(12) X=r n g . s t a n d a r d _ n o r m a l ( ( 1 0 ,1 0 0 ) ) true_mean = np.array([0.5]*50 + [0]*50) X+ =t r u e _ m e a n [ N o n e , : ] 584 13. Multiple Testing To begin, we use ttest_1samp() from the scipy.stats module to test H0:ttest_1samp()µ1=0, the null hypothesis that the first variable has mean zero. In[4]: result = ttest_1samp(X[:,0], 0) result.pvalue Out[4]: 0.931 Thep-value comes out to 0.931, which is not low enough to reject the null hypothesis at level α=0.05. In this case, µ1=0.5, so the null hypothesis is false. Therefore, we have made a Type II error by failing to reject the null hypothesis when the null hypothesis is false. We now test H0,j:µj=0forj=1,...,100. We compute the 100 p- values, and then construct a vector recording whether the jthp-value is less than or equal to 0.05, in which case we reject H0j, or greater than 0.05, in which case we do not reject H0j, forj=1,...,100. In[5]: p_values = np.empty(100) for i in range(100): p_values[i] = ttest_1samp(X[:,i], 0).pvalue decision = pd.cut(p_values, [0, 0.05, 1], labels=[ 'Reject H0' , 'Do not reject H0' ]) truth = pd.Categorical(true_mean == 0, categories=[True, False], ordered=True) Since this is a simulated data set,", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 645, "start_word": 206400, "end_word": 206800, "chunk_words": 400}}, "ISLP_website::c000646": {"text": "100 p- values, and then construct a vector recording whether the jthp-value is less than or equal to 0.05, in which case we reject H0j, or greater than 0.05, in which case we do not reject H0j, forj=1,...,100. In[5]: p_values = np.empty(100) for i in range(100): p_values[i] = ttest_1samp(X[:,i], 0).pvalue decision = pd.cut(p_values, [0, 0.05, 1], labels=[ 'Reject H0' , 'Do not reject H0' ]) truth = pd.Categorical(true_mean == 0, categories=[True, False], ordered=True) Since this is a simulated data set, we can create a 2×2table similar to Table13.2. In[6]: pd.crosstab(decision, truth, rownames=[ 'Decision' ], colnames=[ 'H0']) Out[6]: H0 True False Decision Reject H0 5 15 Do not reject H0 45 35 Therefore, at level α=0.05, we reject 15 of the 50 false null hypotheses, and we incorrectly reject 5 of the true null hypotheses. Using the notation from Section 13.3, we have V=5,S= 15,U= 45andW= 35. We have setα=0.05, which means that we expect to reject around 5% of the true null hypotheses. This is in line with the 2×2table above, which indicates that we rejected V=5of the50true null hypotheses. In the simulation above, for the false null hypotheses, the ratio of the mean to the standard deviation was only 0.5/1=0.5. This amounts to quite a weak signal, and it resulted in a high number of Type II errors. Let’s instead simulate data with a stronger signal, so that the ratio of the mean to the standard deviation for the false null hypotheses equals 1.W e make only 10 Type II errors. 13.6 Lab: Multiple Testing 585 In[7]: true_mean = np.array([1]*50 + [0]*50) X=r n g . s t a n d a r d _ n o r m a l ( ( 1 0 ,1 0 0 ) ) X+ =t r u e _ m e a n [ N o n e , : ] for i in range(100): p_values[i] = ttest_1samp(X[:,i], 0).pvalue decision = pd.cut(p_values, [0, 0.05, 1], labels=[ 'Reject H0' , 'Do not reject H0' ]) truth = pd.Categorical(true_mean == 0, categories=[True, False], ordered=True) pd.crosstab(decision, truth, rownames=[ 'Decision' ], colnames=[ 'H0']) Out[7]: H0 True False Decision Reject H0 2 40 Do not reject H0 48 10 13.6.2 Family-Wise Error Rate Recall from ( 13.5) that if the null hypothesis is true for each of minde- pendent hypothesis tests, then the FWER is equal to 1−(1−α)m.W e can use this expression to compute the FWER", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 646, "start_word": 206720, "end_word": 207120, "chunk_words": 400}}, "ISLP_website::c000647": {"text": "[0, 0.05, 1], labels=[ 'Reject H0' , 'Do not reject H0' ]) truth = pd.Categorical(true_mean == 0, categories=[True, False], ordered=True) pd.crosstab(decision, truth, rownames=[ 'Decision' ], colnames=[ 'H0']) Out[7]: H0 True False Decision Reject H0 2 40 Do not reject H0 48 10 13.6.2 Family-Wise Error Rate Recall from ( 13.5) that if the null hypothesis is true for each of minde- pendent hypothesis tests, then the FWER is equal to 1−(1−α)m.W e can use this expression to compute the FWER for m=1,...,500and α=0.05,0.01, and0.001. We plot the FWER for these values of αin order to reproduce Figure 13.2. In[8]: m=n p . l i n s p a c e ( 1 ,5 0 1 ) fig, ax = plt.subplots() [ax.plot(m, 1-( 1-a l p h a ) * * m , label=r'$\\alpha=%s$' %s t r ( a l p h a ) ) for alpha in [0.05, 0.01, 0.001]] ax.set_xscale( 'log') ax.set_xlabel( 'Number of Hypotheses' ) ax.set_ylabel( 'Family-Wise Error Rate' ) ax.legend() ax.axhline(0.05, c= 'k',l s ='--'); As discussed previously, even for moderate values of msuch as50, the FWER exceeds 0.05unlessαis set to a very low value, such as 0.001. Of course, the problem with setting αto such a low value is that we are likely to make a number of Type II errors: in other words, our power is very low. We now conduct a one-sample t-test for each of the first five managers in theFunddataset, in order to test the null hypothesis that the jth fund manager’s mean return equals zero, H0,j:µj=0. In[9]: Fund = load_data( 'Fund') fund_mini = Fund.iloc[:,:5] fund_mini_pvals = np.empty(5) for i in range(5): 586 13. Multiple Testingfund_mini_pvals[i] = ttest_1samp(fund_mini.iloc[:,i], 0).pvaluefund_mini_pvalsOut[9]:array([0.006, 0.918, 0.012, 0.601, 0.756])Thep-values are low for Managers One and Three, and high for the otherthree managers. However, we cannot simply rejectH0,1andH0,3, sincethis would fail to account for the multiple testing that we have performed.Instead,wewillconductBonferroni’smethodandHolm’smethodtocontrolthe FWER.To do this, we use themultipletests()function from thestatsmodelsmultiple-tests()module (abbreviated tomult_test()). Given thep-values, for methods likeHolm and Bonferroni the function outputsadjustedp-values, which can beadjustedp-valuesthought of as a new set ofp-values that have been corrected for multipletesting. If the adjustedp-value for a given hypothesis is less than or equaltoα, then that hypothesis can be rejected while maintaining a FWER ofno more thanα. In other words, for such methods, the adjustedp-valuesresulting from themultipletests()function can simply be compared tothe desired FWER in order to determine whether or not to reject eachhypothesis. We", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 647, "start_word": 207040, "end_word": 207440, "chunk_words": 400}}, "ISLP_website::c000648": {"text": "(abbreviated tomult_test()). Given thep-values, for methods likeHolm and Bonferroni the function outputsadjustedp-values, which can beadjustedp-valuesthought of as a new set ofp-values that have been corrected for multipletesting. If the adjustedp-value for a given hypothesis is less than or equaltoα, then that hypothesis can be rejected while maintaining a FWER ofno more thanα. In other words, for such methods, the adjustedp-valuesresulting from themultipletests()function can simply be compared tothe desired FWER in order to determine whether or not to reject eachhypothesis. We will later see that we can use the same function to controlFDR as well.Themult_test()function takesp-values and amethodargument, as wellas an optionalalphaargument. It returns the decisions (rejectbelow) aswell as the adjustedp-values (bonf).In[10]:reject, bonf = mult_test(fund_mini_pvals, method =\"bonferroni\")[:2]rejectOut[10]:array([ True, False, False, False, False])Thep-valuesbonfare simply thefund_mini_pvaluesmultiplied by 5 andtruncated to be less than or equal to 1.In[11]:bonf, np.minimum(fund_mini_pvals * 5, 1)Out[11]:(array([0.03, 1. , 0.06, 1. , 1. ]),array([0.03, 1. , 0.06, 1. , 1. ]))Therefore, using Bonferroni’s method, we are able to reject the null hy-pothesis only for Manager One while controlling FWER at0.05.By contrast, using Holm’s method, the adjustedp-values indicate thatwe can reject the null hypotheses for Managers One and Three at a FWERof0.05.In[12]:mult_test(fund_mini_pvals, method =\"holm\",a l p h a = 0 . 0 5 ) [ : 2 ]Out[12]:(array([ True, False, True, False, False]),array([0.03, 1. , 0.05, 1. , 1. ]))Asdiscussedpreviously,ManagerOneseemstoperformparticularlywell,whereas Manager Two has poor performance. 13.6 Lab: Multiple Testing 587 In[13]: fund_mini.mean() Out[13]: Manager1 3.0 Manager2 -0.1 Manager3 2.8 Manager4 0.5 Manager5 0.3 dtype: float64 Isthereevidenceofameaningfuldifferenceinperformancebetweenthese two managers? We can check this by performing a pairedt-testusing thepairedt-testttest_rel() function from scipy.stats :ttest_rel() In[14]: ttest_rel(fund_mini[ 'Manager1' ], fund_mini[ 'Manager2' ]).pvalue Out[14]: 0.038 The test results in a p-value of 0.038, suggesting a statistically significant difference. However, we decided to perform this test only after examining the data and noting that Managers One and Two had the highest and lowest mean performances. In a sense, this means that we have implicitly performed/parenleftbig5 2/parenrightbig = 5(5−1)/2 = 10hypothesis tests, rather than just one, as discussed in Section 13.3.2. Hence, we use the pairwise_tukeyhsd() function frompairwise_ tukeyhsd()statsmodels.stats.multicomp to apply Tukey’s method in order to adjust for multiple testing. This function takes as input a fitted ANOVA regres-ANOVAsion model, which is essentially just a linear regression in which all of the predictors are qualitative. In this case, the response consists of the monthly excess returns achieved by each manager, and the predictor indicates the manager to", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 648, "start_word": 207360, "end_word": 207760, "chunk_words": 400}}, "ISLP_website::c000649": {"text": "= 5(5−1)/2 = 10hypothesis tests, rather than just one, as discussed in Section 13.3.2. Hence, we use the pairwise_tukeyhsd() function frompairwise_ tukeyhsd()statsmodels.stats.multicomp to apply Tukey’s method in order to adjust for multiple testing. This function takes as input a fitted ANOVA regres-ANOVAsion model, which is essentially just a linear regression in which all of the predictors are qualitative. In this case, the response consists of the monthly excess returns achieved by each manager, and the predictor indicates the manager to which each return corresponds. In[15]: returns = np.hstack([fund_mini.iloc[:,i] for i in range(5)]) managers = np.hstack([[i+1]*50 for i in range(5)]) tukey = pairwise_tukeyhsd(returns, managers) print(tukey.summary()) Multiple Comparison of Means - Tukey HSD, FWER=0.05 =================================================== group1 group2 meandiff p-adj lower upper reject --------------------------------------------------- 12 - 3 . 1 0 . 1 8 6 2 - 6 . 9 8 6 5 0 . 7 8 6 5 F a l s e 13 - 0 . 2 0 . 9 9 9 9 - 4 . 0 8 6 5 3 . 6 8 6 5 F a l s e 14 - 2 . 5 0 . 3 9 4 8 - 6 . 3 8 6 5 1 . 3 8 6 5 F a l s e 15 - 2 . 7 0 . 3 1 5 2 - 6 . 5 8 6 5 1 . 1 8 6 5 F a l s e 2 3 2.9 0.2453 -0.9865 6.7865 False 240 . 6 0 . 9 9 3 2 - 3 . 2 8 6 5 4 . 4 8 6 5 F a l s e 250 . 4 0 . 9 9 8 6 - 3 . 4 8 6 5 4 . 2 8 6 5 F a l s e 34 - 2 . 3 0 . 4 8 2 - 6 . 1 8 6 5 1 . 5 8 6 5 F a l s e 35 - 2 . 5 0 . 3 9 4 8 - 6 . 3 8 6 5 1 . 3 8 6 5 F a l s e 45 - 0 . 2 0 . 9 9 9 9 - 4 . 0 8 6 5 3 . 6 8 6 5 F a l s e --------------------------------------------------- Thepairwise_tukeyhsd() function provides confidence intervals for the difference between each pair of managers ( lowerandupper),", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 649, "start_word": 207680, "end_word": 208080, "chunk_words": 400}}, "ISLP_website::c000650": {"text": "5 F a l s e 35 - 2 . 5 0 . 3 9 4 8 - 6 . 3 8 6 5 1 . 3 8 6 5 F a l s e 45 - 0 . 2 0 . 9 9 9 9 - 4 . 0 8 6 5 3 . 6 8 6 5 F a l s e --------------------------------------------------- Thepairwise_tukeyhsd() function provides confidence intervals for the difference between each pair of managers ( lowerandupper), as well as a 588 13. Multiple Testing FIGURE 13.10. 95% confidence intervals for each manager on the Funddata, using Tukey’s method to adjust for multiple testing. All of the confidence intervals overlap, so none of the differences among managers are statistically significant when controlling FWER at level 0.05. p-value. All of these quantities have been adjusted for multiple testing. Notice that the p-value for the difference between Managers One and Two has increased from 0.038to0.186, so there is no longer clear evidence of a difference between the managers’ performances. We can plot the confi- dence intervals for the pairwise comparisons using the plot_simultaneous() method of tukey. Any pair of intervals that don’t overlap indicates a sig- nificant difference at the nominal level of 0.05. In this case, no differences are considered significant as reported in the table above. In[16]: fig, ax = plt.subplots(figsize=(8,8)) tukey.plot_simultaneous(ax=ax); The result can be seen19in Figure 13.10. 13.6.3 False Discovery Rate Now we perform hypothesis tests for all 2,000 fund managers in the Fund dataset. We perform a one-sample t-test ofH0,j:µj=0, which states that thejth fund manager’s mean return is zero. In[17]: fund_pvalues = np.empty(2000) for i, manager in enumerate(Fund.columns): fund_pvalues[i] = ttest_1samp(Fund[manager], 0).pvalue There are far too many managers to consider trying to control the FWER. Instead, we focus on controlling the FDR: that is, the expected fraction of rejected null hypotheses that are actually false positives. The 19Traditionally this plot shows intervals for each paired difference. With many groups it is more convenient and equivalent to display one interval per group, as is done here. By “differencing” all pairs of intervals displayed here you recover the traditional plot. 13.6 Lab: Multiple Testing 589 multipletests() function (abbreviated mult_test() ) can be used to carry out the Benjamini–Hochberg procedure. In[18]: fund_qvalues = mult_test(fund_pvalues, method = \"fdr_bh\" )[1] fund_qvalues[:10] Out[18]: array([0.09, 0.99, 0.12, 0.92, 0.96, 0.08, 0.08, 0.08, 0.08, 0.08]) Theq-values output by the Benjamini–Hochberg procedure", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 650, "start_word": 208000, "end_word": 208400, "chunk_words": 400}}, "ISLP_website::c000651": {"text": "each paired difference. With many groups it is more convenient and equivalent to display one interval per group, as is done here. By “differencing” all pairs of intervals displayed here you recover the traditional plot. 13.6 Lab: Multiple Testing 589 multipletests() function (abbreviated mult_test() ) can be used to carry out the Benjamini–Hochberg procedure. In[18]: fund_qvalues = mult_test(fund_pvalues, method = \"fdr_bh\" )[1] fund_qvalues[:10] Out[18]: array([0.09, 0.99, 0.12, 0.92, 0.96, 0.08, 0.08, 0.08, 0.08, 0.08]) Theq-values output by the Benjamini–Hochberg procedure can be inter-q-valuespreted as the smallest FDR threshold at which we would reject a particular null hypothesis. For instance, a q-value of 0.1indicates that we can reject the corresponding null hypothesis at an FDR of 10% or greater, but that we cannot reject the null hypothesis at an FDR below 10%. If we control the FDR at 10%, then for how many of the fund managers can we reject H0,j:µj=0? In[19]: (fund_qvalues <= 0.1).sum() Out[19]: 146 We find that 146 of the 2,000 fund managers have a q-value below 0.1; therefore, we are able to conclude that 146 of the fund managers beat the market at an FDR of 10%. Only about 15 (10% of 146) of these fund managers are likely to be false discoveries. By contrast, if we had instead used Bonferroni’s method to control the FWER at level α=0.1, then we would have failed to reject any null hypotheses! In[20]: (fund_pvalues <= 0.1 / 2000).sum() Out[20]: 0 Figure13.6displays the ordered p-values,p(1)≤p(2)≤···≤p(2000), for theFunddataset, as well as the threshold for rejection by the Benjamini– Hochberg procedure. Recall that the Benjamini–Hochberg procedure iden- tifies the largest p-value such that p(j)< qj/m, and rejects all hypotheses for which the p-value is less than or equal to p(j). In the code below, we im- plement the Benjamini–Hochberg procedure ourselves, in order to illustrate how it works. We first order the p-values. We then identify all p-values that satisfyp(j)< qj/m (sorted_set_ ). Finally, selected_ is a boolean array indicating which p-values are less than or equal to the largest p-value in sorted_[sorted_set_] . Therefore, selected_ indexes the p-values rejected by the Benjamini–Hochberg procedure. In[21]: sorted_ = np.sort(fund_pvalues) m=f u n d _ p v a l u e s . s h a p e [ 0 ] q=0 . 1 sorted_set_ = np.where(sorted_ < q * np.linspace(1, m, m) / m)[0] if sorted_set_.shape[0] > 0: selected_ = fund_pvalues < sorted_[sorted_set_].max() sorted_set_", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 651, "start_word": 208320, "end_word": 208720, "chunk_words": 400}}, "ISLP_website::c000652": {"text": "Finally, selected_ is a boolean array indicating which p-values are less than or equal to the largest p-value in sorted_[sorted_set_] . Therefore, selected_ indexes the p-values rejected by the Benjamini–Hochberg procedure. In[21]: sorted_ = np.sort(fund_pvalues) m=f u n d _ p v a l u e s . s h a p e [ 0 ] q=0 . 1 sorted_set_ = np.where(sorted_ < q * np.linspace(1, m, m) / m)[0] if sorted_set_.shape[0] > 0: selected_ = fund_pvalues < sorted_[sorted_set_].max() sorted_set_ = np.arange(sorted_set_.max()) else: selected_ = [] sorted_set_ = [] 590 13. Multiple Testing We now reproduce the middle panel of Figure 13.6. In[22]: fig, ax = plt.subplots() ax.scatter(np.arange(0, sorted_.shape[0]) + 1, sorted_, s=10) ax.set_yscale( 'log') ax.set_xscale( 'log') ax.set_ylabel( 'P-Value' ) ax.set_xlabel( 'Index' ) ax.scatter(sorted_set_+1, sorted_[sorted_set_], c= 'r',s = 2 0 ) ax.axline((0, 0), (1,q/m), c= 'k',l s ='--',l i n e w i d t h = 3 ) ; 13.6.4 A Re-Sampling Approach Here, we implement the re-sampling approach to hypothesis testing using theKhandataset, which we investigated in Section 13.5. First, we merge the training and testing data, which results in observations on 83 patients for 2,308 genes. In[23]: Khan = load_data( 'Khan') D=p d . c o n c a t ( [ K h a n [ 'xtrain' ], Khan[ 'xtest' ]]) D['Y']=p d . c o n c a t ( [ K h a n [ 'ytrain' ], Khan[ 'ytest' ]]) D['Y'].value_counts() Out[23]: 22 9 42 5 31 8 11 1 Name: Y, dtype: int64 There are four classes of cancer. For each gene, we compare the mean ex- pression in the second class (rhabdomyosarcoma) to the mean expression in the fourth class (Burkitt’s lymphoma). Performing a standard two-sample t-test using ttest_ind() fromscipy.stats on the11th gene produces attest_ind()test-statistic of -2.09 and an associated p-value of 0.0412, suggesting mod- estevidenceofadifferenceinmeanexpressionlevelsbetweenthetwocancer types. In[24]: D2 = D[lambda df:df[ 'Y']= =2 ] D4 = D[lambda df:df[ 'Y']= =4 ] gene_11 = 'G0011' observedT, pvalue = ttest_ind(D2[gene_11], D4[gene_11], equal_var=True) observedT, pvalue Out[24]: (-2.094, 0.041) However, this p-value relies on the assumption that under the null hy- pothesis of no difference between the two groups, the test statistic follows at-distribution with 29 + 25−2 = 52degrees of freedom. Instead of us- ing this theoretical null distribution, we can randomly split the 54 patients into two groups of 29 and 25, and compute a new test statistic. Under the null hypothesis of", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 652, "start_word": 208640, "end_word": 209040, "chunk_words": 400}}, "ISLP_website::c000653": {"text": "gene_11 = 'G0011' observedT, pvalue = ttest_ind(D2[gene_11], D4[gene_11], equal_var=True) observedT, pvalue Out[24]: (-2.094, 0.041) However, this p-value relies on the assumption that under the null hy- pothesis of no difference between the two groups, the test statistic follows at-distribution with 29 + 25−2 = 52degrees of freedom. Instead of us- ing this theoretical null distribution, we can randomly split the 54 patients into two groups of 29 and 25, and compute a new test statistic. Under the null hypothesis of no difference between the groups, this new test statis- tic should have the same distribution as our original one. Repeating this 13.6 Lab: Multiple Testing 591 process 10,000 times allows us to approximate the null distribution of the test statistic. We compute the fraction of the time that our observed test statistic exceeds the test statistics obtained via re-sampling. In[25]: B=1 0 0 0 0 Tnull = np.empty(B) D_ = np.hstack([D2[gene_11], D4[gene_11]]) n_ = D2[gene_11].shape[0] D_null = D_.copy() for b in range(B): rng.shuffle(D_null) ttest_ = ttest_ind(D_null[:n_], D_null[n_:], equal_var=True) Tnull[b] = ttest_.statistic (np.abs(Tnull) > np.abs(observedT)).mean() Out[25]: 0.0398 Thisfraction,0.0398,isourre-sampling-based p-value.Itisalmostidenti- cal to the p-value of 0.0412 obtained using the theoretical null distribution. We can plot a histogram of the re-sampling-based test statistics in order to reproduce Figure 13.7. In[26]: fig, ax = plt.subplots(figsize=(8,8)) ax.hist(Tnull, bins=100, density=True, facecolor= 'y', label='Null') xval = np.linspace(-4.2, 4.2, 1001) ax.plot(xval, t_dbn.pdf(xval, D_.shape[0]-2), c='r') ax.axvline(observedT, c='b', label='Observed' ) ax.legend() ax.set_xlabel( \"Null Distribution of Test Statistic\" ); The re-sampling-based null distribution is almost identical to the theoret- ical null distribution, which is displayed in red. Finally, we implement the plug-in re-sampling FDR approach outlined in Algorithm 13.4. Depending on the speed of your computer, calculating the FDR for all 2,308 genes in the Khandataset may take a while. Hence, we will illustrate the approach on a random subset of 100 genes. For each gene, we first compute the observed test statistic, and then produce 10,000 re-sampled test statistics. This may take a few minutes to run. If you are in a rush, then you could set Bequal to a smaller value (e.g. B=500). In[27]: m, B = 100, 10000 idx = rng.choice(Khan[ 'xtest' ].columns, m, replace=False) T_vals = np.empty(m) Tnull_vals = np.empty((m, B)) for j in range(m): col = idx[j] 592 13. Multiple Testing T_vals[j] = ttest_ind(D2[col], D4[col], equal_var=True).statistic D_ = np.hstack([D2[col], D4[col]]) D_null = D_.copy() for b in range(B): rng.shuffle(D_null) ttest_ = ttest_ind(D_null[:n_], D_null[n_:], equal_var=True) Tnull_vals[j,b] = ttest_.statistic", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 653, "start_word": 208960, "end_word": 209360, "chunk_words": 400}}, "ISLP_website::c000654": {"text": "may take a few minutes to run. If you are in a rush, then you could set Bequal to a smaller value (e.g. B=500). In[27]: m, B = 100, 10000 idx = rng.choice(Khan[ 'xtest' ].columns, m, replace=False) T_vals = np.empty(m) Tnull_vals = np.empty((m, B)) for j in range(m): col = idx[j] 592 13. Multiple Testing T_vals[j] = ttest_ind(D2[col], D4[col], equal_var=True).statistic D_ = np.hstack([D2[col], D4[col]]) D_null = D_.copy() for b in range(B): rng.shuffle(D_null) ttest_ = ttest_ind(D_null[:n_], D_null[n_:], equal_var=True) Tnull_vals[j,b] = ttest_.statistic Next, we compute the number of rejected null hypotheses R, the esti- mated number of false positives /hatwideV, and the estimated FDR, for a range of threshold values cin Algorithm 13.4. The threshold values are chosen using the absolute values of the test statistics from the 100 genes. In[28]: cutoffs = np.sort(np.abs(T_vals)) FDRs, Rs, Vs = np.empty((3, m)) for j in range(m): R=n p . s u m ( n p . a b s ( T _ v a l s )> =c u t o f f s [ j ] ) V=n p . s u m ( n p . a b s ( T n u l l _ v a l s )> =c u t o f f s [ j ] )/B Rs[j] = R Vs[j] = V FDRs[j] = V / R Now, for any given FDR, we can find the genes that will be rejected. For example, with FDR controlled at 0.1, we reject 15 of the 100 null hypotheses. On average, we would expect about one or two of these genes (i.e. 10% of 15) to be false discoveries. At an FDR of 0.2, we can reject the null hypothesis for 28 genes, of which we expect around six to be false discoveries. The variable idxstores which genes were included in our 100 randomly- selected genes. Let’s look at the genes whose estimated FDR is less than 0.1. In[29]: sorted(idx[np.abs(T_vals) >= cutoffs[FDRs < 0.1].min()]) AtanFDRthresholdof0.2,moregenesareselected,atthecostofhaving a higher expected proportion of false discoveries. In[30]: sorted(idx[np.abs(T_vals) >= cutoffs[FDRs < 0.2].min()]) The next line generates Figure 13.11, which is similar to Figure 13.9, except that it is based on only a subset of the genes. In[31]: fig, ax = plt.subplots() ax.plot(Rs, FDRs, 'b',l i n e w i d t h = 3 ) ax.set_xlabel( \"Number of Rejections\" ) ax.set_ylabel( \"False Discovery Rate\" ); 13.7 Exercises 593 FIGURE 13.11.The estimated false discovery", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 654, "start_word": 209280, "end_word": 209680, "chunk_words": 400}}, "ISLP_website::c000655": {"text": "sorted(idx[np.abs(T_vals) >= cutoffs[FDRs < 0.1].min()]) AtanFDRthresholdof0.2,moregenesareselected,atthecostofhaving a higher expected proportion of false discoveries. In[30]: sorted(idx[np.abs(T_vals) >= cutoffs[FDRs < 0.2].min()]) The next line generates Figure 13.11, which is similar to Figure 13.9, except that it is based on only a subset of the genes. In[31]: fig, ax = plt.subplots() ax.plot(Rs, FDRs, 'b',l i n e w i d t h = 3 ) ax.set_xlabel( \"Number of Rejections\" ) ax.set_ylabel( \"False Discovery Rate\" ); 13.7 Exercises 593 FIGURE 13.11.The estimated false discovery rate versus the number of rejectednull hypotheses, for 100 genes randomly selected from theKhandataset.13.7 ExercisesConceptual1. Suppose we testmnull hypotheses, all of which are true. We controlthe Type I error for each null hypothesis at levelα. For each sub-problem, justify your answer.(a) In total, how many Type I errors do we expect to make?(b) Suppose that themtests that we perform are independent.Whatisthefamily-wiseerrorrateassociatedwiththesemtests?Hint: If two eventsAandBare independent, thenPr(A∩B)=Pr(A) Pr(B).(c) Suppose thatm=2, and that thep-values for the two tests arepositively correlated, so that if one is small then the other willtend to be small as well, and if one is large then the other willtend to be large. How does the family-wise error rate associatedwith thesem=2tests qualitatively compare to the answer in(b) withm=2?Hint: First, suppose that the twop-values are perfectly correlated.(d) Suppose again thatm=2, but that now thep-values for thetwo tests are negatively correlated, so that if one is large thenthe other will tend to be small. How does the family-wise errorrate associated with thesem=2tests qualitatively compare tothe answer in (b) withm=2?Hint: First, suppose that whenever onep-value is less thanα,then the other will be greater thanα. In other words, we cannever reject both null hypotheses. 594 13. Multiple Testing 2. Suppose that we test mhypotheses, and control the Type I error for each hypothesis at level α. Assume that all mp-values are indepen- dent, and that all null hypotheses are true. (a) Let the random variable Ajequal1if thejth null hypothesis is rejected, and 0otherwise. What is the distribution of Aj? (b) What is the distribution of/summationtextm j=1Aj? (c) What is the standard deviation of the number of Type I errors that we will make? 3. Suppose we test mnull hypotheses, and control the Type I error for thejth null hypothesis at level αj, forj=1,...,m . Argue that the family-wise error rate is no greater than/summationtextm j=1αj. Null Hypothesis p-value H01 0.0011 H02 0.031 H03 0.017 H04 0.32 H05 0.11 H06 0.90 H07 0.07", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 655, "start_word": 209600, "end_word": 210000, "chunk_words": 400}}, "ISLP_website::c000656": {"text": "0otherwise. What is the distribution of Aj? (b) What is the distribution of/summationtextm j=1Aj? (c) What is the standard deviation of the number of Type I errors that we will make? 3. Suppose we test mnull hypotheses, and control the Type I error for thejth null hypothesis at level αj, forj=1,...,m . Argue that the family-wise error rate is no greater than/summationtextm j=1αj. Null Hypothesis p-value H01 0.0011 H02 0.031 H03 0.017 H04 0.32 H05 0.11 H06 0.90 H07 0.07 H08 0.006 H09 0.004 H10 0.0009 TABLE 13.4. p-values for Exercise 4. 4. Suppose we test m= 10 hypotheses, and obtain the p-values shown in Table 13.4. (a) Suppose that we wish to control the Type I error for each null hypothesis at level α=0.05. Which null hypotheses will we reject? (b) Now suppose that we wish to control the FWER at level α= 0.05. Which null hypotheses will we reject? Justify your answer. (c) Now suppose that we wish to control the FDR at level q=0.05. Which null hypotheses will we reject? Justify your answer. (d) Now suppose that we wish to control the FDR at level q=0.2. Which null hypotheses will we reject? Justify your answer. (e) Of the null hypotheses rejected at FDR level q=0.2, approxi- mately how many are false positives? Justify your answer. 5. For this problem, you will make up p-values that lead to a certain number of rejections using the Bonferroni and Holm procedures. (a) Give an example of five p-values(i.e. five numbers between 0and 1which, for the purpose of this problem, we will interpret as p- values) for which both Bonferroni’s method and Holm’s method 13.7 Exercises 595 reject exactly one null hypothesis when controlling the FWER at level0.1. (b) Now give an example of five p-values for which Bonferroni re- jects one null hypothesis and Holm rejects more than one null hypothesis at level 0.1. 6. For each of the three panels in Figure 13.3, answer the following questions: (a) How many false positives, false negatives, true positives, true negatives, Type I errors, and Type II errors result from applying the Bonferroni procedure to control the FWER at level α= 0.05? (b) How many false positives, false negatives, true positives, true negatives, Type I errors, and Type II errors result from applying the Holm procedure to control the FWER at level α=0.05? (c) What is the false discovery proportion associated with", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 656, "start_word": 209920, "end_word": 210320, "chunk_words": 400}}, "ISLP_website::c000657": {"text": "panels in Figure 13.3, answer the following questions: (a) How many false positives, false negatives, true positives, true negatives, Type I errors, and Type II errors result from applying the Bonferroni procedure to control the FWER at level α= 0.05? (b) How many false positives, false negatives, true positives, true negatives, Type I errors, and Type II errors result from applying the Holm procedure to control the FWER at level α=0.05? (c) What is the false discovery proportion associated with using the Bonferroni procedure to control the FWER at level α=0.05? (d) What is the false discovery proportion associated with using the Holm procedure to control the FWER at level α=0.05? (e) How would the answers to (a) and (c) change if we instead used the Bonferroni procedure to control the FWER at level α= 0.001? Applied 7. This problem makes use of the Carseats dataset in the ISLPpackage. (a) For each quantitative variable in the dataset besides Sales, fit a linear model to predict Salesusing that quantitative variable. Report the p-values associated with the coefficients for the vari- ables. That is, for each model of the form Y=β0+β1X+/epsilon1, report the p-value associated with the coefficient β1. Here,Y represents SalesandXrepresents one of the other quantitative variables. (b) Suppose we control the Type I error at level α=0.05for the p-values obtained in (a). Which null hypotheses do we reject? (c) NowsupposewecontroltheFWERatlevel 0.05forthep-values. Which null hypotheses do we reject? (d) Finally, suppose we control the FDR at level 0.2for thep-values. Which null hypotheses do we reject? 8. In this problem, we will simulate data from m= 100 fund managers. rng = np.random.default_rng(1) n, m = 20, 100 X=r n g . n o r m a l ( s i z e = ( n ,m ) ) 596 13. Multiple TestingThesedatarepresenteachfundmanager’spercentagereturnsforeachofn= 20months. We wish to test the null hypothesis that eachfund manager’s percentage returns have population mean equal tozero. Notice that we simulated the data in such a way that each fundmanager’s percentage returns do have population mean zero; in otherwords, allmnull hypotheses are true.(a) Conduct a one-samplet-test for each fund manager, and plot ahistogram of thep-values obtained.(b) If we control Type I error for each null hypothesis at levelα=0.05, then how many null hypotheses do we reject?(c) If we control the FWER at level0.05, then how many null hy-potheses do we reject?(d) If we control the FDR at level0.05, then", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 657, "start_word": 210240, "end_word": 210640, "chunk_words": 400}}, "ISLP_website::c000658": {"text": "we simulated the data in such a way that each fundmanager’s percentage returns do have population mean zero; in otherwords, allmnull hypotheses are true.(a) Conduct a one-samplet-test for each fund manager, and plot ahistogram of thep-values obtained.(b) If we control Type I error for each null hypothesis at levelα=0.05, then how many null hypotheses do we reject?(c) If we control the FWER at level0.05, then how many null hy-potheses do we reject?(d) If we control the FDR at level0.05, then how many null hy-potheses do we reject?(e) Now suppose we “cherry-pick” the10fund managers who per-form the best in our data. If we control the FWER for just these10 fund managers at level0.05, then how many null hypothe-ses do we reject? If we control the FDR for just these 10 fundmanagers at level0.05, then how many null hypotheses do wereject?(f) Explain why the analysis in (e) is misleading.Hint: The standard approaches for controlling the FWER andFDR assume thatalltested null hypotheses are adjusted for mul-tiplicity, and that no “cherry-picking” of the smallestp-valueshas occurred. What goes wrong if we cherry-pick? Index accuracy, 415 activation, 400 activation function, 401 additive, 11,94–98,110–111 additivity, 305,306 adjusted R2,87,231,232,236– 238 Advertising data set, 15,16,19, 69,71–73,77,78,80,82, 83,85,87–90,95,96,109– 111 agglomerative clustering, 525 Akaike information criterion, 87, 231,232,236–238 alternative hypothesis, 76,559 analysis of variance, 312 ANOVA, 587 area under the curve, 155,486– 487 argument, 40 array,42 attribute, 42 AUC,155 Autodataset, 12,66,98–101,129, 197,202–207,327,398 auto-correlation, 421 autoregression, 423 axes,48 backfitting, 307,328backpropagation, 429 backward stepwise selection, 87, 234–235 bag-of-n-grams,415 bag-of-words, 414 bagging, 11,24,331,343–346,354, 360–361 BART,343,350,353,354,362– 363 baseline, 93,145,161 basis function, 293–294,296 Bayes classifier, 35–37,147 decision boundary, 148 error,35–37 Bayes’ theorem, 146,250 Bayesian, 250–251,353 Bayesianadditiveregressiontrees, 331,343,350,350,353, 354,362–363 Bayesianinformationcriterion, 87, 231,232,236–238 Benjamini–Hochbergprocedure, 575– 577 Bernoulli distribution, 172 best subset selection, 231,246 bias,31–34,74,90,159,405 bias-variance decomposition, 32 © Springer Nature Switzerland AG 2023 G. James et al., An Introduction to Statistical Learning , Springer Texts in Statistics, https://doi.org/10.1007/978-3-031-38747-0 597 598 Index trade-off, 31–34,38,111–112, 157,159,163,164,242, 254,263,266,301,336, 376,385 bidirectional, 425 Bikeshare data set, 12,167–172 binary,27,138 biplot,507,508 Bonferroni method, 575–577,585 Boolean, 53,176 boosting, 11,24,331,343,347– 350,354,361–362 bootstrap, 11,201,212–214,343 Bostondata set, 12,67,117,122, 133,199,227,287,327, 364,556 bottom-up clustering, 525 boxplot, 62 BrainCancer data set, 12,472– 474,476,482 branch,333 burn-in, 352 C-index, 487 Caravan data set, 12,184,366 Carseats data set, 12,126,130, 364 categorical, 2,27 censored data, 469–502 censoring independent, 471 interval, 471 left,471 mechanism, 471 non-informative, 471 right,471 time,470 chain rule, 429 channel, 407 CIFAR100 data set, 406,409–411, 448,449 classification, 2,11,27,34–39,135– 199,367–382 error rate, 338 tree,337–341,355–358 classifier,", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 658, "start_word": 210560, "end_word": 210960, "chunk_words": 400}}, "ISLP_website::c000659": {"text": "Bikeshare data set, 12,167–172 binary,27,138 biplot,507,508 Bonferroni method, 575–577,585 Boolean, 53,176 boosting, 11,24,331,343,347– 350,354,361–362 bootstrap, 11,201,212–214,343 Bostondata set, 12,67,117,122, 133,199,227,287,327, 364,556 bottom-up clustering, 525 boxplot, 62 BrainCancer data set, 12,472– 474,476,482 branch,333 burn-in, 352 C-index, 487 Caravan data set, 12,184,366 Carseats data set, 12,126,130, 364 categorical, 2,27 censored data, 469–502 censoring independent, 471 interval, 471 left,471 mechanism, 471 non-informative, 471 right,471 time,470 chain rule, 429 channel, 407 CIFAR100 data set, 406,409–411, 448,449 classification, 2,11,27,34–39,135– 199,367–382 error rate, 338 tree,337–341,355–358 classifier, 135 cluster analysis, 25–26 clustering, 4,25–26,520–535 agglomerative, 525bottom-up, 525 hierarchical, 521,525–535 K-means,11,521–524 Cochran–Mantel–Haenszeltest, 475 coefficient, 71 College dataset, 12,65,286,328 collinearity, 106–110 concatenation, 41 conditional probability, 35 confidenceinterval, 75–76,90,110, 292 confounding, 144 confusion matrix, 153,176 continuous, 2 contour, 246 contour plot, 50 contrast, 94 convenience function, 53 convolution filter, 407 convolution layer, 407 convolutionalneuralnetwork, 406– 413 correlation, 79,82–83,530 count data, 167,170 Cox’sproportionalhazardsmodel, 480,483–486 Cp,87,231,232,236–238 Creditdata set, 12,91,92,94, 97,98,106–109 cross-entropy, 405 cross-validation, 11,31,34,201– 211,231,252,270 k-fold,206–209 leave-one-out, 204–206 curse of dimensionality, 115,193, 266 data augmentation, 411 data frame, 55 Data sets Advertising ,15,16,19,69, 71–73,77,78,80,82,83, 85,87–90,95,96,109– 111 Auto,12,66,98–101,129,197, 202–207,327,398 Bikeshare ,12,167–172 Index 599 Boston,12,67,117,122,133, 199,227,287,327,364, 556 BrainCancer ,12,472–474,476, 482 Caravan,12,184,366 Carseats ,12,126,130,364 CIFAR100 ,406,409–411,448, 449 College,12,65,286,328 Credit,12,91,92,94,97,98, 106–109 Default,12,136–139,141– 144,152–156,160,161, 225,226,466 Fund,12,567–570,572,575, 576,585,588,589 Heart,339,340,344–347,352, 353,382,383 Hitters,12,332,333,336, 338,339,366,425,426, 437,446 IMDb,413,415,416,418,420, 437,458,467 Income,16–18,21–23 Khan,12,579–581,583,590, 593 MNIST,402–404,406,430,431, 441,444,445,448 NCI60,4,5,12,546,548–550 NYSE,12,422–424,466,467 OJ,12,365,398 Portfolio ,12 Publication ,12,482–487 Smarket,2,3,12,173,184, 196 USArrests ,12,507,508,510, 512,513,515,516,518, 519 Wage,1,2,8,9,12,290,291, 293,295,297–300,302– 306,309,315,327 Weekly,12,196,226 data type, 42 decision function, 387 decision tree, 11,331–342 deep learning, 399Default dataset, 12,136–139,141– 144,152–156,160,161, 225,226,466 degrees of freedom, 30,266,295, 296,301 dendrogram, 521,525–530 density function, 146 dependent variable, 15 derivative, 296,300 detector layer, 410 deviance, 232 dictionary, 66 dimensionreduction, 230,253–262 discriminant function, 149 discriminant method, 146–161 dissimilarity, 530–532 distance correlation-based, 530–532,554 Euclidean, 509,522,523,529– 532 double descent, 431–435 double-exponentialdistribution, 251 dropout, 406,431 dummy variable, 91–94,138,142, 292 early stopping, 430 effective degrees of freedom, 301 eigen decomposition, 506,516 elbow,548 embedding, 418 embedding layer, 419 ensemble, 343–354 entropy, 337–339,363 epochs,430 error irreducible, 17,30 rate,34 reducible, 17 term,16 Euclideandistance, 509,522,523, 529–532,554 event time, 470 exception, 45 expected value, 18 exploratory data analysis, 504 exponential, 173 exponential family, 173 F-statistic, 84 600 Index factor,92 factorial, 170 failure time, 470 false discoveryproportion, 155,573 discovery rate, 558,573–577, 579–582 negative, 155,562 positive, 155,562,563 positive rate, 155,156,382 family-wiseerrorrate, 565–573,577 feature,15 feature map, 406 feature selection, 230 featurize, 414 feed-forward neural network, 400 figure,48 fit,21 fitted value, 101 flattening, 424 flexible,21 floating point, 43 forwardstepwiseselection, 86,87, 233–234,268 function, 40 Funddata set, 12,567–570,572,", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 659, "start_word": 210880, "end_word": 211280, "chunk_words": 400}}, "ISLP_website::c000660": {"text": "17 term,16 Euclideandistance, 509,522,523, 529–532,554 event time, 470 exception, 45 expected value, 18 exploratory data analysis, 504 exponential, 173 exponential family, 173 F-statistic, 84 600 Index factor,92 factorial, 170 failure time, 470 false discoveryproportion, 155,573 discovery rate, 558,573–577, 579–582 negative, 155,562 positive, 155,562,563 positive rate, 155,156,382 family-wiseerrorrate, 565–573,577 feature,15 feature map, 406 feature selection, 230 featurize, 414 feed-forward neural network, 400 figure,48 fit,21 fitted value, 101 flattening, 424 flexible,21 floating point, 43 forwardstepwiseselection, 86,87, 233–234,268 function, 40 Funddata set, 12,567–570,572, 575,576,585,588,589 Gamma, 173 Gaussian(normal)distribution, 146, 147,150,172,561 generalized additive model, 5,24, 162,289,290,305–309, 319 generalized linear model, 5,135, 167–174,217 generative model, 146–161 Giniindex, 337–339,345,346,363 global minimum, 427 gradient, 428 gradient descent, 427 Harrell’s concordance index, 487 hazard function, 476–478 baseline, 478 hazard rate, 476 Heartdataset, 339,340,344–347, 352,353,382,383 heatmap, 50 helper,311heteroscedasticity, 103,168 hidden layer, 400 hidden units, 400 hierarchical clustering, 525–530 dendrogram, 525–528 inversion, 529 linkage,529–530 hierarchical principle, 96 high-dimensional, 86,234,263 hinge loss, 385 Hitters data set, 12,332,333, 336,338,339,366,425, 426,437,446 hold-out set, 202 Holm’s method, 568,576,585 hypergeometric distribution, 501 hyperparameter, 187 hyperplane, 367–372 hypothesis test, 76–77,84,103, 558–583 IMDbdata set, 413,415,416,418, 420,437,458,467 imputation, 515 Incomedata set, 16–18,21–23 increment, 60 independent variable, 15 indexable, 186 indicator function, 292 inference, 17,18 inner product, 379,380 input layer, 400 input variable, 15 integral, 301 interaction, 70,89,95–98,110– 111,308 intercept, 71,72 interpolate, 432 interpretability, 229 inversion, 529 irreducible error, 17,36,90,110 iterator, 312 joint distribution, 158 K-means clustering, 11,521–524 K-nearestneighbors, 135,164–167 classifier, 11,36–37 regression, 111–115 Index 601 Kaplan–Meiersurvivalcurve, 472– 474,483 kernel,379–382,384,394 linear,380 non-linear, 377–382 polynomial, 380,382 radial,381–383,390 kernel density estimator, 159 keyword, 46 Khandata set, 12,579–581,583, 590,593 knot,290,294,296–299 /lscript1norm,244 /lscript2norm,242 lag,422 Laplace distribution, 251 lasso,11,24,244–251,265–266, 336,385,484 leaf,333,526 learning rate, 429 least squares, 5,21,71–72,140, 141,229 line,73 weighted, 103 level,92 leverage, 104–106 likelihood function, 141 linear,2,69–115 linear combination, 128,230,253, 505 lineardiscriminantanalysis, 5,11, 135,138,147–155,164– 167,377,382 linear kernel, 380 linear model, 20,69–115 linear regression, 5,11,69–115, 172–173 multiple, 80–90 simple,70–80 link function, 172,173 linkage,529–530,548 average, 529–530 centroid, 529–530 complete, 526,529–530 single,529–530 list,41 list comprehension, 123 local minimum, 427local regression, 290 log odds, 145 log-rank test, 474–476,483 logistic function, 139 logistic regression, 5,11,25,135, 138–144,164–167,172– 173,308–309,377,384– 385 multinomial, 145,163 multiple, 142–144 logit,140 loss function, 300,385 low-dimensional, 262 LSTM RNN, 420 main effects, 96 majority vote, 344 Mallow’s Cp,87,231,232,236– 238 Mantel–Haenszel test, 475 margin,370,385 marginal distribution, 158 Markov chain Monte Carlo, 353 matrix completion, 515 matrix multiplication, 10 maximal margin classifier, 367–372 hyperplane, 370 maximumlikelihood, 139–141,143, 170 mean squared error, 28 mesh,53 method, 43 minibatch, 429 misclassification error, 35", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 660, "start_word": 211200, "end_word": 211600, "chunk_words": 400}}, "ISLP_website::c000661": {"text": "minimum, 427local regression, 290 log odds, 145 log-rank test, 474–476,483 logistic function, 139 logistic regression, 5,11,25,135, 138–144,164–167,172– 173,308–309,377,384– 385 multinomial, 145,163 multiple, 142–144 logit,140 loss function, 300,385 low-dimensional, 262 LSTM RNN, 420 main effects, 96 majority vote, 344 Mallow’s Cp,87,231,232,236– 238 Mantel–Haenszel test, 475 margin,370,385 marginal distribution, 158 Markov chain Monte Carlo, 353 matrix completion, 515 matrix multiplication, 10 maximal margin classifier, 367–372 hyperplane, 370 maximumlikelihood, 139–141,143, 170 mean squared error, 28 mesh,53 method, 43 minibatch, 429 misclassification error, 35 missing at random, 515 missing data, 56,515–520 mixed selection, 87 MNISTdataset, 402–404,406,430, 431,441,444,445,448 model assessment, 201 model selection, 201 module, 42 multicollinearity, 108,266 multinomiallogisticregression, 145, 163 multiple testing, 557–583 multi-task learning, 403 multivariate Gaussian, 150 602 Index multivariate normal, 150 naive Bayes, 135,158–161,164– 167 namespace, 116 natural spline, 297,298,301,317 NCI60data set, 4,5,12,546,548– 550 negative binomial, 173 negativepredictivevalue, 155,156 neural network, 5,399 node internal, 333 purity,337–339 terminal, 333 noise,21,252 non-linear, 2,11,289–329 decision boundary, 377–382 kernel,377–382 non-parametric, 20,22–23,111– 115,193 normal(Gaussian)distribution, 146, 147,150,172,476,561 notebook, 40 null,152 distribution, 561,578 hypothesis, 76,559 model,87,231,245 null rate, 186 NYSEdata set, 12,422–424,466, 467 Occam’s razor, 426 odds,140,145,195 OJdata set, 12,365,398 one-hot encoding, 92,126,403 one-standard-error rule, 240 one-versus-all, 384 one-versus-one, 384 one-versus-rest, 384 optimalseparatinghyperplane, 370 optimism of training error, 30 ordered categorical variable, 315 orthogonal, 257,506 basis,125 out-of-bag, 345 outlier,103–104 output variable, 15 over-parametrized, 465 overdispersion, 172overfitting, 21,23,25,30–31,88, 152,233,371 p-value,77,82,560–562,578–579 adjusted, 586 package, 42 parameter, 71 parametric, 20–22,111–115 partialleastsquares, 254,260–262, 282 partial likelihood, 480 path algorithm, 249 permutation, 578 permutation approach, 577–582 perpendicular, 257 Poisson distribution, 169,172 Poisson regression, 135,167–173 polynomial kernel,380,382 regression, 98–99,289–292,294– 295 pooling, 410 population regression line, 73 Portfolio data set, 12 positivepredictivevalue, 155,156 posterior distribution, 251 mode,251 probability, 147 power,108,155,563 precision, 155 prediction, 17 interval, 90,110 predictor, 15 principal components, 505 analysis, 11,254–260,504–515 loading vector, 505,506 missing values, 515–520 proportionofvarianceexplained, 510–515,547 regression, 11,254–260,280– 282,504,515 score vector, 506 scree plot, 514–515 prior distribution, 251 probability, 146 probability density function, 477, 478 Index 603 projection, 230 proportionalhazardsassumption, 478 pruning, 336 cost complexity, 336 weakest link, 336 Publication data set, 12,482– 487 Python objects and functions %%capture ,458 iloc[],58 loc[],57 AgglomerativeClustering() , 543 anova(),313 anova_lm() ,125,129,312, 313 axhline() ,122,551 axline() ,121,129,329 BART(),362 biplot,537 boot_SE() ,223 boxplot() ,62,66 bs(),315,327 BSpline() ,315 clone(),222 columns.drop() ,122 compute_linkage() ,544 confusion_table() ,176 contour() ,50 corr(),129,174 cost_complexity_pruning_path() , 357 CoxPHFitter() ,491 cross_val_predict() ,270 cross_validate() ,218,219, 226 cumsum() ,539 cut_tree() ,545 data.frame() ,227 Dataset,440 decision_function() ,392 DecisionTreeClassifier() , 354,355 DecisionTreeRegressor() ,354 def,121 dendrogram() ,544 describe()", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 661, "start_word": 211520, "end_word": 211920, "chunk_words": 400}}, "ISLP_website::c000662": {"text": "478 pruning, 336 cost complexity, 336 weakest link, 336 Publication data set, 12,482– 487 Python objects and functions %%capture ,458 iloc[],58 loc[],57 AgglomerativeClustering() , 543 anova(),313 anova_lm() ,125,129,312, 313 axhline() ,122,551 axline() ,121,129,329 BART(),362 biplot,537 boot_SE() ,223 boxplot() ,62,66 bs(),315,327 BSpline() ,315 clone(),222 columns.drop() ,122 compute_linkage() ,544 confusion_table() ,176 contour() ,50 corr(),129,174 cost_complexity_pruning_path() , 357 CoxPHFitter() ,491 cross_val_predict() ,270 cross_validate() ,218,219, 226 cumsum() ,539 cut_tree() ,545 data.frame() ,227 Dataset,440 decision_function() ,392 DecisionTreeClassifier() , 354,355 DecisionTreeRegressor() ,354 def,121 dendrogram() ,544 describe() ,62,66 dir(),116drop(),179 dropna() ,56,268,461 DTC(),seeDecisionTreeClassifier() DTR(),seeDecisionTreeRegressor() dtype,43 ElasticNetCV() ,279 enumerate() ,217 export_text() ,356 export_tree() ,365 fit(),118,181,218 fit_transform() ,119 for,59 GaussianNB() ,182 GBR(),seeGradientBoosting- Regressor() get_dummies() ,461 get_influence() ,121 get_prediction() ,120,314 get_rdataset() ,535 glm(),313 glob(),437 GradientBoostingClassifier() , 361 GradientBoostingRegressor() , 354,361 GridSearchCV() ,276 groupby() ,490 hist(),62 iloc[],58,59 import,42 imshow() ,50,449 ISLP.bart ,362 ISLP.cluster ,544 json,437 KaplanMeierFitter() ,502 keras,437 KFold(),219 KMeans() ,542,543 Kmeans() ,542 KNeighborsClassifier() ,183 lambda,58 LDA(),seeLinearDiscriminant- Analysis() legend() ,132 lifelines ,490 LinearDiscriminantAnalysis() , 174,179 LinearGAM() ,317 LinearRegression() ,280 604 Index load_data() ,117 loc[],58,59,177 log_loss() ,355 LogisticGAM() ,323 logrank_test() ,490 lowess() ,324 matplotlib ,48 max(),66 mean(),48 median() ,197 min(),66 MNIST(),444 ModelSpec() ,116–118,122, 124,267 MS(),seeModelSpec() mult_test() ,seemultipletests() multipletests() ,586 multipletests() ,583,589 multivariate_logrank_test() , 496 NaturalSpline() ,317,319 ndim,42 nn.RNN() ,461 normal() ,132,286,555 np,seenumpy np.all() ,54,180 np.allclose() ,190 np.any() ,54 np.arange() ,51 np.argmax() ,122 np.array() ,42 np.concatenate() ,133 np.corrcoef() ,46,554 np.empty() ,224 np.isnan() ,268 np.ix_() ,53 np.linalg.svd() ,539 np.linspace() ,50 np.logspace() ,318 np.mean() ,47,176 np.nan,60 np.nanmean() ,541 np.percentile() ,228 np.power() ,219 np.random.choice() ,553 np.random.default_rng() ,46, 47 np.random.normal() ,45 np.sqrt() ,45np.squeeze() ,457 np.std() ,47 np.sum() ,43 np.var() ,47 np.where() ,180 ns(),317 numpy,42,555 os.chdir() ,55 outer(),219 pairwise_distances() ,554 pairwise_tukeyhsd() ,587 pandas,55 params,175 partial() ,222,269 PCA(),280,537,540,554 pd,seepandas pd.crosstab() ,555 pd.cut() ,315 pd.get_dummies() ,314 pd.plotting.scatter_matrix() , 62 pd.qcut() ,314,315 pd.read_csv() ,55,556 pd.Series() ,62 Pipeline() ,275 plot(),48,61,356,490 plot.scatter() ,120 plot_gam() ,321 plot_svm() ,398 PLSRegression() ,282 poly(),125,313,327 predict() ,175,178,181,216, 218,323,358 predict_survival_function() , 493 print(),40 pvalues,175 pygam,307,317 pytorch_lightning ,435 QDA(),seeQuadraticDiscriminant- Analysis() QuadraticDiscriminantAnalysis() , 174,181 random() ,555 RandomForestRegressor() ,354, 360 read_image() ,436 reindex() ,461 reshape() ,43 Index 605 return,198 RF(),seeRandomForestRegressor() rng,seenp.random.default_rng() rng.choice() ,60 rng.standard_normal() ,60 roc_curve() ,392 RocCurveDisplay.from_estimator() , 387 savefig() ,50 scatter() ,49,61 scipy.interpolate ,315 score(),218,461 seed_everything() ,436 set_index() ,57 set_title() ,49 set_xlabel() ,49 set_xscale() ,198 set_ylabel() ,49 set_yscale() ,198 shape,43 ShuffleSplit() ,219 sim_time() ,495 SimpleDataModule() ,441 SimpleModule.classification() , 446 SimpleModule.regression() , 442 skl,seesklearn.linear_model skl.ElasticNet() ,273,277 skl.ElasticNet.path ,274 skl.ElasticNet.path() ,273 sklearn,118,181 sklearn.ensemble ,360 sklearn.linear_model ,267 sklearn.model_selection ,267 sklearn_selected() ,269 sklearn_selection_path() , 270 sklearn_sm() ,218 skm,seesklearn.model_selection skm.cross_val_predict() ,271 skm.KFold() ,271 skm.ShuffleSplit() ,272 slice(),51,462", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 662, "start_word": 211840, "end_word": 212240, "chunk_words": 400}}, "ISLP_website::c000663": {"text": ",461 reshape() ,43 Index 605 return,198 RF(),seeRandomForestRegressor() rng,seenp.random.default_rng() rng.choice() ,60 rng.standard_normal() ,60 roc_curve() ,392 RocCurveDisplay.from_estimator() , 387 savefig() ,50 scatter() ,49,61 scipy.interpolate ,315 score(),218,461 seed_everything() ,436 set_index() ,57 set_title() ,49 set_xlabel() ,49 set_xscale() ,198 set_ylabel() ,49 set_yscale() ,198 shape,43 ShuffleSplit() ,219 sim_time() ,495 SimpleDataModule() ,441 SimpleModule.classification() , 446 SimpleModule.regression() , 442 skl,seesklearn.linear_model skl.ElasticNet() ,273,277 skl.ElasticNet.path ,274 skl.ElasticNet.path() ,273 sklearn,118,181 sklearn.ensemble ,360 sklearn.linear_model ,267 sklearn.model_selection ,267 sklearn_selected() ,269 sklearn_selection_path() , 270 sklearn_sm() ,218 skm,seesklearn.model_selection skm.cross_val_predict() ,271 skm.KFold() ,271 skm.ShuffleSplit() ,272 slice(),51,462 sm,seestatsmodels sm.GLM() ,174,192,226 sm.Logit() ,174 sm.OLS() ,118,129,174,319StandardScaler() ,185,438, 537,555 statsmodels ,116,173 std(),186 Stepwise() ,269 str.contains() ,59 subplots() ,48 sum(),43,268 summarize() ,118,129,223, 226 summary() ,119,322,587 super(),440 SupportVectorClassifier() , 387,389–391,393 SupportVectorRegression() , 394 SVC(),seeSupportVector- Classifier() svd(),539 SVR(),seeSupportVector- Regression() TensorDataset() ,441 to_numpy() ,437 torch,435 torchinfo ,436 torchmetrics ,436 torchvision ,436 ToTensor() ,444 train_test_split() ,186,216 transform() ,118,119 ttest_1samp() ,584 ttest_ind() ,590 ttest_rel() ,587 tuple,43 uniform() ,555 value_counts() ,66 var(),536 variance_inflation_factor() , 116,124 VIF(),seevariance_inflation- _factor() where(),355 zip(),60,312 q-values, 589 quadratic, 98 quadraticdiscriminantanalysis, 4, 135,156–157,164–167 606 Index qualitative, 2,27,91,135,167, 202 variable, 91–94 quantitative, 2,27,91,135,167, 202 radial kernel, 381,383,390 random forest, 11,331,343,346– 347,354,360–361 random seed, 46 re-sampling, 577–582 recall,155 receiveroperatingcharacteristic(ROC), 154,382–383 recommender systems, 516 rectified linear unit, 401 recurrentneuralnetwork, 416–427 recursivebinarysplitting, 334,337, 338 reducible error, 17,90 regression, 2,11,27 local,289,290,304–305 piecewisepolynomial, 294–295 polynomial, 289–292,299 spline,289,294 tree,331–337,358–360 regularization, 230,240,406,484– 486 ReLU,401 resampling, 201–214 residual, 71,81 plot,100 standarderror, 75,77–78,88– 89,109 studentized, 104 sum of squares, 71,79,81 residuals, 263,348 response, 15 ridgeregression, 11,240–244,385, 484 risk set, 473 robust,374,376,535 ROC curve, 154,382–383,486– 487 R2,77–80,88,109,238 rug plot, 314 scale equivariant, 242 Scheffé’s method, 572 scree plot, 512,514–515elbow,514 semi-supervised learning, 27 sensitivity, 153,155,156 separating hyperplane, 367–372 Seq2Seq, 425 sequence, 41 shrinkage, 230,240,484–486 penalty, 240 sigmoid, 401 signal,252 signature, 45 singularvaluedecomposition, 539 slack variable, 375 slice,51 slope,71,72 Smarket data set, 2,3,12,173, 184,196 smoother, 308 smoothing spline, 290,300–303 soft margin classifier, 372–374 soft-thresholding, 250 softmax, 145,405 sparse,244,252 sparse matrix format, 414 sparsity, 244 specificity, 153,155,156 spline,289,294–303 cubic,296 linear,296 natural, 297,301 regression, 289,294–299 smoothing, 30,290,300–303 thin-plate, 22 standard error, 75,101 standardize, 185 statistical model, 1 step function, 111,289,292–293 stepwise model selection, 11,231, 233 stochastic gradient descent, 429 string,41 string interpolation, 490 stump,349 subset selection, 230–240 subtree, 336 supervised learning, 25–27,261 support vector, 371,376,385 classifier, 367,372–377 machine, 5,11,24,377–386 Index 607 regression, 386 survival analysis, 469–502 curve,472,483 function, 472 time,470 synergy, 70,89,95–98,110–111 systematic, 16 t-distribution, 77,165 t-statistic, 76 t-test one-sample, 583,584,588 paired,587 two-sample, 559,570,571,577– 581,584,590 test error,35,37,176 MSE,28–32 observations, 28 set,30 statistic, 559 theoretical null distribution, 577 time series,", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 663, "start_word": 212160, "end_word": 212560, "chunk_words": 400}}, "ISLP_website::c000664": {"text": "standard error, 75,101 standardize, 185 statistical model, 1 step function, 111,289,292–293 stepwise model selection, 11,231, 233 stochastic gradient descent, 429 string,41 string interpolation, 490 stump,349 subset selection, 230–240 subtree, 336 supervised learning, 25–27,261 support vector, 371,376,385 classifier, 367,372–377 machine, 5,11,24,377–386 Index 607 regression, 386 survival analysis, 469–502 curve,472,483 function, 472 time,470 synergy, 70,89,95–98,110–111 systematic, 16 t-distribution, 77,165 t-statistic, 76 t-test one-sample, 583,584,588 paired,587 two-sample, 559,570,571,577– 581,584,590 test error,35,37,176 MSE,28–32 observations, 28 set,30 statistic, 559 theoretical null distribution, 577 time series, 101 total sum of squares, 79 tracking, 102 train,21 training data,20 error,35,37,176 MSE,28–31 transformer, 311 tree,331–342 tree-based method, 331 true negative, 155 true positive, 155 true positive rate, 155,156,382 truncated power basis, 296 Tukey’s method, 571,585,587 tuning parameter, 187,240,484 two-sample t-test,474 Type I error, 155,562–565 Type I error rate, 563 Type II error, 155,563,568,584unsupervisedlearning, 25–27,255, 260,503–552 USArrests data set, 12,507,508, 510,512,513,515,516, 518,519 validation set, 202 approach, 202–204 variable, 15 dependent, 15 dummy, 91–94,97–98 importance, 346,360 independent, 15 indicator, 35 input,15 output,15 qualitative, 91–94,97–98 selection, 86,230,244 variance, 18,31–34,159 inflation factor, 108–110,123 varying coefficient model, 305 Wagedata set, 1,2,8,9,12,290, 291,293,295,297–300, 302–306,309,315,327 weak learner, 343 weakest link pruning, 336 Weeklydata set, 12,196,226 weight freezing, 412,419 weight sharing, 418 weighted least squares, 103,304 weights, 404 with replacement, 214 within class covariance, 150 wrapper, 217", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\ISLP_website.pdf", "filename": "ISLP_website.pdf", "num_pages_total": 613, "num_pages_read": 613, "chunk_index": 664, "start_word": 212480, "end_word": 212690, "chunk_words": 210}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000000": {"text": "Machine Learning with PyTorch and Scikit-Learn Develop machine learning and deep learning models with Python Sebastian Raschka Yuxi (Hayden) Liu Vahid Mirjalili BIRMINGHAM—MUMBAI “Python” and the Python Logo are trademarks of the Python Software Foundation. Machine Learning with PyTorch and Scikit-Learn Copyright © 2022 Packt Publishing All rights reserved. No part of this book may be reproduced, stored in a retrieval system, or transmitted in any form or by any means, without the prior written permission of the publisher, except in the case of brief quotations embedded in critical articles or reviews. Every effort has been made in the preparation of this book to ensure the accuracy of the information presented. However, the information contained in this book is sold without warranty, either express or implied. Neither the authors, nor Packt Publishing or its dealers and distributors, will be held liable for any damages caused or alleged to have been caused directly or indirectly by this book. Packt Publishing has endeavored to provide trademark information about all of the companies and products mentioned in this book by the appropriate use of capitals. However, Packt Publishing cannot guarantee the accuracy of this information. Producer: Tushar Gupta Acquisition Editor – Peer Reviews: Saby Dsilva Project Editor: Janice Gonsalves Content Development Editor: Bhavesh Amin Copy Editor: Safis Editing Technical Editor: Aniket Shetty Proofreader: Safis Editing Indexer: Tejal Daruwale Soni Presentation Designer: Pranit Padwal First published: February 2022 Production reference: 3220222 Published by Packt Publishing Ltd. Livery Place 35 Livery Street Birmingham B3 2PB, UK. ISBN 978-1-80181-931-2 www.packt.com Foreword Over recent years, machine learning methods, with their ability to make sense of vast amounts of data and automate decisions, have found widespread applications in healthcare, robotics, biology, physics, consumer products, internet services, and various other industries. Giant leaps in science usually come from a combination of powerful ideas and great tools. Machine learning is no exception. The success of data-driven learning methods is based on the ingenious ideas of thousands of talented researchers over the field’s 60-year history. But their recent popularity is also fueled by the evolution of hardware and software solutions that make them scalable and accessible. The ecosystem of excellent libraries for numeric computing, data analysis, and machine learning built around Python like NumPy and scikit-learn gained wide adoption in research and industry. This has greatly helped propel Python to be the most popular programming language. Massive improvements in computer vision,", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 0, "start_word": 0, "end_word": 400, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000001": {"text": "on the ingenious ideas of thousands of talented researchers over the field’s 60-year history. But their recent popularity is also fueled by the evolution of hardware and software solutions that make them scalable and accessible. The ecosystem of excellent libraries for numeric computing, data analysis, and machine learning built around Python like NumPy and scikit-learn gained wide adoption in research and industry. This has greatly helped propel Python to be the most popular programming language. Massive improvements in computer vision, text, speech, and other tasks brought by the recent ad- vent of deep learning techniques exemplify this theme. Approaches draw on neural network theory of the last four decades that started working remarkably well in combination with GPUs and highly optimized compute routines. Our goal with building PyTorch over the past five years has been to give researchers the most flexible tool for expressing deep learning algorithms while taking care of the underlying engineering com- plexities. We benefited from the excellent Python ecosystem. In turn, we’ve been fortunate to see the community of very talented people build advanced deep learning models across various domains on top of PyTorch. The authors of this book were among them. I’ve known Sebastian within this tight-knit community for a few years now. He has unmatched talent in easily explaining information and making the complex accessible. Sebastian contributed to many widely used machine learning software packages and authored dozens of excellent tutorials on deep learning and data visualization. Mastery of both ideas and tools is also required to apply machine learning in practice. Getting started might feel intimidating, from making sense of theoretical concepts to figuring out which software packages to install. Luckily, the book you’re holding in your hands does a beautiful job of combining machine learning concepts and practical engineering steps to guide you in this journey. You’re in for a delightful ride from the basics of data-driven techniques to the most novel deep learning architectures. Within every chapter, you will find concrete code examples applying the introduced methods to a practical task. When the first edition came out in 2015, it set a very high bar for the ML and Python book category. But the excellence didn’t stop there. With every edition, Sebastian and the team kept upgrading and refining the material as the deep learning revolution unfolded in new domains. In this new PyTorch edition, you’ll find new chapters on transformer", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 1, "start_word": 320, "end_word": 720, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000002": {"text": "deep learning architectures. Within every chapter, you will find concrete code examples applying the introduced methods to a practical task. When the first edition came out in 2015, it set a very high bar for the ML and Python book category. But the excellence didn’t stop there. With every edition, Sebastian and the team kept upgrading and refining the material as the deep learning revolution unfolded in new domains. In this new PyTorch edition, you’ll find new chapters on transformer architectures and graph neural networks. These approaches are on the cutting edge of deep learning and have taken the fields of text understanding and molecular structure by storm in the last two years. You will get to practice them using new yet widely popular software packages in the ecosystem like Hugging Face, PyTorch Lightning, and PyTorch Geometric. The excellent balance of theory and practice this book strikes is no surprise given the authors’ com- bination of advanced research expertise and experience in solving problems hands-on. Sebastian Raschka and Vahid Mirjalili draw from their background in deep learning research for computer vision and computational biology. Hayden Liu brings the experience of applying machine learning methods to event prediction, recommendation systems, and other tasks in the industry. All of the authors share a deep passion for education, and it reflects in the approachable way the book goes from simple to advanced. I’m confident that you will find this book invaluable both as a broad overview of the exciting field of machine learning and as a treasure of practical insights. I hope it inspires you to apply machine learning for the greater good in your problem area, whatever it might be. Dmytro Dzhulgakov PyTorch Core Maintainer Contributors About the authors Dr. Sebastian Raschka is an Asst. Professor of Statistics at the University of Wisconsin-Madison focusing on machine learning and deep learning. His recent research focused on general challenges such as few-shot learning for working with limited data and developing deep neural networks for ordinal targets. Sebastian is also an avid open-source contributor, and in his new role as Lead AI Edu- cator at Grid.ai, he plans to follow his passion for helping people to get into machine learning and AI. Big thanks to Jitian Zhao and Ben Kaufman, with whom I had the pleasure to work on the new chapters on transformers and graph neural networks. I’m also very grateful for Hayden’s and", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 2, "start_word": 640, "end_word": 1040, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000003": {"text": "working with limited data and developing deep neural networks for ordinal targets. Sebastian is also an avid open-source contributor, and in his new role as Lead AI Edu- cator at Grid.ai, he plans to follow his passion for helping people to get into machine learning and AI. Big thanks to Jitian Zhao and Ben Kaufman, with whom I had the pleasure to work on the new chapters on transformers and graph neural networks. I’m also very grateful for Hayden’s and Vahid’s help—this book wouldn’t have been possible without you. Lastly, I want to thank Andrea Panizza, Tony Gitter, and Adam Bielski for helpful discussions on sections of the manuscript. Yuxi (Hayden) Liu is a machine learning software engineer at Google and has worked as a machine learning scientist in a variety of data-driven domains. Hayden is the author of a series of ML books. His first book, Python Machine Learning By Example, was ranked the #1 bestseller in its category on Amazon in 2017 and 2018 and was translated into many languages. His other books include R Deep Learning Projects, Hands-On Deep Learning Architectures with Python, and PyTorch 1.x Reinforcement Learning Cookbook. I would like to thank all the great people I worked with, especially my co-authors, my editors at Packt, and my reviewers. Without them, this book would be harder to read and to apply to real-world problems. Lastly, I’d like to thank all the readers for their support, which encouraged me to write the PyTorch edition of this bestselling ML book. Dr. Vahid Mirjalili is a deep learning researcher focusing on computer vision applications. Va - hid received a Ph.D. degree in both Mechanical Engineering and Computer Science from Michigan State University. During his Ph.D. journey, he developed novel computer vision algorithms to solve real-world problems and published several research articles that are highly cited in the computer vision community. Other contributors Benjamin Kaufman is a Ph.D. candidate at the University of Wisconsin-Madison in Biomedical Data Science. His research focuses on the development and application of machine learning methods for drug discovery. His work in this area has provided a deeper understanding of graph neural networks. Jitian Zhao is a Ph.D. student at the University of Wisconsin-Madison, where she developed her interest in large-scale language models. She is passionate about deep learning in developing both real-world applications and theoretical support. I would like to thank my parents for", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 3, "start_word": 960, "end_word": 1360, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000004": {"text": "at the University of Wisconsin-Madison in Biomedical Data Science. His research focuses on the development and application of machine learning methods for drug discovery. His work in this area has provided a deeper understanding of graph neural networks. Jitian Zhao is a Ph.D. student at the University of Wisconsin-Madison, where she developed her interest in large-scale language models. She is passionate about deep learning in developing both real-world applications and theoretical support. I would like to thank my parents for their support. They encouraged me to always pursue my dream and motivated me to be a good person. About the reviewer Roman Tezikov is an industrial research engineer and deep learning enthusiast with over four years of experience in advanced computer vision, NLP, and MLOps. As the co-creator of the ML-REPA community, he organized several workshops and meetups about ML reproducibility and pipeline auto - mation. One of his current work challenges involves utilizing computer vision in the fashion industry. Roman was also a core developer of Catalyst – a PyTorch framework for accelerated deep learning. Join our book’s Discord space Join the book’s Discord workspace for a monthly Ask me Anything session with the authors: https://packt.link/MLwPyTorch Table of Contents Preface xxiii Chapter 1: Giving Computers the Ability to Learn from Data 1 Building intelligent machines to transform data into knowledge ................................................ 1 The three different types of machine learning ........................................................................... 2 Making predictions about the future with supervised learning • 3 Classification for predicting class labels • 4 Regression for predicting continuous outcomes • 5 Solving interactive problems with reinforcement learning • 6 Discovering hidden structures with unsupervised learning • 7 Finding subgroups with clustering • 8 Dimensionality reduction for data compression • 8 Introduction to the basic terminology and notations .................................................................. 9 Notation and conventions used in this book • 9 Machine learning terminology • 11 A roadmap for building machine learning systems .................................................................. 12 Preprocessing – getting data into shape • 13 Training and selecting a predictive model • 13 Evaluating models and predicting unseen data instances • 14 Using Python for machine learning ......................................................................................... 14 Installing Python and packages from the Python Package Index • 14 Using the Anaconda Python distribution and package manager • 15 Packages for scientific computing, data science, and machine learning • 16 Summary ............................................................................................................................... 17 Table of Contents x Chapter 2: Training Simple Machine Learning Algorithms for Classification 19 Artificial neurons", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 4, "start_word": 1280, "end_word": 1680, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000005": {"text": "data into shape • 13 Training and selecting a predictive model • 13 Evaluating models and predicting unseen data instances • 14 Using Python for machine learning ......................................................................................... 14 Installing Python and packages from the Python Package Index • 14 Using the Anaconda Python distribution and package manager • 15 Packages for scientific computing, data science, and machine learning • 16 Summary ............................................................................................................................... 17 Table of Contents x Chapter 2: Training Simple Machine Learning Algorithms for Classification 19 Artificial neurons – a brief glimpse into the early history of machine learning .......................... 19 The formal definition of an artificial neuron • 20 The perceptron learning rule • 22 Implementing a perceptron learning algorithm in Python ....................................................... 25 An object-oriented perceptron API • 25 Training a perceptron model on the Iris dataset • 29 Adaptive linear neurons and the convergence of learning ......................................................... 35 Minimizing loss functions with gradient descent • 37 Implementing Adaline in Python • 39 Improving gradient descent through feature scaling • 43 Large-scale machine learning and stochastic gradient descent • 45 Summary ............................................................................................................................... 51 Chapter 3: A Tour of Machine Learning Classifiers Using Scikit-Learn 53 Choosing a classification algorithm ......................................................................................... 53 First steps with scikit-learn – training a perceptron ................................................................. 54 Modeling class probabilities via logistic regression .................................................................. 59 Logistic regression and conditional probabilities • 60 Learning the model weights via the logistic loss function • 63 Converting an Adaline implementation into an algorithm for logistic regression • 66 Training a logistic regression model with scikit-learn • 70 Tackling overfitting via regularization • 73 Maximum margin classification with support vector machines ................................................ 76 Maximum margin intuition • 77 Dealing with a nonlinearly separable case using slack variables • 77 Alternative implementations in scikit-learn • 79 Solving nonlinear problems using a kernel SVM ...................................................................... 80 Kernel methods for linearly inseparable data • 80 Using the kernel trick to find separating hyperplanes in a high-dimensional space • 82 Decision tree learning ............................................................................................................ 86 Maximizing IG – getting the most bang for your buck • 88 Building a decision tree • 92 Combining multiple decision trees via random forests • 95 K-nearest neighbors – a lazy learning algorithm ...................................................................... 98 Summary ............................................................................................................................. 102 Table of Contents xi Chapter 4: Building Good Training Datasets – Data Preprocessing 105 Dealing with missing data ..................................................................................................... 105 Identifying missing values in tabular data • 106 Eliminating training examples or features with missing values •", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 5, "start_word": 1600, "end_word": 2000, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000006": {"text": "tree learning ............................................................................................................ 86 Maximizing IG – getting the most bang for your buck • 88 Building a decision tree • 92 Combining multiple decision trees via random forests • 95 K-nearest neighbors – a lazy learning algorithm ...................................................................... 98 Summary ............................................................................................................................. 102 Table of Contents xi Chapter 4: Building Good Training Datasets – Data Preprocessing 105 Dealing with missing data ..................................................................................................... 105 Identifying missing values in tabular data • 106 Eliminating training examples or features with missing values • 107 Imputing missing values • 108 Understanding the scikit-learn estimator API • 109 Handling categorical data ..................................................................................................... 111 Categorical data encoding with pandas • 111 Mapping ordinal features • 111 Encoding class labels • 112 Performing one-hot encoding on nominal features • 113 Optional: encoding ordinal features • 116 Partitioning a dataset into separate training and test datasets ................................................ 117 Bringing features onto the same scale ................................................................................... 119 Selecting meaningful features ............................................................................................... 122 L1 and L2 regularization as penalties against model complexity • 122 A geometric interpretation of L2 regularization • 123 Sparse solutions with L1 regularization • 125 Sequential feature selection algorithms • 128 Assessing feature importance with random forests ................................................................ 134 Summary ............................................................................................................................. 137 Chapter 5: Compressing Data via Dimensionality Reduction 139 Unsupervised dimensionality reduction via principal component analysis ............................. 139 The main steps in principal component analysis • 140 Extracting the principal components step by step • 142 Total and explained variance • 144 Feature transformation • 146 Principal component analysis in scikit-learn • 149 Assessing feature contributions • 152 Supervised data compression via linear discriminant analysis ............................................... 154 Principal component analysis versus linear discriminant analysis • 154 The inner workings of linear discriminant analysis • 156 Computing the scatter matrices • 156 Selecting linear discriminants for the new feature subspace • 158 Projecting examples onto the new feature space • 161 Table of Contents xii LDA via scikit-learn • 162 Nonlinear dimensionality reduction and visualization ........................................................... 163 Why consider nonlinear dimensionality reduction? • 164 Visualizing data via t-distributed stochastic neighbor embedding • 165 Summary ............................................................................................................................. 169 Chapter 6: Learning Best Practices for Model Evaluation and Hyperparameter Tuning 171 Streamlining workflows with pipelines ................................................................................. 171 Loading the Breast Cancer Wisconsin dataset • 172 Combining transformers and estimators in a pipeline • 173 Using k-fold cross-validation to assess model performance .................................................... 175 The holdout method • 175 K-fold cross-validation • 176 Debugging algorithms with learning and validation curves", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 6, "start_word": 1920, "end_word": 2320, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000007": {"text": "163 Why consider nonlinear dimensionality reduction? • 164 Visualizing data via t-distributed stochastic neighbor embedding • 165 Summary ............................................................................................................................. 169 Chapter 6: Learning Best Practices for Model Evaluation and Hyperparameter Tuning 171 Streamlining workflows with pipelines ................................................................................. 171 Loading the Breast Cancer Wisconsin dataset • 172 Combining transformers and estimators in a pipeline • 173 Using k-fold cross-validation to assess model performance .................................................... 175 The holdout method • 175 K-fold cross-validation • 176 Debugging algorithms with learning and validation curves .................................................... 180 Diagnosing bias and variance problems with learning curves • 180 Addressing over- and underfitting with validation curves • 183 Fine-tuning machine learning models via grid search ............................................................ 185 Tuning hyperparameters via grid search • 186 Exploring hyperparameter configurations more widely with randomized search • 187 More resource-efficient hyperparameter search with successive halving • 189 Algorithm selection with nested cross-validation • 191 Looking at different performance evaluation metrics ............................................................ 193 Reading a confusion matrix • 193 Optimizing the precision and recall of a classification model • 195 Plotting a receiver operating characteristic • 198 Scoring metrics for multiclass classification • 200 Dealing with class imbalance • 201 Summary ............................................................................................................................. 203 Chapter 7: Combining Different Models for Ensemble Learning 205 Learning with ensembles ...................................................................................................... 205 Combining classifiers via majority vote ................................................................................. 209 Implementing a simple majority vote classifier • 209 Using the majority voting principle to make predictions • 214 Evaluating and tuning the ensemble classifier • 217 Table of Contents xiii Bagging – building an ensemble of classifiers from bootstrap samples ................................... 223 Bagging in a nutshell • 224 Applying bagging to classify examples in the Wine dataset • 225 Leveraging weak learners via adaptive boosting .................................................................... 229 How adaptive boosting works • 229 Applying AdaBoost using scikit-learn • 233 Gradient boosting – training an ensemble based on loss gradients ......................................... 237 Comparing AdaBoost with gradient boosting • 237 Outlining the general gradient boosting algorithm • 237 Explaining the gradient boosting algorithm for classification • 239 Illustrating gradient boosting for classification • 241 Using XGBoost • 243 Summary ............................................................................................................................. 245 Chapter 8: Applying Machine Learning to Sentiment Analysis 247 Preparing the IMDb movie review data for text processing ..................................................... 247 Obtaining the movie review dataset • 248 Preprocessing the movie dataset into a more convenient format • 248 Introducing the bag-of-words model ..................................................................................... 250 Transforming words into feature vectors • 250 Assessing word relevancy via term frequency-inverse document frequency", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 7, "start_word": 2240, "end_word": 2640, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000008": {"text": "gradient boosting algorithm for classification • 239 Illustrating gradient boosting for classification • 241 Using XGBoost • 243 Summary ............................................................................................................................. 245 Chapter 8: Applying Machine Learning to Sentiment Analysis 247 Preparing the IMDb movie review data for text processing ..................................................... 247 Obtaining the movie review dataset • 248 Preprocessing the movie dataset into a more convenient format • 248 Introducing the bag-of-words model ..................................................................................... 250 Transforming words into feature vectors • 250 Assessing word relevancy via term frequency-inverse document frequency • 252 Cleaning text data • 254 Processing documents into tokens • 256 Training a logistic regression model for document classification ............................................ 258 Working with bigger data – online algorithms and out-of-core learning .................................. 260 Topic modeling with latent Dirichlet allocation ..................................................................... 264 Decomposing text documents with LDA • 264 LDA with scikit-learn • 265 Summary ............................................................................................................................. 268 Chapter 9: Predicting Continuous Target Variables with Regression Analysis 269 Introducing linear regression ............................................................................................... 269 Simple linear regression • 270 Multiple linear regression • 271 Exploring the Ames Housing dataset ..................................................................................... 272 Loading the Ames Housing dataset into a DataFrame • 272 Table of Contents xiv Visualizing the important characteristics of a dataset • 274 Looking at relationships using a correlation matrix • 276 Implementing an ordinary least squares linear regression model ........................................... 278 Solving regression for regression parameters with gradient descent • 278 Estimating the coefficient of a regression model via scikit-learn • 283 Fitting a robust regression model using RANSAC ................................................................... 285 Evaluating the performance of linear regression models ........................................................ 288 Using regularized methods for regression ............................................................................. 292 Turning a linear regression model into a curve – polynomial regression ................................. 294 Adding polynomial terms using scikit-learn • 294 Modeling nonlinear relationships in the Ames Housing dataset • 297 Dealing with nonlinear relationships using random forests .................................................... 299 Decision tree regression • 300 Random forest regression • 301 Summary ............................................................................................................................. 304 Chapter 10: Working with Unlabeled Data – Clustering Analysis 305 Grouping objects by similarity using k-means ....................................................................... 305 k-means clustering using scikit-learn • 305 A smarter way of placing the initial cluster centroids using k-means++ • 310 Hard versus soft clustering • 311 Using the elbow method to find the optimal number of clusters • 313 Quantifying the quality of clustering via silhouette plots • 314 Organizing clusters as a hierarchical tree .............................................................................. 319 Grouping clusters in a bottom-up fashion • 320 Performing hierarchical clustering on a distance matrix •", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 8, "start_word": 2560, "end_word": 2960, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000009": {"text": "Grouping objects by similarity using k-means ....................................................................... 305 k-means clustering using scikit-learn • 305 A smarter way of placing the initial cluster centroids using k-means++ • 310 Hard versus soft clustering • 311 Using the elbow method to find the optimal number of clusters • 313 Quantifying the quality of clustering via silhouette plots • 314 Organizing clusters as a hierarchical tree .............................................................................. 319 Grouping clusters in a bottom-up fashion • 320 Performing hierarchical clustering on a distance matrix • 321 Attaching dendrograms to a heat map • 325 Applying agglomerative clustering via scikit-learn • 327 Locating regions of high density via DBSCAN ........................................................................ 328 Summary ............................................................................................................................. 334 Chapter 11: Implementing a Multilayer Artificial Neural Network from Scratch 335 Modeling complex functions with artificial neural networks .................................................. 335 Single-layer neural network recap • 337 Introducing the multilayer neural network architecture • 338 Activating a neural network via forward propagation • 340 Table of Contents xv Classifying handwritten digits .............................................................................................. 343 Obtaining and preparing the MNIST dataset • 343 Implementing a multilayer perceptron • 347 Coding the neural network training loop • 352 Evaluating the neural network performance • 357 Training an artificial neural network ..................................................................................... 360 Computing the loss function • 360 Developing your understanding of backpropagation • 362 Training neural networks via backpropagation • 363 About convergence in neural networks .................................................................................. 367 A few last words about the neural network implementation ................................................... 368 Summary ............................................................................................................................. 368 Chapter 12: Parallelizing Neural Network Training with PyTorch 369 PyTorch and training performance ....................................................................................... 369 Performance challenges • 369 What is PyTorch? • 371 How we will learn PyTorch • 372 First steps with PyTorch ....................................................................................................... 372 Installing PyTorch • 372 Creating tensors in PyTorch • 373 Manipulating the data type and shape of a tensor • 374 Applying mathematical operations to tensors • 375 Split, stack, and concatenate tensors • 376 Building input pipelines in PyTorch ...................................................................................... 378 Creating a PyTorch DataLoader from existing tensors • 378 Combining two tensors into a joint dataset • 379 Shuffle, batch, and repeat • 380 Creating a dataset from files on your local storage disk • 382 Fetching available datasets from the torchvision.datasets library • 386 Building an NN model in PyTorch ......................................................................................... 389 The PyTorch neural network module (torch.nn) • 390 Building a linear regression model • 390 Model training via the torch.nn and torch.optim modules • 394 Building a multilayer perceptron for classifying", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 9, "start_word": 2880, "end_word": 3280, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000010": {"text": "from existing tensors • 378 Combining two tensors into a joint dataset • 379 Shuffle, batch, and repeat • 380 Creating a dataset from files on your local storage disk • 382 Fetching available datasets from the torchvision.datasets library • 386 Building an NN model in PyTorch ......................................................................................... 389 The PyTorch neural network module (torch.nn) • 390 Building a linear regression model • 390 Model training via the torch.nn and torch.optim modules • 394 Building a multilayer perceptron for classifying flowers in the Iris dataset • 395 Evaluating the trained model on the test dataset • 398 Table of Contents xvi Saving and reloading the trained model • 399 Choosing activation functions for multilayer neural networks ................................................ 400 Logistic function recap • 400 Estimating class probabilities in multiclass classification via the softmax function • 402 Broadening the output spectrum using a hyperbolic tangent • 403 Rectified linear unit activation • 405 Summary ............................................................................................................................. 406 Chapter 13: Going Deeper – The Mechanics of PyTorch 409 The key features of PyTorch .................................................................................................. 410 PyTorch’s computation graphs .............................................................................................. 410 Understanding computation graphs • 410 Creating a graph in PyTorch • 411 PyTorch tensor objects for storing and updating model parameters ....................................... 412 Computing gradients via automatic differentiation ................................................................ 415 Computing the gradients of the loss with respect to trainable variables • 415 Understanding automatic differentiation • 416 Adversarial examples • 416 Simplifying implementations of common architectures via the torch.nn module .................... 417 Implementing models based on nn.Sequential • 417 Choosing a loss function • 418 Solving an XOR classification problem • 419 Making model building more flexible with nn.Module • 424 Writing custom layers in PyTorch • 426 Project one – predicting the fuel efficiency of a car ................................................................ 431 Working with feature columns • 431 Training a DNN regression model • 435 Project two – classifying MNIST handwritten digits ............................................................... 436 Higher-level PyTorch APIs: a short introduction to PyTorch-Lightning ................................... 439 Setting up the PyTorch Lightning model • 440 Setting up the data loaders for Lightning • 443 Training the model using the PyTorch Lightning Trainer class • 444 Evaluating the model using TensorBoard • 445 Summary ............................................................................................................................. 449 Table of Contents xvii Chapter 14: Classifying Images with Deep Convolutional Neural Networks 451 The building blocks of CNNs ................................................................................................. 451 Understanding CNNs and feature hierarchies • 452 Performing discrete convolutions • 454 Discrete convolutions in one dimension • 454 Padding inputs to", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 10, "start_word": 3200, "end_word": 3600, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000011": {"text": "up the PyTorch Lightning model • 440 Setting up the data loaders for Lightning • 443 Training the model using the PyTorch Lightning Trainer class • 444 Evaluating the model using TensorBoard • 445 Summary ............................................................................................................................. 449 Table of Contents xvii Chapter 14: Classifying Images with Deep Convolutional Neural Networks 451 The building blocks of CNNs ................................................................................................. 451 Understanding CNNs and feature hierarchies • 452 Performing discrete convolutions • 454 Discrete convolutions in one dimension • 454 Padding inputs to control the size of the output feature maps • 457 Determining the size of the convolution output • 458 Performing a discrete convolution in 2D • 459 Subsampling layers • 463 Putting everything together – implementing a CNN ............................................................... 464 Working with multiple input or color channels • 464 Regularizing an NN with L2 regularization and dropout • 467 Loss functions for classification • 471 Implementing a deep CNN using PyTorch .............................................................................. 473 The multilayer CNN architecture • 473 Loading and preprocessing the data • 474 Implementing a CNN using the torch.nn module • 476 Configuring CNN layers in PyTorch • 476 Constructing a CNN in PyTorch • 477 Smile classification from face images using a CNN ................................................................. 482 Loading the CelebA dataset • 483 Image transformation and data augmentation • 484 Training a CNN smile classifier • 490 Summary ............................................................................................................................. 497 Chapter 15: Modeling Sequential Data Using Recurrent Neural Networks 499 Introducing sequential data .................................................................................................. 499 Modeling sequential data – order matters • 500 Sequential data versus time series data • 500 Representing sequences • 500 The different categories of sequence modeling • 501 RNNs for modeling sequences .............................................................................................. 502 Understanding the dataflow in RNNs • 502 Computing activations in an RNN • 504 Table of Contents xviii Hidden recurrence versus output recurrence • 506 The challenges of learning long-range interactions • 509 Long short-term memory cells • 511 Implementing RNNs for sequence modeling in PyTorch ......................................................... 513 Project one – predicting the sentiment of IMDb movie reviews • 513 Preparing the movie review data • 513 Embedding layers for sentence encoding • 517 Building an RNN model • 520 Building an RNN model for the sentiment analysis task • 521 Project two – character-level language modeling in PyTorch • 525 Preprocessing the dataset • 526 Building a character-level RNN model • 531 Evaluation phase – generating new text passages • 533 Summary ............................................................................................................................. 537 Chapter 16: Transformers –", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 11, "start_word": 3520, "end_word": 3920, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000012": {"text": "one – predicting the sentiment of IMDb movie reviews • 513 Preparing the movie review data • 513 Embedding layers for sentence encoding • 517 Building an RNN model • 520 Building an RNN model for the sentiment analysis task • 521 Project two – character-level language modeling in PyTorch • 525 Preprocessing the dataset • 526 Building a character-level RNN model • 531 Evaluation phase – generating new text passages • 533 Summary ............................................................................................................................. 537 Chapter 16: Transformers – Improving Natural Language Processing with Attention Mechanisms 539 Adding an attention mechanism to RNNs ............................................................................... 540 Attention helps RNNs with accessing information • 540 The original attention mechanism for RNNs • 542 Processing the inputs using a bidirectional RNN • 543 Generating outputs from context vectors • 543 Computing the attention weights • 544 Introducing the self-attention mechanism ............................................................................. 544 Starting with a basic form of self-attention • 545 Parameterizing the self-attention mechanism: scaled dot-product attention • 549 Attention is all we need: introducing the original transformer architecture ............................ 552 Encoding context embeddings via multi-head attention • 554 Learning a language model: decoder and masked multi-head attention • 558 Implementation details: positional encodings and layer normalization • 559 Building large-scale language models by leveraging unlabeled data ........................................ 561 Pre-training and fine-tuning transformer models • 561 Leveraging unlabeled data with GPT • 563 Using GPT-2 to generate new text • 566 Bidirectional pre-training with BERT • 569 The best of both worlds: BART • 572 Table of Contents xix Fine-tuning a BERT model in PyTorch ................................................................................... 574 Loading the IMDb movie review dataset • 575 Tokenizing the dataset • 577 Loading and fine-tuning a pre-trained BERT model • 578 Fine-tuning a transformer more conveniently using the Trainer API • 582 Summary ............................................................................................................................. 586 Chapter 17: Generative Adversarial Networks for Synthesizing New Data 589 Introducing generative adversarial networks ......................................................................... 589 Starting with autoencoders • 590 Generative models for synthesizing new data • 592 Generating new samples with GANs • 593 Understanding the loss functions of the generator and discriminator networks in a GAN model • 594 Implementing a GAN from scratch ........................................................................................ 596 Training GAN models on Google Colab • 596 Implementing the generator and the discriminator networks • 600 Defining the training dataset • 604 Training the GAN model • 605 Improving the quality of synthesized images using a convolutional and Wasserstein GAN ....... 612 Transposed convolution • 612 Batch normalization", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 12, "start_word": 3840, "end_word": 4240, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000013": {"text": "592 Generating new samples with GANs • 593 Understanding the loss functions of the generator and discriminator networks in a GAN model • 594 Implementing a GAN from scratch ........................................................................................ 596 Training GAN models on Google Colab • 596 Implementing the generator and the discriminator networks • 600 Defining the training dataset • 604 Training the GAN model • 605 Improving the quality of synthesized images using a convolutional and Wasserstein GAN ....... 612 Transposed convolution • 612 Batch normalization • 614 Implementing the generator and discriminator • 616 Dissimilarity measures between two distributions • 624 Using EM distance in practice for GANs • 627 Gradient penalty • 628 Implementing WGAN-GP to train the DCGAN model • 629 Mode collapse • 633 Other GAN applications ........................................................................................................ 635 Summary ............................................................................................................................. 635 Chapter 18: Graph Neural Networks for Capturing Dependencies in Graph Structured Data 637 Introduction to graph data .................................................................................................... 638 Undirected graphs • 638 Directed graphs • 639 Table of Contents xx Labeled graphs • 640 Representing molecules as graphs • 640 Understanding graph convolutions ....................................................................................... 641 The motivation behind using graph convolutions • 641 Implementing a basic graph convolution • 644 Implementing a GNN in PyTorch from scratch ....................................................................... 648 Defining the NodeNetwork model • 649 Coding the NodeNetwork’s graph convolution layer • 650 Adding a global pooling layer to deal with varying graph sizes • 652 Preparing the DataLoader • 655 Using the NodeNetwork to make predictions • 658 Implementing a GNN using the PyTorch Geometric library .................................................... 659 Other GNN layers and recent developments ........................................................................... 665 Spectral graph convolutions • 665 Pooling • 667 Normalization • 668 Pointers to advanced graph neural network literature • 669 Summary ............................................................................................................................. 671 Chapter 19: Reinforcement Learning for Decision Making in Complex Environments 673 Introduction – learning from experience ............................................................................... 674 Understanding reinforcement learning • 674 Defining the agent-environment interface of a reinforcement learning system • 675 The theoretical foundations of RL ......................................................................................... 676 Markov decision processes • 677 The mathematical formulation of Markov decision processes • 677 Visualization of a Markov process • 679 Episodic versus continuing tasks • 679 RL terminology: return, policy, and value function • 680 The return • 680 Policy • 682 Value function • 682 Dynamic programming using the Bellman equation • 684 Table of Contents xxi Reinforcement learning algorithms ...................................................................................... 684 Dynamic programming • 685 Policy evaluation – predicting the value function with dynamic programming", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 13, "start_word": 4160, "end_word": 4560, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000014": {"text": "......................................................................................... 676 Markov decision processes • 677 The mathematical formulation of Markov decision processes • 677 Visualization of a Markov process • 679 Episodic versus continuing tasks • 679 RL terminology: return, policy, and value function • 680 The return • 680 Policy • 682 Value function • 682 Dynamic programming using the Bellman equation • 684 Table of Contents xxi Reinforcement learning algorithms ...................................................................................... 684 Dynamic programming • 685 Policy evaluation – predicting the value function with dynamic programming • 686 Improving the policy using the estimated value function • 686 Policy iteration • 687 Value iteration • 687 Reinforcement learning with Monte Carlo • 687 State-value function estimation using MC • 688 Action-value function estimation using MC • 688 Finding an optimal policy using MC control • 688 Policy improvement – computing the greedy policy from the action-value function • 689 Temporal difference learning • 689 TD prediction • 689 On-policy TD control (SARSA) • 691 Off-policy TD control (Q-learning) • 691 Implementing our first RL algorithm .................................................................................... 691 Introducing the OpenAI Gym toolkit • 692 Working with the existing environments in OpenAI Gym • 692 A grid world example • 694 Implementing the grid world environment in OpenAI Gym • 694 Solving the grid world problem with Q-learning • 701 A glance at deep Q-learning .................................................................................................. 706 Training a DQN model according to the Q-learning algorithm • 706 Replay memory • 707 Determining the target values for computing the loss • 708 Implementing a deep Q-learning algorithm • 710 Chapter and book summary .................................................................................................. 714 Other Books You May Enjoy 719 Index 723 Preface Through exposure to the news and social media, you probably are familiar with the fact that machine learning has become one of the most exciting technologies of our time and age. Large companies, such as Microsoft, Google, Meta, Apple, Amazon, IBM, and many more, heavily invest in machine learning research and applications for good reasons. While it may seem that machine learning has become the buzzword of our time and age, it is certainly not hype. This exciting field opens the way to new possibilities and has become indispensable to our daily lives. Talking to the voice assistant on our smartphones, recommending the right product for our customers, preventing credit card fraud, filtering out spam from our e-mail inboxes, detecting and diagnosing medical diseases, the list goes on and on. If you want", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 14, "start_word": 4480, "end_word": 4880, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000015": {"text": "good reasons. While it may seem that machine learning has become the buzzword of our time and age, it is certainly not hype. This exciting field opens the way to new possibilities and has become indispensable to our daily lives. Talking to the voice assistant on our smartphones, recommending the right product for our customers, preventing credit card fraud, filtering out spam from our e-mail inboxes, detecting and diagnosing medical diseases, the list goes on and on. If you want to become a machine learning practitioner, a better problem solver, or even consider a career in machine learning research, then this book is for you! However, for a novice, the theoretical concepts behind machine learning can be quite overwhelming. Yet, many practical books that have been published in recent years will help you get started in machine learning by implementing pow - erful learning algorithms. Getting exposed to practical code examples and working through example applications of machine learning is a great way to dive into this field. Concrete examples help to illustrate the broader concepts by putting the learned material directly into action. However, remember that with great power comes great responsibility! In addition to offering hands-on experience with machine learning using Python and Python-based machine learning libraries, this book also introduces the mathematical concepts behind machine learning algorithms, which is essential for using machine learning successfully. Thus, this book is different from a purely practical book; it is a book that discusses the necessary details regarding machine learning concepts, offers intuitive yet informative explanations on how machine learning algorithms work, how to use them, and most importantly, how to avoid the most common pitfalls. In this book, we will embark on an exciting journey that covers all the essential topics and concepts to give you a head start in this field. If you find that your thirst for knowledge is not satisfied, this book references many useful resources that you can use to follow up on the essential breakthroughs in this field. Preface xxiv Who this book is for This book is the ideal companion for learning how to apply machine learning and deep learning to a wide range of tasks and datasets. If you are a programmer who wants to keep up with the recent trends in technology, this book is definitely for you. Also, if you are a student or considering a career transition, this book", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 15, "start_word": 4800, "end_word": 5200, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000016": {"text": "that you can use to follow up on the essential breakthroughs in this field. Preface xxiv Who this book is for This book is the ideal companion for learning how to apply machine learning and deep learning to a wide range of tasks and datasets. If you are a programmer who wants to keep up with the recent trends in technology, this book is definitely for you. Also, if you are a student or considering a career transition, this book will be both your introduction and a comprehensive guide to the world of machine learning. What this book covers Chapter 1, Giving Computers the Ability to Learn from Data, introduces you to the main subareas of ma - chine learning to tackle various problem tasks. In addition, it discusses the essential steps for creating a typical machine learning model building pipeline that will guide us through the following chapters. Chapter 2, Training Simple Machine Learning Algorithms for Classification , goes back to the origins of ma - chine learning and introduces binary perceptron classifiers and adaptive linear neurons. This chapter is a gentle introduction to the fundamentals of pattern classification and focuses on the interplay of optimization algorithms and machine learning. Chapter 3, A Tour of Machine Learning Classifiers Using Scikit-Learn, describes the essential machine learning algorithms for classification and provides practical examples using one of the most popular and comprehensive open-source machine learning libraries, scikit-learn. Chapter 4, Building Good Training Datasets – Data Preprocessing, discusses how to deal with the most common problems in unprocessed datasets, such as missing data. It also discusses several approach- es to identify the most informative features in datasets and teaches you how to prepare variables of different types as proper inputs for machine learning algorithms. Chapter 5, Compressing Data via Dimensionality Reduction, describes the essential techniques to reduce the number of features in a dataset to smaller sets while retaining most of their useful and discrim- inatory information. It discusses the standard approach to dimensionality reduction via principal component analysis and compares it to supervised and nonlinear transformation techniques. Chapter 6, Learning Best Practices for Model Evaluation and Hyperparameter Tuning, discusses the do’s and don’ts for estimating the performances of predictive models. Moreover, it discusses different metrics for measuring the performance of our models and techniques to fine-tune machine learning algorithms. Chapter 7, Combining Different Models for Ensemble Learning, introduces you to the", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 16, "start_word": 5120, "end_word": 5520, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000017": {"text": "useful and discrim- inatory information. It discusses the standard approach to dimensionality reduction via principal component analysis and compares it to supervised and nonlinear transformation techniques. Chapter 6, Learning Best Practices for Model Evaluation and Hyperparameter Tuning, discusses the do’s and don’ts for estimating the performances of predictive models. Moreover, it discusses different metrics for measuring the performance of our models and techniques to fine-tune machine learning algorithms. Chapter 7, Combining Different Models for Ensemble Learning, introduces you to the different concepts of combining multiple learning algorithms effectively. It teaches you how to build ensembles of experts to overcome the weaknesses of individual learners, resulting in more accurate and reliable predictions. Chapter 8, Applying Machine Learning to Sentiment Analysis, discusses the essential steps to transform textual data into meaningful representations for machine learning algorithms to predict the opinions of people based on their writing. Preface xxv Chapter 9, Predicting Continuous Target Variables with Regression Analysis, discusses the essential tech- niques for modeling linear relationships between target and response variables to make predictions on a continuous scale. After introducing different linear models, it also talks about polynomial regression and tree-based approaches. Chapter 10, Working with Unlabeled Data – Clustering Analysis, shifts the focus to a different subarea of machine learning, unsupervised learning. We apply algorithms from three fundamental families of clustering algorithms to find groups of objects that share a certain degree of similarity. Chapter 11, Implementing a Multilayer Artificial Neural Network from Scratch, extends the concept of gradient-based optimization, which we first introduced in Chapter 2, Training Simple Machine Learn- ing Algorithms for Classification, to build powerful, multilayer neural networks based on the popular backpropagation algorithm in Python. Chapter 12, Parallelizing Neural Network Training with PyTorch, builds upon the knowledge from the previous chapter to provide you with a practical guide for training neural networks more efficiently. The focus of this chapter is on PyTorch, an open-source Python library that allows us to utilize mul- tiple cores of modern GPUs and construct deep neural networks from common building blocks via a user-friendly and flexible API. Chapter 13, Going Deeper – The Mechanics of PyTorch, picks up where the previous chapter left off and introduces more advanced concepts and functionality of PyTorch. PyTorch is an extraordinarily vast and sophisticated library, and this chapter walks you through concepts such as dynamic computation graphs and automatic differentiation. You will also learn how to", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 17, "start_word": 5440, "end_word": 5840, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000018": {"text": "allows us to utilize mul- tiple cores of modern GPUs and construct deep neural networks from common building blocks via a user-friendly and flexible API. Chapter 13, Going Deeper – The Mechanics of PyTorch, picks up where the previous chapter left off and introduces more advanced concepts and functionality of PyTorch. PyTorch is an extraordinarily vast and sophisticated library, and this chapter walks you through concepts such as dynamic computation graphs and automatic differentiation. You will also learn how to use PyTorch’s object-oriented API to implement complex neural networks and how PyTorch Lightning helps you with best practices and minimizing boilerplate code. Chapter 14, Classifying Images with Deep Convolutional Neural Networks, introduces convolutional neu- ral networks (CNNs). A CNN represents a particular type of deep neural network architecture that is particularly well-suited for working with image datasets. Due to their superior performance compared to traditional approaches, CNNs are now widely used in computer vision to achieve state-of-the-art results for various image recognition tasks. Throughout this chapter, you will learn how convolutional layers can be used as powerful feature extractors for image classification. Chapter 15, Modeling Sequential Data Using Recurrent Neural Networks, introduces another popular neural network architecture for deep learning that is especially well suited for working with text and other types of sequential data and time series data. As a warm-up exercise, this chapter introduces recurrent neural networks for predicting the sentiment of movie reviews. Then, we will teach recurrent networks to digest information from books in order to generate entirely new text. Chapter 16, Transformers – Improving Natural Language Processing with Attention Mechanisms, focuses on the latest trends in natural language processing and explains how attention mechanisms help with modeling complex relationships in long sequences. In particular, this chapter describes the influential transformer architecture and state-of-the-art transformer models such as BERT and GPT. Preface xxvi Chapter 17, Generative Adversarial Networks for Synthesizing New Data, introduces a popular adversarial training regime for neural networks that can be used to generate new, realistic-looking images. The chapter starts with a brief introduction to autoencoders, which is a particular type of neural network architecture that can be used for data compression. The chapter then shows you how to combine the decoder part of an autoencoder with a second neural network that can distinguish between real and synthesized images. By letting two neural networks compete with each other in an adversarial training approach,", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 18, "start_word": 5760, "end_word": 6160, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000019": {"text": "training regime for neural networks that can be used to generate new, realistic-looking images. The chapter starts with a brief introduction to autoencoders, which is a particular type of neural network architecture that can be used for data compression. The chapter then shows you how to combine the decoder part of an autoencoder with a second neural network that can distinguish between real and synthesized images. By letting two neural networks compete with each other in an adversarial training approach, you will implement a generative adversarial network that generates new handwritten digits. Chapter 18, Graph Neural Networks for Capturing Dependencies in Graph Structured Data, goes beyond working with tabular datasets, images, and text. This chapter introduces graph neural networks that operate on graph-structured data, such as social media networks and molecules. After explaining the fundamentals of graph convolutions, this chapter includes a tutorial showing you how to implement predictive models for molecular data. Chapter 19, Reinforcement Learning for Decision Making in Complex Environments, covers a subcategory of machine learning that is commonly used for training robots and other autonomous systems. This chapter starts by introducing the basics of reinforcement learning (RL) to become familiar with the agent/environment interactions, the reward process of RL systems, and the concept of learning from experience. After learning about the main categories of RL, you will implement and train an agent that can navigate in a grid world environment using the Q-learning algorithm. Finally, this chapter intro - duces the deep Q-learning algorithm, which is a variant of Q-learning that uses deep neural networks. To get the most out of this book Ideally, you are already comfortable with programming in Python to follow along with the code ex - amples we provide to both illustrate and apply various algorithms and models. To get the most out of this book, a firm grasp of mathematical notation will be helpful as well. A common laptop or desktop computer should be sufficient for running most of the code in this book, and we provide instructions for your Python environment in the first chapter. Later chapters will introduce additional libraries and installation recommendations when the need arises. A recent graphics processing unit (GPU ) can accelerate the code runtimes in the later deep learning chapters. However, a GPU is not required, and we also provide instructions for using free cloud re - sources. Download the example code files All", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 19, "start_word": 6080, "end_word": 6480, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000020": {"text": "computer should be sufficient for running most of the code in this book, and we provide instructions for your Python environment in the first chapter. Later chapters will introduce additional libraries and installation recommendations when the need arises. A recent graphics processing unit (GPU ) can accelerate the code runtimes in the later deep learning chapters. However, a GPU is not required, and we also provide instructions for using free cloud re - sources. Download the example code files All code examples are available for download through GitHub at https://github.com/rasbt/machine- learning-book . We also have other code bundles from our rich catalog of books and videos available at https://github.com/PacktPublishing/ . Check them out! While we recommend using Jupyter Notebook for executing code interactively, all code examples are available in both a Python script (for example, ch02/ch02.py ) and a Jupyter Notebook format (for ex - ample, ch02/ch02.ipynb ). Furthermore, we recommend viewing the README.md file that accompanies each individual chapter for additional information and updates Preface xxvii Download the color images We also provide a PDF file that has color images of the screenshots/diagrams used in this book. You can download it here: https://static.packt-cdn.com/downloads/9781801819312_ColorImages. pdf. In addition, lower resolution color images are embedded in the code notebooks of this book that come bundled with the example code files. Conventions There are a number of text conventions used throughout this book. Here are some examples of these styles and an explanation of their meaning. Code words in text are shown as follows: “And already installed packages can be updated via the --upgrade flag.” A block of code is set as follows: def __init__(self, eta= 0.01, n_iter= 50, random_state= 1): self.eta = eta self.n_iter = n_iter self.random_state = random_state Any input in the Python interpreter is written as follows (notice the >>> symbol). The expected output will be shown without the >>> symbol: >>> v1 = np.array([ 1, 2, 3]) >>> v2 = 0.5 * v1 >>> np.arccos(v1.dot(v2) / (np.linalg.norm(v1) * ... np.linalg.norm(v2))) 0.0 Any command-line input or output is written as follows: pip install gym==0.20 New terms and important words are shown in bold. Words that you see on the screen, for example, in menus or dialog boxes, appear in the text like this: “Clicking the Next button moves you to the next screen.” Warnings or important notes appear in a box like this. Tips and tricks appear like this. Preface", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 20, "start_word": 6400, "end_word": 6800, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000021": {"text": "= 0.5 * v1 >>> np.arccos(v1.dot(v2) / (np.linalg.norm(v1) * ... np.linalg.norm(v2))) 0.0 Any command-line input or output is written as follows: pip install gym==0.20 New terms and important words are shown in bold. Words that you see on the screen, for example, in menus or dialog boxes, appear in the text like this: “Clicking the Next button moves you to the next screen.” Warnings or important notes appear in a box like this. Tips and tricks appear like this. Preface xxviii Get in touch Feedback from our readers is always welcome. General feedback: Email feedback@packtpub.com and mention the book’s title in the subject of your message. If you have questions about any aspect of this book, please email us at questions@packtpub. com. Errata: Although we have taken every care to ensure the accuracy of our content, mistakes do happen. If you have found a mistake in this book we would be grateful if you would report this to us. Please visit, http://www.packtpub.com/submit-errata , selecting your book, clicking on the Errata Submission Form link, and entering the details. Piracy: If you come across any illegal copies of our works in any form on the Internet, we would be grateful if you would provide us with the location address or website name. Please contact us at copyright@packtpub.com with a link to the material. If you are interested in becoming an author: If there is a topic that you have expertise in and you are interested in either writing or contributing to a book, please visit http://authors.packtpub.com . Share your thoughts Once you’ve read Machine Learning with PyTorch and Scikit-Learn, we’d love to hear your thoughts! Please click here to go straight to the Amazon review page for this book and share your feedback. Your review is important to us and the tech community and will help us make sure we’re delivering excellent quality content. 1 Giving Computers the Ability to Learn from Data In my opinion, machine learning, the application and science of algorithms that make sense of data, is the most exciting field of all the computer sciences! We are living in an age where data comes in abundance; using self-learning algorithms from the field of machine learning, we can turn this data into knowledge. Thanks to the many powerful open-source libraries that have been developed in recent years, there has probably never been a better time to break into the", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 21, "start_word": 6720, "end_word": 7120, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000022": {"text": "Data In my opinion, machine learning, the application and science of algorithms that make sense of data, is the most exciting field of all the computer sciences! We are living in an age where data comes in abundance; using self-learning algorithms from the field of machine learning, we can turn this data into knowledge. Thanks to the many powerful open-source libraries that have been developed in recent years, there has probably never been a better time to break into the machine learning field and learn how to utilize powerful algorithms to spot patterns in data and make predictions about future events. In this chapter, you will learn about the main concepts and different types of machine learning. Togeth - er with a basic introduction to the relevant terminology, we will lay the groundwork for successfully using machine learning techniques for practical problem solving. In this chapter, we will cover the following topics: • The general concepts of machine learning • The three types of learning and basic terminology • The building blocks for successfully designing machine learning systems • Installing and setting up Python for data analysis and machine learning Building intelligent machines to transform data into knowledge In this age of modern technology, there is one resource that we have in abundance: a large amount of structured and unstructured data. In the second half of the 20th century, machine learning evolved as a subfield of artificial intelligence (AI ) involving self-learning algorithms that derive knowledge from data to make predictions. Giving Computers the Ability to Learn from Data 2 Instead of requiring humans to manually derive rules and build models from analyzing large amounts of data, machine learning offers a more efficient alternative for capturing the knowledge in data to gradually improve the performance of predictive models and make data-driven decisions. Not only is machine learning becoming increasingly important in computer science research, but it is also playing an ever-greater role in our everyday lives. Thanks to machine learning, we enjoy ro - bust email spam filters, convenient text and voice recognition software, reliable web search engines, recommendations on entertaining movies to watch, mobile check deposits, estimated meal delivery times, and much more. Hopefully, soon, we will add safe and efficient self-driving cars to this list. Also, notable progress has been made in medical applications; for example, researchers demonstrated that deep learning models can detect skin cancer with near-human", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 22, "start_word": 7040, "end_word": 7440, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000023": {"text": "ever-greater role in our everyday lives. Thanks to machine learning, we enjoy ro - bust email spam filters, convenient text and voice recognition software, reliable web search engines, recommendations on entertaining movies to watch, mobile check deposits, estimated meal delivery times, and much more. Hopefully, soon, we will add safe and efficient self-driving cars to this list. Also, notable progress has been made in medical applications; for example, researchers demonstrated that deep learning models can detect skin cancer with near-human accuracy ( https://www.nature.com/ articles/nature21056 ). Another milestone was recently achieved by researchers at DeepMind, who used deep learning to predict 3D protein structures, outperforming physics-based approaches by a substantial margin ( https://deepmind.com/blog/article/alphafold-a-solution-to-a-50-year- old-grand-challenge-in-biology ). While accurate 3D protein structure prediction plays an essential role in biological and pharmaceutical research, there have been many other important applications of machine learning in healthcare recently. For instance, researchers designed systems for predicting the oxygen needs of COVID-19 patients up to four days in advance to help hospitals allocate resources for those in need ( https://ai.facebook.com/blog/new-ai-research-to-help-predict-covid-19- resource-needs-from-a-series-of-x-rays/ ). Another important topic of our day and age is climate change, which presents one of the biggest and most critical challenges. Today, many efforts are be - ing directed toward developing intelligent systems to combat it ( https://www.forbes.com/sites/ robtoews/2021/06/20/these-are-the-startups-applying-ai-to-tackle-climate-change ). One of the many approaches to tackling climate change is the emergent field of precision agriculture. Here, researchers aim to design computer vision-based machine learning systems to optimize resource deployment to minimize the use and waste of fertilizers. The three different types of machine learning In this section, we will take a look at the three types of machine learning: supervised learning, un- supervised learning, and reinforcement learning. We will learn about the fundamental differences between the three different learning types and, using conceptual examples, we will develop an un- derstanding of the practical problem domains where they can be applied: Chapter 1 3 Figure 1.1: The three different types of machine learning Making predictions about the future with supervised learning The main goal in supervised learning is to learn a model from labeled training data that allows us to make predictions about unseen or future data. Here, the term “supervised” refers to a set of training examples (data inputs) where the desired output signals (labels) are already known. Supervised learn- ing is then the process of modeling the relationship between the data inputs and the", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 23, "start_word": 7360, "end_word": 7760, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000024": {"text": "The three different types of machine learning Making predictions about the future with supervised learning The main goal in supervised learning is to learn a model from labeled training data that allows us to make predictions about unseen or future data. Here, the term “supervised” refers to a set of training examples (data inputs) where the desired output signals (labels) are already known. Supervised learn- ing is then the process of modeling the relationship between the data inputs and the labels. Thus, we can also think of supervised learning as “label learning.” Figure 1.2 summarizes a typical supervised learning workflow, where the labeled training data is passed to a machine learning algorithm for fitting a predictive model that can make predictions on new, unlabeled data inputs: Figure 1.2: Supervised learning process Giving Computers the Ability to Learn from Data 4 Considering the example of email spam filtering, we can train a model using a supervised machine learning algorithm on a corpus of labeled emails, which are correctly marked as spam or non-spam, to predict whether a new email belongs to either of the two categories. A supervised learning task with discrete class labels, such as in the previous email spam filtering example, is also called a clas - sification task. Another subcategory of supervised learning is regression, where the outcome signal is a continuous value. Classification for predicting class labels Classification is a subcategory of supervised learning where the goal is to predict the categorical class labels of new instances or data points based on past observations. Those class labels are discrete, un- ordered values that can be understood as the group memberships of the data points. The previously mentioned example of email spam detection represents a typical example of a binary classification task, where the machine learning algorithm learns a set of rules to distinguish between two possible classes: spam and non-spam emails. Figure 1.3 illustrates the concept of a binary classification task given 30 training examples; 15 training examples are labeled as class A and 15 training examples are labeled as class B. In this scenario, our dataset is two-dimensional, which means that each example has two values associated with it: x 1 and x2. Now, we can use a supervised machine learning algorithm to learn a rule—the decision boundary represented as a dashed line—that can separate those two classes and classify new data into each of those", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 24, "start_word": 7680, "end_word": 8080, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000025": {"text": "a binary classification task given 30 training examples; 15 training examples are labeled as class A and 15 training examples are labeled as class B. In this scenario, our dataset is two-dimensional, which means that each example has two values associated with it: x 1 and x2. Now, we can use a supervised machine learning algorithm to learn a rule—the decision boundary represented as a dashed line—that can separate those two classes and classify new data into each of those two categories given its x 1 and x 2 values: Figure 1.3: Classifying a new data point Chapter 1 5 However, the set of class labels does not have to be of a binary nature. The predictive model learned by a supervised learning algorithm can assign any class label that was presented in the training dataset to a new, unlabeled data point or instance. A typical example of a multiclass classification task is handwritten character recognition. We can collect a training dataset that consists of multiple handwritten examples of each letter in the alphabet. The letters (“A,” “B,” “C,” and so on) will represent the different unordered categories or class labels that we want to predict. Now, if a user provides a new handwritten character via an input device, our predictive model will be able to predict the correct letter in the alphabet with certain accuracy. How - ever, our machine learning system will be unable to correctly recognize any of the digits between 0 and 9, for example, if they were not part of the training dataset. Regression for predicting continuous outcomes We learned in the previous section that the task of classification is to assign categorical, unordered labels to instances. A second type of supervised learning is the prediction of continuous outcomes, which is also called regression analysis. In regression analysis, we are given a number of predictor (explanatory ) variables and a continuous response variable (outcome), and we try to find a relationship between those variables that allows us to predict an outcome. Note that in the field of machine learning, the predictor variables are commonly called “features,” and the response variables are usually referred to as “target variables.” We will adopt these conventions throughout this book. For example, let’s assume that we are interested in predicting the math SAT scores of students. (The SAT is a standardized test frequently used for college admissions in the United", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 25, "start_word": 8000, "end_word": 8400, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000026": {"text": "we try to find a relationship between those variables that allows us to predict an outcome. Note that in the field of machine learning, the predictor variables are commonly called “features,” and the response variables are usually referred to as “target variables.” We will adopt these conventions throughout this book. For example, let’s assume that we are interested in predicting the math SAT scores of students. (The SAT is a standardized test frequently used for college admissions in the United States.) If there is a relationship between the time spent studying for the test and the final scores, we could use it as train- ing data to learn a model that uses the study time to predict the test scores of future students who are planning to take this test. Figure 1.4 illustrates the concept of linear regression. Given a feature variable, x, and a target variable, y, we fit a straight line to this data that minimizes the distance—most commonly the average squared distance—between the data points and the fitted line. Regression toward the mean The term “regression” was devised by Francis Galton in his article Regression towards Mediocrity in Hereditary Stature in 1886. Galton described the biological phenomenon that the variance of height in a population does not increase over time. He observed that the height of parents is not passed on to their children, but instead, their children’s height regresses toward the population mean. Giving Computers the Ability to Learn from Data 6 We can now use the intercept and slope learned from this data to predict the target variable of new data: Figure 1.4: A linear regression example Solving interactive problems with reinforcement learning Another type of machine learning is reinforcement learning. In reinforcement learning, the goal is to develop a system (agent ) that improves its performance based on interactions with the environment. Since the information about the current state of the environment typically also includes a so-called reward signal, we can think of reinforcement learning as a field related to supervised learning. How - ever, in reinforcement learning, this feedback is not the correct ground truth label or value, but a measure of how well the action was measured by a reward function. Through its interaction with the environment, an agent can then use reinforcement learning to learn a series of actions that maximizes this reward via an exploratory trial-and-error approach or deliberative planning.", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 26, "start_word": 8320, "end_word": 8720, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000027": {"text": "includes a so-called reward signal, we can think of reinforcement learning as a field related to supervised learning. How - ever, in reinforcement learning, this feedback is not the correct ground truth label or value, but a measure of how well the action was measured by a reward function. Through its interaction with the environment, an agent can then use reinforcement learning to learn a series of actions that maximizes this reward via an exploratory trial-and-error approach or deliberative planning. A popular example of reinforcement learning is a chess program. Here, the agent decides upon a se - ries of moves depending on the state of the board (the environment), and the reward can be defined as win or lose at the end of the game: Chapter 1 7 Figure 1.5: Reinforcement learning process There are many different subtypes of reinforcement learning. However, a general scheme is that the agent in reinforcement learning tries to maximize the reward through a series of interactions with the environment. Each state can be associated with a positive or negative reward, and a reward can be defined as accomplishing an overall goal, such as winning or losing a game of chess. For instance, in chess, the outcome of each move can be thought of as a different state of the environment. To explore the chess example further, let’s think of visiting certain configurations on the chessboard as being associated with states that will more likely lead to winning—for instance, removing an oppo - nent’s chess piece from the board or threatening the queen. Other positions, however, are associated with states that will more likely result in losing the game, such as losing a chess piece to the opponent in the following turn. Now, in the game of chess, the reward (either positive for winning or negative for losing the game) will not be given until the end of the game. In addition, the final reward will also depend on how the opponent plays. For example, the opponent may sacrifice the queen but eventually win the game. In sum, reinforcement learning is concerned with learning to choose a series of actions that maxi- mizes the total reward, which could be earned either immediately after taking an action or via delayed feedback. Discovering hidden structures with unsupervised learning In supervised learning, we know the right answer (the label or target variable) beforehand when we train a", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 27, "start_word": 8640, "end_word": 9040, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000028": {"text": "reward will also depend on how the opponent plays. For example, the opponent may sacrifice the queen but eventually win the game. In sum, reinforcement learning is concerned with learning to choose a series of actions that maxi- mizes the total reward, which could be earned either immediately after taking an action or via delayed feedback. Discovering hidden structures with unsupervised learning In supervised learning, we know the right answer (the label or target variable) beforehand when we train a model, and in reinforcement learning, we define a measure of reward for particular actions carried out by the agent. In unsupervised learning, however, we are dealing with unlabeled data or data of an unknown structure. Using unsupervised learning techniques, we are able to explore the structure of our data to extract meaningful information without the guidance of a known outcome variable or reward function. Giving Computers the Ability to Learn from Data 8 Finding subgroups with clustering Clustering is an exploratory data analysis or pattern discovery technique that allows us to organize a pile of information into meaningful subgroups (clusters) without having any prior knowledge of their group memberships. Each cluster that arises during the analysis defines a group of objects that share a certain degree of similarity but are more dissimilar to objects in other clusters, which is why clustering is also sometimes called unsupervised classification. Clustering is a great technique for structuring information and deriving meaningful relationships from data. For example, it allows marketers to discover customer groups based on their interests, in order to develop distinct marketing programs. Figure 1.6 illustrates how clustering can be applied to organizing unlabeled data into three distinct groups or clusters (A, B, and C, in arbitrary order) based on the similarity of their features, x 1 and x 2: Figure 1.6: How clustering works Dimensionality reduction for data compression Another subfield of unsupervised learning is dimensionality reduction. Often, we are working with data of high dimensionality—each observation comes with a high number of measurements—that can present a challenge for limited storage space and the computational performance of machine learning algorithms. Unsupervised dimensionality reduction is a commonly used approach in feature preprocessing to remove noise from data, which can degrade the predictive performance of certain algorithms. Dimensionality reduction compresses the data onto a smaller dimensional subspace while retaining most of the relevant information. Chapter 1 9 Sometimes, dimensionality reduction can also be", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 28, "start_word": 8960, "end_word": 9360, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000029": {"text": "with data of high dimensionality—each observation comes with a high number of measurements—that can present a challenge for limited storage space and the computational performance of machine learning algorithms. Unsupervised dimensionality reduction is a commonly used approach in feature preprocessing to remove noise from data, which can degrade the predictive performance of certain algorithms. Dimensionality reduction compresses the data onto a smaller dimensional subspace while retaining most of the relevant information. Chapter 1 9 Sometimes, dimensionality reduction can also be useful for visualizing data; for example, a high-dimen - sional feature set can be projected onto one-, two-, or three-dimensional feature spaces to visualize it via 2D or 3D scatterplots or histograms. Figure 1.7 shows an example where nonlinear dimensionality reduction was applied to compress a 3D Swiss roll onto a new 2D feature subspace: Figure 1.7: An example of dimensionality reduction from three to two dimensions Introduction to the basic terminology and notations Now that we have discussed the three broad categories of machine learning—supervised, unsuper - vised, and reinforcement learning—let’s have a look at the basic terminology that we will be using throughout this book. The following subsection covers the common terms we will be using when referring to different aspects of a dataset, as well as the mathematical notation to communicate more precisely and efficiently. As machine learning is a vast field and very interdisciplinary, you are guaranteed to encounter many different terms that refer to the same concepts sooner rather than later. The second subsection collects many of the most commonly used terms that are found in machine learning literature, which may be useful to you as a reference section when reading machine learning publications. Notation and conventions used in this book Figure 1.8 depicts an excerpt of the Iris dataset, which is a classic example in the field of machine learning (more information can be found at https://archive.ics.uci.edu/ml/datasets/iris ). The Iris dataset contains the measurements of 150 Iris flowers from three different species—Setosa, Versicolor, and Virginica. Giving Computers the Ability to Learn from Data 10 Here, each flower example represents one row in our dataset, and the flower measurements in cen- timeters are stored as columns, which we also call the features of the dataset: Figure 1.8: The Iris dataset To keep the notation and implementation simple yet efficient, we will make use of some of the basics of linear algebra. In the following chapters,", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 29, "start_word": 9280, "end_word": 9680, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000030": {"text": "of 150 Iris flowers from three different species—Setosa, Versicolor, and Virginica. Giving Computers the Ability to Learn from Data 10 Here, each flower example represents one row in our dataset, and the flower measurements in cen- timeters are stored as columns, which we also call the features of the dataset: Figure 1.8: The Iris dataset To keep the notation and implementation simple yet efficient, we will make use of some of the basics of linear algebra. In the following chapters, we will use a matrix notation to refer to our data. We will follow the common convention to represent each example as a separate row in a feature matrix, X, where each feature is stored as a separate column. The Iris dataset, consisting of 150 examples and four features, can then be written as a 150×4 matrix, formally denoted as 𝜲𝜲𝜲𝜲150×4 : [ 𝑥𝑥1(1)𝑥𝑥2(1)𝑥𝑥3(1)𝑥𝑥4(1) 𝑥𝑥1(2)𝑥𝑥2(2)𝑥𝑥3(2)𝑥𝑥4(2) ⋮⋮⋮⋮ 𝑥𝑥1(150)𝑥𝑥2(150)𝑥𝑥3(150)𝑥𝑥4(150)] Chapter 1 11 Machine learning terminology Machine learning is a vast field and also very interdisciplinary as it brings together many scientists from other areas of research. As it happens, many terms and concepts have been rediscovered or re - defined and may already be familiar to you but appear under different names. For your convenience, in the following list, you can find a selection of commonly used terms and their synonyms that you may find useful when reading this book and machine learning literature in general: • Training example: A row in a table representing the dataset and synonymous with an obser - vation, record, instance, or sample (in most contexts, sample refers to a collection of training examples). • Training: Model fitting, for parametric models similar to parameter estimation. Notational conventions For most parts of this book, unless noted otherwise, we will use the superscript i to refer to the ith training example, and the subscript j to refer to the jth dimension of the training dataset. We will use lowercase, bold-face letters to refer to vectors ( 𝒙𝒙𝒙𝒙𝒏𝒏𝒏𝒏𝒏 ) and uppercase, bold- face letters to refer to matrices ( 𝜲𝜲𝜲𝜲𝒏𝒏𝒏𝒏𝒏 ). To refer to single elements in a vector or matrix, we will write the letters in italics (x(n) or 𝑥𝑥𝑚𝑚(𝑛𝑛𝑛 , respectively). For example, 𝑥𝑥1(150) refers to the first dimension of flower example 150, the sepal length. Each row in matrix X represents one flower instance and can be written as a four-dimen- sional row vector, 𝒙𝒙(𝑖𝑖𝑖∈ℝ1×4 : 𝑿𝑿(𝑖𝑖𝑖=", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 30, "start_word": 9600, "end_word": 10000, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000031": {"text": "bold-face letters to refer to vectors ( 𝒙𝒙𝒙𝒙𝒏𝒏𝒏𝒏𝒏 ) and uppercase, bold- face letters to refer to matrices ( 𝜲𝜲𝜲𝜲𝒏𝒏𝒏𝒏𝒏 ). To refer to single elements in a vector or matrix, we will write the letters in italics (x(n) or 𝑥𝑥𝑚𝑚(𝑛𝑛𝑛 , respectively). For example, 𝑥𝑥1(150) refers to the first dimension of flower example 150, the sepal length. Each row in matrix X represents one flower instance and can be written as a four-dimen- sional row vector, 𝒙𝒙(𝑖𝑖𝑖∈ℝ1×4 : 𝑿𝑿(𝑖𝑖𝑖= [𝑥𝑥1(𝑖𝑖𝑖 𝑥𝑥2(𝑖𝑖𝑖 𝑥𝑥3(𝑖𝑖𝑖 𝑥𝑥4(𝑖𝑖𝑖] And each feature dimension is a 150-dimensional column vector, 𝑿𝑿(𝑖𝑖𝑖∈ℝ150×1 . For ex - ample: 𝒙𝒙𝒋𝒋= [ 𝑥𝑥𝑗𝑗(1) 𝑥𝑥𝑗𝑗(2) ⋯ 𝑥𝑥𝑗𝑗(150)] Similarly, we can represent the target variables (here, class labels) as a 150-dimensional column vector: 𝒚𝒚𝒚𝒚𝑦𝑦(1) ⋯ 𝑦𝑦(150)], where 𝑦𝑦(𝑖𝑖)∈{Setosa, Versicolor, Virginica } Giving Computers the Ability to Learn from Data 12 • Feature, abbrev. x: A column in a data table or data (design) matrix. Synonymous with predictor, variable, input, attribute, or covariate. • Target, abbrev. y: Synonymous with outcome, output, response variable, dependent variable, (class) label, and ground truth. • Loss function: Often used synonymously with a cost function. Sometimes the loss function is also called an error function. In some literature, the term “loss” refers to the loss measured for a single data point, and the cost is a measurement that computes the loss (average or summed) over the entire dataset. A roadmap for building machine learning systems In previous sections, we discussed the basic concepts of machine learning and the three different types of learning. In this section, we will discuss the other important parts of a machine learning system accompanying the learning algorithm. Figure 1.9 shows a typical workflow for using machine learning in predictive modeling, which we will discuss in the following subsections: Figure 1.9: Predictive modeling workflow Chapter 1 13 Preprocessing – getting data into shape Let’s begin by discussing the roadmap for building machine learning systems. Raw data rarely comes in the form and shape that is necessary for the optimal performance of a learning algorithm. Thus, the preprocessing of the data is one of the most crucial steps in any machine learning application. If we take the Iris flower dataset from the previous section as an example, we can think of the raw data as a series of flower images from which we want to extract meaningful features. Useful features could be centered around the color", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 31, "start_word": 9920, "end_word": 10320, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000032": {"text": "data rarely comes in the form and shape that is necessary for the optimal performance of a learning algorithm. Thus, the preprocessing of the data is one of the most crucial steps in any machine learning application. If we take the Iris flower dataset from the previous section as an example, we can think of the raw data as a series of flower images from which we want to extract meaningful features. Useful features could be centered around the color of the flowers or the height, length, and width of the flowers. Many machine learning algorithms also require that the selected features are on the same scale for optimal performance, which is often achieved by transforming the features in the range [0, 1] or a standard normal distribution with zero mean and unit variance, as we will see in later chapters. Some of the selected features may be highly correlated and therefore redundant to a certain degree. In those cases, dimensionality reduction techniques are useful for compressing the features onto a lower-dimensional subspace. Reducing the dimensionality of our feature space has the advantage that less storage space is required, and the learning algorithm can run much faster. In certain cases, di- mensionality reduction can also improve the predictive performance of a model if the dataset contains a large number of irrelevant features (or noise); that is, if the dataset has a low signal-to-noise ratio. To determine whether our machine learning algorithm not only performs well on the training dataset but also generalizes well to new data, we also want to randomly divide the dataset into separate train- ing and test datasets. We use the training dataset to train and optimize our machine learning model, while we keep the test dataset until the very end to evaluate the final model. Training and selecting a predictive model As you will see in later chapters, many different machine learning algorithms have been developed to solve different problem tasks. An important point that can be summarized from David Wolpert’s famous No free lunch theorems is that we can’t get learning “for free” (The Lack of A Priori Distinctions Between Learning Algorithms, D.H. Wolpert, 1996; No free lunch theorems for optimization, D.H. Wolpert and W .G. Macready, 1997). We can relate this concept to the popular saying, I suppose it is tempting, if the only tool you have is a hammer, to treat everything as", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 32, "start_word": 10240, "end_word": 10640, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000033": {"text": "to solve different problem tasks. An important point that can be summarized from David Wolpert’s famous No free lunch theorems is that we can’t get learning “for free” (The Lack of A Priori Distinctions Between Learning Algorithms, D.H. Wolpert, 1996; No free lunch theorems for optimization, D.H. Wolpert and W .G. Macready, 1997). We can relate this concept to the popular saying, I suppose it is tempting, if the only tool you have is a hammer, to treat everything as if it were a nail (Abraham Maslow, 1966). For example, each classification algorithm has its inherent biases, and no single classification model en- joys superiority if we don’t make any assumptions about the task. In practice, it is therefore essential to compare at least a handful of different learning algorithms in order to train and select the best performing model. But before we can compare different models, we first have to decide upon a metric to measure performance. One commonly used metric is classification accuracy, which is defined as the proportion of correctly classified instances. One legitimate question to ask is this: how do we know which model performs well on the final test dataset and real-world data if we don’t use this test dataset for the model selection, but keep it for the final model evaluation? To address the issue embedded in this question, different techniques summa - rized as “cross-validation” can be used. In cross-validation, we further divide a dataset into training and validation subsets in order to estimate the generalization performance of the model. Giving Computers the Ability to Learn from Data 14 Finally, we also cannot expect that the default parameters of the different learning algorithms provided by software libraries are optimal for our specific problem task. Therefore, we will make frequent use of hyperparameter optimization techniques that help us to fine-tune the performance of our model in later chapters. We can think of those hyperparameters as parameters that are not learned from the data but represent the knobs of a model that we can turn to improve its performance. This will become much clearer in later chapters when we see actual examples. Evaluating models and predicting unseen data instances After we have selected a model that has been fitted on the training dataset, we can use the test dataset to estimate how well it performs on this unseen data to estimate the so-called generalization error.", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 33, "start_word": 10560, "end_word": 10960, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000034": {"text": "as parameters that are not learned from the data but represent the knobs of a model that we can turn to improve its performance. This will become much clearer in later chapters when we see actual examples. Evaluating models and predicting unseen data instances After we have selected a model that has been fitted on the training dataset, we can use the test dataset to estimate how well it performs on this unseen data to estimate the so-called generalization error. If we are satisfied with its performance, we can now use this model to predict new, future data. It is im- portant to note that the parameters for the previously mentioned procedures, such as feature scaling and dimensionality reduction, are solely obtained from the training dataset, and the same parameters are later reapplied to transform the test dataset, as well as any new data instances—the performance measured on the test data may be overly optimistic otherwise. Using Python for machine learning Python is one of the most popular programming languages for data science, and thanks to its very active developer and open-source community, a large number of useful libraries for scientific com- puting and machine learning have been developed. Although the performance of interpreted languages, such as Python, for computation-intensive tasks is inferior to lower-level programming languages, extension libraries such as NumPy and SciPy have been developed that build upon lower-layer Fortran and C implementations for fast vectorized oper - ations on multidimensional arrays. For machine learning programming tasks, we will mostly refer to the scikit-learn library, which is currently one of the most popular and accessible open-source machine learning libraries. In the later chapters, when we focus on a subfield of machine learning called deep learning, we will use the latest version of the PyTorch library, which specializes in training so-called deep neural network models very efficiently by utilizing graphics cards. Installing Python and packages from the Python Package Index Python is available for all three major operating systems—Microsoft Windows, macOS, and Linux— and the installer, as well as the documentation, can be downloaded from the official Python website: https://www.python.org . The code examples provided in this book have been written for and tested in Python 3.9, and we generally recommend that you use the most recent version of Python 3 that is available. Some of the code may also be compatible with Python 2.7, but as the official", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 34, "start_word": 10880, "end_word": 11280, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000035": {"text": "Index Python is available for all three major operating systems—Microsoft Windows, macOS, and Linux— and the installer, as well as the documentation, can be downloaded from the official Python website: https://www.python.org . The code examples provided in this book have been written for and tested in Python 3.9, and we generally recommend that you use the most recent version of Python 3 that is available. Some of the code may also be compatible with Python 2.7, but as the official support for Python 2.7 ended in 2019, and the majority of open-source libraries have already stopped supporting Python 2.7 ( https:// python3statement.org ), we strongly advise that you use Python 3.9 or newer. Chapter 1 15 You can check your Python version by executing python --version or python3 --version in your terminal (or PowerShell if you are using Windows). The additional packages that we will be using throughout this book can be installed via the pip installer program, which has been part of the Python Standard Library since Python 3.3. More information about pip can be found at https://docs.python.org/3/installing/index.html . After we have successfully installed Python, we can execute pip from the terminal to install additional Python packages: pip install SomePackage Already installed packages can be updated via the --upgrade flag: pip install SomePackage --upgrade Using the Anaconda Python distribution and package manager A highly recommended open-source package management system for installing Python for scientific computing contexts is conda by Continuum Analytics. Conda is free and licensed under a permissive open-source license. Its goal is to help with the installation and version management of Python pack - ages for data science, math, and engineering across different operating systems. If you want to use conda, it comes in different flavors, namely Anaconda, Miniconda, and Miniforge: • Anaconda comes with many scientific computing packages pre-installed. The Anaconda in - staller can be downloaded at https://docs.anaconda.com/anaconda/install/ , and an An- aconda quick start guide is available at https://docs.anaconda.com/anaconda/user-guide/ getting-started/ . • Miniconda is a leaner alternative to Anaconda ( https://docs.conda.io/en/latest/miniconda. html ). Essentially, it is similar to Anaconda but without any packages pre-installed, which many people (including the authors) prefer. • Miniforge is similar to Miniconda but community-maintained and uses a different package repository (conda-forge) from Miniconda and Anaconda. We found that Miniforge is a great alternative to Miniconda. Download and installation instructions can be found in the GitHub repository at https://github.com/conda-forge/miniforge .", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 35, "start_word": 11200, "end_word": 11600, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000036": {"text": "guide is available at https://docs.anaconda.com/anaconda/user-guide/ getting-started/ . • Miniconda is a leaner alternative to Anaconda ( https://docs.conda.io/en/latest/miniconda. html ). Essentially, it is similar to Anaconda but without any packages pre-installed, which many people (including the authors) prefer. • Miniforge is similar to Miniconda but community-maintained and uses a different package repository (conda-forge) from Miniconda and Anaconda. We found that Miniforge is a great alternative to Miniconda. Download and installation instructions can be found in the GitHub repository at https://github.com/conda-forge/miniforge . After successfully installing conda through either Anaconda, Miniconda, or Miniforge, we can install new Python packages using the following command: conda install SomePackage Giving Computers the Ability to Learn from Data 16 Existing packages can be updated using the following command: conda update SomePackage Packages that are not available through the official conda channel might be available via the com- munity-supported conda-forge project ( https://conda-forge.org ), which can be specified via the --channel conda-forge flag. For example: conda install SomePackage --channel conda-forge Packages that are not available through the default conda channel or conda-forge can be installed via pip as explained earlier. For example: pip install SomePackage Packages for scientific computing, data science, and machine learning Throughout the first half of this book, we will mainly use NumPy’s multidimensional arrays to store and manipulate data. Occasionally, we will make use of pandas, which is a library built on top of NumPy that provides additional higher-level data manipulation tools that make working with tabular data even more convenient. To augment your learning experience and visualize quantitative data, which is often extremely useful to make sense of it, we will use the very customizable Matplotlib library. The main machine learning library used in this book is scikit-learn (Chapters 3 to 11). Chapter 12, Paral - lelizing Neural Network Training with PyTorch, will then introduce the PyTorch library for deep learning. The version numbers of the major Python packages that were used to write this book are mentioned in the following list. Please make sure that the version numbers of your installed packages are, ideally, equal to these version numbers to ensure that the code examples run correctly: • NumPy 1.21.2 • SciPy 1.7.0 • Scikit-learn 1.0 • Matplotlib 3.4.3 • pandas 1.3.2 After installing these packages, you can double-check the installed version by importing the package in Python and accessing its __version__ attribute, for example: >>> import numpy >>> numpy.__version__ '1.21.2' For", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 36, "start_word": 11520, "end_word": 11920, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000037": {"text": "write this book are mentioned in the following list. Please make sure that the version numbers of your installed packages are, ideally, equal to these version numbers to ensure that the code examples run correctly: • NumPy 1.21.2 • SciPy 1.7.0 • Scikit-learn 1.0 • Matplotlib 3.4.3 • pandas 1.3.2 After installing these packages, you can double-check the installed version by importing the package in Python and accessing its __version__ attribute, for example: >>> import numpy >>> numpy.__version__ '1.21.2' For your convenience, we included a python-environment-check.py script in this book’s compli - mentary code repository at https://github.com/rasbt/machine-learning-book so that you can check both your Python version and the package versions by executing this script. Chapter 1 17 Certain chapters will require additional packages and will provide information about the installations. For instance, do not worry about installing PyTorch at this point. Chapter 12 will provide tips and instructions when you need them. If you encounter errors even though your code matches the code in the chapter exactly, we recom- mend you first check the version numbers of the underlying packages before spending more time on debugging or reaching out to the publisher or authors. Sometimes, newer versions of libraries introduce backward-incompatible changes that could explain these errors. If you do not want to change the package version in your main Python installation, we recommend using a virtual environment for installing the packages used in this book. If you use Python without the conda manager, you can use the venv library to create a new virtual environment. For example, you can create and activate the virtual environment via the following two commands: python3 -m venv /Users/sebastian/Desktop/pyml-book source /Users/sebastian/Desktop/pyml-book/bin/activate Note that you need to activate the virtual environment every time you open a new terminal or Power - Shell. You can find more information about venv at https://docs.python.org/3/library/venv.html . If you are using Anaconda with the conda package manager, you can create and activate a virtual environment as follows: conda create -n pyml python=3.9 conda activate pyml Summary In this chapter, we explored machine learning at a very high level and familiarized ourselves with the big picture and major concepts that we are going to explore in the following chapters in more detail. We learned that supervised learning is composed of two important subfields: classification and regression. While classification models allow us to categorize objects into known classes, we can use regression", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 37, "start_word": 11840, "end_word": 12240, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000038": {"text": "and activate a virtual environment as follows: conda create -n pyml python=3.9 conda activate pyml Summary In this chapter, we explored machine learning at a very high level and familiarized ourselves with the big picture and major concepts that we are going to explore in the following chapters in more detail. We learned that supervised learning is composed of two important subfields: classification and regression. While classification models allow us to categorize objects into known classes, we can use regression analysis to predict the continuous outcomes of target variables. Unsupervised learning not only offers useful techniques for discovering structures in unlabeled data, but it can also be useful for data compression in feature preprocessing steps. We briefly went over the typical roadmap for applying machine learning to problem tasks, which we will use as a foundation for deeper discussions and hands-on examples in the following chapters. Finally, we set up our Python environment and installed and updated the required packages to get ready to see machine learning in action. Later in this book, in addition to machine learning itself, we will introduce different techniques to preprocess a dataset, which will help you to get the best performance out of different machine learning algorithms. While we will cover classification algorithms quite extensively throughout the book, we will also explore different techniques for regression analysis and clustering. Giving Computers the Ability to Learn from Data 18 We have an exciting journey ahead, covering many powerful techniques in the vast field of machine learning. However, we will approach machine learning one step at a time, building upon our knowledge gradually throughout the chapters of this book. In the following chapter, we will start this journey by implementing one of the earliest machine learning algorithms for classification, which will prepare us for Chapter 3, A Tour of Machine Learning Classifiers Using Scikit-Learn, where we will cover more advanced machine learning algorithms using the scikit-learn open-source machine learning library. Join our book’s Discord space Join the book’s Discord workspace for a monthly Ask me Anything session with the authors: https://packt.link/MLwPyTorch 2 Training Simple Machine Learning Algorithms for Classification In this chapter, we will make use of two of the first algorithmically described machine learning algo - rithms for classification: the perceptron and adaptive linear neurons. We will start by implementing a perceptron step by step in Python and training it to classify different flower species", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 38, "start_word": 12160, "end_word": 12560, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000039": {"text": "open-source machine learning library. Join our book’s Discord space Join the book’s Discord workspace for a monthly Ask me Anything session with the authors: https://packt.link/MLwPyTorch 2 Training Simple Machine Learning Algorithms for Classification In this chapter, we will make use of two of the first algorithmically described machine learning algo - rithms for classification: the perceptron and adaptive linear neurons. We will start by implementing a perceptron step by step in Python and training it to classify different flower species in the Iris dataset. This will help us to understand the concept of machine learning algorithms for classification and how they can be efficiently implemented in Python. Discussing the basics of optimization using adaptive linear neurons will then lay the groundwork for using more sophisticated classifiers via the scikit-learn machine learning library in Chapter 3, A Tour of Machine Learning Classifiers Using Scikit-Learn. The topics that we will cover in this chapter are as follows: • Building an understanding of machine learning algorithms • Using pandas, NumPy, and Matplotlib to read in, process, and visualize data • Implementing linear classifiers for 2-class problems in Python Artificial neurons – a brief glimpse into the early history of machine learning Before we discuss the perceptron and related algorithms in more detail, let’s take a brief tour of the beginnings of machine learning. Trying to understand how the biological brain works in order to de - sign an artificial intelligence (AI ), Warren McCulloch and Walter Pitts published the first concept of a simplified brain cell, the so-called McCulloch-Pitts (MCP ) neuron, in 1943 (A Logical Calculus of the Ideas Immanent in Nervous Activity by W. S. McCulloch and W. Pitts, Bulletin of Mathematical Biophysics, 5(4): 115-133, 1943). Training Simple Machine Learning Algorithms for Classification 20 Biological neurons are interconnected nerve cells in the brain that are involved in the processing and transmitting of chemical and electrical signals, which is illustrated in Figure 2.1: Figure 2.1: A neuron processing chemical and electrical signals McCulloch and Pitts described such a nerve cell as a simple logic gate with binary outputs; multiple signals arrive at the dendrites, they are then integrated into the cell body, and, if the accumulated signal exceeds a certain threshold, an output signal is generated that will be passed on by the axon. Only a few years later, Frank Rosenblatt published the first concept of the perceptron learning rule based on", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 39, "start_word": 12480, "end_word": 12880, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000040": {"text": "2.1: Figure 2.1: A neuron processing chemical and electrical signals McCulloch and Pitts described such a nerve cell as a simple logic gate with binary outputs; multiple signals arrive at the dendrites, they are then integrated into the cell body, and, if the accumulated signal exceeds a certain threshold, an output signal is generated that will be passed on by the axon. Only a few years later, Frank Rosenblatt published the first concept of the perceptron learning rule based on the MCP neuron model (The Perceptron: A Perceiving and Recognizing Automaton by F. Rosenblatt, Cornell Aeronautical Laboratory, 1957). With his perceptron rule, Rosenblatt proposed an algorithm that would automatically learn the optimal weight coefficients that would then be multiplied with the input features in order to make the decision of whether a neuron fires (transmits a signal) or not. In the context of supervised learning and classification, such an algorithm could then be used to predict whether a new data point belongs to one class or the other. The formal definition of an artificial neuron More formally, we can put the idea behind artificial neurons into the context of a binary classifica - tion task with two classes: 0 and 1. We can then define a decision function, 𝜎𝜎𝜎𝜎𝜎𝜎 , that takes a linear combination of certain input values, x, and a corresponding weight vector, w, where z is the so-called net input z = w 1x1 + w 2x2 + ... + w mxm: 𝒘𝒘𝒘𝒘𝑤𝑤1 ⋮ 𝑤𝑤𝑚𝑚] , 𝒙𝒙 𝒘 𝒘𝑥𝑥1 ⋮ 𝑥𝑥𝑚𝑚] Now, if the net input of a particular example, x(i), is greater than a defined threshold, 𝜃𝜃 , we predict class 1, and class 0 otherwise. In the perceptron algorithm, the decision function, 𝜎𝜎(∙) , is a variant of a unit step function: 𝜎𝜎𝜎𝜎𝜎𝜎 𝜎 𝜎1if 𝜎𝜎𝑧𝑧𝑧 0 otherwise Chapter 2 21 To simplify the code implementation later, we can modify this setup via a couple of steps. First, we move the threshold, 𝜃𝜃 , to the left side of the equation: 𝑧𝑧𝑧𝑧𝑧 𝑧𝑧𝑧𝑧𝑧𝑧𝑧 Second, we define a so-called bias unit as 𝑏𝑏 𝑏 𝑏𝑏𝑏 and make it part of the net input: z = w 1x1 + ... + w mxm + b = wTx + b Third, given the introduction of the bias unit and the redefinition of the net input z above, we can redefine the decision function as follows: 𝜎𝜎𝜎𝜎𝜎𝜎 𝜎 𝜎1if", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 40, "start_word": 12800, "end_word": 13200, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000041": {"text": "of steps. First, we move the threshold, 𝜃𝜃 , to the left side of the equation: 𝑧𝑧𝑧𝑧𝑧 𝑧𝑧𝑧𝑧𝑧𝑧𝑧 Second, we define a so-called bias unit as 𝑏𝑏 𝑏 𝑏𝑏𝑏 and make it part of the net input: z = w 1x1 + ... + w mxm + b = wTx + b Third, given the introduction of the bias unit and the redefinition of the net input z above, we can redefine the decision function as follows: 𝜎𝜎𝜎𝜎𝜎𝜎 𝜎 𝜎1if 𝜎𝜎𝑧𝑧 𝑧otherwise Linear algebra basics: dot product and matrix transpose In the following sections, we will often make use of basic notations from linear algebra. For example, we will abbreviate the sum of the products of the values in x and w using a vector dot product, whereas the superscript T stands for transpose, which is an operation that transforms a column vector into a row vector and vice versa. For example, assume we have the following two column vectors: 𝒂𝒂𝒂 𝒂𝒂𝒂𝑎𝑎1 𝑎𝑎2 𝑎𝑎3],𝒂𝒂𝒂𝒂𝒃𝒃𝒂 𝒂𝒂𝒂𝑏𝑏1 𝑏𝑏2 𝑏𝑏3] Then, we can write the transpose of vector a as aT = [a 1 a2 a3] and write the dot product as 𝒂𝒂𝑇𝑇𝒃𝒃𝒃 𝒃𝒃𝒃𝒃𝒃 𝑖𝑖𝑏𝑏𝑖𝑖𝒃𝒃𝒃𝒃1∙𝑏𝑏1+𝒃𝒃𝒃2∙𝑏𝑏2+𝒃𝒃𝒃3∙𝑏𝑏3 𝑖𝑖 Furthermore, the transpose operation can also be applied to matrices to reflect it over its diagonal, for example: [12 34 56]𝑇𝑇 =[135 246] Please note that the transpose operation is strictly only defined for matrices; however, in the context of machine learning, we refer to n × 1 or 1 × m matrices when we use the term “vector.” In this book, we will only use very basic concepts from linear algebra; however, if you need a quick refresher, please take a look at Zico Kolter’s excellent Linear Algebra Review and Reference, which is freely available at http://www.cs.cmu.edu/~zkolter/course/ linalg/linalg_notes.pdf . Training Simple Machine Learning Algorithms for Classification 22 Figure 2.2 illustrates how the net input z = wTx + b is squashed into a binary output (0 or 1) by the decision function of the perceptron (left subfigure) and how it can be used to discriminate between two classes separable by a linear decision boundary (right subfigure): Figure 2.2: A threshold function producing a linear decision boundary for a binary classification problem The perceptron learning rule The whole idea behind the MCP neuron and Rosenblatt’s thresholded perceptron model is to use a re - ductionist approach to mimic how a single neuron in the brain works: it", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 41, "start_word": 13120, "end_word": 13520, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000042": {"text": "or 1) by the decision function of the perceptron (left subfigure) and how it can be used to discriminate between two classes separable by a linear decision boundary (right subfigure): Figure 2.2: A threshold function producing a linear decision boundary for a binary classification problem The perceptron learning rule The whole idea behind the MCP neuron and Rosenblatt’s thresholded perceptron model is to use a re - ductionist approach to mimic how a single neuron in the brain works: it either fires or it doesn’t. Thus, Rosenblatt’s classic perceptron rule is fairly simple, and the perceptron algorithm can be summarized by the following steps: 1. Initialize the weights and bias unit to 0 or small random numbers 2. For each training example, x(i): a. Compute the output value, 𝑦𝑦𝑦(𝑖𝑖𝑖 b. Update the weights and bias unit Here, the output value is the class label predicted by the unit step function that we defined earlier, and the simultaneous update of the bias unit and each weight, wj, in the weight vector, w, can be more formally written as: 𝑤𝑤 𝑗𝑗≔𝑤𝑤 𝑗𝑗+ ∆𝑤𝑤 𝑗𝑗 and 𝑏𝑏 𝑏𝑏 𝑏𝑏+ ∆𝑏𝑏 The update values (“deltas”) are computed as follows: ∆𝑤𝑤 𝑗𝑗= 𝜂𝜂𝜂𝜂𝜂(𝑖𝑖)−𝜂𝜂𝑦(𝑖𝑖))𝑥𝑥𝑗𝑗(𝑖𝑖) and ∆𝑏𝑏= 𝜂𝜂𝜂𝜂𝜂(𝑖𝑖)−𝜂𝜂𝑦(𝑖𝑖)) Chapter 2 23 Note that unlike the bias unit, each weight, w j, corresponds to a feature, x j, in the dataset, which is involved in determining the update value, Δ𝑤𝑤𝑗𝑗 , defined above. Furthermore, 𝜂𝜂 is the learning rate (typically a constant between 0.0 and 1.0), y(i) is the true class label of the ith training example, and 𝑦𝑦𝑦(𝑖𝑖) is the predicted class label. It is important to note that the bias unit and all weights in the weight vector are being updated simultaneously, which means that we don’t recompute the predicted label, 𝑦𝑦𝑦(𝑖𝑖) , before the bias unit and all of the weights are updated via the respective update values, Δ𝑤𝑤𝑗𝑗 and Δ𝑏𝑏 . Concretely, for a two-dimensional dataset, we would write the update as: ∆𝑤𝑤 1=𝜂𝜂 (𝑦𝑦(𝑖𝑖𝑖− output(𝑖𝑖𝑖𝑖𝑥𝑥1(𝑖𝑖𝑖; ∆𝑤𝑤 2=𝜂𝜂 (𝑦𝑦(𝑖𝑖𝑖− output(𝑖𝑖𝑖𝑖𝑥𝑥2(𝑖𝑖𝑖; ∆𝑏𝑏 = 𝜂𝜂 (𝑦𝑦(𝑖𝑖𝑖− output(𝑖𝑖𝑖𝑖 Before we implement the perceptron rule in Python, let’s go through a simple thought experiment to illustrate how beautifully simple this learning rule really is. In the two scenarios where the percep - tron predicts the class label correctly, the bias unit and weights remain unchanged, since the update values are 0: (1) 𝑦𝑦(𝑖𝑖)= 0, 𝑦𝑦 𝑦(𝑖𝑖)= 0, ∆𝑤𝑤", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 42, "start_word": 13440, "end_word": 13840, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000043": {"text": "two-dimensional dataset, we would write the update as: ∆𝑤𝑤 1=𝜂𝜂 (𝑦𝑦(𝑖𝑖𝑖− output(𝑖𝑖𝑖𝑖𝑥𝑥1(𝑖𝑖𝑖; ∆𝑤𝑤 2=𝜂𝜂 (𝑦𝑦(𝑖𝑖𝑖− output(𝑖𝑖𝑖𝑖𝑥𝑥2(𝑖𝑖𝑖; ∆𝑏𝑏 = 𝜂𝜂 (𝑦𝑦(𝑖𝑖𝑖− output(𝑖𝑖𝑖𝑖 Before we implement the perceptron rule in Python, let’s go through a simple thought experiment to illustrate how beautifully simple this learning rule really is. In the two scenarios where the percep - tron predicts the class label correctly, the bias unit and weights remain unchanged, since the update values are 0: (1) 𝑦𝑦(𝑖𝑖)= 0, 𝑦𝑦 𝑦(𝑖𝑖)= 0, ∆𝑤𝑤 𝑗𝑗=𝜂𝜂(0−0 )𝑥𝑥𝑗𝑗(𝑖𝑖)= 0, ∆𝑏𝑏 = 𝜂𝜂(0−0 )=0 (2) 𝑦𝑦(𝑖𝑖)= 1, 𝑦𝑦 𝑦(𝑖𝑖)= 1, ∆𝑤𝑤 𝑗𝑗=𝜂𝜂(1−1 )𝑥𝑥𝑗𝑗(𝑖𝑖)= 0, ∆𝑏𝑏 = 𝜂𝜂(1−1 )=0 However, in the case of a wrong prediction, the weights are being pushed toward the direction of the positive or negative target class: (3) 𝑦𝑦(𝑖𝑖)= 1, 𝑦𝑦 𝑦(𝑖𝑖)= 0, ∆𝑤𝑤 𝑗𝑗=𝜂𝜂(1−0 )𝑥𝑥𝑗𝑗(𝑖𝑖)= 𝜂𝜂𝑥𝑥𝑗𝑗(𝑖𝑖), ∆𝑏𝑏 = 𝜂𝜂(1−0 )=𝜂𝜂 (4) 𝑦𝑦(𝑖𝑖)= 0, 𝑦𝑦 𝑦(𝑖𝑖)= 1, ∆𝑤𝑤 𝑗𝑗=𝜂𝜂(0−1 )𝑥𝑥𝑗𝑗(𝑖𝑖)= −𝜂𝜂 𝑥𝑥𝑗𝑗(𝑖𝑖), ∆𝑏𝑏 = 𝜂𝜂(0−1 )= −𝜂𝜂 To get a better understanding of the feature value as a multiplicative factor, 𝑥𝑥𝑗𝑗(𝑖𝑖) , let’s go through an- other simple example, where: 𝑦𝑦𝑦(𝑖𝑖)= 1, 𝑦𝑦(𝑖𝑖)= 0, 𝜂𝜂 = 1 Let’s assume that 𝑥𝑥𝑗𝑗(𝑖𝑖)= 1.5 and we misclassify this example as class 0. In this case, we would increase the corresponding weight by 2.5 in total so that the net input, 𝑧𝑧𝑧𝑧𝑧𝑗𝑗(𝑖𝑖)×𝑤𝑤𝑗𝑗+𝑏𝑏 , would be more positive the next time we encounter this example, and thus be more likely to be above the threshold of the unit step function to classify the example as class 1: ∆𝑤𝑤 𝑗𝑗=(1−0 )1.5 = 1.5, ∆𝑏𝑏 =(1−0 )=1 The weight update, ∆𝑤𝑤𝑗𝑗 , is proportional to the value of 𝑥𝑥𝑗𝑗(𝑖𝑖) . For instance, if we have another example, 𝑥𝑥𝑗𝑗(𝑖𝑖)=2 , that is incorrectly classified as class 0, we will push the decision boundary by an even larger extent to classify this example correctly the next time: ∆𝑤𝑤 𝑗𝑗=(1−0 )2 = 2, ∆𝑏𝑏 =(1−0 )=1 Training Simple Machine Learning Algorithms for Classification 24 It is important to note that the convergence of the perceptron is only guaranteed if the two classes are linearly separable, which means that the two classes cannot be perfectly separated by a linear decision boundary. (Interested readers can find the convergence proof in my lecture notes: https:// sebastianraschka.com/pdf/lecture-notes/stat453ss21/L03_perceptron_slides.pdf ). Figure 2.3 shows visual examples of linearly separable and linearly inseparable scenarios: Figure 2.3: Examples of linearly and nonlinearly separable classes If the two classes can’t be separated", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 43, "start_word": 13760, "end_word": 14160, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000044": {"text": "Classification 24 It is important to note that the convergence of the perceptron is only guaranteed if the two classes are linearly separable, which means that the two classes cannot be perfectly separated by a linear decision boundary. (Interested readers can find the convergence proof in my lecture notes: https:// sebastianraschka.com/pdf/lecture-notes/stat453ss21/L03_perceptron_slides.pdf ). Figure 2.3 shows visual examples of linearly separable and linearly inseparable scenarios: Figure 2.3: Examples of linearly and nonlinearly separable classes If the two classes can’t be separated by a linear decision boundary, we can set a maximum number of passes over the training dataset (epochs ) and/or a threshold for the number of tolerated misclas- sifications—the perceptron would never stop updating the weights otherwise. Later in this chapter, we will cover the Adaline algorithm that produces linear decision boundaries and converges even if the classes are not perfectly linearly separable. In Chapter 3, we will learn about algorithms that can produce nonlinear decision boundaries. Now, before we jump into the implementation in the next section, what you just learned can be sum- marized in a simple diagram that illustrates the general concept of the perceptron:Downloading the example code If you bought this book directly from Packt, you can download the example code files from your account at http://www.packtpub.com . If you purchased this book elsewhere, you can download all code examples and datasets directly from https://github.com/ rasbt/machine-learning-book . Chapter 2 25 Figure 2.4: Weights and bias of the model are updated based on the error function The preceding diagram illustrates how the perceptron receives the inputs of an example (x) and com- bines them with the bias unit (b ) and weights (w ) to compute the net input. The net input is then passed on to the threshold function, which generates a binary output of 0 or 1—the predicted class label of the example. During the learning phase, this output is used to calculate the error of the prediction and update the weights and bias unit. Implementing a perceptron learning algorithm in Python In the previous section, we learned how Rosenblatt’s perceptron rule works; let’s now implement it in Python and apply it to the Iris dataset that we introduced in Chapter 1, Giving Computers the Ability to Learn from Data. An object-oriented perceptron API We will take an object-oriented approach to defining the perceptron interface as a Python class, which will allow us to initialize", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 44, "start_word": 14080, "end_word": 14480, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000045": {"text": "of the prediction and update the weights and bias unit. Implementing a perceptron learning algorithm in Python In the previous section, we learned how Rosenblatt’s perceptron rule works; let’s now implement it in Python and apply it to the Iris dataset that we introduced in Chapter 1, Giving Computers the Ability to Learn from Data. An object-oriented perceptron API We will take an object-oriented approach to defining the perceptron interface as a Python class, which will allow us to initialize new Perceptron objects that can learn from data via a fit method and make predictions via a separate predict method. As a convention, we append an underscore ( _) to attributes that are not created upon the initialization of the object, but we do this by calling the object’s other methods, for example, self.w_ . Training Simple Machine Learning Algorithms for Classification 26 The following is the implementation of a perceptron in Python: import numpy as np class Perceptron : \"\"\"Perceptron classifier. Parameters ------------ eta : float Learning rate (between 0.0 and 1.0) n_iter : int Passes over the training dataset. random_state : int Random number generator seed for random weight initialization. Attributes ----------- w_ : 1d-array Weights after fitting. b_ : Scalar Bias unit after fitting. errors_ : list Number of misclassifications (updates) in each epoch. \"\"\" def __init__(self, eta= 0.01, n_iter= 50, random_state= 1): self.eta = eta self.n_iter = n_iter self.random_state = random_stateAdditional resources for Python’s scientific computing stack If you are not yet familiar with Python’s scientific libraries or need a refresher, please see the following resources: • NumPy: https://sebastianraschka.com/blog/2020/numpy-intro.html • pandas : https://pandas.pydata.org/pandas-docs/stable/user_ guide/10min.html • Matplotlib: https://matplotlib.org/stable/tutorials/introductory/ usage.html Chapter 2 27 def fit(self, X, y): \"\"\"Fit training data. Parameters ---------- X : {array-like}, shape = [n_examples, n_features] Training vectors, where n_examples is the number of examples and n_features is the number of features. y : array-like, shape = [n_examples] Target values. Returns ------- self : object \"\"\" rgen = np.random.RandomState(self.random_state) self.w_ = rgen.normal(loc= 0.0, scale= 0.01, size=X.shape[ 1]) self.b_ = np.float_( 0.) self.errors_ = [] for _ in range (self.n_iter): errors = 0 for xi, target in zip(X, y): update = self.eta * (target - self.predict(xi)) self.w_ += update * xi self.b_ += update errors += int(update != 0.0) self.errors_.append(errors) return self def net_input (self, X): \"\"\"Calculate net input\"\"\" return np.dot(X, self.w_) + self.b_ def predict (self, X): \"\"\"Return class label after unit step\"\"\" return np.where(self.net_input(X)", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 45, "start_word": 14400, "end_word": 14800, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000046": {"text": "\"\"\" rgen = np.random.RandomState(self.random_state) self.w_ = rgen.normal(loc= 0.0, scale= 0.01, size=X.shape[ 1]) self.b_ = np.float_( 0.) self.errors_ = [] for _ in range (self.n_iter): errors = 0 for xi, target in zip(X, y): update = self.eta * (target - self.predict(xi)) self.w_ += update * xi self.b_ += update errors += int(update != 0.0) self.errors_.append(errors) return self def net_input (self, X): \"\"\"Calculate net input\"\"\" return np.dot(X, self.w_) + self.b_ def predict (self, X): \"\"\"Return class label after unit step\"\"\" return np.where(self.net_input(X) >= 0.0, 1, 0) Training Simple Machine Learning Algorithms for Classification 28 Using this perceptron implementation, we can now initialize new Perceptron objects with a given learning rate, eta (𝜂𝜂 ), and the number of epochs, n_iter (passes over the training dataset). Via the fit method, we initialize the bias self.b_ to an initial value 0 and the weights in self.w_ to a vector, ℝ𝑚𝑚 , where m stands for the number of dimensions (features) in the dataset. Notice that the initial weight vector contains small random numbers drawn from a normal distribution with a standard deviation of 0.01 via rgen.normal(loc=0.0, scale=0.01, size=1 + X.shape[1]) , where rgen is a NumPy random number generator that we seeded with a user-specified random seed so that we can reproduce previous results if desired. Technically, we could initialize the weights to zero (in fact, this is done in the original perceptron al- gorithm). However, if we did that, then the learning rate 𝜂𝜂 (eta) would have no effect on the decision boundary. If all the weights are initialized to zero, the learning rate parameter, eta, affects only the scale of the weight vector, not the direction. If you are familiar with trigonometry, consider a vector, v1 =[1 2 3], where the angle between v1 and a vector, v2 = 0.5 × v1, would be exactly zero, as demon- strated by the following code snippet: >>> v1 = np.array([ 1, 2, 3]) >>> v2 = 0.5 * v1 >>> np.arccos(v1.dot(v2) / (np.linalg.norm(v1) * ... np.linalg.norm(v2))) 0.0 Here, np.arccos is the trigonometric inverse cosine, and np.linalg.norm is a function that computes the length of a vector. (Our decision to draw the random numbers from a random normal distribu- tion—for example, instead of from a uniform distribution—and to use a standard deviation of 0.01 was arbitrary; remember, we are just interested in small random values to avoid the properties of all-zero vectors, as discussed earlier.) As", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 46, "start_word": 14720, "end_word": 15120, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000047": {"text": "= 0.5 * v1 >>> np.arccos(v1.dot(v2) / (np.linalg.norm(v1) * ... np.linalg.norm(v2))) 0.0 Here, np.arccos is the trigonometric inverse cosine, and np.linalg.norm is a function that computes the length of a vector. (Our decision to draw the random numbers from a random normal distribu- tion—for example, instead of from a uniform distribution—and to use a standard deviation of 0.01 was arbitrary; remember, we are just interested in small random values to avoid the properties of all-zero vectors, as discussed earlier.) As an optional exercise after reading this chapter, you can change self.w_ = rgen.normal(loc=0.0, scale=0.01, size=X.shape[1]) to self.w_ = np.zeros(X.shape[1]) and run the perceptron train- ing code presented in the next section with different values for eta. You will observe that the decision boundary does not change. NumPy array indexing NumPy indexing for one-dimensional arrays works similarly to Python lists using the square-bracket ([]) notation. For two-dimensional arrays, the first indexer refers to the row number and the second indexer to the column number. For example, we would use X[2, 3] to select the third row and fourth column of a two-dimensional array, X. Chapter 2 29 After the weights have been initialized, the fit method loops over all individual examples in the training dataset and updates the weights according to the perceptron learning rule that we discussed in the previous section. The class labels are predicted by the predict method, which is called in the fit method during training to get the class label for the weight update; but predict can also be used to predict the class labels of new data after we have fitted our model. Furthermore, we also collect the number of mis- classifications during each epoch in the self.errors_ list so that we can later analyze how well our perceptron performed during the training. The np.dot function that is used in the net_input method simply calculates the vector dot product, wTx + b. Training a perceptron model on the Iris dataset To test our perceptron implementation, we will restrict the following analyses and examples in the remainder of this chapter to two feature variables (dimensions). Although the perceptron rule is not restricted to two dimensions, considering only two features, sepal length and petal length, will allow us to visualize the decision regions of the trained model in a scatterplot for learning purposes. Note that we will also only consider two flower classes, setosa and versicolor, from", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 47, "start_word": 15040, "end_word": 15440, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000048": {"text": "model on the Iris dataset To test our perceptron implementation, we will restrict the following analyses and examples in the remainder of this chapter to two feature variables (dimensions). Although the perceptron rule is not restricted to two dimensions, considering only two features, sepal length and petal length, will allow us to visualize the decision regions of the trained model in a scatterplot for learning purposes. Note that we will also only consider two flower classes, setosa and versicolor, from the Iris dataset for practical reasons—remember, the perceptron is a binary classifier. However, the perceptron algorithm can be extended to multi-class classification—for example, the one-versus-all (OvA ) technique.Vectorization: Replacing for loops with vectorized code Instead of using NumPy to calculate the vector dot product between two arrays, a and b, via a.dot(b) or np.dot(a, b), we could also perform the calculation in pure Python via sum([i * j for i, j in zip(a, b)]) . However, the advantage of using NumPy over classic Python for loop structures is that its arithmetic operations are vectorized. Vectorization means that an elemental arithmetic operation is automatically applied to all elements in an array. By formulating our arithmetic operations as a sequence of in- structions on an array, rather than performing a set of operations for each element at a time, we can make better use of our modern central processing unit (CPU ) architectures with single instruction, multiple data (SIMD) support. Furthermore, NumPy uses highly optimized linear algebra libraries, such as Basic Linear Algebra Subprograms ( BLAS) and Linear Algebra Package (LAPACK), that have been written in C or Fortran. Lastly, NumPy also allows us to write our code in a more compact and intuitive way using the basics of linear algebra, such as vector and matrix dot products. Training Simple Machine Learning Algorithms for Classification 30 First, we will use the pandas library to load the Iris dataset directly from the UCI Machine Learning Repository into a DataFrame object and print the last five lines via the tail method to check that the data was loaded correctly: >>> import os >>> import pandas as pd >>> s = 'https://archive.ics.uci.edu/ml/' \\ ... 'machine-learning-databases/iris/iris.data' >>> print('From URL:' , s) From URL: https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris. data >>> df = pd.read_csv(s, ... header= None, ... encoding= 'utf-8') >>> df.tail() After executing the previous code, we should see the following output, which shows the last five lines of the", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 48, "start_word": 15360, "end_word": 15760, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000049": {"text": "Machine Learning Repository into a DataFrame object and print the last five lines via the tail method to check that the data was loaded correctly: >>> import os >>> import pandas as pd >>> s = 'https://archive.ics.uci.edu/ml/' \\ ... 'machine-learning-databases/iris/iris.data' >>> print('From URL:' , s) From URL: https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris. data >>> df = pd.read_csv(s, ... header= None, ... encoding= 'utf-8') >>> df.tail() After executing the previous code, we should see the following output, which shows the last five lines of the Iris dataset: Figure 2.5: The last five lines of the Iris datasetThe OvA method for multi-class classification OvA, which is sometimes also called one-versus-rest ( OvR ), is a technique that allows us to extend any binary classifier to multi-class problems. Using OvA, we can train one classifier per class, where the particular class is treated as the positive class and the examples from all other classes are considered negative classes. If we were to classify a new, unlabeled data instance, we would use our n classifiers, where n is the number of class labels, and assign the class label with the highest confidence to the particular instance we want to classify. In the case of the perceptron, we would use OvA to choose the class label that is associated with the largest absolute net input value. Chapter 2 31 Next, we extract the first 100 class labels that correspond to the 50 Iris-setosa and 50 Iris-versicolor flowers and convert the class labels into the two integer class labels, 1 (versicolor) and 0 (setosa), that we assign to a vector, y, where the values method of a pandas DataFrame yields the corresponding NumPy representation. Similarly, we extract the first feature column (sepal length) and the third feature column (petal length) of those 100 training examples and assign them to a feature matrix, X, which we can visualize via a two-dimensional scatterplot: >>> import matplotlib.pyplot as plt >>> import numpy as np >>> # select setosa and versicolor >>> y = df.iloc[ 0:100, 4].values >>> y = np.where(y == 'Iris-setosa' , 0, 1) >>> # extract sepal length and petal length >>> X = df.iloc[ 0:100, [0, 2]].values >>> # plot data >>> plt.scatter(X[: 50, 0], X[: 50, 1], ... color= 'red', marker= 'o', label= 'Setosa' ) >>> plt.scatter(X[ 50:100, 0], X[ 50:100, 1], ... color= 'blue', marker= 's', label= 'Versicolor' ) >>> plt.xlabel( 'Sepal length [cm]' ) >>> plt.ylabel( 'Petal", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 49, "start_word": 15680, "end_word": 16080, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000050": {"text": "np >>> # select setosa and versicolor >>> y = df.iloc[ 0:100, 4].values >>> y = np.where(y == 'Iris-setosa' , 0, 1) >>> # extract sepal length and petal length >>> X = df.iloc[ 0:100, [0, 2]].values >>> # plot data >>> plt.scatter(X[: 50, 0], X[: 50, 1], ... color= 'red', marker= 'o', label= 'Setosa' ) >>> plt.scatter(X[ 50:100, 0], X[ 50:100, 1], ... color= 'blue', marker= 's', label= 'Versicolor' ) >>> plt.xlabel( 'Sepal length [cm]' ) >>> plt.ylabel( 'Petal length [cm]' ) >>> plt.legend(loc= 'upper left' ) >>> plt.show()Loading the Iris dataset You can find a copy of the Iris dataset (and all other datasets used in this book) in the code bundle of this book, which you can use if you are working offline or if the UCI server at https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data is temporarily unavailable. For instance, to load the Iris dataset from a local directory, you can replace this line, df = pd.read_csv( 'https://archive.ics.uci.edu/ml/' 'machine-learning-databases/iris/iris.data' , header= None, encoding= 'utf-8') with the following one: df = pd.read_csv( 'your/local/path/to/iris.data' , header= None, encoding= 'utf-8') Training Simple Machine Learning Algorithms for Classification 32 After executing the preceding code example, we should see the following scatterplot: Figure 2.6: Scatterplot of setosa and versicolor flowers by sepal and petal length Figure 2.6 shows the distribution of flower examples in the Iris dataset along the two feature axes: petal length and sepal length (measured in centimeters). In this two-dimensional feature subspace, we can see that a linear decision boundary should be sufficient to separate setosa from versicolor flowers. Thus, a linear classifier such as the perceptron should be able to classify the flowers in this dataset perfectly. Now, it’s time to train our perceptron algorithm on the Iris data subset that we just extracted. Also, we will plot the misclassification error for each epoch to check whether the algorithm converged and found a decision boundary that separates the two Iris flower classes: >>> ppn = Perceptron(eta= 0.1, n_iter= 10) >>> ppn.fit(X, y) >>> plt.plot( range(1, len(ppn.errors_) + 1), ... ppn.errors_, marker= 'o') >>> plt.xlabel( 'Epochs' ) >>> plt.ylabel( 'Number of updates' ) >>> plt.show() Note that the number of misclassification errors and the number of updates is the same, since the perceptron weights and bias are updated each time it misclassifies an example. After executing the preceding code, we should see the plot of the misclassification errors versus the number of epochs, as", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 50, "start_word": 16000, "end_word": 16400, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000051": {"text": "ppn = Perceptron(eta= 0.1, n_iter= 10) >>> ppn.fit(X, y) >>> plt.plot( range(1, len(ppn.errors_) + 1), ... ppn.errors_, marker= 'o') >>> plt.xlabel( 'Epochs' ) >>> plt.ylabel( 'Number of updates' ) >>> plt.show() Note that the number of misclassification errors and the number of updates is the same, since the perceptron weights and bias are updated each time it misclassifies an example. After executing the preceding code, we should see the plot of the misclassification errors versus the number of epochs, as shown in Figure 2.7: Chapter 2 33 Figure 2.7: A plot of the misclassification errors against the number of epochs As we can see in Figure 2.7, our perceptron converged after the sixth epoch and should now be able to classify the training examples perfectly. Let’s implement a small convenience function to visualize the decision boundaries for two-dimensional datasets: from matplotlib.colors import ListedColormap def plot_decision_regions (X, y, classifier, resolution= 0.02): # setup marker generator and color map markers = ( 'o', 's', '^', 'v', '<') colors = ( 'red', 'blue' , 'lightgreen' , 'gray' , 'cyan' ) cmap = ListedColormap(colors[: len(np.unique(y))]) # plot the decision surface x1_min, x1_max = X[:, 0].min() - 1, X[:, 0].max() + 1 x2_min, x2_max = X[:, 1].min() - 1, X[:, 1].max() + 1 xx1, xx2 = np.meshgrid(np.arange(x1_min, x1_max, resolution), np.arange(x2_min, x2_max, resolution)) lab = classifier.predict(np.array([xx1.ravel(), xx2.ravel()]).T) lab = lab.reshape(xx1.shape) plt.contourf(xx1, xx2, lab, alpha= 0.3, cmap=cmap) plt.xlim(xx1. min(), xx1. max()) plt.ylim(xx2. min(), xx2. max()) Training Simple Machine Learning Algorithms for Classification 34 # plot class examples for idx, cl in enumerate (np.unique(y)): plt.scatter(x=X[y == cl, 0], y=X[y == cl, 1], alpha= 0.8, c=colors[idx], marker=markers[idx], label= f'Class {cl}', edgecolor= 'black') First, we define a number of colors and markers and create a colormap from the list of colors via ListedColormap . Then, we determine the minimum and maximum values for the two features and use those feature vectors to create a pair of grid arrays, xx1 and xx2, via the NumPy meshgrid function. Since we trained our perceptron classifier on two feature dimensions, we need to flatten the grid arrays and create a matrix that has the same number of columns as the Iris training subset so that we can use the predict method to predict the class labels, lab, of the corresponding grid points. After reshaping the predicted class labels, lab, into a grid with the same dimensions as xx1 and xx2, we can now draw", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 51, "start_word": 16320, "end_word": 16720, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000052": {"text": "xx2, via the NumPy meshgrid function. Since we trained our perceptron classifier on two feature dimensions, we need to flatten the grid arrays and create a matrix that has the same number of columns as the Iris training subset so that we can use the predict method to predict the class labels, lab, of the corresponding grid points. After reshaping the predicted class labels, lab, into a grid with the same dimensions as xx1 and xx2, we can now draw a contour plot via Matplotlib’s contourf function, which maps the different decision regions to different colors for each predicted class in the grid array: >>> plot_decision_regions(X, y, classifier=ppn) >>> plt.xlabel( 'Sepal length [cm]' ) >>> plt.ylabel( 'Petal length [cm]' ) >>> plt.legend(loc= 'upper left' ) >>> plt.show() After executing the preceding code example, we should now see a plot of the decision regions, as shown in Figure 2.8: Chapter 2 35 Figure 2.8: A plot of the perceptron’s decision regions As we can see in the plot, the perceptron learned a decision boundary that can classify all flower examples in the Iris training subset perfectly. Adaptive linear neurons and the convergence of learning In this section, we will take a look at another type of single-layer neural network ( NN): ADAptive LInear NEuron (Adaline). Adaline was published by Bernard Widrow and his doctoral student Tedd Hoff only a few years after Rosenblatt’s perceptron algorithm, and it can be considered an improvement on the latter (An Adaptive “Adaline” Neuron Using Chemical “Memistors”, Technical Report Number 1553-2 by B. Widrow and colleagues, Stanford Electron Labs, Stanford, CA, October 1960).Perceptron convergence Although the perceptron classified the two Iris flower classes perfectly, convergence is one of the biggest problems of the perceptron. Rosenblatt proved mathematically that the perceptron learning rule converges if the two classes can be separated by a linear hy - perplane. However, if the classes cannot be separated perfectly by such a linear decision boundary, the weights will never stop updating unless we set a maximum number of ep - ochs. Interested readers can find a summary of the proof in my lecture notes at https:// sebastianraschka.com/pdf/lecture-notes/stat453ss21/L03_perceptron_slides. pdf. Training Simple Machine Learning Algorithms for Classification 36 The Adaline algorithm is particularly interesting because it illustrates the key concepts of defining and minimizing continuous loss functions. This lays the groundwork for understanding other machine learning algorithms for classification, such as logistic regression,", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 52, "start_word": 16640, "end_word": 17040, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000053": {"text": "a linear decision boundary, the weights will never stop updating unless we set a maximum number of ep - ochs. Interested readers can find a summary of the proof in my lecture notes at https:// sebastianraschka.com/pdf/lecture-notes/stat453ss21/L03_perceptron_slides. pdf. Training Simple Machine Learning Algorithms for Classification 36 The Adaline algorithm is particularly interesting because it illustrates the key concepts of defining and minimizing continuous loss functions. This lays the groundwork for understanding other machine learning algorithms for classification, such as logistic regression, support vector machines, and mul- tilayer neural networks, as well as linear regression models, which we will discuss in future chapters. The key difference between the Adaline rule (also known as the Widrow-Hoff rule) and Rosenblatt’s perceptron is that the weights are updated based on a linear activation function rather than a unit step function like in the perceptron. In Adaline, this linear activation function, 𝜎𝜎(𝑧𝑧) , is simply the identity function of the net input, so that 𝜎𝜎(𝑧𝑧)=𝑧𝑧 . While the linear activation function is used for learning the weights, we still use a threshold function to make the final prediction, which is similar to the unit step function that we covered earlier. The main differences between the perceptron and Adaline algorithm are highlighted in Figure 2.9: Figure 2.9: A comparison between a perceptron and the Adaline algorithm Chapter 2 37 As Figure 2.9 indicates, the Adaline algorithm compares the true class labels with the linear activation function’s continuous valued output to compute the model error and update the weights. In contrast, the perceptron compares the true class labels to the predicted class labels. Minimizing loss functions with gradient descent One of the key ingredients of supervised machine learning algorithms is a defined objective function that is to be optimized during the learning process. This objective function is often a loss or cost function that we want to minimize. In the case of Adaline, we can define the loss function, L , to learn the model parameters as the mean squared error (MSE ) between the calculated outcome and the true class label: 𝐿𝐿(𝒘𝒘𝒘 𝒘𝒘 )=1 2𝑛𝑛∑ (𝑦𝑦(𝑖𝑖)− 𝜎𝜎𝜎𝜎𝜎(𝑖𝑖)))2 𝑛𝑛 𝑖𝑖𝑖𝑖 The term 1 2 is just added for our convenience and will make it easier to derive the gradient of the loss function with respect to the weight parameters, as we will see in the following paragraphs. The main advantage of this continuous linear activation function, in contrast", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 53, "start_word": 16960, "end_word": 17360, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000054": {"text": "function, L , to learn the model parameters as the mean squared error (MSE ) between the calculated outcome and the true class label: 𝐿𝐿(𝒘𝒘𝒘 𝒘𝒘 )=1 2𝑛𝑛∑ (𝑦𝑦(𝑖𝑖)− 𝜎𝜎𝜎𝜎𝜎(𝑖𝑖)))2 𝑛𝑛 𝑖𝑖𝑖𝑖 The term 1 2 is just added for our convenience and will make it easier to derive the gradient of the loss function with respect to the weight parameters, as we will see in the following paragraphs. The main advantage of this continuous linear activation function, in contrast to the unit step function, is that the loss function becomes differentiable. Another nice property of this loss function is that it is convex; thus, we can use a very simple yet powerful optimization algorithm called gradient descent to find the weights that minimize our loss function to classify the examples in the Iris dataset. As illustrated in Figure 2.10, we can describe the main idea behind gradient descent as climbing down a hill until a local or global loss minimum is reached. In each iteration, we take a step in the opposite direction of the gradient, where the step size is determined by the value of the learning rate, as well as the slope of the gradient (for simplicity, the following figure visualizes this only for a single weight, w ): Figure 2.10: How gradient descent works Using gradient descent, we can now update the model parameters by taking a step in the opposite direction of the gradient, ∇𝐿𝐿𝐿𝐿𝐿𝐿 𝐿𝐿𝐿 , of our loss function, L(w, b): 𝒘𝒘𝒘𝒘 𝒘𝒘𝒘𝒘𝒘𝒘𝒘𝒘𝒘𝒘𝒘𝒘𝒘𝒘𝒘 𝒘𝒘 𝒘𝒘𝒘𝒘 Training Simple Machine Learning Algorithms for Classification 38 The parameter changes, Δ𝒘𝒘 and ∆𝑏𝑏 , are defined as the negative gradient multiplied by the learning rate, 𝜂𝜂 : ∆𝒘𝒘 𝒘 𝒘𝒘𝒘𝒘 𝑤𝑤𝐿𝐿(𝒘𝒘𝒘 𝒘𝒘 )𝒘 ∆𝒘𝒘 𝒘 𝒘𝒘𝒘𝒘 𝑏𝑏𝐿𝐿(𝒘𝒘𝒘 𝒘𝒘) To compute the gradient of the loss function, we need to compute the partial derivative of the loss function with respect to each weight, w j: 𝜕𝜕𝜕𝜕 𝜕𝜕𝜕𝜕𝑗𝑗=−2 𝑛𝑛∑(𝑦𝑦(𝑖𝑖)−𝜎𝜎𝜎𝜎𝜎(𝑖𝑖)))𝑥𝑥𝑗𝑗(𝑖𝑖) 𝑖𝑖 Similarly, we compute the partial derivative of the loss with respect to the bias as: 𝜕𝜕𝜕𝜕 𝜕𝜕𝜕𝜕=−2 𝑛𝑛∑(𝑦𝑦(𝑖𝑖)−𝜎𝜎𝜎𝜎𝜎(𝑖𝑖))) 𝑖𝑖 Please note that the 2 in the numerator above is merely a constant scaling factor, and we could omit it without affecting the algorithm. Removing the scaling factor has the same effect as changing the learn - ing rate by a factor of 2. The following information box explains where this scaling factor originates. So we can write the weight", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 54, "start_word": 17280, "end_word": 17680, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000055": {"text": "𝑖𝑖 Similarly, we compute the partial derivative of the loss with respect to the bias as: 𝜕𝜕𝜕𝜕 𝜕𝜕𝜕𝜕=−2 𝑛𝑛∑(𝑦𝑦(𝑖𝑖)−𝜎𝜎𝜎𝜎𝜎(𝑖𝑖))) 𝑖𝑖 Please note that the 2 in the numerator above is merely a constant scaling factor, and we could omit it without affecting the algorithm. Removing the scaling factor has the same effect as changing the learn - ing rate by a factor of 2. The following information box explains where this scaling factor originates. So we can write the weight update as: Δ𝑤𝑤 𝑗𝑗= −𝜂𝜂𝜕𝜕𝜕𝜕 𝜕𝜕𝑤𝑤 𝑗𝑗 and Δ𝑏𝑏 = −𝜂𝜂𝜕𝜕𝜕𝜕 𝜕𝜕𝑏𝑏 Since we update all parameters simultaneously, our Adaline learning rule becomes: 𝒘𝒘𝒘𝒘 𝒘𝒘𝒘𝒘𝒘𝒘𝒘𝒘𝒘𝒘𝒘𝒘𝒘𝒘𝒘 𝒘𝒘𝒘𝒘𝒘𝒘 The mean squared error derivative If you are familiar with calculus, the partial derivative of the MSE loss function with respect to the jth weight can be obtained as follows: 𝜕𝜕𝜕𝜕 𝜕𝜕𝜕𝜕 𝑗𝑗=𝜕𝜕 𝜕𝜕𝜕𝜕𝑗𝑗1 𝑛𝑛∑(𝑦𝑦(𝑖𝑖)− 𝜎𝜎𝜎𝜎𝜎(𝑖𝑖)))2 𝑖𝑖=1 𝑛𝑛𝜕𝜕 𝜕𝜕𝜕𝜕 𝑗𝑗∑(𝑦𝑦(𝑖𝑖)− 𝜎𝜎𝜎𝜎𝜎(𝑖𝑖)))2 𝑖𝑖 =2 𝑛𝑛∑(𝑦𝑦(𝑖𝑖)− 𝜎𝜎𝜎𝜎𝜎(𝑖𝑖))) 𝑖𝑖 𝜕𝜕 𝜕𝜕𝜕𝜕 𝑗𝑗(𝑦𝑦(𝑖𝑖)− 𝜎𝜎𝜎𝜎𝜎(𝑖𝑖))) =2 𝑛𝑛∑(𝑦𝑦(𝑖𝑖)− 𝜎𝜎𝜎𝜎𝜎(𝑖𝑖))) 𝑖𝑖𝜕𝜕 𝜕𝜕𝜕𝜕𝑗𝑗(𝑦𝑦(𝑖𝑖)−∑ (𝜕𝜕𝑗𝑗𝑥𝑥𝑗𝑗(𝑖𝑖)+𝑏𝑏) 𝑖𝑖) =2 𝑛𝑛∑(𝑦𝑦(𝑖𝑖)− 𝜎𝜎𝜎𝜎𝜎(𝑖𝑖))) 𝑖𝑖(−𝑥𝑥𝑗𝑗(𝑖𝑖))=−2 𝑛𝑛∑(𝑦𝑦(𝑖𝑖)− 𝜎𝜎𝜎𝜎𝜎(𝑖𝑖))) 𝑖𝑖𝑥𝑥𝑗𝑗(𝑖𝑖) The same approach can be used to find partial derivative 𝜕𝜕𝜕𝜕 𝜕𝜕𝜕𝜕 except that 𝜕𝜕 𝜕𝜕𝜕𝜕(𝑦𝑦(𝑖𝑖)−∑(𝑤𝑤𝑗𝑗(𝑖𝑖)𝑥𝑥𝑗𝑗(𝑖𝑖)+𝑏𝑏) 𝑖𝑖 ) is equal to –1 and thus the last step simplifies to −2 𝑛𝑛∑(𝑦𝑦(𝑖𝑖)− 𝜎𝜎𝜎𝜎𝜎(𝑖𝑖))) 𝑖𝑖 . Chapter 2 39 Although the Adaline learning rule looks identical to the perceptron rule, we should note that 𝜎𝜎𝜎𝜎𝜎(𝑖𝑖)) with 𝑧𝑧(𝑖𝑖𝑖=𝒘𝒘𝑇𝑇𝒙𝒙(𝑖𝑖𝑖+𝑏𝑏 is a real number and not an integer class label. Furthermore, the weight up - date is calculated based on all examples in the training dataset (instead of updating the parameters incrementally after each training example), which is why this approach is also referred to as batch gradient descent. To be more explicit and avoid confusion when talking about related concepts later in this chapter and this book, we will refer to this process as full batch gradient descent. Implementing Adaline in Python Since the perceptron rule and Adaline are very similar, we will take the perceptron implementation that we defined earlier and change the fit method so that the weight and bias parameters are now updated by minimizing the loss function via gradient descent: class AdalineGD : \"\"\"ADAptive LInear NEuron classifier. Parameters ------------ eta : float Learning rate (between 0.0 and 1.0) n_iter : int Passes over the training dataset. random_state : int Random number generator seed for random weight initialization. Attributes ----------- w_ : 1d-array Weights after fitting. b_ : Scalar Bias unit", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 55, "start_word": 17600, "end_word": 18000, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000056": {"text": "the perceptron implementation that we defined earlier and change the fit method so that the weight and bias parameters are now updated by minimizing the loss function via gradient descent: class AdalineGD : \"\"\"ADAptive LInear NEuron classifier. Parameters ------------ eta : float Learning rate (between 0.0 and 1.0) n_iter : int Passes over the training dataset. random_state : int Random number generator seed for random weight initialization. Attributes ----------- w_ : 1d-array Weights after fitting. b_ : Scalar Bias unit after fitting. losses_ : list Mean squared error loss function values in each epoch. \"\"\" def __init__(self, eta= 0.01, n_iter= 50, random_state= 1): self.eta = eta self.n_iter = n_iter self.random_state = random_state def fit(self, X, y): \"\"\" Fit training data. Training Simple Machine Learning Algorithms for Classification 40 Parameters ---------- X : {array-like}, shape = [n_examples, n_features] Training vectors, where n_examples is the number of examples and n_features is the number of features. y : array-like, shape = [n_examples] Target values. Returns ------- self : object \"\"\" rgen = np.random.RandomState(self.random_state) self.w_ = rgen.normal(loc= 0.0, scale= 0.01, size=X.shape[ 1]) self.b_ = np.float_( 0.) self.losses_ = [] for i in range (self.n_iter): net_input = self.net_input(X) output = self.activation(net_input) errors = (y - output) self.w_ += self.eta * 2.0 * X.T.dot(errors) / X.shape[ 0] self.b_ += self.eta * 2.0 * errors.mean() loss = (errors** 2).mean() self.losses_.append(loss) return self def net_input (self, X): \"\"\"Calculate net input\"\"\" return np.dot(X, self.w_) + self.b_ def activation (self, X): \"\"\"Compute linear activation\"\"\" return X def predict (self, X): \"\"\"Return class label after unit step\"\"\" Chapter 2 41 return np.where(self.activation(self.net_input(X)) >= 0.5, 1, 0) Instead of updating the weights after evaluating each individual training example, as in the perceptron, we calculate the gradient based on the whole training dataset. For the bias unit, this is done via self. eta * 2.0 * errors.mean() , where errors is an array containing the partial derivative values 𝜕𝜕 𝜕𝜕𝜕𝜕 . Similarly, we update the weights. However note that the weight updates via the partial derivatives 𝜕𝜕𝜕𝜕 𝜕𝜕𝜕𝜕𝑗𝑗 involve the feature values x j, which we can compute by multiplying errors with each feature value for each weight: for w_j in range (self.w_.shape[ 0]): self.w_[w_j] += self.eta * ( 2.0 * (X[:, w_j]*errors)).mean() To implement the weight update more efficiently without using a for loop, we can use a matrix-vector multiplication between our feature matrix and the error vector instead: self.w_ += self.eta", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 56, "start_word": 17920, "end_word": 18320, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000057": {"text": "update the weights. However note that the weight updates via the partial derivatives 𝜕𝜕𝜕𝜕 𝜕𝜕𝜕𝜕𝑗𝑗 involve the feature values x j, which we can compute by multiplying errors with each feature value for each weight: for w_j in range (self.w_.shape[ 0]): self.w_[w_j] += self.eta * ( 2.0 * (X[:, w_j]*errors)).mean() To implement the weight update more efficiently without using a for loop, we can use a matrix-vector multiplication between our feature matrix and the error vector instead: self.w_ += self.eta * 2.0 * X.T.dot(errors) / X.shape[ 0] Please note that the activation method has no effect on the code since it is simply an identity func- tion. Here, we added the activation function (computed via the activation method) to illustrate the general concept with regard to how information flows through a single-layer NN: features from the input data, net input, activation, and output. In the next chapter, we will learn about a logistic regression classifier that uses a non-identity, nonlin- ear activation function. We will see that a logistic regression model is closely related to Adaline, with the only difference being its activation and loss function. Now, similar to the previous perceptron implementation, we collect the loss values in a self.losses_ list to check whether the algorithm converged after training. Matrix multiplication Performing a matrix multiplication is similar to calculating a vector dot-product where each row in the matrix is treated as a single row vector. This vectorized approach represents a more compact notation and results in a more efficient computation using NumPy. For example: [123 456]×[7 8 9]=[1×7+2×8+3×9 4×7+5×8+6×9]=[50 122] Please note that in the preceding equation, we are multiplying a matrix with a vector, which is mathematically not defined. However, remember that we use the convention that this preceding vector is regarded as a 3×1 matrix. Training Simple Machine Learning Algorithms for Classification 42 In practice, it often requires some experimentation to find a good learning rate, 𝜂𝜂 , for optimal con- vergence. So, let’s choose two different learning rates, 𝜂𝜂 𝜂 𝜂𝜂𝜂 and 𝜂𝜂 𝜂 𝜂𝜂𝜂𝜂𝜂1 , to start with and plot the loss functions versus the number of epochs to see how well the Adaline implementation learns from the training data. Let’s now plot the loss against the number of epochs for the two different learning rates: >>> fig, ax = plt.subplots(nrows= 1, ncols= 2, figsize=( 10, 4)) >>> ada1 = AdalineGD(n_iter= 15, eta= 0.1).fit(X, y)", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 57, "start_word": 18240, "end_word": 18640, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000058": {"text": ", for optimal con- vergence. So, let’s choose two different learning rates, 𝜂𝜂 𝜂 𝜂𝜂𝜂 and 𝜂𝜂 𝜂 𝜂𝜂𝜂𝜂𝜂1 , to start with and plot the loss functions versus the number of epochs to see how well the Adaline implementation learns from the training data. Let’s now plot the loss against the number of epochs for the two different learning rates: >>> fig, ax = plt.subplots(nrows= 1, ncols= 2, figsize=( 10, 4)) >>> ada1 = AdalineGD(n_iter= 15, eta= 0.1).fit(X, y) >>> ax[0].plot( range(1, len(ada1.losses_) + 1), ... np.log10(ada1.losses_), marker= 'o') >>> ax[0].set_xlabel( 'Epochs' ) >>> ax[0].set_ylabel( 'log(Mean squared error)' ) >>> ax[0].set_title( 'Adaline - Learning rate 0.1' ) >>> ada2 = AdalineGD(n_iter= 15, eta= 0.0001).fit(X, y) >>> ax[1].plot( range(1, len(ada2.losses_) + 1), ... ada2.losses_, marker= 'o') >>> ax[1].set_xlabel( 'Epochs' ) >>> ax[1].set_ylabel( 'Mean squared error' ) >>> ax[1].set_title( 'Adaline - Learning rate 0.0001' ) >>> plt.show() As we can see in the resulting loss function plots, we encountered two different types of problems. The left chart shows what could happen if we choose a learning rate that is too large. Instead of minimizing the loss function, the MSE becomes larger in every epoch, because we overshoot the global minimum. On the other hand, we can see that the loss decreases on the right plot, but the chosen learning rate, 𝜂𝜂 𝜂 𝜂𝜂𝜂𝜂𝜂1 , is so small that the algorithm would require a very large number of epochs to converge to the global loss minimum:Hyperparameters The learning rate, 𝜂𝜂 (eta ), as well as the number of epochs (n_iter), are the so-called hy - perparameters (or tuning parameters) of the perceptron and Adaline learning algorithms. In Chapter 6, Learning Best Practices for Model Evaluation and Hyperparameter Tuning, we will take a look at different techniques to automatically find the values of different hyper - parameters that yield optimal performance of the classification model. Chapter 2 43 Figure 2.11: Error plots for suboptimal learning rates Figure 2.12 illustrates what might happen if we change the value of a particular weight parameter to minimize the loss function, L. The left subfigure illustrates the case of a well-chosen learning rate, where the loss decreases gradually, moving in the direction of the global minimum. The subfigure on the right, however, illustrates what happens if we choose a learning rate that is too large—we overshoot the global minimum: Figure 2.12: A comparison of a well-chosen learning", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 58, "start_word": 18560, "end_word": 18960, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000059": {"text": "suboptimal learning rates Figure 2.12 illustrates what might happen if we change the value of a particular weight parameter to minimize the loss function, L. The left subfigure illustrates the case of a well-chosen learning rate, where the loss decreases gradually, moving in the direction of the global minimum. The subfigure on the right, however, illustrates what happens if we choose a learning rate that is too large—we overshoot the global minimum: Figure 2.12: A comparison of a well-chosen learning rate and a learning rate that is too large Improving gradient descent through feature scaling Many machine learning algorithms that we will encounter throughout this book require some sort of feature scaling for optimal performance, which we will discuss in more detail in Chapter 3, A Tour of Machine Learning Classifiers Using Scikit-Learn, and Chapter 4, Building Good Training Datasets – Data Preprocessing. Training Simple Machine Learning Algorithms for Classification 44 Gradient descent is one of the many algorithms that benefit from feature scaling. In this section, we will use a feature scaling method called standardization. This normalization procedure helps gradient descent learning to converge more quickly; however, it does not make the original dataset normally distributed. Standardization shifts the mean of each feature so that it is centered at zero and each feature has a standard deviation of 1 (unit variance). For instance, to standardize the jth feature, we can simply subtract the sample mean, 𝜇𝜇𝑗𝑗 , from every training example and divide it by its standard deviation, 𝜎𝜎𝑗𝑗 : 𝑥𝑥𝑗𝑗′=𝑥𝑥𝑗𝑗−𝜇𝜇𝑗𝑗 𝜎𝜎𝑗𝑗 Here, xj is a vector consisting of the jth feature values of all training examples, n, and this standard- ization technique is applied to each feature, j, in our dataset. One of the reasons why standardization helps with gradient descent learning is that it is easier to find a learning rate that works well for all weights (and the bias). If the features are on vastly different scales, a learning rate that works well for updating one weight might be too large or too small to update the other weight equally well. Overall, using standardized features can stabilize the training such that the optimizer has to go through fewer steps to find a good or optimal solution (the global loss minimum). Figure 2.13 illustrates possible gradient updates with unscaled features (left) and standardized features (right), where the concentric circles represent the loss surface as a function of", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 59, "start_word": 18880, "end_word": 19280, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000060": {"text": "scales, a learning rate that works well for updating one weight might be too large or too small to update the other weight equally well. Overall, using standardized features can stabilize the training such that the optimizer has to go through fewer steps to find a good or optimal solution (the global loss minimum). Figure 2.13 illustrates possible gradient updates with unscaled features (left) and standardized features (right), where the concentric circles represent the loss surface as a function of two model weights in a two-dimensional classification problem: Figure 2.13: A comparison of unscaled and standardized features on gradient updates Standardization can easily be achieved by using the built-in NumPy methods mean and std: >>> X_std = np.copy(X) >>> X_std[:, 0] = (X[:, 0] - X[:, 0].mean()) / X[:, 0].std() >>> X_std[:, 1] = (X[:, 1] - X[:, 1].mean()) / X[:, 1].std() After standardization, we will train Adaline again and see that it now converges after a small number of epochs using a learning rate of 𝜂𝜂 𝜂 𝜂𝜂𝜂 : >>> ada_gd = AdalineGD(n_iter= 20, eta= 0.5) >>> ada_gd.fit(X_std, y) Chapter 2 45 >>> plot_decision_regions(X_std, y, classifier=ada_gd) >>> plt.title( 'Adaline - Gradient descent' ) >>> plt.xlabel( 'Sepal length [standardized]' ) >>> plt.ylabel( 'Petal length [standardized]' ) >>> plt.legend(loc= 'upper left' ) >>> plt.tight_layout() >>> plt.show() >>> plt.plot( range(1, len(ada_gd.losses_) + 1), ... ada_gd.losses_, marker= 'o') >>> plt.xlabel( 'Epochs' ) >>> plt.ylabel( 'Mean squared error' ) >>> plt.tight_layout() >>> plt.show() After executing this code, we should see a figure of the decision regions, as well as a plot of the de - clining loss, as shown in Figure 2.14: Figure 2.14: Plots of Adaline’s decision regions and MSE by number of epochs As we can see in the plots, Adaline has now converged after training on the standardized features. However, note that the MSE remains non-zero even though all flower examples were classified correctly. Large-scale machine learning and stochastic gradient descent In the previous section, we learned how to minimize a loss function by taking a step in the opposite direction of the loss gradient that is calculated from the whole training dataset; this is why this approach is sometimes also referred to as full batch gradient descent. Now imagine that we have a very large dataset with millions of data points, which is not uncommon in many machine learning applications. Running full batch gradient descent can be computationally quite costly", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 60, "start_word": 19200, "end_word": 19600, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000061": {"text": "In the previous section, we learned how to minimize a loss function by taking a step in the opposite direction of the loss gradient that is calculated from the whole training dataset; this is why this approach is sometimes also referred to as full batch gradient descent. Now imagine that we have a very large dataset with millions of data points, which is not uncommon in many machine learning applications. Running full batch gradient descent can be computationally quite costly in such scenarios, since we need to reevaluate the whole training dataset each time we take one step toward the global minimum. Training Simple Machine Learning Algorithms for Classification 46 A popular alternative to the batch gradient descent algorithm is stochastic gradient descent (SGD ), which is sometimes also called iterative or online gradient descent. Instead of updating the weights based on the sum of the accumulated errors over all training examples, x(i): ∆𝑤𝑤𝑗𝑗=2𝜂𝜂 𝑛𝑛∑(𝑦𝑦(𝑖𝑖)−𝜎𝜎𝜎𝜎𝜎(𝑖𝑖))) 𝑖𝑖𝑥𝑥𝑗𝑗(𝑖𝑖) we update the parameters incrementally for each training example, for instance: ∆𝑤𝑤 𝑗𝑗= 𝜂𝜂 𝜂𝜂𝜂(𝑖𝑖)− 𝜎𝜎𝜎𝜎𝜎(𝑖𝑖))) 𝑥𝑥𝑗𝑗(𝑖𝑖), ∆𝑏𝑏 = 𝜂𝜂 𝜂𝜂𝜂(𝑖𝑖)− 𝜎𝜎𝜎𝜎𝜎(𝑖𝑖))) Although SGD can be considered as an approximation of gradient descent, it typically reaches con- vergence much faster because of the more frequent weight updates. Since each gradient is calculated based on a single training example, the error surface is noisier than in gradient descent, which can also have the advantage that SGD can escape shallow local minima more readily if we are working with nonlinear loss functions, as we will see later in Chapter 11, Implementing a Multilayer Artificial Neural Network from Scratch. To obtain satisfying results via SGD, it is important to present training data in a random order; also, we want to shuffle the training dataset for every epoch to prevent cycles. Another advantage of SGD is that we can use it for online learning. In online learning, our model is trained on the fly as new training data arrives. This is especially useful if we are accumulating large amounts of data, for example, customer data in web applications. Using online learning, the system can immediately adapt to changes, and the training data can be discarded after updating the model if storage space is an issue.Adjusting the learning rate during training In SGD implementations, the fixed learning rate, 𝜂𝜂 , is often replaced by an adaptive learning rate that decreases over time, for example: 𝑐𝑐1 [number of iterations ]+𝑐𝑐", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 61, "start_word": 19520, "end_word": 19920, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000062": {"text": "arrives. This is especially useful if we are accumulating large amounts of data, for example, customer data in web applications. Using online learning, the system can immediately adapt to changes, and the training data can be discarded after updating the model if storage space is an issue.Adjusting the learning rate during training In SGD implementations, the fixed learning rate, 𝜂𝜂 , is often replaced by an adaptive learning rate that decreases over time, for example: 𝑐𝑐1 [number of iterations ]+𝑐𝑐 2 where c1 and c 2 are constants. Note that SGD does not reach the global loss minimum but an area very close to it. And using an adaptive learning rate, we can achieve further annealing to the loss minimum. Chapter 2 47 Since we already implemented the Adaline learning rule using gradient descent, we only need to make a few adjustments to modify the learning algorithm to update the weights via SGD. Inside the fit method, we will now update the weights after each training example. Furthermore, we will imple - ment an additional partial_fit method, which does not reinitialize the weights, for online learning. In order to check whether our algorithm converged after training, we will calculate the loss as the average loss of the training examples in each epoch. Furthermore, we will add an option to shuffle the training data before each epoch to avoid repetitive cycles when we are optimizing the loss function; via the random_state parameter, we allow the specification of a random seed for reproducibility: class AdalineSGD : \"\"\"ADAptive LInear NEuron classifier. Parameters ------------ eta : float Learning rate (between 0.0 and 1.0) n_iter : int Passes over the training dataset. shuffle : bool (default: True) Shuffles training data every epoch if True to prevent cycles. random_state : int Random number generator seed for random weight initialization. Mini-batch gradient descent A compromise between full batch gradient descent and SGD is so-called mini-batch gradi - ent descent. Mini-batch gradient descent can be understood as applying full batch gradient descent to smaller subsets of the training data, for example, 32 training examples at a time. The advantage over full batch gradient descent is that convergence is reached faster via mini-batches because of the more frequent weight updates. Furthermore, mini-batch learning allows us to replace the for loop over the training examples in SGD with vector - ized operations leveraging concepts from linear algebra (for example, implementing", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 62, "start_word": 19840, "end_word": 20240, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000063": {"text": "ent descent. Mini-batch gradient descent can be understood as applying full batch gradient descent to smaller subsets of the training data, for example, 32 training examples at a time. The advantage over full batch gradient descent is that convergence is reached faster via mini-batches because of the more frequent weight updates. Furthermore, mini-batch learning allows us to replace the for loop over the training examples in SGD with vector - ized operations leveraging concepts from linear algebra (for example, implementing a weighted sum via a dot product), which can further improve the computational efficiency of our learning algorithm. Training Simple Machine Learning Algorithms for Classification 48 Attributes ----------- w_ : 1d-array Weights after fitting. b_ : Scalar Bias unit after fitting. losses_ : list Mean squared error loss function value averaged over all training examples in each epoch. \"\"\" def __init__(self, eta= 0.01, n_iter= 10, shuffle= True, random_state= None): self.eta = eta self.n_iter = n_iter self.w_initialized = False self.shuffle = shuffle self.random_state = random_state def fit(self, X, y): \"\"\" Fit training data. Parameters ---------- X : {array-like}, shape = [n_examples, n_features] Training vectors, where n_examples is the number of examples and n_features is the number of features. y : array-like, shape = [n_examples] Target values. Returns ------- self : object \"\"\" self._initialize_weights(X.shape[ 1]) self.losses_ = [] for i in range (self.n_iter): if self.shuffle: Chapter 2 49 X, y = self._shuffle(X, y) losses = [] for xi, target in zip(X, y): losses.append(self._update_weights(xi, target)) avg_loss = np.mean(losses) self.losses_.append(avg_loss) return self def partial_fit (self, X, y): \"\"\"Fit training data without reinitializing the weights\"\"\" if not self.w_initialized: self._initialize_weights(X.shape[ 1]) if y.ravel().shape[ 0] > 1: for xi, target in zip(X, y): self._update_weights(xi, target) else: self._update_weights(X, y) return self def _shuffle(self, X, y): \"\"\"Shuffle training data\"\"\" r = self.rgen.permutation( len(y)) return X[r], y[r] def _initialize_weights(self, m): \"\"\"Initialize weights to small random numbers\"\"\" self.rgen = np.random.RandomState(self.random_state) self.w_ = self.rgen.normal(loc= 0.0, scale= 0.01, size=m) self.b_ = np.float_( 0.) self.w_initialized = True def _update_weights(self, xi, target): \"\"\"Apply Adaline learning rule to update the weights\"\"\" output = self.activation(self.net_input(xi)) error = (target - output) self.w_ += self.eta * 2.0 * xi * (error) self.b_ += self.eta * 2.0 * error loss = error** 2 return loss Training Simple Machine Learning Algorithms for Classification 50 def net_input (self, X): \"\"\"Calculate net input\"\"\" return np.dot(X, self.w_) + self.b_ def activation (self, X): \"\"\"Compute linear activation\"\"\" return X def predict (self, X): \"\"\"Return class", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 63, "start_word": 20160, "end_word": 20560, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000064": {"text": "self.w_initialized = True def _update_weights(self, xi, target): \"\"\"Apply Adaline learning rule to update the weights\"\"\" output = self.activation(self.net_input(xi)) error = (target - output) self.w_ += self.eta * 2.0 * xi * (error) self.b_ += self.eta * 2.0 * error loss = error** 2 return loss Training Simple Machine Learning Algorithms for Classification 50 def net_input (self, X): \"\"\"Calculate net input\"\"\" return np.dot(X, self.w_) + self.b_ def activation (self, X): \"\"\"Compute linear activation\"\"\" return X def predict (self, X): \"\"\"Return class label after unit step\"\"\" return np.where(self.activation(self.net_input(X)) >= 0.5, 1, 0) The _shuffle method that we are now using in the AdalineSGD classifier works as follows: via the permutation function in np.random , we generate a random sequence of unique numbers in the range 0 to 100. Those numbers can then be used as indices to shuffle our feature matrix and class label vector. We can then use the fit method to train the AdalineSGD classifier and use our plot_decision_regions to plot our training results: >>> ada_sgd = AdalineSGD(n_iter= 15, eta= 0.01, random_state= 1) >>> ada_sgd.fit(X_std, y) >>> plot_decision_regions(X_std, y, classifier=ada_sgd) >>> plt.title( 'Adaline - Stochastic gradient descent' ) >>> plt.xlabel( 'Sepal length [standardized]' ) >>> plt.ylabel( 'Petal length [standardized]' ) >>> plt.legend(loc= 'upper left' ) >>> plt.tight_layout() >>> plt.show() >>> plt.plot( range(1, len(ada_sgd.losses_) + 1), ada_sgd.losses_, ... marker= 'o') >>> plt.xlabel( 'Epochs' ) >>> plt.ylabel( 'Average loss' ) >>> plt.tight_layout() >>> plt.show() Chapter 2 51 The two plots that we obtain from executing the preceding code example are shown in Figure 2.15: Figure 2.15: Decision regions and average loss plots after training an Adaline model using SGD As you can see, the average loss goes down pretty quickly, and the final decision boundary after 15 ep - ochs looks similar to the batch gradient descent Adaline. If we want to update our model, for example, in an online learning scenario with streaming data, we could simply call the partial_fit method on individual training examples—for instance, ada_sgd.partial_fit(X_std[0, :], y[0]) . Summary In this chapter, we gained a good understanding of the basic concepts of linear classifiers for super - vised learning. After we implemented a perceptron, we saw how we can train adaptive linear neurons efficiently via a vectorized implementation of gradient descent and online learning via SGD. Now that we have seen how to implement simple classifiers in Python, we are ready to move on to the next chapter, where", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 64, "start_word": 20480, "end_word": 20880, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000065": {"text": "on individual training examples—for instance, ada_sgd.partial_fit(X_std[0, :], y[0]) . Summary In this chapter, we gained a good understanding of the basic concepts of linear classifiers for super - vised learning. After we implemented a perceptron, we saw how we can train adaptive linear neurons efficiently via a vectorized implementation of gradient descent and online learning via SGD. Now that we have seen how to implement simple classifiers in Python, we are ready to move on to the next chapter, where we will use the Python scikit-learn machine learning library to get access to more advanced and powerful machine learning classifiers, which are commonly used in academia as well as in industry. The object-oriented approach that we used to implement the perceptron and Adaline algorithms will help with understanding the scikit-learn API, which is implemented based on the same core concepts that we used in this chapter: the fit and predict methods. Based on these core concepts, we will learn about logistic regression for modeling class probabilities and support vector machines for working with nonlinear decision boundaries. In addition, we will introduce a different class of supervised learning algorithms, tree-based algorithms, which are commonly combined into robust ensemble classifiers. Training Simple Machine Learning Algorithms for Classification 52 Join our book’s Discord space Join the book’s Discord workspace for a monthly Ask me Anything session with the authors: https://packt.link/MLwPyTorch 3 A Tour of Machine Learning Classifiers Using Scikit-Learn In this chapter, we will take a tour of a selection of popular and powerful machine learning algorithms that are commonly used in academia as well as in industry. While learning about the differences between several supervised learning algorithms for classification, we will also develop an appreci - ation of their individual strengths and weaknesses. In addition, we will take our first steps with the scikit-learn library, which offers a user-friendly and consistent interface for using those algorithms efficiently and productively. The topics that will be covered throughout this chapter are as follows: • An introduction to robust and popular algorithms for classification, such as logistic regression, support vector machines, decision trees, and k-nearest neighbors • Examples and explanations using the scikit-learn machine learning library, which provides a wide variety of machine learning algorithms via a user-friendly Python API • Discussions about the strengths and weaknesses of classifiers with linear and nonlinear de - cision boundaries Choosing a classification algorithm Choosing an appropriate classification", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 65, "start_word": 20800, "end_word": 21200, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000066": {"text": "will be covered throughout this chapter are as follows: • An introduction to robust and popular algorithms for classification, such as logistic regression, support vector machines, decision trees, and k-nearest neighbors • Examples and explanations using the scikit-learn machine learning library, which provides a wide variety of machine learning algorithms via a user-friendly Python API • Discussions about the strengths and weaknesses of classifiers with linear and nonlinear de - cision boundaries Choosing a classification algorithm Choosing an appropriate classification algorithm for a particular problem task requires practice and experience; each algorithm has its own quirks and is based on certain assumptions. To paraphrase the no free lunch theorem by David H. Wolpert, no single classifier works best across all possible scenarios (The Lack of A Priori Distinctions Between Learning Algorithms, Wolpert, David H, Neural Computation 8.7 (1996): 1341-1390). In practice, it is always recommended that you compare the performance of at least a handful of different learning algorithms to select the best model for the particular problem; these may differ in the number of features or examples, the amount of noise in a dataset, and whether the classes are linearly separable. A Tour of Machine Learning Classifiers Using Scikit-Learn 54 Eventually, the performance of a classifier—computational performance as well as predictive pow - er—depends heavily on the underlying data that is available for learning. The five main steps that are involved in training a supervised machine learning algorithm can be summarized as follows: 1. Selecting features and collecting labeled training examples 2. Choosing a performance metric 3. Choosing a learning algorithm and training a model 4. Evaluating the performance of the model 5. Changing the settings of the algorithm and tuning the model. Since the approach of this book is to build machine learning knowledge step by step, we will mainly focus on the main concepts of the different algorithms in this chapter and revisit topics such as feature selection and preprocessing, performance metrics, and hyperparameter tuning for more detailed discussions later in the book. First steps with scikit-learn – training a perceptron In Chapter 2, Training Simple Machine Learning Algorithms for Classification, you learned about two relat - ed learning algorithms for classification, the perceptron rule and Adaline, which we implemented in Python and NumPy by ourselves. Now we will take a look at the scikit-learn API, which, as mentioned, combines a user-friendly and consistent interface with a", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 66, "start_word": 21120, "end_word": 21520, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000067": {"text": "selection and preprocessing, performance metrics, and hyperparameter tuning for more detailed discussions later in the book. First steps with scikit-learn – training a perceptron In Chapter 2, Training Simple Machine Learning Algorithms for Classification, you learned about two relat - ed learning algorithms for classification, the perceptron rule and Adaline, which we implemented in Python and NumPy by ourselves. Now we will take a look at the scikit-learn API, which, as mentioned, combines a user-friendly and consistent interface with a highly optimized implementation of several classification algorithms. The scikit-learn library offers not only a large variety of learning algorithms, but also many convenient functions to preprocess data and to fine-tune and evaluate our models. We will discuss this in more detail, together with the underlying concepts, in Chapter 4, Building Good Training Datasets – Data Preprocessing, and Chapter 5, Compressing Data via Dimensionality Reduction. To get started with the scikit-learn library, we will train a perceptron model similar to the one that we implemented in Chapter 2. For simplicity, we will use the already familiar Iris dataset throughout the following sections. Conveniently, the Iris dataset is already available via scikit-learn, since it is a simple yet popular dataset that is frequently used for testing and experimenting with algorithms. Similar to the previous chapter, we will only use two features from the Iris dataset for visualization purposes. We will assign the petal length and petal width of the 150 flower examples to the feature matrix, X, and the corresponding class labels of the flower species to the vector array, y: >>> from sklearn import datasets >>> import numpy as np >>> iris = datasets.load_iris() >>> X = iris.data[:, [ 2, 3]] >>> y = iris.target Chapter 3 55 >>> print('Class labels:' , np.unique(y)) Class labels: [0 1 2] The np.unique(y) function returned the three unique class labels stored in iris.target , and as we can see, the Iris flower class names, Iris-setosa , Iris-versicolor , and Iris-virginica , are already stored as integers (here: 0, 1, 2). Although many scikit-learn functions and class methods also work with class labels in string format, using integer labels is a recommended approach to avoid technical glitches and improve computational performance due to a smaller memory footprint; furthermore, encoding class labels as integers is a common convention among most machine learning libraries. To evaluate how well a trained model performs on unseen data, we will", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 67, "start_word": 21440, "end_word": 21840, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000068": {"text": "Iris-setosa , Iris-versicolor , and Iris-virginica , are already stored as integers (here: 0, 1, 2). Although many scikit-learn functions and class methods also work with class labels in string format, using integer labels is a recommended approach to avoid technical glitches and improve computational performance due to a smaller memory footprint; furthermore, encoding class labels as integers is a common convention among most machine learning libraries. To evaluate how well a trained model performs on unseen data, we will further split the dataset into separate training and test datasets. In Chapter 6, Learning Best Practices for Model Evaluation and Hy- perparameter Tuning, we will discuss the best practices around model evaluation in more detail. Using the train_test_split function from scikit-learn’s model_selection module, we randomly split the X and y arrays into 30 percent test data (45 examples) and 70 percent training data (105 examples): >>> from sklearn.model_selection import train_test_split >>> X_train, X_test, y_train, y_test = train_test_split( ... X, y, test_size= 0.3, random_state= 1, stratify=y ... ) Note that the train_test_split function already shuffles the training datasets internally before split - ting; otherwise, all examples from class 0 and class 1 would have ended up in the training datasets, and the test dataset would consist of 45 examples from class 2. Via the random_state parameter, we provided a fixed random seed ( random_state=1 ) for the internal pseudo-random number generator that is used for shuffling the datasets prior to splitting. Using such a fixed random_state ensures that our results are reproducible. Lastly, we took advantage of the built-in support for stratification via stratify=y . In this context, stratification means that the train_test_split method returns training and test subsets that have the same proportions of class labels as the input dataset. We can use NumPy’s bincount function, which counts the number of occurrences of each value in an array, to verify that this is indeed the case: >>> print('Labels counts in y:' , np.bincount(y)) Labels counts in y: [50 50 50] >>> print('Labels counts in y_train:' , np.bincount(y_train)) Labels counts in y_train: [35 35 35] >>> print('Labels counts in y_test:' , np.bincount(y_test)) Labels counts in y_test: [15 15 15] A Tour of Machine Learning Classifiers Using Scikit-Learn 56 Many machine learning and optimization algorithms also require feature scaling for optimal perfor - mance, as we saw in the gradient descent example in Chapter 2. Here, we will standardize the features using", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 68, "start_word": 21760, "end_word": 22160, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000069": {"text": "y:' , np.bincount(y)) Labels counts in y: [50 50 50] >>> print('Labels counts in y_train:' , np.bincount(y_train)) Labels counts in y_train: [35 35 35] >>> print('Labels counts in y_test:' , np.bincount(y_test)) Labels counts in y_test: [15 15 15] A Tour of Machine Learning Classifiers Using Scikit-Learn 56 Many machine learning and optimization algorithms also require feature scaling for optimal perfor - mance, as we saw in the gradient descent example in Chapter 2. Here, we will standardize the features using the StandardScaler class from scikit-learn’s preprocessing module: >>> from sklearn.preprocessing import StandardScaler >>> sc = StandardScaler() >>> sc.fit(X_train) >>> X_train_std = sc.transform(X_train) >>> X_test_std = sc.transform(X_test) Using the preceding code, we loaded the StandardScaler class from the preprocessing module and initialized a new StandardScaler object that we assigned to the sc variable. Using the fit method, StandardScaler estimated the parameters, 𝜇𝜇 (sample mean) and 𝜎𝜎 (standard deviation), for each feature dimension from the training data. By calling the transform method, we then standardized the training data using those estimated parameters, 𝜇𝜇 and 𝜎𝜎 . Note that we used the same scaling parameters to standardize the test dataset so that both the values in the training and test dataset are comparable with one another. Having standardized the training data, we can now train a perceptron model. Most algorithms in scikit-learn already support multiclass classification by default via the one-versus-rest (OvR ) method, which allows us to feed the three flower classes to the perceptron all at once. The code is as follows: >>> from sklearn.linear_model import Perceptron >>> ppn = Perceptron(eta0= 0.1, random_state= 1) >>> ppn.fit(X_train_std, y_train) The scikit-learn interface will remind you of our perceptron implementation in Chapter 2. After load- ing the Perceptron class from the linear_model module, we initialized a new Perceptron object and trained the model via the fit method. Here, the model parameter, eta0 , is equivalent to the learning rate, eta, that we used in our own perceptron implementation. As you will remember from Chapter 2, finding an appropriate learning rate requires some experimen- tation. If the learning rate is too large, the algorithm will overshoot the global loss minimum. If the learning rate is too small, the algorithm will require more epochs until convergence, which can make the learning slow—especially for large datasets. Also, we used the random_state parameter to ensure the reproducibility of the initial shuffling of the training dataset after each epoch.", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 69, "start_word": 22080, "end_word": 22480, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000070": {"text": "our own perceptron implementation. As you will remember from Chapter 2, finding an appropriate learning rate requires some experimen- tation. If the learning rate is too large, the algorithm will overshoot the global loss minimum. If the learning rate is too small, the algorithm will require more epochs until convergence, which can make the learning slow—especially for large datasets. Also, we used the random_state parameter to ensure the reproducibility of the initial shuffling of the training dataset after each epoch. Having trained a model in scikit-learn, we can make predictions via the predict method, just like in our own perceptron implementation in Chapter 2. The code is as follows: >>> y_pred = ppn.predict(X_test_std) >>> print('Misclassified examples: %d' % (y_test != y_pred). sum()) Misclassified examples: 1 Executing the code, we can see that the perceptron misclassifies 1 out of the 45 flower examples. Thus, the misclassification error on the test dataset is approximately 0.022, or 2.2 percent (1 45≈ 0.022 ). Chapter 3 57 Note that scikit-learn also implements a large variety of different performance metrics that are available via the metrics module. For example, we can calculate the classification accuracy of the perceptron on the test dataset as follows: >>> from sklearn.metrics import accuracy_score >>> print('Accuracy: %.3f' % accuracy_score(y_test, y_pred)) Accuracy: 0.978 Here, y_test is the true class labels and y_pred is the class labels that we predicted previously. Alter - natively, each classifier in scikit-learn has a score method, which computes a classifier’s prediction accuracy by combining the predict call with accuracy_score , as shown here: >>> print('Accuracy: %.3f' % ppn.score(X_test_std, y_test)) Accuracy: 0.978 Finally, we can use our plot_decision_regions function from Chapter 2 to plot the decision regions of our newly trained perceptron model and visualize how well it separates the different flower exam- ples. However, let’s add a small modification to highlight the data instances from the test dataset via small circles: from matplotlib.colors import ListedColormap import matplotlib.pyplot as plt def plot_decision_regions (X, y, classifier, test_idx= None, resolution= 0.02): # setup marker generator and color map markers = ( 'o', 's', '^', 'v', '<') colors = ( 'red', 'blue' , 'lightgreen' , 'gray' , 'cyan' ) cmap = ListedColormap(colors[: len(np.unique(y))])Classification error versus accuracy Instead of the misclassification error, many machine learning practitioners report the classification accuracy of a model, which is simply calculated as follows: 1–error = 0.978, or 97.8 percent Whether we use the classification error", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 70, "start_word": 22400, "end_word": 22800, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000071": {"text": "matplotlib.pyplot as plt def plot_decision_regions (X, y, classifier, test_idx= None, resolution= 0.02): # setup marker generator and color map markers = ( 'o', 's', '^', 'v', '<') colors = ( 'red', 'blue' , 'lightgreen' , 'gray' , 'cyan' ) cmap = ListedColormap(colors[: len(np.unique(y))])Classification error versus accuracy Instead of the misclassification error, many machine learning practitioners report the classification accuracy of a model, which is simply calculated as follows: 1–error = 0.978, or 97.8 percent Whether we use the classification error or accuracy is merely a matter of preference. Overfitting Note that we will evaluate the performance of our models based on the test dataset in this chapter. In Chapter 6, you will learn about useful techniques, including graphical analysis, such as learning curves, to detect and prevent overfitting. Overfitting, which we will return to later in this chapter, means that the model captures the patterns in the training data well but fails to generalize well to unseen data. A Tour of Machine Learning Classifiers Using Scikit-Learn 58 # plot the decision surface x1_min, x1_max = X[:, 0].min() - 1, X[:, 0].max() + 1 x2_min, x2_max = X[:, 1].min() - 1, X[:, 1].max() + 1 xx1, xx2 = np.meshgrid(np.arange(x1_min, x1_max, resolution), np.arange(x2_min, x2_max, resolution)) lab = classifier.predict(np.array([xx1.ravel(), xx2.ravel()]).T) lab = lab.reshape(xx1.shape) plt.contourf(xx1, xx2, lab, alpha= 0.3, cmap=cmap) plt.xlim(xx1. min(), xx1. max()) plt.ylim(xx2. min(), xx2. max()) # plot class examples for idx, cl in enumerate (np.unique(y)): plt.scatter(x=X[y == cl, 0], y=X[y == cl, 1], alpha= 0.8, c=colors[idx], marker=markers[idx], label= f'Class {cl}', edgecolor= 'black') # highlight test examples if test_idx: # plot all examples X_test, y_test = X[test_idx, :], y[test_idx] plt.scatter(X_test[:, 0], X_test[:, 1], c= 'none', edgecolor= 'black', alpha= 1.0, linewidth= 1, marker= 'o', s= 100, label= 'Test set' ) With the slight modification that we made to the plot_decision_regions function, we can now specify the indices of the examples that we want to mark on the resulting plots. The code is as follows: >>> X_combined_std = np.vstack((X_train_std, X_test_std)) >>> y_combined = np.hstack((y_train, y_test)) >>> plot_decision_regions(X=X_combined_std, ... y=y_combined, ... classifier=ppn, ... test_idx= range(105, 150)) >>> plt.xlabel( 'Petal length [standardized]' ) >>> plt.ylabel( 'Petal width [standardized]' ) >>> plt.legend(loc= 'upper left' ) >>> plt.tight_layout() >>> plt.show() Chapter 3 59 As we can see in the resulting plot, the three flower classes can’t be perfectly separated by a linear decision boundary: Figure 3.1: Decision boundaries of a multi-class perceptron model fitted to the Iris dataset", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 71, "start_word": 22720, "end_word": 23120, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000072": {"text": "follows: >>> X_combined_std = np.vstack((X_train_std, X_test_std)) >>> y_combined = np.hstack((y_train, y_test)) >>> plot_decision_regions(X=X_combined_std, ... y=y_combined, ... classifier=ppn, ... test_idx= range(105, 150)) >>> plt.xlabel( 'Petal length [standardized]' ) >>> plt.ylabel( 'Petal width [standardized]' ) >>> plt.legend(loc= 'upper left' ) >>> plt.tight_layout() >>> plt.show() Chapter 3 59 As we can see in the resulting plot, the three flower classes can’t be perfectly separated by a linear decision boundary: Figure 3.1: Decision boundaries of a multi-class perceptron model fitted to the Iris dataset However, remember from our discussion in Chapter 2 that the perceptron algorithm never converges on datasets that aren’t perfectly linearly separable, which is why the use of the perceptron algorithm is typically not recommended in practice. In the following sections, we will look at more powerful linear classifiers that converge to a loss minimum even if the classes are not perfectly linearly separable. Modeling class probabilities via logistic regression Although the perceptron rule offers a nice and easy-going introduction to machine learning algorithms for classification, its biggest disadvantage is that it never converges if the classes are not perfectly lin- early separable. The classification task in the previous section would be an example of such a scenario. The reason for this is that the weights are continuously being updated since there is always at least one misclassified training example present in each epoch. Of course, you can change the learning rate and increase the number of epochs, but be warned that the perceptron will never converge on this dataset. To make better use of our time, we will now take a look at another simple, yet more powerful, algo - rithm for linear and binary classification problems: logistic regression. Note that, despite its name, logistic regression is a model for classification, not regression.Additional perceptron settings The Perceptron , as well as other scikit-learn functions and classes, often has additional parameters that we omit for clarity. You can read more about those parameters using the help function in Python (for instance, help(Perceptron) ) or by going through the excellent scikit-learn online documentation at http://scikit-learn.org/stable/ . A Tour of Machine Learning Classifiers Using Scikit-Learn 60 Logistic regression and conditional probabilities Logistic regression is a classification model that is very easy to implement and performs very well on linearly separable classes. It is one of the most widely used algorithms for classification in industry. Similar to the perceptron and Adaline, the logistic regression", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 72, "start_word": 23040, "end_word": 23440, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000073": {"text": "those parameters using the help function in Python (for instance, help(Perceptron) ) or by going through the excellent scikit-learn online documentation at http://scikit-learn.org/stable/ . A Tour of Machine Learning Classifiers Using Scikit-Learn 60 Logistic regression and conditional probabilities Logistic regression is a classification model that is very easy to implement and performs very well on linearly separable classes. It is one of the most widely used algorithms for classification in industry. Similar to the perceptron and Adaline, the logistic regression model in this chapter is also a linear model for binary classification. To explain the main mechanics behind logistic regression as a probabilistic model for binary classi- fication, let’s first introduce the odds: the odds in favor of a particular event. The odds can be written as 𝑝𝑝 (1−𝑝𝑝) , where p stands for the probability of the positive event. The term “positive event” does not necessarily mean “good,” but refers to the event that we want to predict, for example, the probability that a patient has a certain disease given certain symptoms; we can think of the positive event as class label y = 1 and the symptoms as features x. Hence, for brevity, we can define the probability p as p := p(y = 1|x), the conditional probability that a particular example belongs to a certain class 1 given its features, x. We can then further define the logit function, which is simply the logarithm of the odds (log-odds): logit(𝑝𝑝)= log𝑝𝑝 (1−𝑝𝑝) Note that log refers to the natural logarithm, as it is the common convention in computer science. The logit function takes input values in the range 0 to 1 and transforms them into values over the entire real-number range. Under the logistic model, we assume that there is a linear relationship between the weighted inputs (referred to as net inputs in Chapter 2) and the log-odds: logit(𝑝𝑝)=𝑤𝑤1𝑥𝑥1+⋯+𝑤𝑤 𝑚𝑚𝑥𝑥𝑚𝑚+𝑏𝑏=𝑏𝑤𝑤𝑗𝑗𝑥𝑥𝑗𝑗+𝑏𝑏 𝑖𝑖𝑖𝑗𝑗=𝒘𝒘𝑇𝑇𝒙𝒙+𝑏𝑏 While the preceding describes an assumption we make about the linear relationship between the log-odds and the net inputs, what we are actually interested in is the probability p, the class-member - ship probability of an example given its features. While the logit function maps the probability to a real-number range, we can consider the inverse of this function to map the real-number range back to a [0, 1] range for the probability p.Logistic regression for multiple classes Note that logistic regression can be readily generalized to", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 73, "start_word": 23360, "end_word": 23760, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000074": {"text": "make about the linear relationship between the log-odds and the net inputs, what we are actually interested in is the probability p, the class-member - ship probability of an example given its features. While the logit function maps the probability to a real-number range, we can consider the inverse of this function to map the real-number range back to a [0, 1] range for the probability p.Logistic regression for multiple classes Note that logistic regression can be readily generalized to multiclass settings, which is known as multinomial logistic regression, or softmax regression. More detailed coverage of multinomial logistic regression is outside the scope of this book, but the interested read - er can find more information in my lecture notes at https://sebastianraschka.com/ pdf/lecture-notes/stat453ss21/L08_logistic__slides.pdf or https://youtu. be/L0FU8NFpx4E . Another way to use logistic regression in multiclass settings is via the OvR technique, which we discussed previously. Chapter 3 61 This inverse of the logit function is typically called the logistic sigmoid function, which is sometimes simply abbreviated to sigmoid function due to its characteristic S-shape: 𝜎𝜎(𝑧𝑧)=1 1+𝑒𝑒−𝑧𝑧 Here, z is the net input, the linear combination of weights, and the inputs (that is, the features asso - ciated with the training examples): z = wTx + b Now, let’s simply plot the sigmoid function for some values in the range –7 to 7 to see how it looks: >>> import matplotlib.pyplot as plt >>> import numpy as np >>> def sigmoid (z): ... return 1.0 / (1.0 + np.exp(-z)) >>> z = np.arange(- 7, 7, 0.1 ) >>> sigma_z = sigmoid(z) >>> plt.plot(z, sigma_z) >>> plt.axvline( 0.0, color= 'k') >>> plt.ylim(- 0.1, 1.1) >>> plt.xlabel( 'z') >>> plt.ylabel( '$\\sigma (z)$' ) >>> # y axis ticks and gridline >>> plt.yticks([ 0.0, 0.5, 1.0]) >>> ax = plt.gca() >>> ax.yaxis.grid( True) >>> plt.tight_layout() >>> plt.show() As a result of executing the previous code example, we should now see the S-shaped (sigmoidal) curve: Figure 3.2: A plot of the logistic sigmoid function A Tour of Machine Learning Classifiers Using Scikit-Learn 62 We can see that 𝜎𝜎(𝑧𝑧) approaches 1 if z goes toward infinity (z →∞) since e–z becomes very small for large values of z. Similarly, 𝜎𝜎(𝑧𝑧) goes toward 0 for z→–∞ as a result of an increasingly large denominator. Thus, we can conclude that this sigmoid function takes real-number values as input and transforms them into values in the range [0, 1]", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 74, "start_word": 23680, "end_word": 24080, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000075": {"text": "Figure 3.2: A plot of the logistic sigmoid function A Tour of Machine Learning Classifiers Using Scikit-Learn 62 We can see that 𝜎𝜎(𝑧𝑧) approaches 1 if z goes toward infinity (z →∞) since e–z becomes very small for large values of z. Similarly, 𝜎𝜎(𝑧𝑧) goes toward 0 for z→–∞ as a result of an increasingly large denominator. Thus, we can conclude that this sigmoid function takes real-number values as input and transforms them into values in the range [0, 1] with an intercept at 𝜎𝜎(0)= 0.5 . To build some understanding of the logistic regression model, we can relate it to Chapter 2. In Adaline, we used the identity function, 𝜎𝜎(𝑧𝑧)=𝑧𝑧 , as the activation function. In logistic regression, this activation function simply becomes the sigmoid function that we defined earlier. The difference between Adaline and logistic regression is illustrated in the following figure, where the only difference is the activation function: Figure 3.3: Logistic regression compared to Adaline The output of the sigmoid function is then interpreted as the probability of a particular ex - ample belonging to class 1, 𝜎𝜎(𝑧𝑧)=𝑝𝑝(𝑦𝑦=𝑦|𝒙𝒙𝒙𝒙𝒙𝒙𝒙𝒙) , given its features, x , and parameterized by the weights and bias, w and b. For example, if we compute 𝜎𝜎(𝑧𝑧)= 0.8 for a particular flow - er example, it means that the chance that this example is an Iris-versicolor flower is 80 per - cent. Therefore, the probability that this flower is an Iris-setosa flower can be calculated as p(y = 0|x; w, b) = 1 – p(y = 1|x; w, b) = 0.2, or 20 percent. Chapter 3 63 The predicted probability can then simply be converted into a binary outcome via a threshold function: 𝑦𝑦𝑦 𝑦 𝑦1if 𝜎𝜎(𝑧𝑧)≥ 0.5 0 otherwise If we look at the preceding plot of the sigmoid function, this is equivalent to the following: 𝑦𝑦𝑦 𝑦 𝑦1if 𝑧𝑧 𝑧 𝑧𝑧𝑧 𝑧otherwise In fact, there are many applications where we are not only interested in the predicted class labels, but where the estimation of the class-membership probability is particularly useful (the output of the sigmoid function prior to applying the threshold function). Logistic regression is used in weather forecasting, for example, not only to predict whether it will rain on a particular day, but also to report the chance of rain. Similarly, logistic regression can be used to predict the chance that a patient has a particular disease given certain symptoms,", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 75, "start_word": 24000, "end_word": 24400, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000076": {"text": "not only interested in the predicted class labels, but where the estimation of the class-membership probability is particularly useful (the output of the sigmoid function prior to applying the threshold function). Logistic regression is used in weather forecasting, for example, not only to predict whether it will rain on a particular day, but also to report the chance of rain. Similarly, logistic regression can be used to predict the chance that a patient has a particular disease given certain symptoms, which is why logistic regression enjoys great popularity in the field of medicine. Learning the model weights via the logistic loss function You have learned how we can use the logistic regression model to predict probabilities and class labels; now, let’s briefly talk about how we fit the parameters of the model, for instance, the weights and bias unit, w and b. In the previous chapter, we defined the mean squared error loss function as follows: 𝐿𝐿(𝒘𝒘𝒘𝒘𝒘|𝒙𝒙)=∑1 2(𝜎𝜎(𝜎𝜎(𝑖𝑖))−𝑦𝑦(𝑖𝑖))2 𝑖𝑖 We minimized this function in order to learn the parameters for our Adaline classification model. To explain how we can derive the loss function for logistic regression, let’s first define the likelihood, ℒ , that we want to maximize when we build a logistic regression model, assuming that the individual examples in our dataset are independent of one another. The formula is as follows: ℒ(𝒘𝒘𝒘𝒘𝒘|𝒙𝒙)=𝑝𝑝(𝑦𝑦|𝒙𝒙𝒙𝒘𝒘𝒘𝒘𝒘)= ∏𝑝𝑝𝑝𝑦𝑦(𝑖𝑖)|𝒙𝒙(𝑖𝑖)𝒙𝒘𝒘𝒘𝒘𝒘𝒘𝑛𝑛 𝑖𝑖𝑖𝑖= ∏𝑝𝜎𝜎𝑝𝜎𝜎(𝑖𝑖)𝒘𝒘𝑦𝑦(𝑖𝑖) 𝑝1−𝜎𝜎𝑝𝜎𝜎(𝑖𝑖)𝒘𝒘𝑖−𝑦𝑦(𝑖𝑖)𝑛𝑛 𝑖𝑖𝑖𝑖 In practice, it is easier to maximize the (natural) log of this equation, which is called the log-likelihood function: 𝑙𝑙(𝒘𝒘𝒘𝒘𝒘|𝒙𝒙)= logℒ(𝒘𝒘𝒘𝒘𝒘|𝒙𝒙)= ∑[𝑦𝑦(𝑖𝑖)log(𝜎𝜎(𝜎𝜎(𝑖𝑖)))+(1−𝑦𝑦(𝑖𝑖))log(1−𝜎𝜎 (𝜎𝜎(𝑖𝑖)))] 𝑖𝑖𝑖𝑖 Firstly, applying the log function reduces the potential for numerical underflow, which can occur if the likelihoods are very small. Secondly, we can convert the product of factors into a summation of factors, which makes it easier to obtain the derivative of this function via the addition trick, as you may remember from calculus. A Tour of Machine Learning Classifiers Using Scikit-Learn 64 Now, we could use an optimization algorithm such as gradient ascent to maximize this log-likelihood function. (Gradient ascent works exactly the same way as gradient descent explained in Chapter 2, except that gradient ascent maximizes a function instead of minimizing it.) Alternatively, let’s rewrite the log-likelihood as a loss function, L, that can be minimized using gradient descent as in Chapter 2: 𝐿𝐿(𝒘𝒘𝒘𝒘𝒘)= ∑[−𝑦𝑦(𝑖𝑖)log(𝜎𝜎(𝜎𝜎(𝑖𝑖)))−(1−𝑦𝑦(𝑖𝑖))log(1−𝜎𝜎 (𝜎𝜎(𝑖𝑖)))]𝑛𝑛 𝑖𝑖𝑖𝑖 To get a better grasp of this loss function, let’s take a look at the loss that we", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 76, "start_word": 24320, "end_word": 24720, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000077": {"text": "an optimization algorithm such as gradient ascent to maximize this log-likelihood function. (Gradient ascent works exactly the same way as gradient descent explained in Chapter 2, except that gradient ascent maximizes a function instead of minimizing it.) Alternatively, let’s rewrite the log-likelihood as a loss function, L, that can be minimized using gradient descent as in Chapter 2: 𝐿𝐿(𝒘𝒘𝒘𝒘𝒘)= ∑[−𝑦𝑦(𝑖𝑖)log(𝜎𝜎(𝜎𝜎(𝑖𝑖)))−(1−𝑦𝑦(𝑖𝑖))log(1−𝜎𝜎 (𝜎𝜎(𝑖𝑖)))]𝑛𝑛 𝑖𝑖𝑖𝑖 To get a better grasp of this loss function, let’s take a look at the loss that we calculate for one single training example: 𝐿𝐿(𝜎𝜎(𝑧𝑧),𝑦𝑦𝑦𝑦𝑦,𝑦𝑦)= −𝑦𝑦𝑦𝑦𝑦 (𝜎𝜎(𝑧𝑧))−(1−𝑦𝑦)𝑦𝑦𝑦(1−𝜎𝜎(𝑧𝑧)) Looking at the equation, we can see that the first term becomes zero if y = 0, and the second term becomes zero if y = 1: 𝐿𝐿(𝜎𝜎(𝑧𝑧),𝑦𝑦 𝑦𝑦𝑦 ,𝑦𝑦)={− log (𝜎𝜎(𝑧𝑧)) if 𝑦𝑦=𝑦 − log (𝑦−𝜎𝜎 (𝑧𝑧)) if 𝑦𝑦=𝑦 Deriving the likelihood function We can obtain the expression for the likelihood of the model given the data, ℒ(𝐰𝐰𝐰𝐰𝐰𝐰|𝐰𝐱𝐱) , as follows. Given that we have a binary classification problem with class labels 0 and 1, we can think of the label 1 as a Bernoulli variable—it can take on two values, 0 and 1, with the probability p of being 1: 𝑌𝑌𝑌𝑌𝑌𝑌𝑌𝑌𝑌𝑌𝑌𝑌𝑌𝑌𝑌 . For a single data point, we can write this probability as 𝑃𝑃𝑃𝑃𝑃 𝑃 𝑃𝑃𝑃𝑃𝑃𝑃 𝑃 𝑃(𝑖𝑖𝑖)𝑃𝜎𝜎𝑃𝜎𝜎(𝑖𝑖𝑖) and 𝑃𝑃𝑃𝑃𝑃 𝑃 𝑃𝑃𝑃𝑃𝑃𝑃 𝑃 𝑃(𝑖𝑖𝑖)𝑃1−𝜎𝜎𝑃𝜎𝜎(𝑖𝑖𝑖) . Putting these two expressions together, and using the shorthand 𝑃𝑃𝑃𝑃𝑃 𝑃 𝑃𝑃(𝑖𝑖𝑖 | 𝑋𝑋 𝑃𝑋(𝑖𝑖𝑖)𝑃𝑝𝑝𝑃𝑃𝑃(𝑖𝑖𝑖 | 𝑋(𝑖𝑖𝑖) , we get the probability mass function of the Bernoul- li variable: 𝑝𝑝𝑝𝑝𝑝(𝑖𝑖𝑖 | x(𝑖𝑖𝑖)= (𝜎𝜎𝑝𝜎𝜎(𝑖𝑖𝑖))𝑦𝑦(𝑖𝑖𝑖 (1 − 𝜎𝜎 𝑝𝜎𝜎(𝑖𝑖𝑖))1−𝑦𝑦(𝑖𝑖𝑖 We can write the likelihood of the training labels given the assumption that all training examples are independent, using the multiplication rule to compute the probability that all events occur, as follows: ℒ(𝐰𝐰𝐰𝐰𝐰𝐰|𝐰𝐱𝐱)= ∏𝑝𝑝𝑝𝑝𝑝(𝑖𝑖)𝐰|𝐰𝐱𝐱(𝑖𝑖);𝐰𝐰𝐰𝐰𝐰𝐰𝑛𝑛 𝑖𝑖𝑖𝑖 Now, substituting the probability mass function of the Bernoulli variable, we arrive at the expression of the likelihood, which we attempt to maximize by changing the model parameters: ℒ(𝐰𝐰𝐰𝐰𝐰𝐰|𝐰𝐱𝐱)=∏(𝜎𝜎𝜎𝜎𝜎(𝑖𝑖)))𝑦𝑦(𝑖𝑖) (1−𝜎𝜎𝜎𝜎𝜎(𝑖𝑖)))1−𝑦𝑦(𝑖𝑖)𝑛𝑛 𝑖𝑖𝑖1 Chapter 3 65 Let’s write a short code snippet to create a plot that illustrates the loss of classifying a single training example for different values of 𝜎𝜎(𝑧𝑧) : >>> def loss_1(z): ... return - np.log(sigmoid(z)) >>> def loss_0(z): ... return - np.log( 1 - sigmoid(z)) >>> z = np.arange(- 10, 10, 0.1 ) >>> sigma_z = sigmoid(z) >>> c1 = [loss_1(x) for x in z] >>> plt.plot(sigma_z, c1, label= 'L(w, b) if y=1' ) >>> c0 = [loss_0(x) for x", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 77, "start_word": 24640, "end_word": 25040, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000078": {"text": "3 65 Let’s write a short code snippet to create a plot that illustrates the loss of classifying a single training example for different values of 𝜎𝜎(𝑧𝑧) : >>> def loss_1(z): ... return - np.log(sigmoid(z)) >>> def loss_0(z): ... return - np.log( 1 - sigmoid(z)) >>> z = np.arange(- 10, 10, 0.1 ) >>> sigma_z = sigmoid(z) >>> c1 = [loss_1(x) for x in z] >>> plt.plot(sigma_z, c1, label= 'L(w, b) if y=1' ) >>> c0 = [loss_0(x) for x in z] >>> plt.plot(sigma_z, c0, linestyle= '--', label= 'L(w, b) if y=0' ) >>> plt.ylim( 0.0, 5.1) >>> plt.xlim([ 0, 1]) >>> plt.xlabel( '$\\sigma(z)$' ) >>> plt.ylabel( 'L(w, b)' ) >>> plt.legend(loc= 'best') >>> plt.tight_layout() >>> plt.show() The resulting plot shows the sigmoid activation on the x axis in the range 0 to 1 (the inputs to the sigmoid function were z values in the range –10 to 10) and the associated logistic loss on the y axis: Figure 3.4: A plot of the loss function used in logistic regression We can see that the loss approaches 0 (continuous line) if we correctly predict that an example belongs to class 1. Similarly, we can see on the y axis that the loss also approaches 0 if we correctly predict y = 0 (dashed line). However, if the prediction is wrong, the loss goes toward infinity. The main point is that we penalize wrong predictions with an increasingly larger loss. A Tour of Machine Learning Classifiers Using Scikit-Learn 66 Converting an Adaline implementation into an algorithm for logistic regression If we were to implement logistic regression ourselves, we could simply substitute the loss function, L, in our Adaline implementation from Chapter 2, with the new loss function: 𝐿𝐿(𝒘𝒘𝒘𝒘𝒘)=1 𝑛𝑛∑[−𝑦𝑦(𝑖𝑖)log(𝜎𝜎(𝜎𝜎(𝑖𝑖)))−(1−𝑦𝑦(𝑖𝑖))log(1−𝜎𝜎 (𝜎𝜎(𝑖𝑖)))]𝑛𝑛 𝑖𝑖𝑖𝑖 We use this to compute the loss of classifying all training examples per epoch. Also, we need to swap the linear activation function with the sigmoid. If we make those changes to the Adaline code, we will end up with a working logistic regression implementation. The following is an implementation for full-batch gradient descent (but note that the same changes could be made to the stochastic gradient descent version as well): class LogisticRegressionGD : \"\"\"Gradient descent-based logistic regression classifier. Parameters ------------ eta : float Learning rate (between 0.0 and 1.0) n_iter : int Passes over the training dataset. random_state : int Random number generator seed for random weight initialization. Attributes", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 78, "start_word": 24960, "end_word": 25360, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000079": {"text": "changes to the Adaline code, we will end up with a working logistic regression implementation. The following is an implementation for full-batch gradient descent (but note that the same changes could be made to the stochastic gradient descent version as well): class LogisticRegressionGD : \"\"\"Gradient descent-based logistic regression classifier. Parameters ------------ eta : float Learning rate (between 0.0 and 1.0) n_iter : int Passes over the training dataset. random_state : int Random number generator seed for random weight initialization. Attributes ----------- w_ : 1d-array Weights after training. b_ : Scalar Bias unit after fitting. losses_ : list Mean squared error loss function values in each epoch. \"\"\" def __init__(self, eta= 0.01, n_iter= 50, random_state= 1): self.eta = eta self.n_iter = n_iter self.random_state = random_state Chapter 3 67 def fit(self, X, y): \"\"\" Fit training data. Parameters ---------- X : {array-like}, shape = [n_examples, n_features] Training vectors, where n_examples is the number of examples and n_features is the number of features. y : array-like, shape = [n_examples] Target values. Returns ------- self : Instance of LogisticRegressionGD \"\"\" rgen = np.random.RandomState(self.random_state) self.w_ = rgen.normal(loc= 0.0, scale= 0.01, size=X.shape[ 1]) self.b_ = np.float_( 0.) self.losses_ = [] for i in range (self.n_iter): net_input = self.net_input(X) output = self.activation(net_input) errors = (y - output) self.w_ += self.eta * 2.0 * X.T.dot(errors) / X.shape[ 0] self.b_ += self.eta * 2.0 * errors.mean() loss = (-y.dot(np.log(output)) - (( 1 - y).dot(np.log( 1 - output))) / X.shape[ 0]) self.losses_.append(loss) return self def net_input (self, X): \"\"\"Calculate net input\"\"\" return np.dot(X, self.w_) + self.b_ def activation (self, z): \"\"\"Compute logistic sigmoid activation\"\"\" return 1. / (1. + np.exp(-np.clip(z, - 250, 250))) A Tour of Machine Learning Classifiers Using Scikit-Learn 68 def predict (self, X): \"\"\"Return class label after unit step\"\"\" return np.where(self.activation(self.net_input(X)) >= 0.5, 1, 0) When we fit a logistic regression model, we have to keep in mind that it only works for binary clas- sification tasks. So, let’s consider only setosa and versicolor flowers (classes 0 and 1) and check that our implemen- tation of logistic regression works: >>> X_train_01_subset = X_train_std[(y_train == 0) | (y_train == 1)] >>> y_train_01_subset = y_train[(y_train == 0) | (y_train == 1)] >>> lrgd = LogisticRegressionGD(eta= 0.3, ... n_iter= 1000, ... random_state= 1) >>> lrgd.fit(X_train_01_subset, ... y_train_01_subset) >>> plot_decision_regions(X=X_train_01_subset, ... y=y_train_01_subset, ... classifier=lrgd) >>> plt.xlabel( 'Petal length [standardized]' ) >>> plt.ylabel( 'Petal width [standardized]' ) >>> plt.legend(loc= 'upper left' )", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 79, "start_word": 25280, "end_word": 25680, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000080": {"text": "So, let’s consider only setosa and versicolor flowers (classes 0 and 1) and check that our implemen- tation of logistic regression works: >>> X_train_01_subset = X_train_std[(y_train == 0) | (y_train == 1)] >>> y_train_01_subset = y_train[(y_train == 0) | (y_train == 1)] >>> lrgd = LogisticRegressionGD(eta= 0.3, ... n_iter= 1000, ... random_state= 1) >>> lrgd.fit(X_train_01_subset, ... y_train_01_subset) >>> plot_decision_regions(X=X_train_01_subset, ... y=y_train_01_subset, ... classifier=lrgd) >>> plt.xlabel( 'Petal length [standardized]' ) >>> plt.ylabel( 'Petal width [standardized]' ) >>> plt.legend(loc= 'upper left' ) >>> plt.tight_layout() >>> plt.show() The resulting decision region plot looks as follows: Figure 3.5: The decision region plot for the logistic regression model Chapter 3 69 The gradient descent learning algorithm for logistic regression If you compared the LogisticRegressionGD in the previous code with the AdalineGD code from Chapter 2, you may have noticed that the weight and bias update rules remained unchanged (except for the scaling factor 2). Using calculus, we can show that the param- eter updates via gradient descent are indeed similar for logistic regression and Adaline. However, please note that the following derivation of the gradient descent learning rule is intended for readers who are interested in the mathematical concepts behind the gra - dient descent learning rule for logistic regression. It is not essential for following the rest of this chapter. Figure 3.6 summarizes how we can calculate the partial derivative of the log-likelihood function with respect to the jth weight: Figure 3.6: Calculating the partial derivative of the log-likelihood function Note that we omitted averaging over the training examples for brevity. Remember from Chapter 2 that we take steps in the opposite direction of the gradient. Hence, we flip 𝜕𝜕𝜕𝜕 𝑤𝑤𝑗𝑗=−(𝑦𝑦−𝑦𝑦)𝑥𝑥𝑗𝑗 and update the jth weight as follows, including the learn- ing rate 𝜂𝜂 : 𝑤𝑤𝑗𝑗≔𝑤𝑤𝑗𝑗+𝜂𝜂(𝑦𝑦𝑦𝑦𝑦)𝑥𝑥𝑗𝑗 While the partial derivative of the loss function with respect to the bias unit is not shown, bias derivation follows the same overall concept using the chain rule, resulting in the following update rule: 𝑏𝑏𝑏𝑏𝑏𝑏𝑏𝑏 (𝑦𝑦𝑦𝑦𝑦) Both the weight and bias unit updates are equal to the ones for Adaline in Chapter 2. A Tour of Machine Learning Classifiers Using Scikit-Learn 70 Training a logistic regression model with scikit-learn We just went through useful coding and math exercises in the previous subsection, which helped to illustrate the conceptual differences between Adaline and logistic regression. Now, let’s learn how to use scikit-learn’s more optimized implementation of logistic regression, which", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 80, "start_word": 25600, "end_word": 26000, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000081": {"text": "resulting in the following update rule: 𝑏𝑏𝑏𝑏𝑏𝑏𝑏𝑏 (𝑦𝑦𝑦𝑦𝑦) Both the weight and bias unit updates are equal to the ones for Adaline in Chapter 2. A Tour of Machine Learning Classifiers Using Scikit-Learn 70 Training a logistic regression model with scikit-learn We just went through useful coding and math exercises in the previous subsection, which helped to illustrate the conceptual differences between Adaline and logistic regression. Now, let’s learn how to use scikit-learn’s more optimized implementation of logistic regression, which also supports multiclass settings off the shelf. Note that in recent versions of scikit-learn, the technique used for multiclass classification, multinomial, or OvR, is chosen automatically. In the following code example, we will use the sklearn.linear_model.LogisticRegression class as well as the familiar fit method to train the model on all three classes in the standardized flower training dataset. Also, we set multi_class='ovr' for illustration purposes. As an exercise for the reader, you may want to compare the results with multi_class='multinomial' . Note that the multinomial setting is now the default choice in scikit- learn’s LogisticRegression class and recommended in practice for mutually exclusive classes, such as those found in the Iris dataset. Here, “mutually exclusive” means that each training example can only belong to a single class (in contrast to multilabel classification, where a training example can be a member of multiple classes). Now, let’s have a look at the code example: >>> from sklearn.linear_model import LogisticRegression >>> lr = LogisticRegression(C= 100.0, solver= 'lbfgs', ... multi_class= 'ovr') >>> lr.fit(X_train_std, y_train) >>> plot_decision_regions(X_combined_std, ... y_combined, ... classifier=lr, ... test_idx= range(105, 150)) >>> plt.xlabel( 'Petal length [standardized]' ) >>> plt.ylabel( 'Petal width [standardized]' ) >>> plt.legend(loc= 'upper left' ) >>> plt.tight_layout() >>> plt.show() Chapter 3 71 After fitting the model on the training data, we plotted the decision regions, training examples, and test examples, as shown in Figure 3.7: Figure 3.7: Decision regions for scikit-learn’s multi-class logistic regression model Algorithms for convex optimization Note that there exist many different algorithms for solving optimization problems. For minimizing convex loss functions, such as the logistic regression loss, it is recommended to use more advanced approaches than regular stochastic gradient descent ( SGD ). In fact, scikit-learn implements a whole range of such optimization algorithms, which can be specified via the solver parameter, namely, 'newton-cg' , 'lbfgs' , 'liblinear' , 'sag' , and 'saga' . While the logistic regression loss is convex, most optimization algorithms", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 81, "start_word": 25920, "end_word": 26320, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000082": {"text": "optimization Note that there exist many different algorithms for solving optimization problems. For minimizing convex loss functions, such as the logistic regression loss, it is recommended to use more advanced approaches than regular stochastic gradient descent ( SGD ). In fact, scikit-learn implements a whole range of such optimization algorithms, which can be specified via the solver parameter, namely, 'newton-cg' , 'lbfgs' , 'liblinear' , 'sag' , and 'saga' . While the logistic regression loss is convex, most optimization algorithms should converge to the global loss minimum with ease. However, there are certain advantages of using one algorithm over the other. For example, in previous versions (for instance, v 0.21), scikit-learn used 'liblinear' as a default, which cannot handle the multinomial loss and is limited to the OvR scheme for multiclass classification. However, in scikit-learn v 0.22, the default solver was changed to 'lbfgs' , which stands for the limited-memory Broyden–Fletcher–Goldfarb–Shanno (BFGS ) algorithm (https://en.wikipedia.org/ wiki/Limited-memory_BFGS ) and is more flexible in this regard. A Tour of Machine Learning Classifiers Using Scikit-Learn 72 Looking at the preceding code that we used to train the LogisticRegression model, you might now be wondering, “What is this mysterious parameter C?” We will discuss this parameter in the next subsection, where we will introduce the concepts of overfitting and regularization. However, before we move on to those topics, let’s finish our discussion of class membership probabilities. The probability that training examples belong to a certain class can be computed using the predict_ proba method. For example, we can predict the probabilities of the first three examples in the test dataset as follows: >>> lr.predict_proba(X_test_std[: 3, :]) This code snippet returns the following array: array([[3.81527885e-09, 1.44792866e-01, 8.55207131e-01], [8.34020679e-01, 1.65979321e-01, 3.25737138e-13], [8.48831425e-01, 1.51168575e-01, 2.62277619e-14]]) The first row corresponds to the class membership probabilities of the first flower, the second row corresponds to the class membership probabilities of the second flower, and so forth. Notice that the column-wise sum in each row is 1, as expected. (You can confirm this by executing lr.predict_ proba(X_test_std[:3, :]).sum(axis=1) .) The highest value in the first row is approximately 0.85, which means that the first example belongs to class 3 ( Iris-virginica ) with a predicted probability of 85 percent. So, as you may have already noticed, we can get the predicted class labels by identifying the largest column in each row, for ex - ample, using NumPy’s argmax function: >>>", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 82, "start_word": 26240, "end_word": 26640, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000083": {"text": "column-wise sum in each row is 1, as expected. (You can confirm this by executing lr.predict_ proba(X_test_std[:3, :]).sum(axis=1) .) The highest value in the first row is approximately 0.85, which means that the first example belongs to class 3 ( Iris-virginica ) with a predicted probability of 85 percent. So, as you may have already noticed, we can get the predicted class labels by identifying the largest column in each row, for ex - ample, using NumPy’s argmax function: >>> lr.predict_proba(X_test_std[: 3, :]).argmax(axis= 1) The returned class indices are shown here (they correspond to Iris-virginica , Iris-setosa , and Iris-setosa ): array([2, 0, 0]) In the preceding code example, we computed the conditional probabilities and converted these into class labels manually by using NumPy’s argmax function. In practice, the more convenient way of obtaining class labels when using scikit-learn is to call the predict method directly: >>> lr.predict(X_test_std[: 3, :]) array([2, 0, 0]) Lastly, a word of caution if you want to predict the class label of a single flower example: scikit-learn expects a two-dimensional array as data input; thus, we have to convert a single row slice into such a format first. One way to convert a single row entry into a two-dimensional data array is to use NumPy’s reshape method to add a new dimension, as demonstrated here: >>> lr.predict(X_test_std[ 0, :].reshape( 1, -1)) array([2]) Chapter 3 73 Tackling overfitting via regularization Overfitting is a common problem in machine learning, where a model performs well on training data but does not generalize well to unseen data (test data). If a model suffers from overfitting, we also say that the model has a high variance, which can be caused by having too many parameters, leading to a model that is too complex given the underlying data. Similarly, our model can also suffer from underfitting (high bias), which means that our model is not complex enough to capture the pattern in the training data well and therefore also suffers from low performance on unseen data. Although we have only encountered linear models for classification so far, the problems of overfitting and underfitting can be best illustrated by comparing a linear decision boundary to more complex, nonlinear decision boundaries, as shown in Figure 3.8: Figure 3.8: Examples of underfitted, well-fitted, and overfitted models The bias-variance tradeoff Often, researchers use the terms “bias” and “variance” or “bias-variance tradeoff” to de - scribe", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 83, "start_word": 26560, "end_word": 26960, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000084": {"text": "in the training data well and therefore also suffers from low performance on unseen data. Although we have only encountered linear models for classification so far, the problems of overfitting and underfitting can be best illustrated by comparing a linear decision boundary to more complex, nonlinear decision boundaries, as shown in Figure 3.8: Figure 3.8: Examples of underfitted, well-fitted, and overfitted models The bias-variance tradeoff Often, researchers use the terms “bias” and “variance” or “bias-variance tradeoff” to de - scribe the performance of a model—that is, you may stumble upon talks, books, or articles where people say that a model has a “high variance” or “high bias.” So, what does that mean? In general, we might say that “high variance” is proportional to overfitting and “high bias” is proportional to underfitting. In the context of machine learning models, variance measures the consistency (or vari- ability) of the model prediction for classifying a particular example if we retrain the model multiple times, for example, on different subsets of the training dataset. We can say that the model is sensitive to the randomness in the training data. In contrast, bias measures how far off the predictions are from the correct values in general if we rebuild the model multiple times on different training datasets; bias is the measure of the systematic error that is not due to randomness. If you are interested in the technical specification and derivation of the “bias” and “variance” terms, I’ve written about it in my lecture notes here: https://sebastianraschka.com/ pdf/lecture-notes/stat451fs20/08-model-eval-1-intro__notes.pdf . A Tour of Machine Learning Classifiers Using Scikit-Learn 74 One way of finding a good bias-variance tradeoff is to tune the complexity of the model via regulariza - tion. Regularization is a very useful method for handling collinearity (high correlation among features), filtering out noise from data, and eventually preventing overfitting. The concept behind regularization is to introduce additional information to penalize extreme parameter (weight) values. The most common form of regularization is so-called L2 regularization (sometimes also called L2 shrinkage or weight decay), which can be written as follows: 𝜆𝜆 2𝑛𝑛‖𝒘𝒘‖2=𝜆𝜆 2𝑛𝑛∑𝑤𝑤𝑗𝑗2𝑚𝑚 𝑗𝑗𝑗𝑗 Here, 𝜆𝜆 is the so-called regularization parameter. Note that the 2 in the denominator is merely a scaling factor, such that it cancels when computing the loss gradient. The sample size n is added to scale the regularization term similar to the loss. The loss function for logistic regression can be regularized", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 84, "start_word": 26880, "end_word": 27280, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000085": {"text": "The most common form of regularization is so-called L2 regularization (sometimes also called L2 shrinkage or weight decay), which can be written as follows: 𝜆𝜆 2𝑛𝑛‖𝒘𝒘‖2=𝜆𝜆 2𝑛𝑛∑𝑤𝑤𝑗𝑗2𝑚𝑚 𝑗𝑗𝑗𝑗 Here, 𝜆𝜆 is the so-called regularization parameter. Note that the 2 in the denominator is merely a scaling factor, such that it cancels when computing the loss gradient. The sample size n is added to scale the regularization term similar to the loss. The loss function for logistic regression can be regularized by adding a simple regularization term, which will shrink the weights during model training: 𝐿𝐿(𝒘𝒘𝒘𝒘𝒘)=1 𝑛𝑛∑[−𝑦𝑦(𝑖𝑖)log(𝜎𝜎(𝜎𝜎(𝑖𝑖)))−(1−𝑦𝑦(𝑖𝑖))log(1−𝜎𝜎 (𝜎𝜎(𝑖𝑖)))]𝑛𝑛 𝑖𝑖𝑖𝑖+𝜆𝜆 2𝑛𝑛‖𝒘𝒘‖2 The partial derivative of the unregularized loss is defined as: 𝜕𝜕𝜕𝜕(𝒘𝒘𝒘𝒘𝒘) 𝜕𝜕𝜕𝜕𝑗𝑗=(1 𝑛𝑛∑(𝜎𝜎(𝒘𝒘𝑇𝑇𝒙𝒙(𝑖𝑖))−𝑦𝑦(𝑖𝑖))𝑥𝑥𝑗𝑗(𝑖𝑖)𝑛𝑛 𝑖𝑖𝑖𝑖) Adding the regularization term to the loss changes the partial derivative to the following form: 𝜕𝜕𝜕𝜕(𝒘𝒘𝒘𝒘𝒘) 𝜕𝜕𝜕𝜕𝑗𝑗=(1 𝑛𝑛∑(𝜎𝜎(𝒘𝒘𝑇𝑇𝒙𝒙(𝑖𝑖))−𝑦𝑦(𝑖𝑖))𝑥𝑥𝑗𝑗(𝑖𝑖)𝑛𝑛 𝑖𝑖𝑖𝑖)+𝜆𝜆 𝑛𝑛𝜕𝜕𝑗𝑗 Regularization and feature normalization Regularization is another reason why feature scaling such as standardization is import- ant. For regularization to work properly, we need to ensure that all our features are on comparable scales. Chapter 3 75 Via the regularization parameter, 𝜆𝜆 , we can then control how closely we fit the training data, while keeping the weights small. By increasing the value of 𝜆𝜆 , we increase the regularization strength. Please note that the bias unit, which is essentially an intercept term or negative threshold, as we learned in Chapter 2, is usually not regularized. The parameter, C, that is implemented for the LogisticRegression class in scikit-learn comes from a convention in support vector machines, which will be the topic of the next section. The term C is inversely proportional to the regularization parameter, 𝜆𝜆 . Consequently, decreasing the value of the inverse regularization parameter, C, means that we are increasing the regularization strength, which we can visualize by plotting the L2 regularization path for the two weight coefficients: >>> weights, params = [], [] >>> for c in np.arange(- 5, 5): ... lr = LogisticRegression(C= 10.**c, ... multi_class= 'ovr') ... lr.fit(X_train_std, y_train) ... weights.append(lr.coef_[ 1]) ... params.append( 10.**c) >>> weights = np.array(weights) >>> plt.plot(params, weights[:, 0], ... label= 'Petal length' ) >>> plt.plot(params, weights[:, 1], linestyle= '--', ... label= 'Petal width' ) >>> plt.ylabel( 'Weight coefficient' ) >>> plt.xlabel( 'C') >>> plt.legend(loc= 'upper left' ) >>> plt.xscale( 'log') >>> plt.show() By executing the preceding code, we fitted 10 logistic regression models with different values for the inverse-regularization parameter, C. For illustration purposes, we only collected", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 85, "start_word": 27200, "end_word": 27600, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000086": {"text": "10.**c, ... multi_class= 'ovr') ... lr.fit(X_train_std, y_train) ... weights.append(lr.coef_[ 1]) ... params.append( 10.**c) >>> weights = np.array(weights) >>> plt.plot(params, weights[:, 0], ... label= 'Petal length' ) >>> plt.plot(params, weights[:, 1], linestyle= '--', ... label= 'Petal width' ) >>> plt.ylabel( 'Weight coefficient' ) >>> plt.xlabel( 'C') >>> plt.legend(loc= 'upper left' ) >>> plt.xscale( 'log') >>> plt.show() By executing the preceding code, we fitted 10 logistic regression models with different values for the inverse-regularization parameter, C. For illustration purposes, we only collected the weight coefficients of class 1 (here, the second class in the dataset: Iris-versicolor ) versus all classifiers—remember that we are using the OvR technique for multiclass classification. A Tour of Machine Learning Classifiers Using Scikit-Learn 76 As we can see in the resulting plot, the weight coefficients shrink if we decrease parameter C, that is, if we increase the regularization strength: Figure 3.9: The impact of the inverse regularization strength parameter C on L2 regularized model results Increasing the regularization strength can reduce overfitting, so we might ask why we don’t strongly regularize all models by default. The reason is that we have to be careful when adjusting the regular - ization strength. For instance, if the regularization strength is too high and the weights coefficients approach zero, the model can perform very poorly due to underfitting, as illustrated in Figure 3.8. Maximum margin classification with support vector machines Another powerful and widely used learning algorithm is the support vector machine (SVM ), which can be considered an extension of the perceptron. Using the perceptron algorithm, we minimized misclassification errors. However, in SVMs, our optimization objective is to maximize the margin. The margin is defined as the distance between the separating hyperplane (decision boundary) and the training examples that are closest to this hyperplane, which are the so-called support vectors.An additional resource on logistic regression Since in-depth coverage of the individual classification algorithms exceeds the scope of this book, Logistic Regression: From Introductory to Advanced Concepts and Applications, Dr. Scott Menard, Sage Publications, 2009, is recommended to readers who want to learn more about logistic regression. Chapter 3 77 This is illustrated in Figure 3.10: Figure 3.10: SVM maximizes the margin between the decision boundary and training data points Maximum margin intuition The rationale behind having decision boundaries with large margins is that they tend to have a lower generalization error, whereas models with small margins are more prone", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 86, "start_word": 27520, "end_word": 27920, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000087": {"text": "Logistic Regression: From Introductory to Advanced Concepts and Applications, Dr. Scott Menard, Sage Publications, 2009, is recommended to readers who want to learn more about logistic regression. Chapter 3 77 This is illustrated in Figure 3.10: Figure 3.10: SVM maximizes the margin between the decision boundary and training data points Maximum margin intuition The rationale behind having decision boundaries with large margins is that they tend to have a lower generalization error, whereas models with small margins are more prone to overfitting. Unfortunately, while the main intuition behind SVMs is relatively simple, the mathematics behind them is quite advanced and would require sound knowledge of constrained optimization. Hence, the details behind maximum margin optimization in SVMs are beyond the scope of this book. However, we recommend the following resources if you are interested in learning more: • Chris J.C. Burges’ excellent explanation in A Tutorial on Support Vector Machines for Pattern Recognition (Data Mining and Knowledge Discovery, 2(2): 121-167, 1998) • Vladimir Vapnik’s book The Nature of Statistical Learning Theory, Springer Science+Business Media, Vladimir Vapnik, 2000 • Andrew Ng’s very detailed lecture notes available at https://see.stanford.edu/materials/ aimlcs229/cs229-notes3.pdf Dealing with a nonlinearly separable case using slack variables Although we don’t want to dive much deeper into the more involved mathematical concepts behind the maximum-margin classification, let’s briefly mention the so-called slack variable, which was intro - duced by Vladimir Vapnik in 1995 and led to the so-called soft-margin classification. The motivation for introducing the slack variable was that the linear constraints in the SVM optimization objective need to be relaxed for nonlinearly separable data to allow the convergence of the optimization in the presence of misclassifications, under appropriate loss penalization. A Tour of Machine Learning Classifiers Using Scikit-Learn 78 The use of the slack variable, in turn, introduces the variable, which is commonly referred to as C in SVM contexts. We can consider C as a hyperparameter for controlling the penalty for misclassification. Large values of C correspond to large error penalties, whereas we are less strict about misclassification errors if we choose smaller values for C. We can then use the C parameter to control the width of the margin and therefore tune the bias-variance tradeoff, as illustrated in Figure 3.11: Figure 3.11: The impact of large and small values of the inverse regularization strength C on clas - sification This concept is related to regularization, which we discussed in", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 87, "start_word": 27840, "end_word": 28240, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000088": {"text": "for misclassification. Large values of C correspond to large error penalties, whereas we are less strict about misclassification errors if we choose smaller values for C. We can then use the C parameter to control the width of the margin and therefore tune the bias-variance tradeoff, as illustrated in Figure 3.11: Figure 3.11: The impact of large and small values of the inverse regularization strength C on clas - sification This concept is related to regularization, which we discussed in the previous section in the context of regularized regression, where decreasing the value of C increases the bias (underfitting) and lowers the variance (overfitting) of the model. Now that we have learned the basic concepts behind a linear SVM, let’s train an SVM model to classify the different flowers in our Iris dataset: >>> from sklearn.svm import SVC >>> svm = SVC(kernel= 'linear' , C=1.0, random_state= 1) >>> svm.fit(X_train_std, y_train) >>> plot_decision_regions(X_combined_std, ... y_combined, ... classifier=svm, ... test_idx= range(105, 150)) >>> plt.xlabel( 'Petal length [standardized]' ) >>> plt.ylabel( 'Petal width [standardized]' ) >>> plt.legend(loc= 'upper left' ) >>> plt.tight_layout() >>> plt.show() Chapter 3 79 The three decision regions of the SVM, visualized after training the classifier on the Iris dataset by executing the preceding code example, are shown in Figure 3.12: Figure 3.12: SVM’s decision regions Alternative implementations in scikit-learn The scikit-learn library’s LogisticRegression class, which we used in the previous sections, can make use of the LIBLINEAR library by setting solver='liblinear' . LIBLINEAR is a highly optimized C/C++ library developed at the National Taiwan University ( http://www.csie.ntu.edu.tw/~cjlin/ liblinear/ ). Similarly, the SVC class that we used to train an SVM makes use of LIBSVM, which is an equivalent C/ C++ library specialized for SVMs ( http://www.csie.ntu.edu.tw/~cjlin/libsvm/ ).Logistic regression versus SVMs In practical classification tasks, linear logistic regression and linear SVMs often yield very similar results. Logistic regression tries to maximize the conditional likelihoods of the training data, which makes it more prone to outliers than SVMs, which mostly care about the points that are closest to the decision boundary (support vectors). On the other hand, logistic regression has the advantage of being a simpler model and can be implemented more easily, and is mathematically easier to explain. Furthermore, logistic regression models can be easily updated, which is attractive when working with streaming data. A Tour of Machine Learning Classifiers Using Scikit-Learn 80 The advantage of using LIBLINEAR and LIBSVM", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 88, "start_word": 28160, "end_word": 28560, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000089": {"text": "it more prone to outliers than SVMs, which mostly care about the points that are closest to the decision boundary (support vectors). On the other hand, logistic regression has the advantage of being a simpler model and can be implemented more easily, and is mathematically easier to explain. Furthermore, logistic regression models can be easily updated, which is attractive when working with streaming data. A Tour of Machine Learning Classifiers Using Scikit-Learn 80 The advantage of using LIBLINEAR and LIBSVM over, for example, native Python implementations is that they allow the extremely quick training of large amounts of linear classifiers. However, sometimes our datasets are too large to fit into computer memory. Thus, scikit-learn also offers alternative im- plementations via the SGDClassifier class, which also supports online learning via the partial_fit method. The concept behind the SGDClassifier class is similar to the stochastic gradient algorithm that we implemented in Chapter 2 for Adaline. We could initialize the SGD version of the perceptron ( loss='perceptron' ), logistic regression (loss='log' ), and an SVM with default parameters ( loss='hinge' ), as follows: >>> from sklearn.linear_model import SGDClassifier >>> ppn = SGDClassifier(loss= 'perceptron' ) >>> lr = SGDClassifier(loss= 'log') >>> svm = SGDClassifier(loss= 'hinge') Solving nonlinear problems using a kernel SVM Another reason why SVMs enjoy high popularity among machine learning practitioners is that they can be easily kernelized to solve nonlinear classification problems. Before we discuss the main con- cept behind the so-called kernel SVM, the most common variant of SVMs, let’s first create a synthetic dataset to see what such a nonlinear classification problem may look like. Kernel methods for linearly inseparable data Using the following code, we will create a simple dataset that has the form of an XOR gate using the logical_or function from NumPy, where 100 examples will be assigned the class label 1, and 100 examples will be assigned the class label -1: >>> import matplotlib.pyplot as plt >>> import numpy as np >>> np.random.seed( 1) >>> X_xor = np.random.randn( 200, 2) >>> y_xor = np.logical_xor(X_xor[:, 0] > 0, ... X_xor[:, 1] > 0) >>> y_xor = np.where(y_xor, 1, 0) >>> plt.scatter(X_xor[y_xor == 1, 0], ... X_xor[y_xor == 1, 1], ... c= 'royalblue' , marker= 's', ... label= 'Class 1' ) Chapter 3 81 >>> plt.scatter(X_xor[y_xor == 0, 0], ... X_xor[y_xor == 0, 1], ... c= 'tomato' , marker= 'o', ... label= 'Class 0' ) >>> plt.xlim([-", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 89, "start_word": 28480, "end_word": 28880, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000090": {"text": "plt >>> import numpy as np >>> np.random.seed( 1) >>> X_xor = np.random.randn( 200, 2) >>> y_xor = np.logical_xor(X_xor[:, 0] > 0, ... X_xor[:, 1] > 0) >>> y_xor = np.where(y_xor, 1, 0) >>> plt.scatter(X_xor[y_xor == 1, 0], ... X_xor[y_xor == 1, 1], ... c= 'royalblue' , marker= 's', ... label= 'Class 1' ) Chapter 3 81 >>> plt.scatter(X_xor[y_xor == 0, 0], ... X_xor[y_xor == 0, 1], ... c= 'tomato' , marker= 'o', ... label= 'Class 0' ) >>> plt.xlim([- 3, 3]) >>> plt.ylim([- 3, 3]) >>> plt.xlabel( 'Feature 1' ) >>> plt.ylabel( 'Feature 2' ) >>> plt.legend(loc= 'best') >>> plt.tight_layout() >>> plt.show() After executing the code, we will have an XOR dataset with random noise, as shown in Figure 3.13: Figure 3.13: A plot of the XOR dataset Obviously, we would not be able to separate the examples from the positive and negative class very well using a linear hyperplane as a decision boundary via the linear logistic regression or linear SVM model that we discussed in earlier sections. The basic idea behind kernel methods for dealing with such linearly inseparable data is to create nonlinear combinations of the original features to project them onto a higher-dimensional space via a mapping function, 𝜙𝜙 , where the data becomes linearly separable. As shown in Figure 3.14, we can transform a two-dimensional dataset into a new three-dimensional feature space, where the classes become separable via the following projection: 𝜙𝜙(𝑥𝑥1,𝑥𝑥2)=(𝑧𝑧1,𝑧𝑧2,𝑧𝑧3)=(𝑥𝑥1,𝑥𝑥2,𝑥𝑥12+𝑥𝑥22) A Tour of Machine Learning Classifiers Using Scikit-Learn 82 This allows us to separate the two classes shown in the plot via a linear hyperplane that becomes a nonlinear decision boundary if we project it back onto the original feature space, as illustrated with the following concentric circle dataset: Figure 3.14: The process of classifying nonlinear data using kernel methods Using the kernel trick to find separating hyperplanes in a high- dimensional space To solve a nonlinear problem using an SVM, we would transform the training data into a higher-dimen - sional feature space via a mapping function, 𝜙𝜙 , and train a linear SVM model to classify the data in this new feature space. Then, we could use the same mapping function, 𝜙𝜙 , to transform new, unseen data to classify it using the linear SVM model. Chapter 3 83 However, one problem with this mapping approach is that the construction of the new features is computationally very expensive, especially if", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 90, "start_word": 28800, "end_word": 29200, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000091": {"text": "would transform the training data into a higher-dimen - sional feature space via a mapping function, 𝜙𝜙 , and train a linear SVM model to classify the data in this new feature space. Then, we could use the same mapping function, 𝜙𝜙 , to transform new, unseen data to classify it using the linear SVM model. Chapter 3 83 However, one problem with this mapping approach is that the construction of the new features is computationally very expensive, especially if we are dealing with high-dimensional data. This is where the so-called kernel trick comes into play. Although we did not go into much detail about how to solve the quadratic programming task to train an SVM, in practice, we just need to replace the dot product x(i)Tx(j) by 𝜙𝜙𝜙𝜙𝜙(𝑖𝑖))𝑇𝑇𝜙𝜙𝜙𝜙𝜙(𝑗𝑗)) . To save the expensive step of calculating this dot product between two points explicitly, we define a so-called kernel function: 𝜅𝜅𝜅𝜅𝜅(𝑖𝑖),𝜅𝜅(𝑗𝑗)) = 𝜙𝜙𝜅𝜅𝜅(𝑖𝑖))𝑇𝑇𝜙𝜙𝜅𝜅𝜅(𝑗𝑗)) One of the most widely used kernels is the radial basis function (RBF ) kernel, which can simply be called the Gaussian kernel: 𝜅𝜅𝜅𝜅𝜅(𝑖𝑖),𝜅𝜅(𝑗𝑗)) = exp(−‖𝜅𝜅(𝑖𝑖)−𝜅𝜅(𝑗𝑗)‖2 2𝜎𝜎2) This is often simplified to: 𝜅𝜅𝜅𝜅𝜅(𝑖𝑖),𝜅𝜅(𝑗𝑗)) = exp(−𝛾𝛾𝛾 𝜅𝜅(𝑖𝑖)−𝜅𝜅(𝑗𝑗)𝛾2) Here, 𝛾𝛾𝛾1 2𝜎𝜎2 is a free parameter to be optimized. Roughly speaking, the term “kernel” can be interpreted as a similarity function between a pair of exam - ples. The minus sign inverts the distance measure into a similarity score, and, due to the exponential term, the resulting similarity score will fall into a range between 1 (for exactly similar examples) and 0 (for very dissimilar examples). Now that we have covered the big picture behind the kernel trick, let’s see if we can train a kernel SVM that is able to draw a nonlinear decision boundary that separates the XOR data well. Here, we simply use the SVC class from scikit-learn that we imported earlier and replace the kernel='linear' parameter with kernel='rbf' : >>> svm = SVC(kernel= 'rbf', random_state= 1, gamma= 0.10, C=10.0) >>> svm.fit(X_xor, y_xor) >>> plot_decision_regions(X_xor, y_xor, classifier=svm) >>> plt.legend(loc= 'upper left' ) >>> plt.tight_layout() >>> plt.show() A Tour of Machine Learning Classifiers Using Scikit-Learn 84 As we can see in the resulting plot, the kernel SVM separates the XOR data relatively well: Figure 3.15: The decision boundary on the XOR data using a kernel method The 𝛾𝛾 parameter, which we set to gamma=0.1 , can be understood as a cut-off parameter for the Gauss- ian sphere. If", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 91, "start_word": 29120, "end_word": 29520, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000092": {"text": "gamma= 0.10, C=10.0) >>> svm.fit(X_xor, y_xor) >>> plot_decision_regions(X_xor, y_xor, classifier=svm) >>> plt.legend(loc= 'upper left' ) >>> plt.tight_layout() >>> plt.show() A Tour of Machine Learning Classifiers Using Scikit-Learn 84 As we can see in the resulting plot, the kernel SVM separates the XOR data relatively well: Figure 3.15: The decision boundary on the XOR data using a kernel method The 𝛾𝛾 parameter, which we set to gamma=0.1 , can be understood as a cut-off parameter for the Gauss- ian sphere. If we increase the value for 𝛾𝛾 , we increase the influence or reach of the training examples, which leads to a tighter and bumpier decision boundary. To get a better understanding of 𝛾𝛾 , let’s apply an RBF kernel SVM to our Iris flower dataset: >>> svm = SVC(kernel= 'rbf', random_state= 1, gamma= 0.2, C=1.0) >>> svm.fit(X_train_std, y_train) >>> plot_decision_regions(X_combined_std, ... y_combined, classifier=svm, ... test_idx= range(105, 150)) >>> plt.xlabel( 'Petal length [standardized]' ) >>> plt.ylabel( 'Petal width [standardized]' ) >>> plt.legend(loc= 'upper left' ) >>> plt.tight_layout() >>> plt.show() Chapter 3 85 Since we chose a relatively small value for 𝛾𝛾 , the resulting decision boundary of the RBF kernel SVM model will be relatively soft, as shown in Figure 3.16: Figure 3.16: The decision boundaries on the Iris dataset using an RBF kernel SVM model with a small 𝛾𝛾 value Now, let’s increase the value of 𝛾𝛾 and observe the effect on the decision boundary: >>> svm = SVC(kernel= 'rbf', random_state= 1, gamma= 100.0, C=1.0) >>> svm.fit(X_train_std, y_train) >>> plot_decision_regions(X_combined_std, ... y_combined, classifier=svm, ... test_idx= range(105,150)) >>> plt.xlabel( 'Petal length [standardized]' ) >>> plt.ylabel( 'Petal width [standardized]' ) >>> plt.legend(loc= 'upper left' ) >>> plt.tight_layout() >>> plt.show() A Tour of Machine Learning Classifiers Using Scikit-Learn 86 In Figure 3.17, we can now see that the decision boundary around the classes 0 and 1 is much tighter using a relatively large value of 𝛾𝛾 : Figure 3.17: The decision boundaries on the Iris dataset using an RBF kernel SVM model with a large 𝛾𝛾 value Although the model fits the training dataset very well, such a classifier will likely have a high general- ization error on unseen data. This illustrates that the 𝛾𝛾 parameter also plays an important role in con- trolling overfitting or variance when the algorithm is too sensitive to fluctuations in the training dataset. Decision tree learning Decision tree classifiers are attractive models if we care about interpretability.", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 92, "start_word": 29440, "end_word": 29840, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000093": {"text": "the Iris dataset using an RBF kernel SVM model with a large 𝛾𝛾 value Although the model fits the training dataset very well, such a classifier will likely have a high general- ization error on unseen data. This illustrates that the 𝛾𝛾 parameter also plays an important role in con- trolling overfitting or variance when the algorithm is too sensitive to fluctuations in the training dataset. Decision tree learning Decision tree classifiers are attractive models if we care about interpretability. As the name “decision tree” suggests, we can think of this model as breaking down our data by making a decision based on asking a series of questions. Chapter 3 87 Let’s consider the following example in which we use a decision tree to decide upon an activity on a particular day: Figure 3.18: An example of a decision tree Based on the features in our training dataset, the decision tree model learns a series of questions to infer the class labels of the examples. Although Figure 3.18 illustrates the concept of a decision tree based on categorical variables, the same concept applies if our features are real numbers, like in the Iris dataset. For example, we could simply define a cut-off value along the sepal width feature axis and ask a binary question: “Is the sepal width ≥ 2.8 cm?” Using the decision algorithm, we start at the tree root and split the data on the feature that results in the largest information gain (IG ), which will be explained in more detail in the following section. In an iterative process, we can then repeat this splitting procedure at each child node until the leaves are pure. This means that the training examples at each node all belong to the same class. In practice, this can result in a very deep tree with many nodes, which can easily lead to overfitting. Thus, we typically want to prune the tree by setting a limit for the maximum depth of the tree. A Tour of Machine Learning Classifiers Using Scikit-Learn 88 Maximizing IG – getting the most bang for your buck To split the nodes at the most informative features, we need to define an objective function to optimize via the tree learning algorithm. Here, our objective function is to maximize the IG at each split, which we define as follows: 𝐼𝐼𝐼𝐼(𝐷𝐷𝑝𝑝,𝑓𝑓𝑓 𝑓𝐼𝐼(𝐷𝐷𝑝𝑝𝑓−∑𝑁𝑁𝑗𝑗 𝑁𝑁𝑝𝑝𝐼𝐼(𝐷𝐷𝑗𝑗𝑓𝑚𝑚 𝑗𝑗𝑗𝑗 Here, f is the feature to", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 93, "start_word": 29760, "end_word": 30160, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000094": {"text": "by setting a limit for the maximum depth of the tree. A Tour of Machine Learning Classifiers Using Scikit-Learn 88 Maximizing IG – getting the most bang for your buck To split the nodes at the most informative features, we need to define an objective function to optimize via the tree learning algorithm. Here, our objective function is to maximize the IG at each split, which we define as follows: 𝐼𝐼𝐼𝐼(𝐷𝐷𝑝𝑝,𝑓𝑓𝑓 𝑓𝐼𝐼(𝐷𝐷𝑝𝑝𝑓−∑𝑁𝑁𝑗𝑗 𝑁𝑁𝑝𝑝𝐼𝐼(𝐷𝐷𝑗𝑗𝑓𝑚𝑚 𝑗𝑗𝑗𝑗 Here, f is the feature to perform the split; D p and D j are the dataset of the parent and jth child node; I is our impurity measure; N p is the total number of training examples at the parent node; and N j is the number of examples in the jth child node. As we can see, the information gain is simply the difference between the impurity of the parent node and the sum of the child node impurities—the lower the impurities of the child nodes, the larger the information gain. However, for simplicity and to reduce the combinatorial search space, most libraries (including scikit-learn) implement binary decision trees. This means that each parent node is split into two child nodes, D left and D right: 𝐼𝐼𝐼𝐼(𝐷𝐷𝑝𝑝,𝑓𝑓𝑓 𝑓𝐼𝐼(𝐷𝐷𝑝𝑝𝑓−𝑁𝑁𝑙𝑙𝑙𝑙𝑙𝑙𝑙𝑙 𝑁𝑁𝑝𝑝𝐼𝐼(𝐷𝐷𝑙𝑙𝑙𝑙𝑙𝑙𝑙𝑙𝑓−𝑁𝑁𝑟𝑟𝑟𝑟𝑟𝑟𝑟𝑙𝑙 𝑁𝑁𝑝𝑝𝐼𝐼(𝐷𝐷𝑟𝑟𝑟𝑟𝑟𝑟𝑟𝑙𝑙𝑓 The three impurity measures or splitting criteria that are commonly used in binary decision trees are Gini impurity (I G), entropy (IH), and the classification error (I E). Let’s start with the definition of entropy for all non-empty classes ( 𝑝𝑝(𝑖𝑖|𝑡𝑡)≠0 ): 𝐼𝐼𝐻𝐻(𝑡𝑡)=−∑𝑝𝑝 (𝑖𝑖|𝑡𝑡)log2𝑝𝑝(𝑖𝑖|𝑡𝑡)𝑐𝑐 𝑖𝑖𝑖𝑖 Here, p(i|t) is the proportion of the examples that belong to class i for a particular node, t . The entropy is therefore 0 if all examples at a node belong to the same class, and the entropy is maximal if we have a uniform class distribution. For example, in a binary class setting, the entropy is 0 if p(i=1|t) = 1 or p(i=0|t) = 0. If the classes are distributed uniformly with p(i=1|t) = 0.5 and p(i=0|t) = 0.5, the entropy is 1. Therefore, we can say that the entropy criterion attempts to maximize the mutual information in the tree. To provide a visual intuition, let us visualize the entropy values for different class distributions via the following code: >>> def entropy (p): ... return - p * np.log2(p) - ( 1 - p) * np.log2(( 1 - p)) >>> x = np.arange( 0.0, 1.0, 0.01) >>> ent", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 94, "start_word": 30080, "end_word": 30480, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000095": {"text": "are distributed uniformly with p(i=1|t) = 0.5 and p(i=0|t) = 0.5, the entropy is 1. Therefore, we can say that the entropy criterion attempts to maximize the mutual information in the tree. To provide a visual intuition, let us visualize the entropy values for different class distributions via the following code: >>> def entropy (p): ... return - p * np.log2(p) - ( 1 - p) * np.log2(( 1 - p)) >>> x = np.arange( 0.0, 1.0, 0.01) >>> ent = [entropy(p) if p != 0 else None for p in x] >>> plt.ylabel( 'Entropy' ) >>> plt.xlabel( 'Class-membership probability p(i=1)' ) >>> plt.plot(x, ent) >>> plt.show() Chapter 3 89 Figure 3.19 below shows the plot produced by the preceding code: Figure 3.19: Entropy values for different class-membership probabilities The Gini impurity can be understood as a criterion to minimize the probability of misclassification: 𝐼𝐼𝐺𝐺(𝑡𝑡)=∑𝑝𝑝(𝑖𝑖|𝑡𝑡)(1−𝑝𝑝(𝑖𝑖|𝑡𝑡))𝑐𝑐 𝑖𝑖𝑖𝑖=1−∑𝑝𝑝 (𝑖𝑖|𝑡𝑡)2𝑐𝑐 𝑖𝑖𝑖𝑖 Similar to entropy, the Gini impurity is maximal if the classes are perfectly mixed, for example, in a binary class setting (c = 2): 𝐼𝐼𝐺𝐺(𝑡𝑡)= 1−∑0.52𝑐𝑐 𝑖𝑖𝑖𝑖= 0.5 However, in practice, both the Gini impurity and entropy typically yield very similar results, and it is often not worth spending much time on evaluating trees using different impurity criteria rather than experimenting with different pruning cut-offs. In fact, as you will see later in Figure 3.21, both the Gini impurity and entropy have a similar shape. Another impurity measure is the classification error: 𝐼𝐼𝐸𝐸(𝑡𝑡)= 1−max {𝑝𝑝(𝑖𝑖|𝑡𝑡)} This is a useful criterion for pruning, but not recommended for growing a decision tree, since it is less sensitive to changes in the class probabilities of the nodes. We can illustrate this by looking at the two possible splitting scenarios shown in Figure 3.20: Figure 3.20: Decision tree data splits A Tour of Machine Learning Classifiers Using Scikit-Learn 90 We start with a dataset, D p, at the parent node, which consists of 40 examples from class 1 and 40 examples from class 2 that we split into two datasets, D left and D right. The information gain using the classification error as a splitting criterion would be the same (IG E = 0.25) in both scenarios, A and B: 𝐼𝐼𝐸𝐸(𝐷𝐷𝑝𝑝) = 1 − 0.5 = 0.5 𝐴𝐴𝐴 𝐼𝐼𝐸𝐸(𝐷𝐷𝑙𝑙𝑙𝑙𝑙𝑙𝑙𝑙)=1−3 4= 0. 25 𝐴𝐴𝐴 𝐼𝐼𝐸𝐸(𝐷𝐷𝑟𝑟𝑟𝑟𝑟𝑟𝑟 𝑙𝑙)=1−3 4= 0. 25 𝐴𝐴𝐴 𝐼𝐼𝐼𝐼𝐸𝐸= 0.5 −4 80.25−4 80.25= 0. 25 𝐵𝐵𝐴 𝐼𝐼 𝐸𝐸(𝐷𝐷𝑙𝑙𝑙𝑙𝑙𝑙𝑙𝑙)=1−4 6=1 3 𝐵𝐵𝐴 𝐼𝐼 𝐸𝐸(𝐷𝐷𝑟𝑟𝑟𝑟𝑟𝑟𝑟 𝑙𝑙)=1−1=0 𝐵𝐵𝐴", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 95, "start_word": 30400, "end_word": 30800, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000096": {"text": "class 1 and 40 examples from class 2 that we split into two datasets, D left and D right. The information gain using the classification error as a splitting criterion would be the same (IG E = 0.25) in both scenarios, A and B: 𝐼𝐼𝐸𝐸(𝐷𝐷𝑝𝑝) = 1 − 0.5 = 0.5 𝐴𝐴𝐴 𝐼𝐼𝐸𝐸(𝐷𝐷𝑙𝑙𝑙𝑙𝑙𝑙𝑙𝑙)=1−3 4= 0. 25 𝐴𝐴𝐴 𝐼𝐼𝐸𝐸(𝐷𝐷𝑟𝑟𝑟𝑟𝑟𝑟𝑟 𝑙𝑙)=1−3 4= 0. 25 𝐴𝐴𝐴 𝐼𝐼𝐼𝐼𝐸𝐸= 0.5 −4 80.25−4 80.25= 0. 25 𝐵𝐵𝐴 𝐼𝐼 𝐸𝐸(𝐷𝐷𝑙𝑙𝑙𝑙𝑙𝑙𝑙𝑙)=1−4 6=1 3 𝐵𝐵𝐴 𝐼𝐼 𝐸𝐸(𝐷𝐷𝑟𝑟𝑟𝑟𝑟𝑟𝑟 𝑙𝑙)=1−1=0 𝐵𝐵𝐴 𝐼𝐼𝐼𝐼𝐸𝐸= 0.5 −6 8×1 3− 0 = 0. 25 However, the Gini impurity would favor the split in scenario B (𝐼𝐼𝐼𝐼𝐺𝐺= 0.16̅ ) over scenario A (IGG = 0.125), which is indeed purer: 𝐼𝐼𝐺𝐺(𝐷𝐷𝑝𝑝) = 1 − (0.52+ 0.52)= 0.5 𝐴𝐴𝐴 𝐼𝐼𝐺𝐺(𝐷𝐷𝑙𝑙𝑙𝑙𝑙𝑙𝑙𝑙) = 1 − ((3 4)2 +(1 4)2 )=3 8= 0. 375 𝐴𝐴𝐴 𝐼𝐼𝐺𝐺(𝐷𝐷𝑟𝑟𝑟𝑟𝑟𝑟𝑟 𝑙𝑙) = 1 − ((1 4)2 +(3 4)2 )=3 8= 0. 375 𝐴𝐴𝐴 𝐼𝐼𝐼𝐼𝐺𝐺= 0.5 −4 80.375 −4 80.375 = 0. 125 𝐵𝐵𝐴 𝐼𝐼 𝐺𝐺(𝐷𝐷𝑙𝑙𝑙𝑙𝑙𝑙𝑙𝑙) = 1 − ((2 6)2 +(4 6)2 )=4 9= 0. 4 ̅ 𝐵𝐵𝐴 𝐼𝐼 𝐺𝐺(𝐷𝐷𝑟𝑟𝑟𝑟𝑟𝑟𝑟 𝑙𝑙)=1− (12+02)=0 𝐵𝐵𝐴 𝐼𝐼𝐼𝐼𝐺𝐺= 0.5 −6 80. 4̅− 0 = 0.16 ̅ Chapter 3 91 Similarly, the entropy criterion would also favor scenario B (IG H = 0.31) over scenario A (IG H = 0.19): 𝐼𝐼𝐻𝐻(𝐷𝐷𝑝𝑝) = − (0.5 log 2(0.5)+ 0.5 log 2(0.5))=1 𝐴𝐴𝐴 𝐼𝐼𝐻𝐻(𝐷𝐷𝑙𝑙𝑙𝑙𝑙𝑙𝑙𝑙)= −(3 4log 2(3 4)+1 4log 2(1 4)) = 0. 81 𝐴𝐴𝐴 𝐼𝐼𝐻𝐻(𝐷𝐷𝑟𝑟𝑟𝑟𝑟𝑟𝑟 𝑙𝑙) = −(1 4log 2(1 4)+3 4log 2(3 4)) = 0. 81 𝐴𝐴𝐴 𝐼𝐼𝐼𝐼𝐻𝐻=1−4 80.81−4 80.81= 0. 19 𝐵𝐵𝐴 𝐼𝐼 𝐻𝐻(𝐷𝐷𝑙𝑙𝑙𝑙𝑙𝑙𝑙𝑙)= −(2 6log 2(2 6)+4 6log 2(4 6)) = 0. 92 𝐵𝐵𝐴 𝐼𝐼 𝐻𝐻(𝐷𝐷𝑟𝑟𝑟𝑟𝑟𝑟𝑟 𝑙𝑙)=0 𝐵𝐵𝐴 𝐼𝐼𝐼𝐼𝐻𝐻=1−6 80.92− 0 = 0. 31 For a more visual comparison of the three different impurity criteria that we discussed previously, let’s plot the impurity indices for the probability range [0, 1] for class 1. Note that we will also add a scaled version of the entropy (entropy / 2) to observe that the Gini impurity is an intermediate measure between entropy and the classification error. The code is as follows: >>> import matplotlib.pyplot as plt >>> import numpy as np >>> def gini(p): ... return p*(1 - p) + ( 1 - p)*( 1 - (1-p)) >>> def entropy (p): ... return - p*np.log2(p) - ( 1 - p)*np.log2(( 1 - p)) >>> def error(p): ... return 1 - np. max([p, 1 - p]) >>> x = np.arange( 0.0, 1.0,", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 96, "start_word": 30720, "end_word": 31120, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000097": {"text": "observe that the Gini impurity is an intermediate measure between entropy and the classification error. The code is as follows: >>> import matplotlib.pyplot as plt >>> import numpy as np >>> def gini(p): ... return p*(1 - p) + ( 1 - p)*( 1 - (1-p)) >>> def entropy (p): ... return - p*np.log2(p) - ( 1 - p)*np.log2(( 1 - p)) >>> def error(p): ... return 1 - np. max([p, 1 - p]) >>> x = np.arange( 0.0, 1.0, 0.01) >>> ent = [entropy(p) if p != 0 else None for p in x] >>> sc_ent = [e* 0.5 if e else None for e in ent] >>> err = [error(i) for i in x] >>> fig = plt.figure() >>> ax = plt.subplot( 111) A Tour of Machine Learning Classifiers Using Scikit-Learn 92 >>> for i, lab, ls, c, in zip([ent, sc_ent, gini(x), err], ... [ 'Entropy' , 'Entropy (scaled)' , ... 'Gini impurity' , ... 'Misclassification error' ], ... [ '-', '-', '--', '-.'], ... [ 'black', 'lightgray' , ... 'red', 'green' , 'cyan' ]): ... line = ax.plot(x, i, label=lab, ... linestyle=ls, lw= 2, color=c) >>> ax.legend(loc= 'upper center' , bbox_to_anchor=( 0.5, 1.15), ... ncol= 5, fancybox= True, shadow= False) >>> ax.axhline(y= 0.5, linewidth= 1, color= 'k', linestyle= '--') >>> ax.axhline(y= 1.0, linewidth= 1, color= 'k', linestyle= '--') >>> plt.ylim([ 0, 1.1]) >>> plt.xlabel( 'p(i=1)' ) >>> plt.ylabel( 'impurity index' ) >>> plt.show() The plot produced by the preceding code example is as follows: Figure 3.21: The different impurity indices for different class-membership probabilities between 0 and 1 Building a decision tree Decision trees can build complex decision boundaries by dividing the feature space into rectangles. However, we have to be careful since the deeper the decision tree, the more complex the decision boundary becomes, which can easily result in overfitting. Using scikit-learn, we will now train a de - cision tree with a maximum depth of 4, using the Gini impurity as a criterion for impurity. Chapter 3 93 Although feature scaling may be desired for visualization purposes, note that feature scaling is not a requirement for decision tree algorithms. The code is as follows: >>> from sklearn.tree import DecisionTreeClassifier >>> tree_model = DecisionTreeClassifier(criterion= 'gini', ... max_depth= 4, ... random_state= 1) >>> tree_model.fit(X_train, y_train) >>> X_combined = np.vstack((X_train, X_test)) >>> y_combined = np.hstack((y_train, y_test)) >>> plot_decision_regions(X_combined, ... y_combined, ... classifier=tree_model, ... test_idx= range(105, 150)) >>> plt.xlabel(", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 97, "start_word": 31040, "end_word": 31440, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000098": {"text": "4, using the Gini impurity as a criterion for impurity. Chapter 3 93 Although feature scaling may be desired for visualization purposes, note that feature scaling is not a requirement for decision tree algorithms. The code is as follows: >>> from sklearn.tree import DecisionTreeClassifier >>> tree_model = DecisionTreeClassifier(criterion= 'gini', ... max_depth= 4, ... random_state= 1) >>> tree_model.fit(X_train, y_train) >>> X_combined = np.vstack((X_train, X_test)) >>> y_combined = np.hstack((y_train, y_test)) >>> plot_decision_regions(X_combined, ... y_combined, ... classifier=tree_model, ... test_idx= range(105, 150)) >>> plt.xlabel( 'Petal length [cm]' ) >>> plt.ylabel( 'Petal width [cm]' ) >>> plt.legend(loc= 'upper left' ) >>> plt.tight_layout() >>> plt.show() After executing the code example, we get the typical axis-parallel decision boundaries of the decision tree: Figure 3.22: The decision boundaries of the Iris data using a decision tree A Tour of Machine Learning Classifiers Using Scikit-Learn 94 A nice feature in scikit-learn is that it allows us to readily visualize the decision tree model after train- ing via the following code: >>> from sklearn import tree >>> feature_names = [ 'Sepal length' , 'Sepal width' , ... 'Petal length' , 'Petal width' ] >>> tree.plot_tree(tree_model, ... feature_names=feature_names, ... filled= True) >>> plt.show() Figure 3.23: A decision tree model fit to the Iris dataset Setting filled=True in the plot_tree function we called colors the nodes by the majority class label at that node. There are many additional options available, which you can find in the documentation at https://scikit-learn.org/stable/modules/generated/sklearn.tree.plot_tree.html . Looking at the decision tree figure, we can now nicely trace back the splits that the decision tree de - termined from our training dataset. Regarding the feature splitting criterion at each node, note that the branches to the left correspond to “True” and branches to the right correspond to “False.” Chapter 3 95 Looking at the root node, it starts with 105 examples at the top. The first split uses a sepal width cut- off ≤ 0.75 cm for splitting the root node into two child nodes with 35 examples (left child node) and 70 examples (right child node). After the first split, we can see that the left child node is already pure and only contains examples from the Iris-setosa class (Gini impurity = 0). The further splits on the right are then used to separate the examples from the Iris-versicolor and Iris-virginica class. Looking at this tree, and the decision region plot of the tree, we can see that", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 98, "start_word": 31360, "end_word": 31760, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000099": {"text": "root node into two child nodes with 35 examples (left child node) and 70 examples (right child node). After the first split, we can see that the left child node is already pure and only contains examples from the Iris-setosa class (Gini impurity = 0). The further splits on the right are then used to separate the examples from the Iris-versicolor and Iris-virginica class. Looking at this tree, and the decision region plot of the tree, we can see that the decision tree does a very good job of separating the flower classes. Unfortunately, scikit-learn currently does not implement functionality to manually post-prune a decision tree. However, we could go back to our previous code example, change the max_depth of our decision tree to 3, and compare it to our current model, but we leave this as an exercise for the interested reader. Alternatively, scikit-learn provides an automatic cost complexity post-pruning procedure for decision trees. Interested readers can find more information about this more advanced topic in the following tutorial: https://scikit-learn.org/stable/auto_examples/tree/plot_cost_complexity_pruning. html . Combining multiple decision trees via random forests Ensemble methods have gained huge popularity in applications of machine learning during the last decade due to their good classification performance and robustness toward overfitting. While we are going to cover different ensemble methods, including bagging and boosting, later in Chapter 7, Combining Different Models for Ensemble Learning, let’s discuss the decision tree-based random forest algorithm, which is known for its good scalability and ease of use. A random forest can be considered as an ensemble of decision trees. The idea behind a random forest is to average multiple (deep) deci- sion trees that individually suffer from high variance to build a more robust model that has a better generalization performance and is less susceptible to overfitting. The random forest algorithm can be summarized in four simple steps: 1. Draw a random bootstrap sample of size n (randomly choose n examples from the training dataset with replacement). 2. Grow a decision tree from the bootstrap sample. At each node: a. Randomly select d features without replacement. b. Split the node using the feature that provides the best split according to the objective function, for instance, maximizing the information gain. 3. Repeat steps 1-2 k times. 4. Aggregate the prediction by each tree to assign the class label by majority vote. Majority voting will be discussed in more detail in Chapter", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 99, "start_word": 31680, "end_word": 32080, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000100": {"text": "examples from the training dataset with replacement). 2. Grow a decision tree from the bootstrap sample. At each node: a. Randomly select d features without replacement. b. Split the node using the feature that provides the best split according to the objective function, for instance, maximizing the information gain. 3. Repeat steps 1-2 k times. 4. Aggregate the prediction by each tree to assign the class label by majority vote. Majority voting will be discussed in more detail in Chapter 7. A Tour of Machine Learning Classifiers Using Scikit-Learn 96 We should note one slight modification in step 2 when we are training the individual decision trees: instead of evaluating all features to determine the best split at each node, we only consider a random subset of those. Although random forests don’t offer the same level of interpretability as decision trees, a big advantage of random forests is that we don’t have to worry so much about choosing good hyperparameter values. We typically don’t need to prune the random forest since the ensemble model is quite robust to noise from averaging the predictions among the individual decision trees. The only parameter that we need to care about in practice is the number of trees, k, (step 3) that we choose for the random forest. Typically, the larger the number of trees, the better the performance of the random forest classifier at the expense of an increased computational cost.Sampling with and without replacement In case you are not familiar with the terms sampling “with” and “without” replacement, let’s walk through a simple thought experiment. Let’s assume that we are playing a lottery game where we randomly draw numbers from an urn. We start with an urn that holds five unique numbers, 0, 1, 2, 3, and 4, and we draw exactly one number on each turn. In the first round, the chance of drawing a particular number from the urn would be 1/5. Now, in sampling without replacement, we do not put the number back into the urn after each turn. Consequently, the probability of drawing a particular number from the set of remaining numbers in the next round depends on the previous round. For example, if we have a remaining set of numbers 0, 1, 2, and 4, the chance of drawing number 0 would become 1/4 in the next turn. However, in random sampling with replacement, we always return", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 100, "start_word": 32000, "end_word": 32400, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000101": {"text": "be 1/5. Now, in sampling without replacement, we do not put the number back into the urn after each turn. Consequently, the probability of drawing a particular number from the set of remaining numbers in the next round depends on the previous round. For example, if we have a remaining set of numbers 0, 1, 2, and 4, the chance of drawing number 0 would become 1/4 in the next turn. However, in random sampling with replacement, we always return the drawn number to the urn so that the probability of drawing a particular number at each turn does not change; we can draw the same number more than once. In other words, in sampling with replacement, the samples (numbers) are independent and have a covariance of zero. For example, the results from five rounds of drawing random numbers could look like this: • Random sampling without replacement: 2, 1, 3, 4, 0 • Random sampling with replacement: 1, 3, 3, 4, 1 Chapter 3 97 Although it is less common in practice, other hyperparameters of the random forest classifier that can be optimized—using techniques that we will discuss in Chapter 6, Learning Best Practices for Model Evaluation and Hyperparameter Tuning—are the size, n , of the bootstrap sample (step 1) and the number of features, d, that are randomly chosen for each split (step 2a), respectively. Via the sample size, n, of the bootstrap sample, we control the bias-variance tradeoff of the random forest. Decreasing the size of the bootstrap sample increases the diversity among the individual trees since the probability that a particular training example is included in the bootstrap sample is lower. Thus, shrinking the size of the bootstrap samples may increase the randomness of the random forest, and it can help to reduce the effect of overfitting. However, smaller bootstrap samples typically result in a lower overall performance of the random forest and a small gap between training and test performance, but a low test performance overall. Conversely, increasing the size of the bootstrap sample may increase the degree of overfitting. Because the bootstrap samples, and consequently the individual decision trees, become more similar to one another, they learn to fit the original training dataset more closely. In most implementations, including the RandomForestClassifier implementation in scikit-learn, the size of the bootstrap sample is chosen to be equal to the number of training examples in the original", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 101, "start_word": 32320, "end_word": 32720, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000102": {"text": "between training and test performance, but a low test performance overall. Conversely, increasing the size of the bootstrap sample may increase the degree of overfitting. Because the bootstrap samples, and consequently the individual decision trees, become more similar to one another, they learn to fit the original training dataset more closely. In most implementations, including the RandomForestClassifier implementation in scikit-learn, the size of the bootstrap sample is chosen to be equal to the number of training examples in the original training dataset, which usually provides a good bias-variance tradeoff. For the number of features, d, at each split, we want to choose a value that is smaller than the total number of features in the training dataset. A reasonable default that is used in scikit-learn and other implementations is 𝑑𝑑𝑑√𝑚𝑚 , where m is the number of features in the training dataset. Conveniently, we don’t have to construct the random forest classifier from individual decision trees by ourselves because there is already an implementation in scikit-learn that we can use: >>> from sklearn.ensemble import RandomForestClassifier >>> forest = RandomForestClassifier(n_estimators= 25, ... random_state= 1, ... n_jobs= 2) >>> forest.fit(X_train, y_train) >>> plot_decision_regions(X_combined, y_combined, ... classifier=forest, test_idx= range(105,150)) >>> plt.xlabel( 'Petal length [cm]' ) >>> plt.ylabel( 'Petal width [cm]' ) >>> plt.legend(loc= 'upper left' ) >>> plt.tight_layout() >>> plt.show() A Tour of Machine Learning Classifiers Using Scikit-Learn 98 After executing the preceding code, we should see the decision regions formed by the ensemble of trees in the random forest, as shown in Figure 3.24: Figure 3.24: Decision boundaries on the Iris dataset using a random forest Using the preceding code, we trained a random forest from 25 decision trees via the n_estimators parameter. By default, it uses the Gini impurity measure as a criterion to split the nodes. Although we are growing a very small random forest from a very small training dataset, we used the n_jobs pa- rameter for demonstration purposes, which allows us to parallelize the model training using multiple cores of our computer (here, two cores). If you encounter errors with this code, your computer may not support multiprocessing. You can omit the n_jobs parameter or set it to n_jobs=None . K-nearest neighbors – a lazy learning algorithm The last supervised learning algorithm that we want to discuss in this chapter is the k-nearest neigh- bor (KNN) classifier, which is particularly interesting because it is fundamentally different from the", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 102, "start_word": 32640, "end_word": 33040, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000103": {"text": "which allows us to parallelize the model training using multiple cores of our computer (here, two cores). If you encounter errors with this code, your computer may not support multiprocessing. You can omit the n_jobs parameter or set it to n_jobs=None . K-nearest neighbors – a lazy learning algorithm The last supervised learning algorithm that we want to discuss in this chapter is the k-nearest neigh- bor (KNN) classifier, which is particularly interesting because it is fundamentally different from the learning algorithms that we have discussed so far. KNN is a typical example of a lazy learner. It is called “lazy” not because of its apparent simplicity, but because it doesn’t learn a discriminative function from the training data but memorizes the training dataset instead. Chapter 3 99 The KNN algorithm itself is fairly straightforward and can be summarized by the following steps: 1. Choose the number of k and a distance metric 2. Find the k-nearest neighbors of the data record that we want to classify 3. Assign the class label by majority vote Figure 3.25 illustrates how a new data point (?) is assigned the triangle class label based on majority voting among its five nearest neighbors: Figure 3.25: How k-nearest neighbors worksParametric versus non-parametric models Machine learning algorithms can be grouped into parametric and non-parametric models. Using parametric models, we estimate parameters from the training dataset to learn a function that can classify new data points without requiring the original training dataset anymore. Typical examples of parametric models are the perceptron, logistic regression, and the linear SVM. In contrast, non-parametric models can’t be characterized by a fixed set of parameters, and the number of parameters changes with the amount of training data. Two examples of non-parametric models that we have seen so far are the decision tree classifier/random forest and the kernel (but not linear) SVM. KNN belongs to a subcategory of non-parametric models described as instance-based learning. Models based on instance-based learning are characterized by memorizing the training dataset, and lazy learning is a special case of instance-based learning that is associated with no (zero) cost during the learning process. A Tour of Machine Learning Classifiers Using Scikit-Learn 100 Based on the chosen distance metric, the KNN algorithm finds the k examples in the training dataset that are closest (most similar) to the point that we want to classify. The class label of the data point", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 103, "start_word": 32960, "end_word": 33360, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000104": {"text": "learning. Models based on instance-based learning are characterized by memorizing the training dataset, and lazy learning is a special case of instance-based learning that is associated with no (zero) cost during the learning process. A Tour of Machine Learning Classifiers Using Scikit-Learn 100 Based on the chosen distance metric, the KNN algorithm finds the k examples in the training dataset that are closest (most similar) to the point that we want to classify. The class label of the data point is then determined by a majority vote among its k nearest neighbors. By executing the following code, we will now implement a KNN model in scikit-learn using a Euclid- ean distance metric: >>> from sklearn.neighbors import KNeighborsClassifier >>> knn = KNeighborsClassifier(n_neighbors= 5, p=2, ... metric= 'minkowski' ) >>> knn.fit(X_train_std, y_train) >>> plot_decision_regions(X_combined_std, y_combined, ... classifier=knn, test_idx= range(105,150)) >>> plt.xlabel( 'Petal length [standardized]' ) >>> plt.ylabel( 'Petal width [standardized]' ) >>> plt.legend(loc= 'upper left' ) >>> plt.tight_layout() >>> plt.show()Advantages and disadvantages of memory-based approaches The main advantage of such a memory-based approach is that the classifier immediately adapts as we collect new training data. However, the downside is that the computational complexity for classifying new examples grows linearly with the number of examples in the training dataset in the worst-case scenario—unless the dataset has very few dimen- sions (features) and the algorithm has been implemented using efficient data structures for querying the training data more effectively. Such data structures include k-d tree (https://en.wikipedia.org/wiki/K-d_tree ) and ball tree (https://en.wikipedia. org/wiki/Ball_tree ), which are both supported in scikit-learn. Furthermore, next to computational costs for querying data, large datasets can also be problematic in terms of limited storage capacities. However, in many cases when we are working with relatively small to medium-sized data - sets, memory-based methods can provide good predictive and computational performance and are thus a good choice for approaching many real-world problems. Recent examples of using nearest neighbor methods include predicting properties of pharmaceutical drug targets (Machine Learning to Identify Flexibility Signatures of Class A GPCR Inhibition, Bio - molecules, 2020, Joe Bemister-Buffington, Alex J. Wolf, Sebastian Raschka, and Leslie A. Kuhn, https://www.mdpi.com/2218-273X/10/3/454 ) and state-of-the-art language models (Efficient Nearest Neighbor Language Models, 2021, Junxian He, Graham Neubig, and Taylor Berg-Kirkpatrick, https://arxiv.org/abs/2109.04212 ). Chapter 3 101 By specifying five neighbors in the KNN model for this dataset, we obtain a relatively smooth decision boundary, as shown in Figure 3.26: Figure 3.26:", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 104, "start_word": 33280, "end_word": 33680, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000105": {"text": "properties of pharmaceutical drug targets (Machine Learning to Identify Flexibility Signatures of Class A GPCR Inhibition, Bio - molecules, 2020, Joe Bemister-Buffington, Alex J. Wolf, Sebastian Raschka, and Leslie A. Kuhn, https://www.mdpi.com/2218-273X/10/3/454 ) and state-of-the-art language models (Efficient Nearest Neighbor Language Models, 2021, Junxian He, Graham Neubig, and Taylor Berg-Kirkpatrick, https://arxiv.org/abs/2109.04212 ). Chapter 3 101 By specifying five neighbors in the KNN model for this dataset, we obtain a relatively smooth decision boundary, as shown in Figure 3.26: Figure 3.26: k-nearest neighbors’ decision boundaries on the Iris dataset The right choice of k is crucial to finding a good balance between overfitting and underfitting. We also have to make sure that we choose a distance metric that is appropriate for the features in the dataset. Often, a simple Euclidean distance measure is used for real-value examples, for example, the flowers in our Iris dataset, which have features measured in centimeters. However, if we are using a Euclidean distance measure, it is also important to standardize the data so that each feature contributes equally to the distance. The minkowski distance that we used in the previous code is just a generalization of the Euclidean and Manhattan distance, which can be written as follows: 𝑑𝑑𝑑𝑑𝑑(𝑖𝑖),𝑑𝑑(𝑗𝑗))=√∑|𝑥𝑥𝑘𝑘(𝑖𝑖)−𝑥𝑥𝑘𝑘(𝑗𝑗)|𝑝𝑝 𝑘𝑘𝑝𝑝 Resolving ties In the case of a tie, the scikit-learn implementation of the KNN algorithm will prefer the neighbors with a closer distance to the data record to be classified. If the neighbors have similar distances, the algorithm will choose the class label that comes first in the training dataset. A Tour of Machine Learning Classifiers Using Scikit-Learn 102 It becomes the Euclidean distance if we set the parameter p=2 or the Manhattan distance at p=1. Many other distance metrics are available in scikit-learn and can be provided to the metric param - eter. They are listed at https://scikit-learn.org/stable/modules/generated/sklearn.metrics. DistanceMetric.html . Lastly, it is important to mention that KNN is very susceptible to overfitting due to the curse of dimen- sionality. The curse of dimensionality describes the phenomenon where the feature space becomes increasingly sparse for an increasing number of dimensions of a fixed-size training dataset. We can think of even the closest neighbors as being too far away in a high-dimensional space to give a good estimate. We discussed the concept of regularization in the section about logistic regression as one way to avoid overfitting. However, in models where regularization is not applicable, such as", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 105, "start_word": 33600, "end_word": 34000, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000106": {"text": "the curse of dimen- sionality. The curse of dimensionality describes the phenomenon where the feature space becomes increasingly sparse for an increasing number of dimensions of a fixed-size training dataset. We can think of even the closest neighbors as being too far away in a high-dimensional space to give a good estimate. We discussed the concept of regularization in the section about logistic regression as one way to avoid overfitting. However, in models where regularization is not applicable, such as decision trees and KNN, we can use feature selection and dimensionality reduction techniques to help us to avoid the curse of dimensionality. This will be discussed in more detail in the next two chapters. Summary In this chapter, you learned about many different machine learning algorithms that are used to tackle linear and nonlinear problems. You have seen that decision trees are particularly attractive if we care about interpretability. Logistic regression is not only a useful model for online learning via SGD, but also allows us to predict the probability of a particular event. Although SVMs are powerful linear models that can be extended to nonlinear problems via the kernel trick, they have many parameters that have to be tuned in order to make good predictions. In contrast, ensemble methods, such as random forests, don’t require much parameter tuning and don’t overfit as easily as decision trees, which makes them attractive models for many practical problem domains. The KNN classifier offers an alternative approach to classification via lazy learning that allows us to make predictions without any model training, but with a more computationally expensive prediction step.Alternative machine learning implementations with GPU support When working with large datasets, running k-nearest neighbors or fitting random forests with many estimators can require substantial computing resources and processing time. If you have a computer equipped with an NVIDIA GPU that is compatible with recent versions of NVIDIA’s CUDA library, we recommend considering the RAPIDS ecosystem (https:// docs.rapids.ai/api ). For instance, RAPIDS’ cuML (https://docs.rapids.ai/api/ cuml/stable/ ) library implements many of scikit-learn’s machine learning algorithms with GPU support to accelerate the processing speeds. You can find an introduction to cuML at https://docs.rapids.ai/api/cuml/stable/estimator_intro.html. If you are interested in learning more about the RAPIDS ecosystem, please also see the freely accessible journal article that we wrote in collaboration with the RAPIDS team: Machine Learning in Python: Main Developments and Technology Trends in Data Science, Machine Learning, and", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 106, "start_word": 33920, "end_word": 34320, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000107": {"text": "RAPIDS ecosystem (https:// docs.rapids.ai/api ). For instance, RAPIDS’ cuML (https://docs.rapids.ai/api/ cuml/stable/ ) library implements many of scikit-learn’s machine learning algorithms with GPU support to accelerate the processing speeds. You can find an introduction to cuML at https://docs.rapids.ai/api/cuml/stable/estimator_intro.html. If you are interested in learning more about the RAPIDS ecosystem, please also see the freely accessible journal article that we wrote in collaboration with the RAPIDS team: Machine Learning in Python: Main Developments and Technology Trends in Data Science, Machine Learning, and Artificial Intelligence (https://www.mdpi.com/2078-2489/11/4/193 ). Chapter 3 103 However, even more important than the choice of an appropriate learning algorithm is the available data in our training dataset. No algorithm will be able to make good predictions without informative and discriminatory features. In the next chapter, we will discuss important topics regarding the preprocessing of data, feature selection, and dimensionality reduction, which means that we will need to build powerful machine learning models. Later, in Chapter 6, Learning Best Practices for Model Evaluation and Hyperparameter Tuning, we will see how we can evaluate and compare the performance of our models and learn useful tricks to fine-tune the different algorithms. Join our book’s Discord space Join the book’s Discord workspace for a monthly Ask me Anything session with the authors: https://packt.link/MLwPyTorch 4 Building Good Training Datasets – Data Preprocessing The quality of the data and the amount of useful information that it contains are key factors that determine how well a machine learning algorithm can learn. Therefore, it is absolutely critical to ensure that we examine and preprocess a dataset before we feed it to a machine learning algorithm. In this chapter, we will discuss the essential data preprocessing techniques that will help us to build good machine learning models. The topics that we will cover in this chapter are as follows: • Removing and imputing missing values from the dataset • Getting categorical data into shape for machine learning algorithms • Selecting relevant features for the model construction Dealing with missing data It is not uncommon in real-world applications for our training examples to be missing one or more values for various reasons. There could have been an error in the data collection process, certain mea - surements may not be applicable, or particular fields could have been simply left blank in a survey, for example. We typically see missing values as blank spaces in our data table or as placeholder", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 107, "start_word": 34240, "end_word": 34640, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000108": {"text": "Selecting relevant features for the model construction Dealing with missing data It is not uncommon in real-world applications for our training examples to be missing one or more values for various reasons. There could have been an error in the data collection process, certain mea - surements may not be applicable, or particular fields could have been simply left blank in a survey, for example. We typically see missing values as blank spaces in our data table or as placeholder strings such as NaN, which stands for “not a number,” or NULL (a commonly used indicator of unknown values in relational databases). Unfortunately, most computational tools are unable to handle such missing values or will produce unpredictable results if we simply ignore them. Therefore, it is crucial that we take care of those missing values before we proceed with further analyses. In this section, we will work through several practical techniques for dealing with missing values by re - moving entries from our dataset or imputing missing values from other training examples and features. Building Good Training Datasets – Data Preprocessing 106 Identifying missing values in tabular data Before we discuss several techniques for dealing with missing values, let’s create a simple example DataFrame from a comma-separated values (CSV ) file to get a better grasp of the problem: >>> import pandas as pd >>> from io import StringIO >>> csv_data = \\ ... '''A,B,C,D ... 1.0,2.0,3.0,4.0 ... 5.0,6.0,,8.0 ... 10.0,11.0,12.0,''' >>> # If you are using Python 2.7, you need >>> # to convert the string to unicode: >>> # csv_data = unicode(csv_data) >>> df = pd.read_csv(StringIO(csv_data)) >>> df A B C D 0 1.0 2.0 3.0 4.0 1 5.0 6.0 NaN 8.0 2 10.0 11.0 12.0 NaN Using the preceding code, we read CSV-formatted data into a pandas DataFrame via the read_csv function and noticed that the two missing cells were replaced by NaN. The StringIO function in the preceding code example was simply used for the purposes of illustration. It allowed us to read the string assigned to csv_data into a pandas DataFrame as if it was a regular CSV file on our hard drive. For a larger DataFrame , it can be tedious to look for missing values manually; in this case, we can use the isnull method to return a DataFrame with Boolean values that indicate whether a cell contains a numeric value ( False", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 108, "start_word": 34560, "end_word": 34960, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000109": {"text": "the preceding code example was simply used for the purposes of illustration. It allowed us to read the string assigned to csv_data into a pandas DataFrame as if it was a regular CSV file on our hard drive. For a larger DataFrame , it can be tedious to look for missing values manually; in this case, we can use the isnull method to return a DataFrame with Boolean values that indicate whether a cell contains a numeric value ( False ) or if data is missing ( True ). Using the sum method, we can then return the number of missing values per column as follows: >>> df.isnull(). sum() A 0 B 0 C 1 D 1 dtype: int64 This way, we can count the number of missing values per column; in the following subsections, we will take a look at different strategies for how to deal with this missing data. Chapter 4 107 Eliminating training examples or features with missing values One of the easiest ways to deal with missing data is simply to remove the corresponding features (columns) or training examples (rows) from the dataset entirely; rows with missing values can easily be dropped via the dropna method: >>> df.dropna(axis= 0) A B C D 0 1.0 2.0 3.0 4.0 Similarly, we can drop columns that have at least one NaN in any row by setting the axis argument to 1: >>> df.dropna(axis= 1) A B 0 1.0 2.0 1 5.0 6.0 2 10.0 11.0 The dropna method supports several additional parameters that can come in handy: >>> # only drop rows where all columns are NaN >>> # (returns the whole array here since we don't >>> # have a row with all values NaN) >>> df.dropna(how= 'all') A B C D 0 1.0 2.0 3.0 4.0 1 5.0 6.0 NaN 8.0 2 10.0 11.0 12.0 NaNConvenient data handling with pandas’ DataFrame Although scikit-learn was originally developed for working with NumPy arrays only, it can sometimes be more convenient to preprocess data using pandas’ DataFrame . Nowa - days, most scikit-learn functions support DataFrame objects as inputs, but since NumPy array handling is more mature in the scikit-learn API, it is recommended to use NumPy arrays when possible. Note that you can always access the underlying NumPy array of a DataFrame via the values attribute before you feed it into a scikit-learn estimator: >>> df.values array([[ 1.,", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 109, "start_word": 34880, "end_word": 35280, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000110": {"text": "for working with NumPy arrays only, it can sometimes be more convenient to preprocess data using pandas’ DataFrame . Nowa - days, most scikit-learn functions support DataFrame objects as inputs, but since NumPy array handling is more mature in the scikit-learn API, it is recommended to use NumPy arrays when possible. Note that you can always access the underlying NumPy array of a DataFrame via the values attribute before you feed it into a scikit-learn estimator: >>> df.values array([[ 1., 2., 3., 4.], [ 5., 6., nan, 8.], [ 10., 11., 12., nan]]) Building Good Training Datasets – Data Preprocessing 108 >>> # drop rows that have fewer than 4 real values >>> df.dropna(thresh= 4) A B C D 0 1.0 2.0 3.0 4.0 >>> # only drop rows where NaN appear in specific columns (here: 'C') >>> df.dropna(subset=[ 'C']) A B C D 0 1.0 2.0 3.0 4.0 2 10.0 11.0 12.0 NaN Although the removal of missing data seems to be a convenient approach, it also comes with certain disadvantages; for example, we may end up removing too many samples, which will make a reliable analysis impossible. Or, if we remove too many feature columns, we will run the risk of losing valuable information that our classifier needs to discriminate between classes. In the next section, we will look at one of the most commonly used alternatives for dealing with missing values: interpolation techniques. Imputing missing values Often, the removal of training examples or dropping of entire feature columns is simply not feasible, because we might lose too much valuable data. In this case, we can use different interpolation tech- niques to estimate the missing values from the other training examples in our dataset. One of the most common interpolation techniques is mean imputation, where we simply replace the missing value with the mean value of the entire feature column. A convenient way to achieve this is by using the SimpleImputer class from scikit-learn, as shown in the following code: >>> from sklearn.impute import SimpleImputer >>> import numpy as np >>> imr = SimpleImputer(missing_values=np.nan, strategy= 'mean') >>> imr = imr.fit(df.values) >>> imputed_data = imr.transform(df.values) >>> imputed_data array([[ 1., 2., 3., 4.], [ 5., 6., 7.5, 8.], [ 10., 11., 12., 6.]]) Here, we replaced each NaN value with the corresponding mean, which is separately calculated for each feature column. Other options for the strategy parameter are median or", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 110, "start_word": 35200, "end_word": 35600, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000111": {"text": "using the SimpleImputer class from scikit-learn, as shown in the following code: >>> from sklearn.impute import SimpleImputer >>> import numpy as np >>> imr = SimpleImputer(missing_values=np.nan, strategy= 'mean') >>> imr = imr.fit(df.values) >>> imputed_data = imr.transform(df.values) >>> imputed_data array([[ 1., 2., 3., 4.], [ 5., 6., 7.5, 8.], [ 10., 11., 12., 6.]]) Here, we replaced each NaN value with the corresponding mean, which is separately calculated for each feature column. Other options for the strategy parameter are median or most_frequent , where the latter replaces the missing values with the most frequent values. This is useful for imputing cate - gorical feature values, for example, a feature column that stores an encoding of color names, such as red, green, and blue. We will encounter examples of such data later in this chapter. Chapter 4 109 Alternatively, an even more convenient way to impute missing values is by using pandas’ fillna method and providing an imputation method as an argument. For example, using pandas, we could achieve the same mean imputation directly in the DataFrame object via the following command: >>> df.fillna(df.mean()) Figure 4.1: Replacing missing values in data with the mean Understanding the scikit-learn estimator API In the previous section, we used the SimpleImputer class from scikit-learn to impute missing values in our dataset. The SimpleImputer class is part of the so-called transformer API in scikit-learn, which is used for implementing Python classes related to data transformation. (Please note that the scikit- learn transformer API is not to be confused with the transformer architecture that is used in natural language processing, which we will cover in more detail in Chapter 16 , Transformers – Improving Natural Language Processing with Attention Mechanisms.) The two essential methods of those estimators are fit and transform . The fit method is used to learn the parameters from the training data, and the transform method uses those parameters to transform the data. Any data array that is to be trans- formed needs to have the same number of features as the data array that was used to fit the model.Additional imputation methods for missing data For additional imputation techniques, including the KNNImputer based on a k-nearest neighbors approach to impute missing features by nearest neighbors, we recommend the scikit-learn imputation documentation at https://scikit-learn.org/stable/ modules/impute.html . Building Good Training Datasets – Data Preprocessing 110 Figure 4.2 illustrates how a scikit-learn transformer instance, fitted on the", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 111, "start_word": 35520, "end_word": 35920, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000112": {"text": "array that is to be trans- formed needs to have the same number of features as the data array that was used to fit the model.Additional imputation methods for missing data For additional imputation techniques, including the KNNImputer based on a k-nearest neighbors approach to impute missing features by nearest neighbors, we recommend the scikit-learn imputation documentation at https://scikit-learn.org/stable/ modules/impute.html . Building Good Training Datasets – Data Preprocessing 110 Figure 4.2 illustrates how a scikit-learn transformer instance, fitted on the training data, is used to transform a training dataset as well as a new test dataset: Figure 4.2: Using the scikit-learn API for data transformation The classifiers that we used in Chapter 3 , A Tour of Machine Learning Classifiers Using Scikit-Learn, belong to the so-called estimators in scikit-learn, with an API that is conceptually very similar to the scikit- learn transformer API. Estimators have a predict method but can also have a transform method, as you will see later in this chapter. As you may recall, we also used the fit method to learn the parame - ters of a model when we trained those estimators for classification. However, in supervised learning tasks, we additionally provide the class labels for fitting the model, which can then be used to make predictions about new, unlabeled data examples via the predict method, as illustrated in Figure 4.3: Figure 4.3: Using the scikit-learn API for predictive models such as classifiers Chapter 4 111 Handling categorical data So far, we have only been working with numerical values. However, it is not uncommon for real-world datasets to contain one or more categorical feature columns. In this section, we will make use of sim- ple yet effective examples to see how to deal with this type of data in numerical computing libraries. When we are talking about categorical data, we have to further distinguish between ordinal and nom- inal features. Ordinal features can be understood as categorical values that can be sorted or ordered. For example, t-shirt size would be an ordinal feature, because we can define an order: XL > L > M. In contrast, nominal features don’t imply any order; to continue with the previous example, we could think of t-shirt color as a nominal feature since it typically doesn’t make sense to say that, for example, red is larger than blue. Categorical data encoding with pandas Before we explore different techniques for", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 112, "start_word": 35840, "end_word": 36240, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000113": {"text": "as categorical values that can be sorted or ordered. For example, t-shirt size would be an ordinal feature, because we can define an order: XL > L > M. In contrast, nominal features don’t imply any order; to continue with the previous example, we could think of t-shirt color as a nominal feature since it typically doesn’t make sense to say that, for example, red is larger than blue. Categorical data encoding with pandas Before we explore different techniques for handling such categorical data, let’s create a new DataFrame to illustrate the problem: >>> import pandas as pd >>> df = pd.DataFrame([ ... [ 'green', 'M', 10.1, 'class2' ], ... [ 'red', 'L', 13.5, 'class1' ], ... [ 'blue', 'XL', 15.3, 'class2' ]]) >>> df.columns = [ 'color', 'size' , 'price' , 'classlabel' ] >>> df color size price classlabel 0 green M 10.1 class2 1 red L 13.5 class1 2 blue XL 15.3 class2 As we can see in the preceding output, the newly created DataFrame contains a nominal feature ( color ), an ordinal feature ( size ), and a numerical feature ( price ) column. The class labels (assuming that we created a dataset for a supervised learning task) are stored in the last column. The learning algorithms for classification that we discuss in this book do not use ordinal information in class labels. Mapping ordinal features To make sure that the learning algorithm interprets the ordinal features correctly, we need to convert the categorical string values into integers. Unfortunately, there is no convenient function that can automatically derive the correct order of the labels of our size feature, so we have to define the map - ping manually. In the following simple example, let’s assume that we know the numerical difference between features, for example, XL = L + 1 = M + 2: >>> size_mapping = { 'XL': 3, ... 'L': 2, ... 'M': 1} Building Good Training Datasets – Data Preprocessing 112 >>> df['size'] = df['size'].map(size_mapping) >>> df color size price classlabel 0 green 1 10.1 class2 1 red 2 13.5 class1 2 blue 3 15.3 class2 If we want to transform the integer values back to the original string representation at a later stage, we can simply define a reverse-mapping dictionary, inv_size_mapping = {v: k for k, v in size_ mapping.items()} , which can then be used via the pandas map method on", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 113, "start_word": 36160, "end_word": 36560, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000114": {"text": "Building Good Training Datasets – Data Preprocessing 112 >>> df['size'] = df['size'].map(size_mapping) >>> df color size price classlabel 0 green 1 10.1 class2 1 red 2 13.5 class1 2 blue 3 15.3 class2 If we want to transform the integer values back to the original string representation at a later stage, we can simply define a reverse-mapping dictionary, inv_size_mapping = {v: k for k, v in size_ mapping.items()} , which can then be used via the pandas map method on the transformed feature column and is similar to the size_mapping dictionary that we used previously. We can use it as follows: >>> inv_size_mapping = {v: k for k, v in size_mapping.items()} >>> df['size'].map(inv_size_mapping) 0 M 1 L 2 XL Name: size, dtype: object Encoding class labels Many machine learning libraries require that class labels are encoded as integer values. Although most estimators for classification in scikit-learn convert class labels to integers internally, it is considered good practice to provide class labels as integer arrays to avoid technical glitches. To encode the class labels, we can use an approach similar to the mapping of ordinal features discussed previously. We need to remember that class labels are not ordinal, and it doesn’t matter which integer number we assign to a particular string label. Thus, we can simply enumerate the class labels, starting at 0: >>> import numpy as np >>> class_mapping = {label: idx for idx, label in ... enumerate (np.unique(df[ 'classlabel' ]))} >>> class_mapping {'class1': 0, 'class2': 1} Next, we can use the mapping dictionary to transform the class labels into integers: >>> df['classlabel' ] = df['classlabel' ].map(class_mapping) >>> df color size price classlabel 0 green 1 10.1 1 1 red 2 13.5 0 2 blue 3 15.3 1 Chapter 4 113 We can reverse the key-value pairs in the mapping dictionary as follows to map the converted class labels back to the original string representation: >>> inv_class_mapping = {v: k for k, v in class_mapping.items()} >>> df['classlabel' ] = df['classlabel' ].map(inv_class_mapping) >>> df color size price classlabel 0 green 1 10.1 class2 1 red 2 13.5 class1 2 blue 3 15.3 class2 Alternatively, there is a convenient LabelEncoder class directly implemented in scikit-learn to achieve this: >>> from sklearn.preprocessing import LabelEncoder >>> class_le = LabelEncoder() >>> y = class_le.fit_transform(df[ 'classlabel' ].values) >>> y array([1, 0, 1]) Note that the fit_transform method is just a shortcut for calling fit and transform", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 114, "start_word": 36480, "end_word": 36880, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000115": {"text": "for k, v in class_mapping.items()} >>> df['classlabel' ] = df['classlabel' ].map(inv_class_mapping) >>> df color size price classlabel 0 green 1 10.1 class2 1 red 2 13.5 class1 2 blue 3 15.3 class2 Alternatively, there is a convenient LabelEncoder class directly implemented in scikit-learn to achieve this: >>> from sklearn.preprocessing import LabelEncoder >>> class_le = LabelEncoder() >>> y = class_le.fit_transform(df[ 'classlabel' ].values) >>> y array([1, 0, 1]) Note that the fit_transform method is just a shortcut for calling fit and transform separately, and we can use the inverse_transform method to transform the integer class labels back into their orig- inal string representation: >>> class_le.inverse_transform(y) array(['class2', 'class1', 'class2'], dtype=object) Performing one-hot encoding on nominal features In the previous Mapping ordinal features section, we used a simple dictionary mapping approach to convert the ordinal size feature into integers. Since scikit-learn’s estimators for classification treat class labels as categorical data that does not imply any order (nominal), we used the convenient LabelEncoder to encode the string labels into integers. We could use a similar approach to transform the nominal color column of our dataset, as follows: >>> X = df[[ 'color', 'size' , 'price' ]].values >>> color_le = LabelEncoder() >>> X[:, 0] = color_le.fit_transform(X[:, 0]) >>> X array([[1, 1, 10.1], [2, 2, 13.5], [0, 3, 15.3]], dtype=object) Building Good Training Datasets – Data Preprocessing 114 After executing the preceding code, the first column of the NumPy array, X, now holds the new color values, which are encoded as follows: • blue = 0 • green = 1 • red = 2 If we stop at this point and feed the array to our classifier, we will make one of the most common mistakes in dealing with categorical data. Can you spot the problem? Although the color values don’t come in any particular order, common classification models, such as the ones covered in the previous chapters, will now assume that green is larger than blue , and red is larger than green . Although this assumption is incorrect, a classifier could still produce useful results. However, those results would not be optimal. A common workaround for this problem is to use a technique called one-hot encoding . The idea behind this approach is to create a new dummy feature for each unique value in the nominal feature column. Here, we would convert the color feature into three new features: blue , green , and red.", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 115, "start_word": 36800, "end_word": 37200, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000116": {"text": ", and red is larger than green . Although this assumption is incorrect, a classifier could still produce useful results. However, those results would not be optimal. A common workaround for this problem is to use a technique called one-hot encoding . The idea behind this approach is to create a new dummy feature for each unique value in the nominal feature column. Here, we would convert the color feature into three new features: blue , green , and red. Binary values can then be used to indicate the particular color of an example; for example, a blue example can be encoded as blue=1 , green=0 , red=0 . To perform this transformation, we can use the OneHotEncoder that is implemented in scikit-learn’s preprocessing module: >>> from sklearn.preprocessing import OneHotEncoder >>> X = df[[ 'color', 'size' , 'price' ]].values >>> color_ohe = OneHotEncoder() >>> color_ohe.fit_transform(X[:, 0].reshape(- 1, 1)).toarray() array([[0., 1., 0.], [0., 0., 1.], [1., 0., 0.]]) Note that we applied the OneHotEncoder to only a single column, (X[:, 0].reshape(-1, 1)) , to avoid modifying the other two columns in the array as well. If we want to selectively transform columns in a multi-feature array, we can use the ColumnTransformer , which accepts a list of (name, transformer, column(s)) tuples as follows: >>> from sklearn.compose import ColumnTransformer >>> X = df[[ 'color', 'size' , 'price' ]].values >>> c_transf = ColumnTransformer([ ... ('onehot' , OneHotEncoder(), [ 0]), ... ('nothing' , 'passthrough' , [1, 2]) ... ]) >>> c_transf.fit_transform(X).astype( float) array([[0.0, 1.0, 0.0, 1, 10.1], [0.0, 0.0, 1.0, 2, 13.5], [1.0, 0.0, 0.0, 3, 15.3]]) Chapter 4 115 In the preceding code example, we specified that we want to modify only the first column and leave the other two columns untouched via the 'passthrough' argument. An even more convenient way to create those dummy features via one-hot encoding is to use the get_dummies method implemented in pandas. Applied to a DataFrame , the get_dummies method will only convert string columns and leave all other columns unchanged: >>> pd.get_dummies(df[[ 'price', 'color' , 'size' ]]) price size color_blue color_green color_red 0 10.1 1 0 1 0 1 13.5 2 0 0 1 2 15.3 3 1 0 0 When we are using one-hot encoding datasets, we have to keep in mind that this introduces multi- collinearity, which can be an issue for certain methods (for instance, methods that require matrix inversion). If features are", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 116, "start_word": 37120, "end_word": 37520, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000117": {"text": "the get_dummies method will only convert string columns and leave all other columns unchanged: >>> pd.get_dummies(df[[ 'price', 'color' , 'size' ]]) price size color_blue color_green color_red 0 10.1 1 0 1 0 1 13.5 2 0 0 1 2 15.3 3 1 0 0 When we are using one-hot encoding datasets, we have to keep in mind that this introduces multi- collinearity, which can be an issue for certain methods (for instance, methods that require matrix inversion). If features are highly correlated, matrices are computationally difficult to invert, which can lead to numerically unstable estimates. To reduce the correlation among variables, we can simply remove one feature column from the one-hot encoded array. Note that we do not lose any important information by removing a feature column, though; for example, if we remove the column color_blue , the feature information is still preserved since if we observe color_green=0 and color_red=0 , it implies that the observation must be blue . If we use the get_dummies function, we can drop the first column by passing a True argument to the drop_first parameter, as shown in the following code example: >>> pd.get_dummies(df[[ 'price', 'color' , 'size' ]], ... drop_first= True) price size color_green color_red 0 10.1 1 1 0 1 13.5 2 0 1 2 15.3 3 0 0 In order to drop a redundant column via the OneHotEncoder , we need to set drop='first' and set categories='auto' as follows: >>> color_ohe = OneHotEncoder(categories= 'auto', drop='first') >>> c_transf = ColumnTransformer([ ... ( 'onehot' , color_ohe, [ 0]), ... ( 'nothing' , 'passthrough' , [1, 2]) ... ]) >>> c_transf.fit_transform(X).astype( float) array([[ 1. , 0. , 1. , 10.1], [ 0. , 1. , 2. , 13.5], [ 0. , 0. , 3. , 15.3]]) Building Good Training Datasets – Data Preprocessing 116 Optional: encoding ordinal features If we are unsure about the numerical differences between the categories of ordinal features, or the difference between two ordinal values is not defined, we can also encode them using a threshold encoding with 0/1 values. For example, we can split the feature size with values M, L, and XL into two new features, x > M and x > L . Let’s consider the original DataFrame : >>> df = pd.DataFrame([[ 'green', 'M', 10.1, ... 'class2' ], ... [ 'red', 'L', 13.5, ... 'class1' ], ... [ 'blue', 'XL', 15.3, ... 'class2' ]]) >>> df.columns", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 117, "start_word": 37440, "end_word": 37840, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000118": {"text": "difference between two ordinal values is not defined, we can also encode them using a threshold encoding with 0/1 values. For example, we can split the feature size with values M, L, and XL into two new features, x > M and x > L . Let’s consider the original DataFrame : >>> df = pd.DataFrame([[ 'green', 'M', 10.1, ... 'class2' ], ... [ 'red', 'L', 13.5, ... 'class1' ], ... [ 'blue', 'XL', 15.3, ... 'class2' ]]) >>> df.columns = [ 'color', 'size' , 'price' , ... 'classlabel' ] >>> df We can use the apply method of pandas’ DataFrame to write custom lambda expressions in order to encode these variables using the value-threshold approach: >>> df['x > M'] = df['size'].apply( ... lambda x: 1 if x in {'L', 'XL'} else 0) >>> df['x > L'] = df['size'].apply( ... lambda x: 1 if x == 'XL' else 0)Additional encoding schemes for nominal data While one-hot encoding is the most common way to encode unordered categorical vari- ables, several alternative methods exist. Some of these techniques can be useful when working with categorical features that have high cardinality (a large number of unique category labels). Examples include: • Binary encoding, which produces multiple binary features similar to one-hot encoding but requires fewer feature columns, i.e., log 2(K) instead of K – 1, where K is the number of unique categories. In binary encoding, numbers are first con- verted into binary representations, and then each binary number position will form a new feature column. • Count or frequency encoding, which replaces the label of each category by the number of times or frequency it occurs in the training set. These methods, as well as additional categorical encoding schemes, are available via the scikit-learn-compatible category_encoders library: https://contrib.scikit-learn. org/category_encoders/ . While these methods are not guaranteed to perform better than one-hot encoding in terms of model performance, we can consider the choice of a categorical encoding scheme as an additional “hyperparameter” for improving model performance. Chapter 4 117 >>> del df['size'] >>> df Partitioning a dataset into separate training and test datasets We briefly introduced the concept of partitioning a dataset into separate datasets for training and testing in Chapter 1, Giving Computers the Ability to Learn from Data, and Chapter 3, A Tour of Machine Learning Classifiers Using Scikit-Learn. Remember that comparing predictions to true labels in the test set can be", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 118, "start_word": 37760, "end_word": 38160, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000119": {"text": "a categorical encoding scheme as an additional “hyperparameter” for improving model performance. Chapter 4 117 >>> del df['size'] >>> df Partitioning a dataset into separate training and test datasets We briefly introduced the concept of partitioning a dataset into separate datasets for training and testing in Chapter 1, Giving Computers the Ability to Learn from Data, and Chapter 3, A Tour of Machine Learning Classifiers Using Scikit-Learn. Remember that comparing predictions to true labels in the test set can be understood as the unbiased performance evaluation of our model before we let it loose in the real world. In this section, we will prepare a new dataset, the Wine dataset. After we have preprocessed the dataset, we will explore different techniques for feature selection to reduce the dimensionality of a dataset. The Wine dataset is another open-source dataset that is available from the UCI machine learning re - pository ( https://archive.ics.uci.edu/ml/datasets/Wine ); it consists of 178 wine examples with 13 features describing their different chemical properties. Using the pandas library, we will directly read in the open-source Wine dataset from the UCI machine learning repository: >>> df_wine = pd.read_csv( 'https://archive.ics.uci.edu/' ... 'ml/machine-learning-databases/' ... 'wine/wine.data' , header= None)Obtaining the Wine dataset You can find a copy of the Wine dataset (and all other datasets used in this book) in the code bundle of this book, which you can use if you are working offline or the dataset at https://archive.ics.uci.edu/ml/machine-learning-databases/wine/wine.data is temporarily unavailable on the UCI server. For instance, to load the Wine dataset from a local directory, you can replace this line: df = pd.read_csv( 'https://archive.ics.uci.edu/ml/' 'machine-learning-databases/wine/wine.data' , header= None ) with the following one: df = pd.read_csv( 'your/local/path/to/wine.data' , header= None ) Building Good Training Datasets – Data Preprocessing 118 >>> df_wine.columns = [ 'Class label' , 'Alcohol' , ... 'Malic acid' , 'Ash', ... 'Alcalinity of ash' , 'Magnesium' , ... 'Total phenols' , 'Flavanoids' , ... 'Nonflavanoid phenols' , ... 'Proanthocyanins' , ... 'Color intensity' , 'Hue', ... 'OD280/OD315 of diluted wines' , ... 'Proline' ] >>> print('Class labels' , np.unique(df_wine[ 'Class label' ])) Class labels [1 2 3] >>> df_wine.head() The 13 different features in the Wine dataset, describing the chemical properties of the 178 wine examples, are listed in the following table: Figure 4.4: A sample of the Wine dataset The examples belong to one of three different classes, 1, 2, and 3, which refer to", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 119, "start_word": 38080, "end_word": 38480, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000120": {"text": ", ... 'Proanthocyanins' , ... 'Color intensity' , 'Hue', ... 'OD280/OD315 of diluted wines' , ... 'Proline' ] >>> print('Class labels' , np.unique(df_wine[ 'Class label' ])) Class labels [1 2 3] >>> df_wine.head() The 13 different features in the Wine dataset, describing the chemical properties of the 178 wine examples, are listed in the following table: Figure 4.4: A sample of the Wine dataset The examples belong to one of three different classes, 1, 2, and 3, which refer to the three different types of grape grown in the same region in Italy but derived from different wine cultivars, as described in the dataset summary ( https://archive.ics.uci.edu/ml/machine-learning-databases/wine/ wine.names ). A convenient way to randomly partition this dataset into separate test and training datasets is to use the train_test_split function from scikit-learn’s model_selection submodule: >>> from sklearn.model_selection import train_test_split >>> X, y = df_wine.iloc[:, 1:].values, df_wine.iloc[:, 0].values >>> X_train, X_test, y_train, y_test =\\ ... train_test_split(X, y, ... test_size= 0.3, ... random_state= 0, ... stratify=y) First, we assigned the NumPy array representation of the feature columns 1-13 to the variable X and we assigned the class labels from the first column to the variable y. Then, we used the train_test_split function to randomly split X and y into separate training and test datasets. Chapter 4 119 By setting test_size=0.3 , we assigned 30 percent of the wine examples to X_test and y_test , and the remaining 70 percent of the examples were assigned to X_train and y_train , respectively. Providing the class label array y as an argument to stratify ensures that both training and test datasets have the same class proportions as the original dataset. Bringing features onto the same scale Feature scaling is a crucial step in our preprocessing pipeline that can easily be forgotten. Decision trees and random forests are two of the very few machine learning algorithms where we don’t need to worry about feature scaling. Those algorithms are scale-invariant. However, the majority of machine learning and optimization algorithms behave much better if features are on the same scale, as we saw in Chapter 2, Training Simple Machine Learning Algorithms for Classification, when we implemented the gradient descent optimization algorithm. The importance of feature scaling can be illustrated by a simple example. Let’s assume that we have two features where one feature is measured on a scale from 1 to 10 and the second feature is measured on", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 120, "start_word": 38400, "end_word": 38800, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000121": {"text": "are scale-invariant. However, the majority of machine learning and optimization algorithms behave much better if features are on the same scale, as we saw in Chapter 2, Training Simple Machine Learning Algorithms for Classification, when we implemented the gradient descent optimization algorithm. The importance of feature scaling can be illustrated by a simple example. Let’s assume that we have two features where one feature is measured on a scale from 1 to 10 and the second feature is measured on a scale from 1 to 100,000, respectively. When we think of the squared error function in Adaline from Chapter 2, it makes sense to say that the algorithm will mostly be busy optimizing the weights according to the larger errors in the second feature. Another example is the k-nearest neighbors ( KNN) algorithm with a Euclidean distance measure: the computed distances between examples will be dominated by the second feature axis.Choosing an appropriate ratio for partitioning a dataset into training and test datasets If we are dividing a dataset into training and test datasets, we have to keep in mind that we are withholding valuable information that the learning algorithm could benefit from. Thus, we don’t want to allocate too much information to the test set. However, the smaller the test set, the more inaccurate the estimation of the generalization error. Dividing a dataset into training and test datasets is all about balancing this tradeoff. In practice, the most commonly used splits are 60:40, 70:30, or 80:20, depending on the size of the initial dataset. However, for large datasets, 90:10 or 99:1 splits are also common and appropriate. For example, if the dataset contains more than 100,000 training examples, it might be fine to withhold only 10,000 examples for testing in order to get a good estimate of the gener - alization performance. More information and illustrations can be found in section one of my article Model evaluation, model selection, and algorithm selection in machine learning, which is freely available at https://arxiv.org/pdf/1811.12808.pdf. Also, we will revisit the topic of model evaluation and discuss it in more detail in Chapter 6, Learning Best Practices for Model Evaluation and Hyperparameter Tuning. Moreover, instead of discarding the allocated test data after model training and evaluation, it is a common practice to retrain a classifier on the entire dataset, as it can improve the predictive performance of the model. While this approach is generally", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 121, "start_word": 38720, "end_word": 39120, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000122": {"text": "and algorithm selection in machine learning, which is freely available at https://arxiv.org/pdf/1811.12808.pdf. Also, we will revisit the topic of model evaluation and discuss it in more detail in Chapter 6, Learning Best Practices for Model Evaluation and Hyperparameter Tuning. Moreover, instead of discarding the allocated test data after model training and evaluation, it is a common practice to retrain a classifier on the entire dataset, as it can improve the predictive performance of the model. While this approach is generally recommended, it could lead to worse generalization performance if the dataset is small and the test dataset contains outliers, for example. Also, after refitting the model on the whole dataset, we don’t have any independent data left to evaluate its performance. Building Good Training Datasets – Data Preprocessing 120 Now, there are two common approaches to bringing different features onto the same scale: normaliza - tion and standardization . Those terms are often used quite loosely in different fields, and the meaning has to be derived from the context. Most often, normalization refers to the rescaling of the features to a range of [0, 1], which is a special case of min-max scaling. To normalize our data, we can simply apply the min-max scaling to each feature column, where the new value, 𝑥𝑥𝑛𝑛𝑛𝑛𝑛𝑛𝑛𝑛(𝑖𝑖) , of an example, x(i), can be calculated as follows: 𝑥𝑥𝑛𝑛𝑛𝑛𝑛𝑛𝑛𝑛(𝑖𝑖)=𝑥𝑥(𝑖𝑖)−𝑥𝑥𝑛𝑛𝑖𝑖𝑛𝑛 𝑥𝑥𝑛𝑛𝑚𝑚𝑚𝑚−𝑥𝑥𝑛𝑛𝑖𝑖𝑛𝑛 Here, x(i) is a particular example, x min is the smallest value in a feature column, and x max is the largest value. The min-max scaling procedure is implemented in scikit-learn and can be used as follows: >>> from sklearn.preprocessing import MinMaxScaler >>> mms = MinMaxScaler() >>> X_train_norm = mms.fit_transform(X_train) >>> X_test_norm = mms.transform(X_test) Although normalization via min-max scaling is a commonly used technique that is useful when we need values in a bounded interval, standardization can be more practical for many machine learning algorithms, especially for optimization algorithms such as gradient descent. The reason is that many linear models, such as the logistic regression and SVM from Chapter 3, initialize the weights to 0 or small random values close to 0. Using standardization, we center the feature columns at mean 0 with standard deviation 1 so that the feature columns have the same parameters as a standard normal distribution (zero mean and unit variance), which makes it easier to learn the weights. However, we shall emphasize that standardization does not change the shape of", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 122, "start_word": 39040, "end_word": 39440, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000123": {"text": "is that many linear models, such as the logistic regression and SVM from Chapter 3, initialize the weights to 0 or small random values close to 0. Using standardization, we center the feature columns at mean 0 with standard deviation 1 so that the feature columns have the same parameters as a standard normal distribution (zero mean and unit variance), which makes it easier to learn the weights. However, we shall emphasize that standardization does not change the shape of the distribution, and it does not transform non-normally distributed data into normally distributed data. In addition to scaling data such that it has zero mean and unit variance, standardization maintains useful information about outliers and makes the algorithm less sensitive to them in contrast to min-max scaling, which scales the data to a limited range of values. The procedure for standardization can be expressed by the following equation: 𝑥𝑥𝑠𝑠𝑠𝑠𝑠𝑠(𝑖𝑖)=𝑥𝑥(𝑖𝑖)−𝜇𝜇𝑥𝑥 𝜎𝜎𝑥𝑥 Chapter 4 121 Here, 𝜇𝜇𝑥𝑥 is the sample mean of a particular feature column, and 𝜎𝜎𝑥𝑥 is the corresponding standard deviation. The following table illustrates the difference between the two commonly used feature scaling tech- niques, standardization and normalization, on a simple example dataset consisting of numbers 0 to 5: Input Standardized Min-max normalized 0.0 -1.46385 0.0 1.0 -0.87831 0.2 2.0 -0.29277 0.4 3.0 0.29277 0.6 4.0 0.87831 0.8 5.0 1.46385 1.0 Table 4.1: A comparison between standardization and min-max normalization You can perform the standardization and normalization shown in the table manually by executing the following code examples: >>> ex = np.array([ 0, 1, 2, 3, 4, 5]) >>> print('standardized:' , (ex - ex.mean()) / ex.std()) standardized: [-1.46385011 -0.87831007 -0.29277002 0.29277002 0.87831007 1.46385011] >>> print('normalized:' , (ex - ex. min()) / (ex. max() - ex. min())) normalized: [ 0. 0.2 0.4 0.6 0.8 1. ] Similar to the MinMaxScaler class, scikit-learn also implements a class for standardization: >>> from sklearn.preprocessing import StandardScaler >>> stdsc = StandardScaler() >>> X_train_std = stdsc.fit_transform(X_train) >>> X_test_std = stdsc.transform(X_test) Building Good Training Datasets – Data Preprocessing 122 Again, it is also important to highlight that we fit the StandardScaler class only once—on the training data—and use those parameters to transform the test dataset or any new data point. Other, more advanced methods for feature scaling are available from scikit-learn, such as RobustScaler . RobustScaler is especially helpful and recommended if we are working with small datasets that contain many outliers. Similarly, if the machine", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 123, "start_word": 39360, "end_word": 39760, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000124": {"text": "stdsc.fit_transform(X_train) >>> X_test_std = stdsc.transform(X_test) Building Good Training Datasets – Data Preprocessing 122 Again, it is also important to highlight that we fit the StandardScaler class only once—on the training data—and use those parameters to transform the test dataset or any new data point. Other, more advanced methods for feature scaling are available from scikit-learn, such as RobustScaler . RobustScaler is especially helpful and recommended if we are working with small datasets that contain many outliers. Similarly, if the machine learning algorithm applied to this dataset is prone to overfitting, RobustScaler can be a good choice. Operating on each feature column independently, RobustScaler removes the median value and scales the dataset according to the 1st and 3rd quartile of the dataset (that is, the 25th and 75th quantile, respectively) such that more extreme values and outliers become less pronounced. The interested reader can find more information about RobustScaler in the official scikit-learn documentation at https://scikit-learn.org/stable/modules/generated/ sklearn.preprocessing.RobustScaler.html . Selecting meaningful features If we notice that a model performs much better on a training dataset than on the test dataset, this ob - servation is a strong indicator of overfitting. As we discussed in Chapter 3, A Tour of Machine Learning Classifiers Using Scikit-Learn, overfitting means the model fits the parameters too closely with regard to the particular observations in the training dataset but does not generalize well to new data; we say that the model has a high variance. The reason for the overfitting is that our model is too complex for the given training data. Common solutions to reduce the generalization error are as follows: • Collect more training data • Introduce a penalty for complexity via regularization • Choose a simpler model with fewer parameters • Reduce the dimensionality of the data Collecting more training data is often not applicable. In Chapter 6, Learning Best Practices for Model Evaluation and Hyperparameter Tuning, we will learn about a useful technique to check whether more training data is helpful. In the following sections, we will look at common ways to reduce overfitting by regularization and dimensionality reduction via feature selection, which leads to simpler models by requiring fewer parameters to be fitted to the data. Then, in Chapter 5, Compressing Data via Dimen- sionality Reduction, we will take a look at additional feature extraction techniques. L1 and L2 regularization as penalties against model complexity You will recall from Chapter 3 that", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 124, "start_word": 39680, "end_word": 40080, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000125": {"text": "to check whether more training data is helpful. In the following sections, we will look at common ways to reduce overfitting by regularization and dimensionality reduction via feature selection, which leads to simpler models by requiring fewer parameters to be fitted to the data. Then, in Chapter 5, Compressing Data via Dimen- sionality Reduction, we will take a look at additional feature extraction techniques. L1 and L2 regularization as penalties against model complexity You will recall from Chapter 3 that L2 regularization is one approach to reduce the complexity of a model by penalizing large individual weights. We defined the squared L2 norm of our weight vector, w, as follows: 𝐿𝐿𝐿𝐿‖𝒘𝒘‖22=∑𝑤𝑤𝑗𝑗2𝑚𝑚 𝑗𝑗𝑗𝑗 Chapter 4 123 Another approach to reduce the model complexity is the related L1 regularization: 𝐿𝐿𝐿𝐿‖𝒘𝒘‖1= ∑|𝑤𝑤 𝑗𝑗|𝑚𝑚 𝑗𝑗𝑗1 Here, we simply replaced the square of the weights with the sum of the absolute values of the weights. In contrast to L2 regularization, L1 regularization usually yields sparse feature vectors, and most fea - ture weights will be zero. Sparsity can be useful in practice if we have a high-dimensional dataset with many features that are irrelevant, especially in cases where we have more irrelevant dimensions than training examples. In this sense, L1 regularization can be understood as a technique for feature selection. A geometric interpretation of L2 regularization As mentioned in the previous section, L2 regularization adds a penalty term to the loss function that effectively results in less extreme weight values compared to a model trained with an unregularized loss function. To better understand how L1 regularization encourages sparsity, let’s take a step back and take a look at a geometric interpretation of regularization. Let’s plot the contours of a convex loss function for two weight coefficients, w 1 and w 2. Here, we will consider the mean squared error ( MSE ) loss function that we used for Adaline in Chapter 2, which computes the squared distances between the true and predicted class labels, y and 𝑦𝑦𝑦 , aver - aged over all N examples in the training set. Since the MSE is spherical, it is easier to draw than the loss function of logistic regression; however, the same concepts apply. Remember that our goal is to find the combination of weight coefficients that minimize the loss function for the training data, as shown in Figure 4.5 (the point in the center of the ellipses):", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 125, "start_word": 40000, "end_word": 40400, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000126": {"text": "squared distances between the true and predicted class labels, y and 𝑦𝑦𝑦 , aver - aged over all N examples in the training set. Since the MSE is spherical, it is easier to draw than the loss function of logistic regression; however, the same concepts apply. Remember that our goal is to find the combination of weight coefficients that minimize the loss function for the training data, as shown in Figure 4.5 (the point in the center of the ellipses): Figure 4.5: Minimizing the mean squared error loss function Building Good Training Datasets – Data Preprocessing 124 We can think of regularization as adding a penalty term to the loss function to encourage smaller weights; in other words, we penalize large weights. Thus, by increasing the regularization strength via the regularization parameter, 𝜆𝜆 , we shrink the weights toward zero and decrease the dependence of our model on the training data. Let’s illustrate this concept in the following figure for the L2 penalty term: Figure 4.6: Applying L2 regularization to the loss function The quadratic L2 regularization term is represented by the shaded ball. Here, our weight coefficients cannot exceed our regularization budget—the combination of the weight coefficients cannot fall outside the shaded area. On the other hand, we still want to minimize the loss function. Under the penalty constraint, our best effort is to choose the point where the L2 ball intersects with the contours of the unpenalized loss function. The larger the value of the regularization parameter, 𝜆𝜆 , gets, the faster the penalized loss grows, which leads to a narrower L2 ball. For example, if we increase the regularization parameter toward infinity, the weight coefficients will become effectively zero, denoted by the center of the L2 ball. To summarize the main message of the example, our goal is to minimize the sum of the unpenalized loss plus the penalty term, which can be understood as adding bias and preferring a simpler model to reduce the variance in the absence of sufficient training data to fit the model. Chapter 4 125 Sparse solutions with L1 regularization Now, let’s discuss L1 regularization and sparsity. The main concept behind L1 regularization is similar to what we discussed in the previous section. However, since the L1 penalty is the sum of the absolute weight coefficients (remember that the L2 term is quadratic), we can represent it as a diamond-shape budget, as", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 126, "start_word": 40320, "end_word": 40720, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000127": {"text": "and preferring a simpler model to reduce the variance in the absence of sufficient training data to fit the model. Chapter 4 125 Sparse solutions with L1 regularization Now, let’s discuss L1 regularization and sparsity. The main concept behind L1 regularization is similar to what we discussed in the previous section. However, since the L1 penalty is the sum of the absolute weight coefficients (remember that the L2 term is quadratic), we can represent it as a diamond-shape budget, as shown in Figure 4.7: Figure 4.7: Applying L1 regularization to the loss function In the preceding figure, we can see that the contour of the loss function touches the L1 diamond at w1 = 0. Since the contours of an L1 regularized system are sharp, it is more likely that the optimum—that is, the intersection between the ellipses of the loss function and the boundary of the L1 diamond—is located on the axes, which encourages sparsity. L1 regularization and sparsity The mathematical details of why L1 regularization can lead to sparse solutions are beyond the scope of this book. If you are interested, an excellent explanation of L2 versus L1 reg- ularization can be found in Section 3.4, The Elements of Statistical Learning by Trevor Hastie, Robert Tibshirani, and Jerome Friedman, Springer Science+Business Media, 2009. Building Good Training Datasets – Data Preprocessing 126 For regularized models in scikit-learn that support L1 regularization, we can simply set the penalty parameter to 'l1' to obtain a sparse solution: >>> from sklearn.linear_model import LogisticRegression >>> LogisticRegression(penalty= 'l1', ... solver= 'liblinear' , ... multi_class= 'ovr') Note that we also need to select a different optimization algorithm (for example, solver='liblinear' ), since 'lbfgs' currently does not support L1-regularized loss optimization. Applied to the standardized Wine data, the L1 regularized logistic regression would yield the following sparse solution: >>> lr = LogisticRegression(penalty= 'l1', ... C= 1.0, ... solver= 'liblinear' , ... multi_class= 'ovr') >>> # Note that C=1.0 is the default. You can increase >>> # or decrease it to make the regularization effect >>> # stronger or weaker, respectively. >>> lr.fit(X_train_std, y_train) >>> print('Training accuracy:' , lr.score(X_train_std, y_train)) Training accuracy: 1.0 >>> print('Test accuracy:' , lr.score(X_test_std, y_test)) Test accuracy: 1.0 Both training and test accuracies (both 100 percent) indicate that our model does a perfect job on both datasets. When we access the intercept terms via the lr.intercept_ attribute, we can see that the array", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 127, "start_word": 40640, "end_word": 41040, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000128": {"text": "that C=1.0 is the default. You can increase >>> # or decrease it to make the regularization effect >>> # stronger or weaker, respectively. >>> lr.fit(X_train_std, y_train) >>> print('Training accuracy:' , lr.score(X_train_std, y_train)) Training accuracy: 1.0 >>> print('Test accuracy:' , lr.score(X_test_std, y_test)) Test accuracy: 1.0 Both training and test accuracies (both 100 percent) indicate that our model does a perfect job on both datasets. When we access the intercept terms via the lr.intercept_ attribute, we can see that the array returns three values: >>> lr.intercept_ array([-1.26317363, -1.21537306, -2.37111954]) Since we fit the LogisticRegression object on a multiclass dataset via the one-versus-rest ( OvR ) approach, the first intercept belongs to the model that fits class 1 versus classes 2 and 3, the second value is the intercept of the model that fits class 2 versus classes 1 and 3, and the third value is the intercept of the model that fits class 3 versus classes 1 and 2: >>> lr.coef_ array([[ 1.24647953, 0.18050894, 0.74540443, -1.16301108, 0. ,0. , 1.16243821, 0. , 0. , 0. , 0. , 0.55620267, 2.50890638], [-1.53919461, -0.38562247, -0.99565934, 0.36390047, -0.05892612, 0. , 0.66710883, 0. , 0. , -1.9318798 , 1.23775092, 0. , Chapter 4 127 -2.23280039], [ 0.13557571, 0.16848763, 0.35710712, 0. , 0. , 0. , -2.43804744, 0. , 0. , 1.56388787, -0.81881015, -0.49217022, 0. ]]) The weight array that we accessed via the lr.coef_ attribute contains three rows of weight coefficients, one weight vector for each class. Each row consists of 13 weights, where each weight is multiplied by the respective feature in the 13-dimensional Wine dataset to calculate the net input: 𝑧𝑧𝑧𝑧𝑧1𝑥𝑥1+⋯+𝑧𝑧𝑚𝑚𝑥𝑥𝑚𝑚+𝑏𝑏𝑧𝑏𝑥𝑥𝑗𝑗𝑧𝑧𝑗𝑗+𝑏𝑏𝑚𝑚 𝑗𝑗𝑗1𝑧𝒘𝒘𝑇𝑇𝒙𝒙+𝑏𝑏 As a result of L1 regularization, which, as mentioned, serves as a method for feature selection, we just trained a model that is robust to the potentially irrelevant features in this dataset. Strictly speaking, though, the weight vectors from the previous example are not necessarily sparse because they contain more non-zero than zero entries. However, we could enforce sparsity (more zero entries) by further increasing the regularization strength—that is, choosing lower values for the C parameter. In the last example on regularization in this chapter, we will vary the regularization strength and plot the regularization path—the weight coefficients of the different features for different regularization strengths: >>> import matplotlib.pyplot as plt >>> fig = plt.figure() >>> ax = plt.subplot( 111) >>> colors = [ 'blue', 'green' , 'red', 'cyan' , ...", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 128, "start_word": 40960, "end_word": 41360, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000129": {"text": "than zero entries. However, we could enforce sparsity (more zero entries) by further increasing the regularization strength—that is, choosing lower values for the C parameter. In the last example on regularization in this chapter, we will vary the regularization strength and plot the regularization path—the weight coefficients of the different features for different regularization strengths: >>> import matplotlib.pyplot as plt >>> fig = plt.figure() >>> ax = plt.subplot( 111) >>> colors = [ 'blue', 'green' , 'red', 'cyan' , ... 'magenta' , 'yellow' , 'black' , ... 'pink', 'lightgreen' , 'lightblue' , ... 'gray', 'indigo' , 'orange' ] >>> weights, params = [], [] >>> for c in np.arange(- 4., 6.): ... lr = LogisticRegression(penalty= 'l1', C=10.**c, ... solver= 'liblinear' , ... multi_class= 'ovr', random_state= 0) ... lr.fit(X_train_std, y_train) ... weights.append(lr.coef_[ 1]) ... params.append( 10**c)Accessing the bias unit and weight parameters of scikit-learn estimators In scikit-learn, intercept_ corresponds to the bias unit and coef_ corresponds to the values w j. Building Good Training Datasets – Data Preprocessing 128 >>> weights = np.array(weights) >>> for column, color in zip(range(weights.shape[ 1]), colors): ... plt.plot(params, weights[:, column], ... label=df_wine.columns[column + 1], ... color=color) >>> plt.axhline( 0, color= 'black', linestyle= '--', linewidth= 3) >>> plt.xlim([ 10**(-5), 10**5]) >>> plt.ylabel( 'Weight coefficient' ) >>> plt.xlabel( 'C (inverse regularization strength)' ) >>> plt.xscale( 'log') >>> plt.legend(loc= 'upper left' ) >>> ax.legend(loc= 'upper center' , ... bbox_to_anchor=( 1.38, 1.03), ... ncol= 1, fancybox= True) >>> plt.show() The resulting plot provides us with further insights into the behavior of L1 regularization. As we can see, all feature weights will be zero if we penalize the model with a strong regularization parameter (C < 0.01); C is the inverse of the regularization parameter, 𝜆𝜆 : Figure 4.8: The impact of the value of the regularization strength hyperparameter C Sequential feature selection algorithms An alternative way to reduce the complexity of the model and avoid overfitting is dimensionality reduction via feature selection, which is especially useful for unregularized models. There are two main categories of dimensionality reduction techniques: feature selection and feature extraction. Via feature selection, we select a subset of the original features, whereas in feature extraction, we derive information from the feature set to construct a new feature subspace. Chapter 4 129 In this section, we will take a look at a classic family of feature selection algorithms. In the next chapter, Chapter 5, Compressing Data via Dimensionality", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 129, "start_word": 41280, "end_word": 41680, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000130": {"text": "feature selection, which is especially useful for unregularized models. There are two main categories of dimensionality reduction techniques: feature selection and feature extraction. Via feature selection, we select a subset of the original features, whereas in feature extraction, we derive information from the feature set to construct a new feature subspace. Chapter 4 129 In this section, we will take a look at a classic family of feature selection algorithms. In the next chapter, Chapter 5, Compressing Data via Dimensionality Reduction, we will learn about different feature extraction techniques to compress a dataset onto a lower-dimensional feature subspace. Sequential feature selection algorithms are a family of greedy search algorithms that are used to reduce an initial d-dimensional feature space to a k-dimensional feature subspace where k<d. The motivation behind feature selection algorithms is to automatically select a subset of features that are most relevant to the problem, to improve computational efficiency, or to reduce the generalization error of the model by removing irrelevant features or noise, which can be useful for algorithms that don’t support regularization. A classic sequential feature selection algorithm is sequential backward selection ( SBS), which aims to reduce the dimensionality of the initial feature subspace with a minimum decay in the performance of the classifier to improve upon computational efficiency. In certain cases, SBS can even improve the predictive power of the model if a model suffers from overfitting. The idea behind the SBS algorithm is quite simple: SBS sequentially removes features from the full feature subset until the new feature subspace contains the desired number of features. To determine which feature is to be removed at each stage, we need to define the criterion function, J, that we want to minimize. The criterion calculated by the criterion function can simply be the difference in the performance of the classifier before and after the removal of a particular feature. Then, the feature to be removed at each stage can simply be defined as the feature that maximizes this criterion; or in more simple terms, at each stage we eliminate the feature that causes the least performance loss after removal. Based on the preceding definition of SBS, we can outline the algorithm in four simple steps: 1. Initialize the algorithm with k = d, where d is the dimensionality of the full feature space, X d. 2. Determine the feature, x–, that maximizes the criterion: x– =", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 130, "start_word": 41600, "end_word": 42000, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000131": {"text": "each stage can simply be defined as the feature that maximizes this criterion; or in more simple terms, at each stage we eliminate the feature that causes the least performance loss after removal. Based on the preceding definition of SBS, we can outline the algorithm in four simple steps: 1. Initialize the algorithm with k = d, where d is the dimensionality of the full feature space, X d. 2. Determine the feature, x–, that maximizes the criterion: x– = argmax J(X k – x), where 𝒙𝒙𝒙𝒙𝒙𝑘𝑘 . 3. Remove the feature, x–, from the feature set: X k–1 = X k – x–; k = k – 1. 4. Terminate if k equals the number of desired features; otherwise, go to step 2.Greedy search algorithms Greedy algorithms make locally optimal choices at each stage of a combinatorial search problem and generally yield a suboptimal solution to the problem, in contrast to exhaustive search algorithms, which evaluate all possible combinations and are guaranteed to find the optimal solution. However, in practice, an exhaustive search is often computationally not feasible, whereas greedy algorithms allow for a less complex, computationally more efficient solution. Building Good Training Datasets – Data Preprocessing 130 To practice our coding skills and ability to implement our own algorithms, let’s go ahead and imple - ment it in Python from scratch: from sklearn.base import clone from itertools import combinations import numpy as np from sklearn.metrics import accuracy_score from sklearn.model_selection import train_test_split class SBS: def __init__(self, estimator, k_features, scoring=accuracy_score, test_size= 0.25, random_state= 1): self.scoring = scoring self.estimator = clone(estimator) self.k_features = k_features self.test_size = test_size self.random_state = random_state def fit(self, X, y): X_train, X_test, y_train, y_test = \\ train_test_split(X, y, test_size=self.test_size, random_state=self.random_state) dim = X_train.shape[ 1] self.indices_ = tuple(range(dim)) self.subsets_ = [self.indices_] score = self._calc_score(X_train, y_train, X_test, y_test, self.indices_) self.scores_ = [score] while dim > self.k_features: scores = [] subsets = [] for p in combinations(self.indices_, r=dim - 1): score = self._calc_score(X_train, y_train,A resource on sequential feature algorithms You can find a detailed evaluation of several sequential feature algorithms in Compara - tive Study of Techniques for Large-Scale Feature Selection by F. Ferri, P. Pudil, M. Hatef, and J. Kittler, pages 403-413, 1994. Chapter 4 131 X_test, y_test, p) scores.append(score) subsets.append(p) best = np.argmax(scores) self.indices_ = subsets[best] self.subsets_.append(self.indices_) dim -= 1 self.scores_.append(scores[best]) self.k_score_ = self.scores_[- 1] return self def transform (self, X): return X[:, self.indices_] def _calc_score(self, X_train, y_train,", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 131, "start_word": 41920, "end_word": 42320, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000132": {"text": "score = self._calc_score(X_train, y_train,A resource on sequential feature algorithms You can find a detailed evaluation of several sequential feature algorithms in Compara - tive Study of Techniques for Large-Scale Feature Selection by F. Ferri, P. Pudil, M. Hatef, and J. Kittler, pages 403-413, 1994. Chapter 4 131 X_test, y_test, p) scores.append(score) subsets.append(p) best = np.argmax(scores) self.indices_ = subsets[best] self.subsets_.append(self.indices_) dim -= 1 self.scores_.append(scores[best]) self.k_score_ = self.scores_[- 1] return self def transform (self, X): return X[:, self.indices_] def _calc_score(self, X_train, y_train, X_test, y_test, indices): self.estimator.fit(X_train[:, indices], y_train) y_pred = self.estimator.predict(X_test[:, indices]) score = self.scoring(y_test, y_pred) return score In the preceding implementation, we defined the k_features parameter to specify the desired number of features we want to return. By default, we use accuracy_score from scikit-learn to evaluate the performance of a model (an estimator for classification) on the feature subsets. Inside the while loop of the fit method, the feature subsets created by the itertools.combination function are evaluated and reduced until the feature subset has the desired dimensionality. In each iteration, the accuracy score of the best subset is collected in a list, self.scores_ , based on the inter - nally created test dataset, X_test . We will use those scores later to evaluate the results. The column indices of the final feature subset are assigned to self.indices_ , which we can use via the transform method to return a new data array with the selected feature columns. Note that, instead of calculating the criterion explicitly inside the fit method, we simply removed the feature that is not contained in the best performing feature subset. Now, let’s see our SBS implementation in action using the KNN classifier from scikit-learn: >>> import matplotlib.pyplot as plt >>> from sklearn.neighbors import KNeighborsClassifier >>> knn = KNeighborsClassifier(n_neighbors= 5) >>> sbs = SBS(knn, k_features= 1) >>> sbs.fit(X_train_std, y_train) Building Good Training Datasets – Data Preprocessing 132 Although our SBS implementation already splits the dataset into a test and training dataset inside the fit function, we still fed the training dataset, X_train , to the algorithm. The SBS fit method will then create new training subsets for testing (validation) and training, which is why this test set is also called the validation dataset. This approach is necessary to prevent our original test set from becoming part of the training data. Remember that our SBS algorithm collects the scores of the best feature subset at each stage, so let’s", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 132, "start_word": 42240, "end_word": 42640, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000133": {"text": "and training dataset inside the fit function, we still fed the training dataset, X_train , to the algorithm. The SBS fit method will then create new training subsets for testing (validation) and training, which is why this test set is also called the validation dataset. This approach is necessary to prevent our original test set from becoming part of the training data. Remember that our SBS algorithm collects the scores of the best feature subset at each stage, so let’s move on to the more exciting part of our implementation and plot the classification accuracy of the KNN classifier that was calculated on the validation dataset. The code is as follows: >>> k_feat = [ len(k) for k in sbs.subsets_] >>> plt.plot(k_feat, sbs.scores_, marker= 'o') >>> plt.ylim([ 0.7, 1.02]) >>> plt.ylabel( 'Accuracy' ) >>> plt.xlabel( 'Number of features' ) >>> plt.grid() >>> plt.tight_layout() >>> plt.show() As we can see in Figure 4.9, the accuracy of the KNN classifier improved on the validation dataset as we reduced the number of features, which is likely due to a decrease in the curse of dimensionality that we discussed in the context of the KNN algorithm in Chapter 3. Also, we can see in the following plot that the classifier achieved 100 percent accuracy for k = {3, 7, 8, 9, 10, 11, 12}: Figure 4.9: Impact of number of features on model accuracy Chapter 4 133 To satisfy our own curiosity, let’s see what the smallest feature subset ( k=3), which yielded such a good performance on the validation dataset, looks like: >>> k3 = list(sbs.subsets_[ 10]) >>> print(df_wine.columns[ 1:][k3]) Index(['Alcohol', 'Malic acid', 'OD280/OD315 of diluted wines'], dtype='object') Using the preceding code, we obtained the column indices of the three-feature subset from the 11th position in the sbs.subsets_ attribute and returned the corresponding feature names from the column index of the pandas Wine DataFrame . Next, let’s evaluate the performance of the KNN classifier on the original test dataset: >>> knn.fit(X_train_std, y_train) >>> print('Training accuracy:' , knn.score(X_train_std, y_train)) Training accuracy: 0.967741935484 >>> print('Test accuracy:' , knn.score(X_test_std, y_test)) Test accuracy: 0.962962962963 In the preceding code section, we used the complete feature set and obtained approximately 97 percent accuracy on the training dataset and approximately 96 percent accuracy on the test dataset, which indicates that our model already generalizes well to new data. Now, let’s use the selected three-feature subset and see how well KNN", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 133, "start_word": 42560, "end_word": 42960, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000134": {"text": "classifier on the original test dataset: >>> knn.fit(X_train_std, y_train) >>> print('Training accuracy:' , knn.score(X_train_std, y_train)) Training accuracy: 0.967741935484 >>> print('Test accuracy:' , knn.score(X_test_std, y_test)) Test accuracy: 0.962962962963 In the preceding code section, we used the complete feature set and obtained approximately 97 percent accuracy on the training dataset and approximately 96 percent accuracy on the test dataset, which indicates that our model already generalizes well to new data. Now, let’s use the selected three-feature subset and see how well KNN performs: >>> knn.fit(X_train_std[:, k3], y_train) >>> print('Training accuracy:' , ... knn.score(X_train_std[:, k3], y_train)) Training accuracy: 0.951612903226 >>> print('Test accuracy:' , ... knn.score(X_test_std[:, k3], y_test)) Test accuracy: 0.925925925926 When using less than a quarter of the original features in the Wine dataset, the prediction accuracy on the test dataset declined slightly. This may indicate that those three features do not provide less discriminatory information than the original dataset. However, we also have to keep in mind that the Wine dataset is a small dataset and is very susceptible to randomness—that is, the way we split the dataset into training and test subsets, and how we split the training dataset further into a training and validation subset. While we did not increase the performance of the KNN model by reducing the number of features, we shrank the size of the dataset, which can be useful in real-world applications that may involve expensive data collection steps. Also, by substantially reducing the number of features, we obtain simpler models, which are easier to interpret. Building Good Training Datasets – Data Preprocessing 134 Assessing feature importance with random forests In previous sections, you learned how to use L1 regularization to zero out irrelevant features via logistic regression and how to use the SBS algorithm for feature selection and apply it to a KNN algorithm. Another useful approach for selecting relevant features from a dataset is using a random forest , an en - semble technique that was introduced in Chapter 3. Using a random forest, we can measure the feature importance as the averaged impurity decrease computed from all decision trees in the forest, without making any assumptions about whether our data is linearly separable or not. Conveniently, the random forest implementation in scikit-learn already collects the feature importance values for us so that we can access them via the feature_importances_ attribute after fitting a RandomForestClassifier . By executing the following code, we will now", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 134, "start_word": 42880, "end_word": 43280, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000135": {"text": "that was introduced in Chapter 3. Using a random forest, we can measure the feature importance as the averaged impurity decrease computed from all decision trees in the forest, without making any assumptions about whether our data is linearly separable or not. Conveniently, the random forest implementation in scikit-learn already collects the feature importance values for us so that we can access them via the feature_importances_ attribute after fitting a RandomForestClassifier . By executing the following code, we will now train a forest of 500 trees on the Wine dataset and rank the 13 features by their respective importance measures—remember from our discussion in Chapter 3 that we don’t need to use standardized or normalized features in tree-based models: >>> from sklearn.ensemble import RandomForestClassifier >>> feat_labels = df_wine.columns[ 1:] >>> forest = RandomForestClassifier(n_estimators= 500, ... random_state= 1) >>> forest.fit(X_train, y_train) >>> importances = forest.feature_importances_ >>> indices = np.argsort(importances)[::- 1] >>> for f in range (X_train.shape[ 1]): ... print(\"%2d) %-*s %f\" % (f + 1, 30, ... feat_labels[indices[f]],Feature selection algorithms in scikit-learn You can find implementations of several different flavors of sequential feature selec - tion related to the simple SBS that we implemented previously in the Python package mlxtend at http://rasbt.github.io/mlxtend/user_guide/feature_selection/ SequentialFeatureSelector/ . While our mlxtend implementation comes with many bells and whistles, we collaborated with the scikit-learn team to implement a simplified, user-friendly version, which has been part of the recent v0.24 release. The usage and be - havior are very similar to the SBS code we implemented in this chapter. If you would like to learn more, please see the documentation at https://scikit-learn.org/stable/ modules/generated/sklearn.feature_selection.SequentialFeatureSelector. html . There are many more feature selection algorithms available via scikit-learn. These include recursive backward elimination based on feature weights, tree-based methods to select features by importance, and univariate statistical tests. A comprehensive discussion of the different feature selection methods is beyond the scope of this book, but a good summary with illustrative examples can be found at http://scikit-learn.org/stable/modules/ feature_selection.html . Chapter 4 135 ... importances[indices[f]])) >>> plt.title( 'Feature importance' ) >>> plt.bar( range(X_train.shape[ 1]), ... importances[indices], ... align= 'center' ) >>> plt.xticks( range(X_train.shape[ 1]), ... feat_labels[indices], rotation= 90) >>> plt.xlim([- 1, X_train.shape[ 1]]) >>> plt.tight_layout() >>> plt.show() 1) Proline 0.185453 2) Flavanoids 0.174751 3) Color intensity 0.143920 4) OD280/OD315 of diluted wines 0.136162 5) Alcohol 0.118529 6) Hue 0.058739 7) Total phenols 0.050872 8) Magnesium 0.031357 9) Malic acid 0.025648 10) Proanthocyanins", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 135, "start_word": 43200, "end_word": 43600, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000136": {"text": "examples can be found at http://scikit-learn.org/stable/modules/ feature_selection.html . Chapter 4 135 ... importances[indices[f]])) >>> plt.title( 'Feature importance' ) >>> plt.bar( range(X_train.shape[ 1]), ... importances[indices], ... align= 'center' ) >>> plt.xticks( range(X_train.shape[ 1]), ... feat_labels[indices], rotation= 90) >>> plt.xlim([- 1, X_train.shape[ 1]]) >>> plt.tight_layout() >>> plt.show() 1) Proline 0.185453 2) Flavanoids 0.174751 3) Color intensity 0.143920 4) OD280/OD315 of diluted wines 0.136162 5) Alcohol 0.118529 6) Hue 0.058739 7) Total phenols 0.050872 8) Magnesium 0.031357 9) Malic acid 0.025648 10) Proanthocyanins 0.025570 11) Alcalinity of ash 0.022366 12) Nonflavanoid phenols 0.013354 13) Ash 0.013279 After executing the code, we created a plot that ranks the different features in the Wine dataset by their relative importance; note that the feature importance values are normalized so that they sum up to 1.0: Figure 4.10: Random forest-based feature importance of the Wine dataset Building Good Training Datasets – Data Preprocessing 136 We can conclude that the proline and flavonoid levels, the color intensity, the OD280/OD315 diffraction, and the alcohol concentration of wine are the most discriminative features in the dataset based on the average impurity decrease in the 500 decision trees. Interestingly, two of the top-ranked features in the plot are also in the three-feature subset selection from the SBS algorithm that we implemented in the previous section (alcohol concentration and OD280/OD315 of diluted wines). However, as far as interpretability is concerned, the random forest technique comes with an import- ant gotcha that is worth mentioning. If two or more features are highly correlated, one feature may be ranked very highly while the information on the other feature(s) may not be fully captured. On the other hand, we don’t need to be concerned about this problem if we are merely interested in the predictive performance of a model rather than the interpretation of feature importance values. To conclude this section about feature importance values and random forests, it is worth mentioning that scikit-learn also implements a SelectFromModel object that selects features based on a user-spec - ified threshold after model fitting, which is useful if we want to use the RandomForestClassifier as a feature selector and intermediate step in a scikit-learn Pipeline object, which allows us to connect different preprocessing steps with an estimator, as you will see in Chapter 6, Learning Best Practices for Model Evaluation and Hyperparameter Tuning. For example, we could set the threshold to 0.1 to reduce the dataset to", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 136, "start_word": 43520, "end_word": 43920, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000137": {"text": "implements a SelectFromModel object that selects features based on a user-spec - ified threshold after model fitting, which is useful if we want to use the RandomForestClassifier as a feature selector and intermediate step in a scikit-learn Pipeline object, which allows us to connect different preprocessing steps with an estimator, as you will see in Chapter 6, Learning Best Practices for Model Evaluation and Hyperparameter Tuning. For example, we could set the threshold to 0.1 to reduce the dataset to the five most important features using the following code: >>> from sklearn.feature_selection import SelectFromModel >>> sfm = SelectFromModel(forest, threshold= 0.1, prefit= True) >>> X_selected = sfm.transform(X_train) >>> print('Number of features that meet this threshold' , ... 'criterion:' , X_selected.shape[ 1]) Number of features that meet this threshold criterion: 5 >>> for f in range (X_selected.shape[ 1]): ... print(\"%2d) %-*s %f\" % (f + 1, 30, ... feat_labels[indices[f]], ... importances[indices[f]])) 1) Proline 0.185453 2) Flavanoids 0.174751 3) Color intensity 0.143920 4) OD280/OD315 of diluted wines 0.136162 5) Alcohol 0.118529 Chapter 4 137 Summary We started this chapter by looking at useful techniques to make sure that we handle missing data correctly. Before we feed data to a machine learning algorithm, we also have to make sure that we encode categorical variables correctly, and in this chapter, we saw how we can map ordinal and nom- inal feature values to integer representations. Moreover, we briefly discussed L1 regularization, which can help us to avoid overfitting by reducing the complexity of a model. As an alternative approach to removing irrelevant features, we used a sequential feature selection algorithm to select meaningful features from a dataset. In the next chapter, you will learn about yet another useful approach to dimensionality reduction: feature extraction. It allows us to compress features onto a lower-dimensional subspace, rather than removing features entirely as in feature selection. Join our book’s Discord space Join the book’s Discord workspace for a monthly Ask me Anything session with the authors: https://packt.link/MLwPyTorch 5 Compressing Data via Dimensionality Reduction In Chapter 4 , Building Good Training Datasets – Data Preprocessing, you learned about the different ap - proaches for reducing the dimensionality of a dataset using different feature selection techniques. An alternative approach to feature selection for dimensionality reduction is feature extraction. In this chap - ter, you will learn about two fundamental techniques that will help you to summarize the information content of", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 137, "start_word": 43840, "end_word": 44240, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000138": {"text": "monthly Ask me Anything session with the authors: https://packt.link/MLwPyTorch 5 Compressing Data via Dimensionality Reduction In Chapter 4 , Building Good Training Datasets – Data Preprocessing, you learned about the different ap - proaches for reducing the dimensionality of a dataset using different feature selection techniques. An alternative approach to feature selection for dimensionality reduction is feature extraction. In this chap - ter, you will learn about two fundamental techniques that will help you to summarize the information content of a dataset by transforming it onto a new feature subspace of lower dimensionality than the original one. Data compression is an important topic in machine learning, and it helps us to store and analyze the increasing amounts of data that are produced and collected in the modern age of technology. In this chapter, we will cover the following topics: • Principal component analysis for unsupervised data compression • Linear discriminant analysis as a supervised dimensionality reduction technique for maxi - mizing class separability • A brief overview of nonlinear dimensionality reduction techniques and t-distributed stochastic neighbor embedding for data visualization Unsupervised dimensionality reduction via principal component analysis Similar to feature selection, we can use different feature extraction techniques to reduce the number of features in a dataset. The difference between feature selection and feature extraction is that while we maintain the original features when we use feature selection algorithms, such as sequential back - ward selection, we use feature extraction to transform or project the data onto a new feature space. In the context of dimensionality reduction, feature extraction can be understood as an approach to data compression with the goal of maintaining most of the relevant information. In practice, feature extraction is not only used to improve storage space or the computational efficiency of the learning algorithm but can also improve the predictive performance by reducing the curse of dimensionali- ty—especially if we are working with non-regularized models. Compressing Data via Dimensionality Reduction 140 The main steps in principal component analysis In this section, we will discuss principal component analysis (PCA ), an unsupervised linear transfor - mation technique that is widely used across different fields, most prominently for feature extraction and dimensionality reduction. Other popular applications of PCA include exploratory data analysis and the denoising of signals in stock market trading, and the analysis of genome data and gene expression levels in the field of bioinformatics. PCA helps", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 138, "start_word": 44160, "end_word": 44560, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000139": {"text": "Data via Dimensionality Reduction 140 The main steps in principal component analysis In this section, we will discuss principal component analysis (PCA ), an unsupervised linear transfor - mation technique that is widely used across different fields, most prominently for feature extraction and dimensionality reduction. Other popular applications of PCA include exploratory data analysis and the denoising of signals in stock market trading, and the analysis of genome data and gene expression levels in the field of bioinformatics. PCA helps us to identify patterns in data based on the correlation between features. In a nutshell, PCA aims to find the directions of maximum variance in high-dimensional data and projects the data onto a new subspace with equal or fewer dimensions than the original one. The orthogonal axes (principal components) of the new subspace can be interpreted as the directions of maximum variance given the constraint that the new feature axes are orthogonal to each other, as illustrated in Figure 5.1: Figure 5.1: Using PCA to find the directions of maximum variance in a dataset In Figure 5.1, x1 and x 2 are the original feature axes, and PC 1 and PC 2 are the principal components. If we use PCA for dimensionality reduction, we construct a d×k-dimensional transformation matrix, W, that allows us to map a vector of the features of the training example, x, onto a new k-dimensional feature subspace that has fewer dimensions than the original d -dimensional feature space. For instance, the process is as follows. Suppose we have a feature vector, x: 𝒙𝒙𝒙 [𝑥𝑥1,𝑥𝑥2,…,𝑥𝑥 𝑑𝑑], 𝒙𝒙 𝒙 𝒙𝑑𝑑 which is then transformed by a transformation matrix, 𝑾𝑾𝑾𝑾𝑑𝑑𝑑𝑑𝑑 : xW = z resulting in the output vector: 𝒛𝒛𝒛 [𝑧𝑧1,𝑧𝑧2,…,𝑧𝑧 𝑘𝑘], 𝒛𝒛 𝒛 𝒛𝑘𝑘 Chapter 5 141 As a result of transforming the original d-dimensional data onto this new k-dimensional subspace (typically k << d), the first principal component will have the largest possible variance. All consequent principal components will have the largest variance given the constraint that these components are uncorrelated (orthogonal) to the other principal components—even if the input features are correlated, the resulting principal components will be mutually orthogonal (uncorrelated). Note that the PCA directions are highly sensitive to data scaling, and we need to standardize the features prior to PCA if the features were measured on different scales and we want to assign equal importance to all features. Before looking at the PCA algorithm", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 139, "start_word": 44480, "end_word": 44880, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000140": {"text": "components will have the largest variance given the constraint that these components are uncorrelated (orthogonal) to the other principal components—even if the input features are correlated, the resulting principal components will be mutually orthogonal (uncorrelated). Note that the PCA directions are highly sensitive to data scaling, and we need to standardize the features prior to PCA if the features were measured on different scales and we want to assign equal importance to all features. Before looking at the PCA algorithm for dimensionality reduction in more detail, let’s summarize the approach in a few simple steps: 1. Standardize the d-dimensional dataset. 2. Construct the covariance matrix. 3. Decompose the covariance matrix into its eigenvectors and eigenvalues. 4. Sort the eigenvalues by decreasing order to rank the corresponding eigenvectors. 5. Select k eigenvectors, which correspond to the k largest eigenvalues, where k is the dimension- ality of the new feature subspace ( 𝑘𝑘𝑘𝑘𝑘 ). 6. Construct a projection matrix, W, from the “top” k eigenvectors. 7. Transform the d-dimensional input dataset, X, using the projection matrix, W, to obtain the new k-dimensional feature subspace. In the following sections, we will perform a PCA step by step using Python as a learning exercise. Then, we will see how to perform a PCA more conveniently using scikit-learn. Eigendecomposition: Decomposing a Matrix into Eigenvectors and Eigenvalues Eigendecomposition, the factorization of a square matrix into so-called eigenvalues and eigenvectors, is at the core of the PCA procedure described in this section. The covariance matrix is a special case of a square matrix: it’s a symmetric matrix, which means that the matrix is equal to its transpose, A = AT. When we decompose such a symmetric matrix, the eigenvalues are real (rather than complex) numbers, and the eigenvectors are orthogonal (perpendicular) to each other. Furthermore, eigenvalues and eigenvectors come in pairs. If we decompose a covariance matrix into its eigenvectors and eigenvalues, the eigenvectors associated with the highest eigenvalue corresponds to the direction of maximum variance in the dataset. Here, this “direction” is a linear transformation of the dataset’s feature columns. While a more detailed discussion of eigenvalues and eigenvectors is beyond the scope of this book, a relatively thorough treatment with pointers to additional resources can be found on Wikipedia at https://en.wikipedia.org/wiki/Eigenvalues_and_eigenvectors . Compressing Data via Dimensionality Reduction 142 Extracting the principal components step by step In this subsection, we will tackle the first four steps", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 140, "start_word": 44800, "end_word": 45200, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000141": {"text": "highest eigenvalue corresponds to the direction of maximum variance in the dataset. Here, this “direction” is a linear transformation of the dataset’s feature columns. While a more detailed discussion of eigenvalues and eigenvectors is beyond the scope of this book, a relatively thorough treatment with pointers to additional resources can be found on Wikipedia at https://en.wikipedia.org/wiki/Eigenvalues_and_eigenvectors . Compressing Data via Dimensionality Reduction 142 Extracting the principal components step by step In this subsection, we will tackle the first four steps of a PCA: 1. Standardizing the data 2. Constructing the covariance matrix 3. Obtaining the eigenvalues and eigenvectors of the covariance matrix 4. Sorting the eigenvalues by decreasing order to rank the eigenvectors First, we will start by loading the Wine dataset that we worked with in Chapter 4 , Building Good Training Datasets – Data Preprocessing: >>> import pandas as pd >>> df_wine = pd.read_csv( ... 'https://archive.ics.uci.edu/ml/' ... 'machine-learning-databases/wine/wine.data' , ... header= None ... ) Obtaining the Wine dataset You can find a copy of the Wine dataset (and all other datasets used in this book) in the code bundle of this book, which you can use if you are working offline or the UCI server at https://archive.ics.uci.edu/ml/machine-learning-databases/wine/wine.data is temporarily unavailable. For instance, to load the Wine dataset from a local directory, you can replace the following lines: df = pd.read_csv( 'https://archive.ics.uci.edu/ml/' 'machine-learning-databases/wine/wine.data' , header= None ) with these ones: df = pd.read_csv( 'your/local/path/to/wine.data' , header= None ) Chapter 5 143 Next, we will process the Wine data into separate training and test datasets—using 70 percent and 30 percent of the data, respectively—and standardize it to unit variance: >>> from sklearn.model_selection import train_test_split >>> X, y = df_wine.iloc[:, 1:].values, df_wine.iloc[:, 0].values >>> X_train, X_test, y_train, y_test = \\ ... train_test_split(X, y, test_size= 0.3, ... stratify=y, ... random_state= 0) >>> # standardize the features >>> from sklearn.preprocessing import StandardScaler >>> sc = StandardScaler() >>> X_train_std = sc.fit_transform(X_train) >>> X_test_std = sc.transform(X_test) After completing the mandatory preprocessing by executing the preceding code, let’s advance to the second step: constructing the covariance matrix. The symmetric d×d-dimensional covariance matrix, where d is the number of dimensions in the dataset, stores the pairwise covariances between the dif- ferent features. For example, the covariance between two features, x j and x k, on the population level can be calculated via the following equation: 𝜎𝜎𝑗𝑗𝑗𝑗=1 𝑛𝑛𝑛1∑(𝑥𝑥𝑗𝑗(𝑖𝑖)𝑛𝜇𝜇𝑗𝑗)𝑛𝑛 𝑖𝑖𝑖𝑖(𝑥𝑥𝑗𝑗(𝑖𝑖)𝑛𝜇𝜇𝑗𝑗) Here, 𝜇𝜇𝑗𝑗 and 𝜇𝜇𝑘𝑘 are the sample means of", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 141, "start_word": 45120, "end_word": 45520, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000142": {"text": "sc.transform(X_test) After completing the mandatory preprocessing by executing the preceding code, let’s advance to the second step: constructing the covariance matrix. The symmetric d×d-dimensional covariance matrix, where d is the number of dimensions in the dataset, stores the pairwise covariances between the dif- ferent features. For example, the covariance between two features, x j and x k, on the population level can be calculated via the following equation: 𝜎𝜎𝑗𝑗𝑗𝑗=1 𝑛𝑛𝑛1∑(𝑥𝑥𝑗𝑗(𝑖𝑖)𝑛𝜇𝜇𝑗𝑗)𝑛𝑛 𝑖𝑖𝑖𝑖(𝑥𝑥𝑗𝑗(𝑖𝑖)𝑛𝜇𝜇𝑗𝑗) Here, 𝜇𝜇𝑗𝑗 and 𝜇𝜇𝑘𝑘 are the sample means of features j and k, respectively. Note that the sample means are zero if we standardized the dataset. A positive covariance between two features indicates that the features increase or decrease together, whereas a negative covariance indicates that the features vary in opposite directions. For example, the covariance matrix of three features can then be writ- ten as follows (note that Σ is the Greek uppercase letter sigma, which is not to be confused with the summation symbol): Σ=[𝜎𝜎12𝜎𝜎12𝜎𝜎13 𝜎𝜎21𝜎𝜎22𝜎𝜎23 𝜎𝜎31𝜎𝜎32𝜎𝜎32] The eigenvectors of the covariance matrix represent the principal components (the directions of maximum variance), whereas the corresponding eigenvalues will define their magnitude. In the case of the Wine dataset, we would obtain 13 eigenvectors and eigenvalues from the 13×13-dimensional covariance matrix. Compressing Data via Dimensionality Reduction 144 Now, for our third step, let’s obtain the eigenpairs of the covariance matrix. If you have taken a linear algebra class, you may have learned that an eigenvector, v, satisfies the following condition: Σ𝒗𝒗 𝒗 𝒗𝒗𝒗𝒗 Here, 𝜆𝜆 is a scalar: the eigenvalue. Since the manual computation of eigenvectors and eigenvalues is a somewhat tedious and elaborate task, we will use the linalg.eig function from NumPy to obtain the eigenpairs of the Wine covariance matrix: >>> import numpy as np >>> cov_mat = np.cov(X_train_std.T) >>> eigen_vals, eigen_vecs = np.linalg.eig(cov_mat) >>> print('\\nEigenvalues \\n' , eigen_vals) Eigenvalues [ 4.84274532 2.41602459 1.54845825 0.96120438 0.84166161 0.6620634 0.51828472 0.34650377 0.3131368 0.10754642 0.21357215 0.15362835 0.1808613 ] Using the numpy.cov function, we computed the covariance matrix of the standardized training data - set. Using the linalg.eig function, we performed the eigendecomposition, which yielded a vector (eigen_vals ) consisting of 13 eigenvalues and the corresponding eigenvectors stored as columns in a 13×13-dimensional matrix ( eigen_vecs ). Total and explained variance Since we want to reduce the dimensionality of our dataset by compressing it onto a new feature sub - space, we only select the subset of the eigenvectors (principal components)", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 142, "start_word": 45440, "end_word": 45840, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000143": {"text": "numpy.cov function, we computed the covariance matrix of the standardized training data - set. Using the linalg.eig function, we performed the eigendecomposition, which yielded a vector (eigen_vals ) consisting of 13 eigenvalues and the corresponding eigenvectors stored as columns in a 13×13-dimensional matrix ( eigen_vecs ). Total and explained variance Since we want to reduce the dimensionality of our dataset by compressing it onto a new feature sub - space, we only select the subset of the eigenvectors (principal components) that contains most of the information (variance). The eigenvalues define the magnitude of the eigenvectors, so we have to sort the eigenvalues by decreasing magnitude; we are interested in the top k eigenvectors based on the values of their corresponding eigenvalues. But before we collect those k most informative eigenvectors, let’s plot the variance explained ratios of the eigenvalues. The variance explained ratio of an eigenvalue, 𝜆𝜆𝑗𝑗 , is simply the fraction of an eigenvalue, 𝜆𝜆𝑗𝑗 , and the total sum of the eigenvalues: Explained variance ratio =𝜆𝜆𝑗𝑗 ∑ 𝜆𝜆𝑗𝑗𝑑𝑑 𝑗𝑗𝑗𝑗 Eigendecomposition in NumPy The numpy.linalg.eig function was designed to operate on both symmetric and non-sym - metric square matrices. However, you may find that it returns complex eigenvalues in certain cases. A related function, numpy.linalg.eigh, has been implemented to decompose Hermetian matrices, which is a numerically more stable approach to working with symmetric matri- ces such as the covariance matrix; numpy.linalg.eigh always returns real eigenvalues. Chapter 5 145 Using the NumPy cumsum function, we can then calculate the cumulative sum of explained variances, which we will then plot via Matplotlib’s step function: >>> tot = sum(eigen_vals) >>> var_exp = [(i / tot) for i in ... sorted(eigen_vals, reverse= True)] >>> cum_var_exp = np.cumsum(var_exp) >>> import matplotlib.pyplot as plt >>> plt.bar( range(1,14), var_exp, align= 'center' , ... label= 'Individual explained variance' ) >>> plt.step( range(1,14), cum_var_exp, where= 'mid', ... label= 'Cumulative explained variance' ) >>> plt.ylabel( 'Explained variance ratio' ) >>> plt.xlabel( 'Principal component index' ) >>> plt.legend(loc= 'best') >>> plt.tight_layout() >>> plt.show() The resulting plot indicates that the first principal component alone accounts for approximately 40 percent of the variance. Also, we can see that the first two principal components combined explain almost 60 percent of the variance in the dataset: Figure 5.2: The proportion of the total variance captured by the principal components Compressing Data via Dimensionality Reduction 146 Although the explained variance plot reminds us of the", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 143, "start_word": 45760, "end_word": 46160, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000144": {"text": ">>> plt.xlabel( 'Principal component index' ) >>> plt.legend(loc= 'best') >>> plt.tight_layout() >>> plt.show() The resulting plot indicates that the first principal component alone accounts for approximately 40 percent of the variance. Also, we can see that the first two principal components combined explain almost 60 percent of the variance in the dataset: Figure 5.2: The proportion of the total variance captured by the principal components Compressing Data via Dimensionality Reduction 146 Although the explained variance plot reminds us of the feature importance values that we computed in Chapter 4, Building Good Training Datasets – Data Preprocessing, via random forests, we should remind ourselves that PCA is an unsupervised method, which means that information about the class labels is ignored. Whereas a random forest uses the class membership information to compute the node impurities, variance measures the spread of values along a feature axis. Feature transformation Now that we have successfully decomposed the covariance matrix into eigenpairs, let’s proceed with the last three steps to transform the Wine dataset onto the new principal component axes. The re - maining steps we are going to tackle in this section are the following: 1. Select k eigenvectors, which correspond to the k largest eigenvalues, where k is the dimension- ality of the new feature subspace ( 𝑘𝑘𝑘𝑘𝑘 ). 2. Construct a projection matrix, W, from the “top” k eigenvectors. 3. Transform the d-dimensional input dataset, X, using the projection matrix, W, to obtain the new k-dimensional feature subspace. Or, in less technical terms, we will sort the eigenpairs by descending order of the eigenvalues, con- struct a projection matrix from the selected eigenvectors, and use the projection matrix to transform the data onto the lower-dimensional subspace. We start by sorting the eigenpairs by decreasing order of the eigenvalues: >>> # Make a list of (eigenvalue, eigenvector) tuples >>> eigen_pairs = [(np. abs(eigen_vals[i]), eigen_vecs[:, i]) ... for i in range (len(eigen_vals))] >>> # Sort the (eigenvalue, eigenvector) tuples from high to low >>> eigen_pairs.sort(key= lambda k: k[0], reverse= True) Next, we collect the two eigenvectors that correspond to the two largest eigenvalues, to capture about 60 percent of the variance in this dataset. Note that two eigenvectors have been chosen for the purpose of illustration, since we are going to plot the data via a two-dimensional scatterplot later in this sub - section. In practice, the number of principal components has to be determined", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 144, "start_word": 46080, "end_word": 46480, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000145": {"text": "the (eigenvalue, eigenvector) tuples from high to low >>> eigen_pairs.sort(key= lambda k: k[0], reverse= True) Next, we collect the two eigenvectors that correspond to the two largest eigenvalues, to capture about 60 percent of the variance in this dataset. Note that two eigenvectors have been chosen for the purpose of illustration, since we are going to plot the data via a two-dimensional scatterplot later in this sub - section. In practice, the number of principal components has to be determined by a tradeoff between computational efficiency and the performance of the classifier: >>> w = np.hstack((eigen_pairs[ 0][1][:, np.newaxis], ... eigen_pairs[ 1][1][:, np.newaxis])) >>> print('Matrix W:\\n' , w) Matrix W: [[-0.13724218 0.50303478] [ 0.24724326 0.16487119] [-0.02545159 0.24456476] [ 0.20694508 -0.11352904] [-0.15436582 0.28974518] Chapter 5 147 [-0.39376952 0.05080104] [-0.41735106 -0.02287338] [ 0.30572896 0.09048885] [-0.30668347 0.00835233] [ 0.07554066 0.54977581] [-0.32613263 -0.20716433] [-0.36861022 -0.24902536] [-0.29669651 0.38022942]] By executing the preceding code, we have created a 13×2-dimensional projection matrix, W, from the top two eigenvectors. Using the projection matrix, we can now transform an example, x (represented as a 13-dimensional row vector), onto the PCA subspace (the principal components one and two) obtaining x ′, now a two-dimensional example vector consisting of two new features: x′ = xW >>> X_train_std[ 0].dot(w) array([ 2.38299011, 0.45458499]) Similarly, we can transform the entire 124×13-dimensional training dataset onto the two principal components by calculating the matrix dot product: X′ = XW >>> X_train_pca = X_train_std.dot(w)Mirrored projections Depending on which versions of NumPy and LAPACK you are using, you may obtain the matrix, W, with its signs flipped. Please note that this is not an issue; if v is an eigenvector of a matrix, Σ , we have: Σ𝒗𝒗 𝒗 𝒗𝒗𝒗𝒗 Here, v is the eigenvector, and –v is also an eigenvector, which we can show as follows. Using basic algebra, we can multiply both sides of the equation by a scalar, 𝛼𝛼 : 𝛼𝛼𝛼𝛼𝛼 𝛼 𝛼𝛼𝛼𝛼𝛼𝛼 Since matrix multiplication is associative for scalar multiplication, we can then rearrange this to the following: Σ(𝛼𝛼𝛼𝛼)=𝜆𝜆(𝛼𝛼𝛼𝛼) Now, we can see that 𝛼𝛼𝛼𝛼 is an eigenvector with the same eigenvalue, 𝜆𝜆 , for both 𝛼𝛼𝛼𝛼 and 𝛼𝛼 𝛼 𝛼𝛼 . Hence, both v and –v are eigenvectors. Compressing Data via Dimensionality Reduction 148 Lastly, let’s visualize the transformed Wine training dataset, now stored as an 124×2-dimensional matrix, in a two-dimensional scatterplot: >>> colors = [ 'r', 'b', 'g'] >>> markers = [ 'o',", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 145, "start_word": 46400, "end_word": 46800, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000146": {"text": "is associative for scalar multiplication, we can then rearrange this to the following: Σ(𝛼𝛼𝛼𝛼)=𝜆𝜆(𝛼𝛼𝛼𝛼) Now, we can see that 𝛼𝛼𝛼𝛼 is an eigenvector with the same eigenvalue, 𝜆𝜆 , for both 𝛼𝛼𝛼𝛼 and 𝛼𝛼 𝛼 𝛼𝛼 . Hence, both v and –v are eigenvectors. Compressing Data via Dimensionality Reduction 148 Lastly, let’s visualize the transformed Wine training dataset, now stored as an 124×2-dimensional matrix, in a two-dimensional scatterplot: >>> colors = [ 'r', 'b', 'g'] >>> markers = [ 'o', 's', '^'] >>> for l, c, m in zip(np.unique(y_train), colors, markers): ... plt.scatter(X_train_pca[y_train==l, 0], ... X_train_pca[y_train==l, 1], ... c=c, label= f'Class {l}', marker=m) >>> plt.xlabel( 'PC 1') >>> plt.ylabel( 'PC 2') >>> plt.legend(loc= 'lower left' ) >>> plt.tight_layout() >>> plt.show() As we can see in Figure 5.3, the data is more spread along the first principal component (x axis) than the second principal component (y axis), which is consistent with the explained variance ratio plot that we created in the previous subsection. However, we can tell that a linear classifier will likely be able to separate the classes well: Figure 5.3: Data records from the Wine dataset projected onto a 2D feature space via PCA Although we encoded the class label information for the purpose of illustration in the preceding scatterplot, we have to keep in mind that PCA is an unsupervised technique that doesn’t use any class label information. Chapter 5 149 Principal component analysis in scikit-learn Although the verbose approach in the previous subsection helped us to follow the inner workings of PCA, we will now discuss how to use the PCA class implemented in scikit-learn. The PCA class is another one of scikit-learn’s transformer classes, with which we first fit the model using the training data before we transform both the training data and the test dataset using the same model parameters. Now, let’s use the PCA class from scikit-learn on the Wine training dataset, classify the transformed examples via logistic regression, and visualize the decision regions via the plot_decision_regions function that we defined in Chapter 2, Training Simple Machine Learning Algorithms for Classification: from matplotlib.colors import ListedColormap def plot_decision_regions (X, y, classifier, test_idx= None, resolution= 0.02): # setup marker generator and color map markers = ( 'o', 's', '^', 'v', '<') colors = ( 'red', 'blue' , 'lightgreen' , 'gray' , 'cyan' ) cmap = ListedColormap(colors[: len(np.unique(y))]) # plot the decision surface x1_min, x1_max = X[:,", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 146, "start_word": 46720, "end_word": 47120, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000147": {"text": "transformed examples via logistic regression, and visualize the decision regions via the plot_decision_regions function that we defined in Chapter 2, Training Simple Machine Learning Algorithms for Classification: from matplotlib.colors import ListedColormap def plot_decision_regions (X, y, classifier, test_idx= None, resolution= 0.02): # setup marker generator and color map markers = ( 'o', 's', '^', 'v', '<') colors = ( 'red', 'blue' , 'lightgreen' , 'gray' , 'cyan' ) cmap = ListedColormap(colors[: len(np.unique(y))]) # plot the decision surface x1_min, x1_max = X[:, 0].min() - 1, X[:, 0].max() + 1 x2_min, x2_max = X[:, 1].min() - 1, X[:, 1].max() + 1 xx1, xx2 = np.meshgrid(np.arange(x1_min, x1_max, resolution), np.arange(x2_min, x2_max, resolution)) lab = classifier.predict(np.array([xx1.ravel(), xx2.ravel()]).T) lab = lab.reshape(xx1.shape) plt.contourf(xx1, xx2, lab, alpha= 0.3, cmap=cmap) plt.xlim(xx1. min(), xx1. max()) plt.ylim(xx2. min(), xx2. max()) # plot class examples for idx, cl in enumerate (np.unique(y)): plt.scatter(x=X[y == cl, 0], y=X[y == cl, 1], alpha= 0.8, c=colors[idx], marker=markers[idx], label= f'Class {cl}', edgecolor= 'black') Compressing Data via Dimensionality Reduction 150 For your convenience, you can place the preceding plot_decision_regions code into a separate code file in your current working directory, for example, plot_decision_regions_script.py , and import it into your current Python session: >>> from sklearn.linear_model import LogisticRegression >>> from sklearn.decomposition import PCA >>> # initializing the PCA transformer and >>> # logistic regression estimator: >>> pca = PCA(n_components= 2) >>> lr = LogisticRegression(multi_class= 'ovr', ... random_state= 1, ... solver= 'lbfgs') >>> # dimensionality reduction: >>> X_train_pca = pca.fit_transform(X_train_std) >>> X_test_pca = pca.transform(X_test_std) >>> # fitting the logistic regression model on the reduced dataset: >>> lr.fit(X_train_pca, y_train) >>> plot_decision_regions(X_train_pca, y_train, classifier=lr) >>> plt.xlabel( 'PC 1') >>> plt.ylabel( 'PC 2') >>> plt.legend(loc= 'lower left' ) >>> plt.tight_layout() >>> plt.show() By executing this code, we should now see the decision regions for the training data reduced to two principal component axes: Figure 5.4: Training examples and logistic regression decision regions after using scikit-learn’s PCA for dimensionality reduction Chapter 5 151 When we compare the PCA projections via scikit-learn with our own PCA implementation, we might see that the resulting plots are mirror images of each other. Note that this is not due to an error in either of those two implementations; the reason for this difference is that, depending on the eigen- solver, eigenvectors can have either negative or positive signs. Not that it matters, but we could simply revert the mirror image by multiplying the data by –1 if we wanted", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 147, "start_word": 47040, "end_word": 47440, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000148": {"text": "compare the PCA projections via scikit-learn with our own PCA implementation, we might see that the resulting plots are mirror images of each other. Note that this is not due to an error in either of those two implementations; the reason for this difference is that, depending on the eigen- solver, eigenvectors can have either negative or positive signs. Not that it matters, but we could simply revert the mirror image by multiplying the data by –1 if we wanted to; note that eigenvectors are typically scaled to unit length 1. For the sake of completeness, let’s plot the decision regions of the logistic regression on the transformed test dataset to see if it can separate the classes well: >>> plot_decision_regions(X_test_pca, y_test, classifier=lr) >>> plt.xlabel( 'PC 1') >>> plt.ylabel( 'PC 2') >>> plt.legend(loc= 'lower left' ) >>> plt.tight_layout() >>> plt.show() After we plot the decision regions for the test dataset by executing the preceding code, we can see that logistic regression performs quite well on this small two-dimensional feature subspace and only misclassifies a few examples in the test dataset: Figure 5.5: Test datapoints with logistic regression decision regions in the PCA-based feature space If we are interested in the explained variance ratios of the different principal components, we can simply initialize the PCA class with the n_components parameter set to None , so all principal components are kept and the explained variance ratio can then be accessed via the explained_variance_ratio_ attribute: >>> pca = PCA(n_components= None) >>> X_train_pca = pca.fit_transform(X_train_std) >>> pca.explained_variance_ratio_ array([ 0.36951469, 0.18434927, 0.11815159, 0.07334252, Compressing Data via Dimensionality Reduction 152 0.06422108, 0.05051724, 0.03954654, 0.02643918, 0.02389319, 0.01629614, 0.01380021, 0.01172226, 0.00820609]) Note that we set n_components=None when we initialized the PCA class so that it will return all principal components in a sorted order, instead of performing a dimensionality reduction. Assessing feature contributions In this section, we will take a brief look at how we can assess the contributions of the original features to the principal components. As we learned, via PCA, we create principal components that represent linear combinations of the features. Sometimes, we are interested to know about how much each orig- inal feature contributes to a given principal component. These contributions are often called loadings . The factor loadings can be computed by scaling the eigenvectors by the square root of the eigenvalues. The resulting values can then be interpreted as the correlation between the", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 148, "start_word": 47360, "end_word": 47760, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000149": {"text": "contributions of the original features to the principal components. As we learned, via PCA, we create principal components that represent linear combinations of the features. Sometimes, we are interested to know about how much each orig- inal feature contributes to a given principal component. These contributions are often called loadings . The factor loadings can be computed by scaling the eigenvectors by the square root of the eigenvalues. The resulting values can then be interpreted as the correlation between the original features and the principal component. To illustrate this, let us plot the loadings for the first principal component. First, we compute the 13×13-dimensional loadings matrix by multiplying the eigenvectors by the square root of the eigenvalues: >>> loadings = eigen_vecs * np.sqrt(eigen_vals) Then, we plot the loadings for the first principal component, loadings[:, 0] , which is the first col- umn in this matrix: >>> fig, ax = plt.subplots() >>> ax.bar( range(13), loadings[:, 0], align= 'center' ) >>> ax.set_ylabel( 'Loadings for PC 1' ) >>> ax.set_xticks( range(13)) >>> ax.set_xticklabels(df_wine.columns[ 1:], rotation= 90) >>> plt.ylim([- 1, 1]) >>> plt.tight_layout() >>> plt.show() In Figure 5.6, we can see that, for example, Alcohol has a negative correlation with the first principal component (approximately –0.3), whereas Malic acid has a positive correlation (approximately 0.54). Note that a value of 1 describes a perfect positive correlation whereas a value of –1 corresponds to a perfect negative correlation: Chapter 5 153 Figure 5.6: Feature correlations with the first principal component In the preceding code example, we compute the factor loadings for our own PCA implementation. We can obtain the loadings from a fitted scikit-learn PCA object in a similar manner, where pca. components_ represents the eigenvectors and pca.explained_variance_ represents the eigenvalues: >>> sklearn_loadings = pca.components_.T * np.sqrt(pca.explained_variance_) To compare the scikit-learn PCA loadings with those we created previously, let us create a similar bar plot: >>> fig, ax = plt.subplots() >>> ax.bar( range(13), sklearn_loadings[:, 0], align= 'center' ) >>> ax.set_ylabel( 'Loadings for PC 1' ) >>> ax.set_xticks( range(13)) >>> ax.set_xticklabels(df_wine.columns[ 1:], rotation= 90) >>> plt.ylim([- 1, 1]) >>> plt.tight_layout() >>> plt.show() Compressing Data via Dimensionality Reduction 154 As we can see, the bar plots look the same: Figure 5.7: Feature correlations to the first principal component using scikit-learn After exploring PCA as an unsupervised feature extraction technique, the next section will introduce linear discriminant analysis (LDA ), which is a linear transformation technique that takes", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 149, "start_word": 47680, "end_word": 48080, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000150": {"text": "align= 'center' ) >>> ax.set_ylabel( 'Loadings for PC 1' ) >>> ax.set_xticks( range(13)) >>> ax.set_xticklabels(df_wine.columns[ 1:], rotation= 90) >>> plt.ylim([- 1, 1]) >>> plt.tight_layout() >>> plt.show() Compressing Data via Dimensionality Reduction 154 As we can see, the bar plots look the same: Figure 5.7: Feature correlations to the first principal component using scikit-learn After exploring PCA as an unsupervised feature extraction technique, the next section will introduce linear discriminant analysis (LDA ), which is a linear transformation technique that takes class label information into account. Supervised data compression via linear discriminant analysis LDA can be used as a technique for feature extraction to increase computational efficiency and reduce the degree of overfitting due to the curse of dimensionality in non-regularized models. The general concept behind LDA is very similar to PCA, but whereas PCA attempts to find the orthogonal component axes of maximum variance in a dataset, the goal in LDA is to find the feature subspace that optimizes class separability. In the following sections, we will discuss the similarities between LDA and PCA in more detail and walk through the LDA approach step by step. Principal component analysis versus linear discriminant analysis Both PCA and LDA are linear transformation techniques that can be used to reduce the number of di- mensions in a dataset; the former is an unsupervised algorithm, whereas the latter is supervised. Thus, we might think that LDA is a superior feature extraction technique for classification tasks compared to PCA. However, A.M. Martinez reported that preprocessing via PCA tends to result in better clas- sification results in an image recognition task in certain cases, for instance, if each class consists of only a small number of examples (PCA Versus LDA by A. M. Martinez and A. C. Kak, IEEE Transactions on Pattern Analysis and Machine Intelligence, 23(2): 228-233, 2001). Chapter 5 155 Figure 5.8 summarizes the concept of LDA for a two-class problem. Examples from class 1 are shown as circles, and examples from class 2 are shown as crosses: Figure 5.8: The concept of LDA for a two-class problem A linear discriminant, as shown on the x axis (LD 1 ), would separate the two normal distributed class- es well. Although the exemplary linear discriminant shown on the y axis (LD 2 ) captures a lot of the variance in the dataset, it would fail as a good linear discriminant since it does not capture", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 150, "start_word": 48000, "end_word": 48400, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000151": {"text": "1 are shown as circles, and examples from class 2 are shown as crosses: Figure 5.8: The concept of LDA for a two-class problem A linear discriminant, as shown on the x axis (LD 1 ), would separate the two normal distributed class- es well. Although the exemplary linear discriminant shown on the y axis (LD 2 ) captures a lot of the variance in the dataset, it would fail as a good linear discriminant since it does not capture any of the class-discriminatory information. One assumption in LDA is that the data is normally distributed. Also, we assume that the classes have identical covariance matrices and that the training examples are statistically independent of each oth - er. However, even if one, or more, of those assumptions is (slightly) violated, LDA for dimensionality reduction can still work reasonably well (Pattern Classification 2nd Edition by R. O. Duda, P. E. Hart, and D. G. Stork, New York, 2001).Fisher LDA LDA is sometimes also called Fisher’s LDA. Ronald A. Fisher initially formulated Fisher’s Linear Discriminant for two-class classification problems in 1936 (The Use of Multiple Mea- surements in Taxonomic Problems, R. A. Fisher, Annals of Eugenics, 7(2): 179-188, 1936). In 1948, Fisher’s linear discriminant was generalized for multiclass problems by C. Radhakrishna Rao under the assumption of equal class covariances and normally distributed classes, which we now call LDA (The Utilization of Multiple Measurements in Problems of Biological Classification by C. R. Rao, Journal of the Royal Statistical Society. Series B (Methodological), 10(2): 159-203, 1948). Compressing Data via Dimensionality Reduction 156 The inner workings of linear discriminant analysis Before we dive into the code implementation, let’s briefly summarize the main steps that are required to perform LDA: 1. Standardize the d-dimensional dataset (d is the number of features). 2. For each class, compute the d-dimensional mean vector. 3. Construct the between-class scatter matrix, S B, and the within-class scatter matrix, S W. 4. Compute the eigenvectors and corresponding eigenvalues of the matrix, 𝑺𝑺𝑊𝑊−1𝑺𝑺𝐵𝐵 . 5. Sort the eigenvalues by decreasing order to rank the corresponding eigenvectors. 6. Choose the k eigenvectors that correspond to the k largest eigenvalues to construct a d×k-di- mensional transformation matrix, W; the eigenvectors are the columns of this matrix. 7. Project the examples onto the new feature subspace using the transformation matrix, W. As we can see, LDA is quite similar to PCA in the sense", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 151, "start_word": 48320, "end_word": 48720, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000152": {"text": "W. 4. Compute the eigenvectors and corresponding eigenvalues of the matrix, 𝑺𝑺𝑊𝑊−1𝑺𝑺𝐵𝐵 . 5. Sort the eigenvalues by decreasing order to rank the corresponding eigenvectors. 6. Choose the k eigenvectors that correspond to the k largest eigenvalues to construct a d×k-di- mensional transformation matrix, W; the eigenvectors are the columns of this matrix. 7. Project the examples onto the new feature subspace using the transformation matrix, W. As we can see, LDA is quite similar to PCA in the sense that we are decomposing matrices into ei - genvalues and eigenvectors, which will form the new lower-dimensional feature space. However, as mentioned before, LDA takes class label information into account, which is represented in the form of the mean vectors computed in step 2. In the following sections, we will discuss these seven steps in more detail, accompanied by illustrative code implementations. Computing the scatter matrices Since we already standardized the features of the Wine dataset in the PCA section at the beginning of this chapter, we can skip the first step and proceed with the calculation of the mean vectors, which we will use to construct the within-class scatter matrix and between-class scatter matrix, respectively. Each mean vector, m i, stores the mean feature value, 𝜇𝜇𝑚𝑚 , with respect to the examples of class i: 𝒎𝒎𝑖𝑖=1 𝑛𝑛𝑖𝑖∑𝒙𝒙𝑚𝑚 𝒙𝒙𝒙𝒙𝒙𝑖𝑖 This results in three mean vectors: 𝒎𝒎𝑖𝑖=[𝜇𝜇𝑖𝑖𝑖𝑖𝑖𝑖𝑖𝑖𝑖𝑖𝑖𝑖𝑖𝑖𝑖𝑖 𝜇𝜇𝑖𝑖𝑖𝑖𝑖𝑖𝑖𝑖𝑖𝑖𝑖𝑖𝑖𝑖𝑖𝑖𝑖𝑖𝑖𝑖𝑖𝑖 ⋮ 𝜇𝜇𝑖𝑖𝑖𝑖𝑖𝑖𝑖𝑖𝑖𝑖𝑖𝑖𝑖𝑖𝑖𝑖𝑖]𝑇𝑇 𝑖𝑖𝑖𝑖𝑖𝑖 𝑖{1𝑖2𝑖3} These mean vectors can be computed by the following code, where we compute one mean vector for each of the three labels: >>> np.set_printoptions(precision= 4) >>> mean_vecs = [] >>> for label in range (1,4): ... mean_vecs.append(np.mean( ... X_train_std[y_train==label], axis= 0)) ... print(f'MV {label}: {mean_vecs[label - 1]}\\n' ) Chapter 5 157 MV 1: [ 0.9066 -0.3497 0.3201 -0.7189 0.5056 0.8807 0.9589 -0.5516 0.5416 0.2338 0.5897 0.6563 1.2075] MV 2: [-0.8749 -0.2848 -0.3735 0.3157 -0.3848 -0.0433 0.0635 -0.0946 0.0703 -0.8286 0.3144 0.3608 -0.7253] MV 3: [ 0.1992 0.866 0.1682 0.4148 -0.0451 -1.0286 -1.2876 0.8287 -0.7795 0.9649 -1.209 -1.3622 -0.4013] Using the mean vectors, we can now compute the within-class scatter matrix, S W: 𝑺𝑺𝑊𝑊=∑𝑺𝑺 𝑖𝑖𝒄𝒄 𝑖𝑖𝑖𝑖 This is calculated by summing up the individual scatter matrices, S i, of each individual class i: 𝑺𝑺𝑖𝑖=∑(𝒙𝒙𝒙𝒙𝒙 𝑖𝑖)(𝒙𝒙𝒙𝒙𝒙 𝑖𝑖)𝑇𝑇 𝒙𝒙𝒙𝒙𝒙𝑖𝑖 >>> d = 13 # number of features >>> S_W = np.zeros((d, d)) >>> for label, mv in zip(range(1, 4), mean_vecs): ... class_scatter = np.zeros((d, d)) ... for row in X_train_std[y_train == label]:", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 152, "start_word": 48640, "end_word": 49040, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000153": {"text": "-0.0451 -1.0286 -1.2876 0.8287 -0.7795 0.9649 -1.209 -1.3622 -0.4013] Using the mean vectors, we can now compute the within-class scatter matrix, S W: 𝑺𝑺𝑊𝑊=∑𝑺𝑺 𝑖𝑖𝒄𝒄 𝑖𝑖𝑖𝑖 This is calculated by summing up the individual scatter matrices, S i, of each individual class i: 𝑺𝑺𝑖𝑖=∑(𝒙𝒙𝒙𝒙𝒙 𝑖𝑖)(𝒙𝒙𝒙𝒙𝒙 𝑖𝑖)𝑇𝑇 𝒙𝒙𝒙𝒙𝒙𝑖𝑖 >>> d = 13 # number of features >>> S_W = np.zeros((d, d)) >>> for label, mv in zip(range(1, 4), mean_vecs): ... class_scatter = np.zeros((d, d)) ... for row in X_train_std[y_train == label]: ... row, mv = row.reshape(d, 1), mv.reshape(d, 1) ... class_scatter += (row - mv).dot((row - mv).T) ... S_W += class_scatter >>> print('Within-class scatter matrix: ' ... f'{S_W.shape[ 0]}x{S_W.shape[ 1]}') Within-class scatter matrix: 13x13 The assumption that we are making when we are computing the scatter matrices is that the class labels in the training dataset are uniformly distributed. However, if we print the number of class labels, we see that this assumption is violated: >>> print('Class label distribution:' , ... np.bincount(y_train)[ 1:]) Class label distribution: [41 50 33] Thus, we want to scale the individual scatter matrices, S i, before we sum them up as the scatter matrix, SW. When we divide the scatter matrices by the number of class-examples, n i, we can see that com- puting the scatter matrix is in fact the same as computing the covariance matrix, Σ𝑖𝑖 —the covariance matrix is a normalized version of the scatter matrix: Σ𝑖𝑖=1 𝑛𝑛𝑖𝑖𝑺𝑺𝑖𝑖=1 𝑛𝑛𝑖𝑖∑(𝒙𝒙𝒙𝒙𝒙 𝑖𝑖)(𝒙𝒙𝒙𝒙𝒙 𝑖𝑖)𝑇𝑇 𝒙𝒙𝒙𝒙𝒙𝑖𝑖 Compressing Data via Dimensionality Reduction 158 The code for computing the scaled within-class scatter matrix is as follows: >>> d = 13 # number of features >>> S_W = np.zeros((d, d)) >>> for label,mv in zip(range(1, 4), mean_vecs): ... class_scatter = np.cov(X_train_std[y_train==label].T) ... S_W += class_scatter >>> print('Scaled within-class scatter matrix: ' ... f'{S_W.shape[ 0]}x{S_W.shape[ 1]}') Scaled within-class scatter matrix: 13x13 After we compute the scaled within-class scatter matrix (or covariance matrix), we can move on to the next step and compute the between-class scatter matrix S B: 𝑺𝑺𝐵𝐵=∑𝑛𝑛 𝑖𝑖(𝒎𝒎𝑖𝑖−𝒎𝒎)(𝒎𝒎𝑖𝑖−𝒎𝒎)𝑇𝑇𝒄𝒄 𝑖𝑖𝑖𝑖 Here, m is the overall mean that is computed, including examples from all c classes: >>> mean_overall = np.mean(X_train_std, axis= 0) >>> mean_overall = mean_overall.reshape(d, 1) >>> d = 13 # number of features >>> S_B = np.zeros((d, d)) >>> for i, mean_vec in enumerate (mean_vecs): ... n = X_train_std[y_train == i + 1, :].shape[ 0] ... mean_vec = mean_vec.reshape(d, 1) # make column vector ... S_B += n *", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 153, "start_word": 48960, "end_word": 49360, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000154": {"text": "compute the between-class scatter matrix S B: 𝑺𝑺𝐵𝐵=∑𝑛𝑛 𝑖𝑖(𝒎𝒎𝑖𝑖−𝒎𝒎)(𝒎𝒎𝑖𝑖−𝒎𝒎)𝑇𝑇𝒄𝒄 𝑖𝑖𝑖𝑖 Here, m is the overall mean that is computed, including examples from all c classes: >>> mean_overall = np.mean(X_train_std, axis= 0) >>> mean_overall = mean_overall.reshape(d, 1) >>> d = 13 # number of features >>> S_B = np.zeros((d, d)) >>> for i, mean_vec in enumerate (mean_vecs): ... n = X_train_std[y_train == i + 1, :].shape[ 0] ... mean_vec = mean_vec.reshape(d, 1) # make column vector ... S_B += n * (mean_vec - mean_overall).dot( ... (mean_vec - mean_overall).T) >>> print('Between-class scatter matrix: ' ... f'{S_B.shape[ 0]}x{S_B.shape[ 1]}') Between-class scatter matrix: 13x13 Selecting linear discriminants for the new feature subspace The remaining steps of the LDA are similar to the steps of the PCA. However, instead of performing the eigendecomposition on the covariance matrix, we solve the generalized eigenvalue problem of the matrix, 𝑺𝑺𝑊𝑊−1𝑺𝑺𝐵𝐵 : >>> eigen_vals, eigen_vecs =\\ ... np.linalg.eig(np.linalg.inv(S_W).dot(S_B)) After we compute the eigenpairs, we can sort the eigenvalues in descending order: >>> eigen_pairs = [(np. abs(eigen_vals[i]), eigen_vecs[:,i]) ... for i in range (len(eigen_vals))] Chapter 5 159 >>> eigen_pairs = sorted(eigen_pairs, ... key= lambda k: k[0], reverse= True) >>> print('Eigenvalues in descending order:\\n' ) >>> for eigen_val in eigen_pairs: ... print(eigen_val[ 0]) Eigenvalues in descending order: 349.617808906 172.76152219 3.78531345125e-14 2.11739844822e-14 1.51646188942e-14 1.51646188942e-14 1.35795671405e-14 1.35795671405e-14 7.58776037165e-15 5.90603998447e-15 5.90603998447e-15 2.25644197857e-15 0.0 In LDA, the number of linear discriminants is at most c – 1, where c is the number of class labels, since the in-between scatter matrix, S B, is the sum of c matrices with rank one or less. We can indeed see that we only have two nonzero eigenvalues (the eigenvalues 3-13 are not exactly zero, but this is due to the floating-point arithmetic in NumPy.) To measure how much of the class-discriminatory information is captured by the linear discriminants (eigenvectors), let’s plot the linear discriminants by decreasing eigenvalues, similar to the explained variance plot that we created in the PCA section. For simplicity, we will call the content of class-dis- criminatory information discriminability: >>> tot = sum(eigen_vals.real) >>> discr = [(i / tot) for i in sorted (eigen_vals.real, ... reverse= True)] >>> cum_discr = np.cumsum(discr) >>> plt.bar( range(1, 14), discr, align= 'center' , ... label= 'Individual discriminability' )Collinearity Note that in the rare case of perfect collinearity (all aligned example points fall on a straight line), the covariance matrix would have rank one, which would result in only one", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 154, "start_word": 49280, "end_word": 49680, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000155": {"text": "PCA section. For simplicity, we will call the content of class-dis- criminatory information discriminability: >>> tot = sum(eigen_vals.real) >>> discr = [(i / tot) for i in sorted (eigen_vals.real, ... reverse= True)] >>> cum_discr = np.cumsum(discr) >>> plt.bar( range(1, 14), discr, align= 'center' , ... label= 'Individual discriminability' )Collinearity Note that in the rare case of perfect collinearity (all aligned example points fall on a straight line), the covariance matrix would have rank one, which would result in only one eigenvector with a nonzero eigenvalue. Compressing Data via Dimensionality Reduction 160 >>> plt.step( range(1, 14), cum_discr, where= 'mid', ... label= 'Cumulative discriminability' ) >>> plt.ylabel( '\"Discriminability\" ratio' ) >>> plt.xlabel( 'Linear Discriminants' ) >>> plt.ylim([- 0.1, 1.1]) >>> plt.legend(loc= 'best') >>> plt.tight_layout() >>> plt.show() As we can see in Figure 5.9, the first two linear discriminants alone capture 100 percent of the useful information in the Wine training dataset: Figure 5.9: The top two discriminants capture 100 percent of the useful information Let’s now stack the two most discriminative eigenvector columns to create the transformation matrix, W: >>> w = np.hstack((eigen_pairs[ 0][1][:, np.newaxis].real, ... eigen_pairs[ 1][1][:, np.newaxis].real)) >>> print('Matrix W:\\n' , w) Matrix W: [[-0.1481 -0.4092] [ 0.0908 -0.1577] [-0.0168 -0.3537] [ 0.1484 0.3223] [-0.0163 -0.0817] [ 0.1913 0.0842] [-0.7338 0.2823] [-0.075 -0.0102] Chapter 5 161 [ 0.0018 0.0907] [ 0.294 -0.2152] [-0.0328 0.2747] [-0.3547 -0.0124] [-0.3915 -0.5958]] Projecting examples onto the new feature space Using the transformation matrix W that we created in the previous subsection, we can now transform the training dataset by multiplying the matrices: X′ = XW >>> X_train_lda = X_train_std.dot(w) >>> colors = [ 'r', 'b', 'g'] >>> markers = [ 'o', 's', '^' ] >>> for l, c, m in zip(np.unique(y_train), colors, markers): ... plt.scatter(X_train_lda[y_train==l, 0], ... X_train_lda[y_train==l, 1] * (-1), ... c=c, label= f'Class {l}', marker=m) >>> plt.xlabel( 'LD 1') >>> plt.ylabel( 'LD 2') >>> plt.legend(loc= 'lower right' ) >>> plt.tight_layout() >>> plt.show() As we can see in Figure 5.10, the three Wine classes are now perfectly linearly separable in the new feature subspace: Figure 5.10: Wine classes perfectly separable after projecting the data onto the first two discriminants Compressing Data via Dimensionality Reduction 162 LDA via scikit-learn That step-by-step implementation was a good exercise to understand the inner workings of LDA and understand the differences between LDA and PCA. Now, let’s look at the LDA class implemented in scikit-learn: >>> # the", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 155, "start_word": 49600, "end_word": 50000, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000156": {"text": "As we can see in Figure 5.10, the three Wine classes are now perfectly linearly separable in the new feature subspace: Figure 5.10: Wine classes perfectly separable after projecting the data onto the first two discriminants Compressing Data via Dimensionality Reduction 162 LDA via scikit-learn That step-by-step implementation was a good exercise to understand the inner workings of LDA and understand the differences between LDA and PCA. Now, let’s look at the LDA class implemented in scikit-learn: >>> # the following import statement is one line >>> from sklearn.discriminant_analysis import LinearDiscriminantAnalysis as LDA >>> lda = LDA(n_components= 2) >>> X_train_lda = lda.fit_transform(X_train_std, y_train) Next, let’s see how the logistic regression classifier handles the lower-dimensional training dataset after the LDA transformation: >>> lr = LogisticRegression(multi_class= 'ovr', random_state= 1, ... solver= 'lbfgs') >>> lr = lr.fit(X_train_lda, y_train) >>> plot_decision_regions(X_train_lda, y_train, classifier=lr) >>> plt.xlabel( 'LD 1') >>> plt.ylabel( 'LD 2') >>> plt.legend(loc= 'lower left' ) >>> plt.tight_layout() >>> plt.show() Looking at Figure 5.11, we can see that the logistic regression model misclassifies one of the examples from class 2: Figure 5.11: The logistic regression model misclassifies one of the classes Chapter 5 163 By lowering the regularization strength, we could probably shift the decision boundaries so that the logistic regression model classifies all examples in the training dataset correctly. However, and more importantly, let’s take a look at the results on the test dataset: >>> X_test_lda = lda.transform(X_test_std) >>> plot_decision_regions(X_test_lda, y_test, classifier=lr) >>> plt.xlabel( 'LD 1') >>> plt.ylabel( 'LD 2') >>> plt.legend(loc= 'lower left' ) >>> plt.tight_layout() >>> plt.show() As we can see in Figure 5.12, the logistic regression classifier is able to get a perfect accuracy score for classifying the examples in the test dataset by only using a two-dimensional feature subspace, instead of the original 13 Wine features: Figure 5.12: The logistic regression model works perfectly on the test data Nonlinear dimensionality reduction and visualization In the previous section, we covered linear transformation techniques, such as PCA and LDA, for fea - ture extraction. In this section, we will discuss why considering nonlinear dimensionality reduction techniques might be worthwhile. One nonlinear dimensionality reduction technique that is particularly worth highlighting is t-dis - tributed stochastic neighbor embedding (t-SNE ) since it is frequently used in literature to visualize high-dimensional datasets in two or three dimensions. We will see how we can apply t-SNE to plot images of handwritten images in a 2-dimensional", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 156, "start_word": 49920, "end_word": 50320, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000157": {"text": "linear transformation techniques, such as PCA and LDA, for fea - ture extraction. In this section, we will discuss why considering nonlinear dimensionality reduction techniques might be worthwhile. One nonlinear dimensionality reduction technique that is particularly worth highlighting is t-dis - tributed stochastic neighbor embedding (t-SNE ) since it is frequently used in literature to visualize high-dimensional datasets in two or three dimensions. We will see how we can apply t-SNE to plot images of handwritten images in a 2-dimensional feature space. Why consider nonlinear dimensionality reduction? Many machine learning algorithms make assumptions about the linear separability of the input data. Compressing Data via Dimensionality Reduction 164 You have learned that the perceptron even requires perfectly linearly separable training data to con- verge. Other algorithms that we have covered so far assume that the lack of perfect linear separability is due to noise: Adaline, logistic regression, and the (standard) SVM to just name a few. However, if we are dealing with nonlinear problems, which we may encounter rather frequently in real-world applications, linear transformation techniques for dimensionality reduction, such as PCA and LDA, may not be the best choice: Figure 5.13: The difference between linear and nonlinear problems The scikit-learn library implements a selection of advanced techniques for nonlinear dimensionality reduction that are beyond the scope of this book. The interested reader can find a nice overview of the current implementations in scikit-learn, complemented by illustrative examples, at http://scikit- learn.org/stable/modules/manifold.html . The development and application of nonlinear dimensionality reduction techniques is also often referred to as manifold learning, where a manifold refers to a lower dimensional topological space embedded in a high-dimensional space. Algorithms for manifold learning have to capture the compli - cated structure of the data in order to project it onto a lower-dimensional space where the relationship between data points is preserved. Chapter 5 165 A classic example of manifold learning is the 3-dimensional Swiss roll illustrated in Figure 5.14: Figure 5.14: Three-dimensional Swiss roll projected into a lower, two-dimensional space While nonlinear dimensionality reduction and manifold learning algorithms are very powerful, we should note that these techniques are notoriously hard to use, and with non-ideal hyperparameter choices, they may cause more harm than good. The reason behind this difficulty is that we are often working with high-dimensional datasets that we cannot readily visualize and where the structure is not obvious (unlike the Swiss roll example in", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 157, "start_word": 50240, "end_word": 50640, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000158": {"text": "in Figure 5.14: Figure 5.14: Three-dimensional Swiss roll projected into a lower, two-dimensional space While nonlinear dimensionality reduction and manifold learning algorithms are very powerful, we should note that these techniques are notoriously hard to use, and with non-ideal hyperparameter choices, they may cause more harm than good. The reason behind this difficulty is that we are often working with high-dimensional datasets that we cannot readily visualize and where the structure is not obvious (unlike the Swiss roll example in Figure 5.14). Moreover, unless we project the dataset into two or three dimensions (which is often not sufficient for capturing more complicated relationships), it is hard or even impossible to assess the quality of the results. Hence, many people still rely on simpler techniques such as PCA and LDA for dimensionality reduction. Visualizing data via t-distributed stochastic neighbor embedding After introducing nonlinear dimensionality reduction and discussing some of its challenges, let’s take a look at a hands-on example involving t-SNE, which is often used for visualizing complex datasets in two or three dimensions. Compressing Data via Dimensionality Reduction 166 In a nutshell, t-SNE is modeling data points based on their pair-wise distances in the high-dimen - sional (original) feature space. Then, it finds a probability distribution of pair-wise distances in the new, lower-dimensional space that is close to the probability distribution of pair-wise distances in the original space. Or, in other words, t-SNE learns to embed data points into a lower-dimensional space such that the pairwise distances in the original space are preserved. You can find more details about this method in the original research paper Visualizing data using t-SNE by Maaten and Hinton, Jour- nal of Machine Learning Research, 2018 ( https://www.jmlr.org/papers/volume9/vandermaaten08a/ vandermaaten08a.pdf ). However, as the research paper title suggests, t-SNE is a technique intended for visualization purposes as it requires the whole dataset for the projection. Since it projects the points directly (unlike PCA, it does not involve a projection matrix), we cannot apply t-SNE to new data points. The following code shows a quick demonstration of how t-SNE can be applied to a 64-dimensional dataset. First, we load the Digits dataset from scikit-learn, which consists of low-resolution handwrit- ten digits (the numbers 0-9): >>> from sklearn.datasets import load_digits >>> digits = load_digits() The digits are 8×8 grayscale images. The following code plots the first four images in the dataset, which consists of 1,797 images in total:", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 158, "start_word": 50560, "end_word": 50960, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000159": {"text": "involve a projection matrix), we cannot apply t-SNE to new data points. The following code shows a quick demonstration of how t-SNE can be applied to a 64-dimensional dataset. First, we load the Digits dataset from scikit-learn, which consists of low-resolution handwrit- ten digits (the numbers 0-9): >>> from sklearn.datasets import load_digits >>> digits = load_digits() The digits are 8×8 grayscale images. The following code plots the first four images in the dataset, which consists of 1,797 images in total: >>> fig, ax = plt.subplots( 1, 4) >>> for i in range (4): >>> ax[i].imshow(digits.images[i], cmap= 'Greys') >>> plt.show() As we can see in Figure 5.15, the images are relatively low resolution, 8×8 pixels (that is, 64 pixels per image): Figure 5.15: Low resolution images of handwritten digits Note that the digits.data attribute lets us access a tabular version of this dataset where the examples are represented by the rows, and the columns correspond to the pixels: >>> digits.data.shape (1797, 64) Chapter 5 167 Next, let us assign the features (pixels) to a new variable X_digits and the labels to another new variable y_digits : >>> y_digits = digits.target >>> X_digits = digits.data Then, we import the t-SNE class from scikit-learn and fit a new tsne object. Using fit_transform , we perform the t-SNE fitting and data transformation in one step: >>> from sklearn.manifold import TSNE >>> tsne = TSNE(n_components= 2, init= 'pca', ... random_state= 123) >>> X_digits_tsne = tsne.fit_transform(X_digits) Using this code, we projected the 64-dimensional dataset onto a 2-dimensional space. We specified init='pca' , which initializes the t-SNE embedding using PCA as it is recommended in the research article Initialization is critical for preserving global data structure in both t-SNE and UMAP by Kobak and Linderman, Nature Biotechnology Volume 39, pages 156–157, 2021 ( https://www.nature.com/articles/ s41587-020-00809-z ). Note that t-SNE includes additional hyperparameters such as the perplexity and learning rate (often called epsilon), which we omitted in the example (we used the scikit-learn default values). In practice, we recommend you explore these parameters as well. More information about these parameters and their effects on the results can be found in the excellent article How to Use t-SNE Effectively by Watten- berg , Viegas, and Johnson, Distill, 2016 ( https://distill.pub/2016/misread-tsne/ ). Finally, let us visualize the 2D t-SNE embeddings using the following code: >>> import matplotlib.patheffects as PathEffects >>> def plot_projection (x, colors): ... f = plt.figure(figsize=( 8, 8))", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 159, "start_word": 50880, "end_word": 51280, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000160": {"text": "example (we used the scikit-learn default values). In practice, we recommend you explore these parameters as well. More information about these parameters and their effects on the results can be found in the excellent article How to Use t-SNE Effectively by Watten- berg , Viegas, and Johnson, Distill, 2016 ( https://distill.pub/2016/misread-tsne/ ). Finally, let us visualize the 2D t-SNE embeddings using the following code: >>> import matplotlib.patheffects as PathEffects >>> def plot_projection (x, colors): ... f = plt.figure(figsize=( 8, 8)) ... ax = plt.subplot(aspect= 'equal') ... for i in range (10): ... plt.scatter(x[colors == i, 0], ... x[colors == i, 1]) ... for i in range (10): ... xtext, ytext = np.median(x[colors == i, :], axis= 0) ... txt = ax.text(xtext, ytext, str(i), fontsize= 24) ... txt.set_path_effects([ ... PathEffects.Stroke(linewidth= 5, foreground= \"w\"), ... PathEffects.Normal()]) Compressing Data via Dimensionality Reduction 168 >>> plot_projection(X_digits_tsne, y_digits) >>> plt.show() Like PCA, t-SNE is an unsupervised method, and in the preceding code, we use the class labels y_digits (0-9) only for visualization purposes via the functions color argument. Matplotlib’s PathEffects are used for visual purposes, such that the class label is displayed in the center (via np.median ) of data points belonging to each respective digit. The resulting plot is as follows: Figure 5.16: A visualization of how t-SNE embeds the handwritten digits in a 2D feature space As we can see, t-SNE is able to separate the different digits (classes) nicely, although not perfectly. It might be possible to achieve better separation by tuning the hyperparameters. However, a certain degree of class mixing might be unavoidable due to illegible handwriting. For instance, by inspecting individual images, we might find that certain instances of the number 3 indeed look like the number 9, and so forth. Uniform manifold approximation and projection Another popular visualization technique is uniform manifold approximation and pro - jection (UMAP ). While UMAP can produce similarly good results as t-SNE (for example, see the Kobak and Linderman paper referenced previously), it is typically faster, and it can also be used to project new data, which makes it more attractive as a dimensionality reduction technique in a machine learning context, similar to PCA. Interested readers can find more information about UMAP in the original paper: UMAP: Uniform manifold approximation and projection for dimension reduction by McInnes, Healy, and Melville, 2018 (https://arxiv.org/abs/1802.03426). A scikit-learn compatible implementation of UMAP can be found at https://umap-learn.readthedocs.io", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 160, "start_word": 51200, "end_word": 51600, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000161": {"text": "example, see the Kobak and Linderman paper referenced previously), it is typically faster, and it can also be used to project new data, which makes it more attractive as a dimensionality reduction technique in a machine learning context, similar to PCA. Interested readers can find more information about UMAP in the original paper: UMAP: Uniform manifold approximation and projection for dimension reduction by McInnes, Healy, and Melville, 2018 (https://arxiv.org/abs/1802.03426). A scikit-learn compatible implementation of UMAP can be found at https://umap-learn.readthedocs.io . Chapter 5 169 Summary In this chapter, you learned about two fundamental dimensionality reduction techniques for feature extraction: PCA and LDA. Using PCA, we projected data onto a lower-dimensional subspace to maxi- mize the variance along the orthogonal feature axes, while ignoring the class labels. LDA, in contrast to PCA, is a technique for supervised dimensionality reduction, which means that it considers class information in the training dataset to attempt to maximize the class separability in a linear feature space. Lastly, you also learned about t-SNE, which is a nonlinear feature extraction technique that can be used for visualizing data in two or three dimensions. Equipped with PCA and LDA as fundamental data preprocessing techniques, you are now well prepared to learn about the best practices for efficiently incorporating different preprocessing techniques and evaluating the performance of different models in the next chapter. Join our book’s Discord space Join the book’s Discord workspace for a monthly Ask me Anything session with the authors: https://packt.link/MLwPyTorch 6 Learning Best Practices for Model Evaluation and Hyperparameter Tuning In the previous chapters, we learned about the essential machine learning algorithms for classifica - tion and how to get our data into shape before we feed it into those algorithms. Now, it’s time to learn about the best practices of building good machine learning models by fine-tuning the algorithms and evaluating the performance of the models. In this chapter, we will learn how to do the following: • Assess the performance of machine learning models • Diagnose the common problems of machine learning algorithms • Fine-tune machine learning models • Evaluate predictive models using different performance metrics Streamlining workflows with pipelines When we applied different preprocessing techniques in the previous chapters, such as standardiza - tion for feature scaling in Chapter 4, Building Good Training Datasets – Data Preprocessing, or principal component analysis for data compression in Chapter 5, Compressing Data via Dimensionality Reduction,", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 161, "start_word": 51520, "end_word": 51920, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000162": {"text": "do the following: • Assess the performance of machine learning models • Diagnose the common problems of machine learning algorithms • Fine-tune machine learning models • Evaluate predictive models using different performance metrics Streamlining workflows with pipelines When we applied different preprocessing techniques in the previous chapters, such as standardiza - tion for feature scaling in Chapter 4, Building Good Training Datasets – Data Preprocessing, or principal component analysis for data compression in Chapter 5, Compressing Data via Dimensionality Reduction, you learned that we have to reuse the parameters that were obtained during the fitting of the training data to scale and compress any new data, such as the examples in the separate test dataset. In this section, you will learn about an extremely handy tool, the Pipeline class in scikit-learn. It allows us to fit a model including an arbitrary number of transformation steps and apply it to make predictions about new data. Learning Best Practices for Model Evaluation and Hyperparameter Tuning 172 Loading the Breast Cancer Wisconsin dataset In this chapter, we will be working with the Breast Cancer Wisconsin dataset, which contains 569 ex - amples of malignant and benign tumor cells. The first two columns in the dataset store the unique ID numbers of the examples and the corresponding diagnoses ( M = malignant, B = benign), respectively. Columns 3-32 contain 30 real-valued features that have been computed from digitized images of the cell nuclei, which can be used to build a model to predict whether a tumor is benign or malignant. The Breast Cancer Wisconsin dataset has been deposited in the UCI Machine Learning Repository, and more detailed information about this dataset can be found at https://archive.ics.uci.edu/ ml/datasets/Breast+Cancer+Wisconsin+(Diagnostic) . In this section, we will read in the dataset and split it into training and test datasets in three simple steps: 1. We will start by reading in the dataset directly from the UCI website using pandas: >>> import pandas as pd >>> df = pd.read_csv( 'https://archive.ics.uci.edu/ml/' ... 'machine-learning-databases' ... '/breast-cancer-wisconsin/wdbc.data' , ... header= None)Obtaining the Breast Cancer Wisconsin dataset You can find a copy of the dataset (and all other datasets used in this book) in the code bundle of this book, which you can use if you are working offline or the UCI server at https://archive.ics.uci.edu/ml/machine-learning-databases/breast-cancer- wisconsin/wdbc.data is temporarily unavailable. For instance, to load the dataset from a local directory, you can replace the", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 162, "start_word": 51840, "end_word": 52240, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000163": {"text": "pandas: >>> import pandas as pd >>> df = pd.read_csv( 'https://archive.ics.uci.edu/ml/' ... 'machine-learning-databases' ... '/breast-cancer-wisconsin/wdbc.data' , ... header= None)Obtaining the Breast Cancer Wisconsin dataset You can find a copy of the dataset (and all other datasets used in this book) in the code bundle of this book, which you can use if you are working offline or the UCI server at https://archive.ics.uci.edu/ml/machine-learning-databases/breast-cancer- wisconsin/wdbc.data is temporarily unavailable. For instance, to load the dataset from a local directory, you can replace the following lines: df = pd.read_csv( 'https://archive.ics.uci.edu/ml/' 'machine-learning-databases' '/breast-cancer-wisconsin/wdbc.data' , header= None ) with these: df = pd.read_csv( 'your/local/path/to/wdbc.data' , header= None ) Chapter 6 173 2. Next, we will assign the 30 features to a NumPy array, X. Using a LabelEncoder object, we will transform the class labels from their original string representation ( 'M' and 'B') into integers: >>> from sklearn.preprocessing import LabelEncoder >>> X = df.loc[:, 2:].values >>> y = df.loc[:, 1].values >>> le = LabelEncoder() >>> y = le.fit_transform(y) >>> le.classes_ array(['B', 'M'], dtype=object) 3. After encoding the class labels (diagnosis) in an array, y, the malignant tumors are now rep - resented as class 1, and the benign tumors are represented as class 0, respectively. We can double-check this mapping by calling the transform method of the fitted LabelEncoder on two dummy class labels: >>> le.transform([ 'M', 'B']) array([1, 0]) 4. Before we construct our first model pipeline in the following subsection, let’s divide the dataset into a separate training dataset (80 percent of the data) and a separate test dataset (20 percent of the data): >>> from sklearn.model_selection import train_test_split >>> X_train, X_test, y_train, y_test = \\ ... train_test_split(X, y, ... test_size= 0.20, ... stratify=y, ... random_state= 1) Combining transformers and estimators in a pipeline In the previous chapter, you learned that many learning algorithms require input features on the same scale for optimal performance. Since the features in the Breast Cancer Wisconsin dataset are measured on various different scales, we will standardize the columns in the Breast Cancer Wisconsin dataset before we feed them to a linear classifier, such as logistic regression. Furthermore, let’s assume that we want to compress our data from the initial 30 dimensions into a lower two-dimensional subspace via principal component analysis (PCA ), a feature extraction technique for dimensionality reduction that was introduced in Chapter 5. Learning Best Practices for Model Evaluation and Hyperparameter Tuning 174 Instead of going", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 163, "start_word": 52160, "end_word": 52560, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000164": {"text": "measured on various different scales, we will standardize the columns in the Breast Cancer Wisconsin dataset before we feed them to a linear classifier, such as logistic regression. Furthermore, let’s assume that we want to compress our data from the initial 30 dimensions into a lower two-dimensional subspace via principal component analysis (PCA ), a feature extraction technique for dimensionality reduction that was introduced in Chapter 5. Learning Best Practices for Model Evaluation and Hyperparameter Tuning 174 Instead of going through the model fitting and data transformation steps for the training and test datasets separately, we can chain the StandardScaler , PCA, and LogisticRegression objects in a pipeline: >>> from sklearn.preprocessing import StandardScaler >>> from sklearn.decomposition import PCA >>> from sklearn.linear_model import LogisticRegression >>> from sklearn.pipeline import make_pipeline >>> pipe_lr = make_pipeline(StandardScaler(), ... PCA(n_components= 2), ... LogisticRegression()) >>> pipe_lr.fit(X_train, y_train) >>> y_pred = pipe_lr.predict(X_test) >>> test_acc = pipe_lr.score(X_test, y_test) >>> print(f'Test accuracy: {test_acc: .3f}') Test accuracy: 0.956 The make_pipeline function takes an arbitrary number of scikit-learn transformers (objects that sup - port the fit and transform methods as input), followed by a scikit-learn estimator that implements the fit and predict methods. In our preceding code example, we provided two scikit-learn transformers, StandardScaler and PCA, and a LogisticRegression estimator as inputs to the make_pipeline func- tion, which constructs a scikit-learn Pipeline object from these objects. We can think of a scikit-learn Pipeline as a meta-estimator or wrapper around those individual transformers and estimators. If we call the fit method of Pipeline , the data will be passed down a series of transformers via fit and transform calls on these intermediate steps until it arrives at the estimator object (the final element in a pipeline). The estimator will then be fitted to the transformed training data. When we executed the fit method on the pipe_lr pipeline in the preceding code example, StandardScaler first performed fit and transform calls on the training data. Second, the trans - formed training data was passed on to the next object in the pipeline, PCA. Similar to the previous step, PCA also executed fit and transform on the scaled input data and passed it to the final element of the pipeline, the estimator. Finally, the LogisticRegression estimator was fit to the training data after it underwent transfor - mations via StandardScaler and PCA. Again, we should note that there is no limit to the number of intermediate", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 164, "start_word": 52480, "end_word": 52880, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000165": {"text": "Second, the trans - formed training data was passed on to the next object in the pipeline, PCA. Similar to the previous step, PCA also executed fit and transform on the scaled input data and passed it to the final element of the pipeline, the estimator. Finally, the LogisticRegression estimator was fit to the training data after it underwent transfor - mations via StandardScaler and PCA. Again, we should note that there is no limit to the number of intermediate steps in a pipeline; however, if we want to use the pipeline for prediction tasks, the last pipeline element has to be an estimator. Similar to calling fit on a pipeline, pipelines also implement a predict method if the last step in the pipeline is an estimator. If we feed a dataset to the predict call of a Pipeline object instance, the data will pass through the intermediate steps via transform calls. In the final step, the estimator object will then return a prediction on the transformed data. Chapter 6 175 The pipelines of the scikit-learn library are immensely useful wrapper tools that we will use frequently throughout the rest of this book. To make sure that you’ve got a good grasp of how the Pipeline ob- ject works, please take a close look at Figure 6.1, which summarizes our discussion from the previous paragraphs: Figure 6.1: The inner workings of the Pipeline object Using k-fold cross-validation to assess model performance In this section, you will learn about the common cross-validation techniques holdout cross-validation and k-fold cross-validation, which can help us to obtain reliable estimates of the model’s generalization performance, that is, how well the model performs on unseen data. The holdout method A classic and popular approach for estimating the generalization performance of machine learning models is the holdout method. Using the holdout method, we split our initial dataset into separate training and test datasets—the former is used for model training, and the latter is used to estimate its generalization performance. However, in typical machine learning applications, we are also inter - ested in tuning and comparing different parameter settings to further improve the performance for making predictions on unseen data. This process is called model selection, with the name referring to a given classification problem for which we want to select the optimal values of tuning parameters (also called hyperparameters). However, if we reuse the same test dataset", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 165, "start_word": 52800, "end_word": 53200, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000166": {"text": "model training, and the latter is used to estimate its generalization performance. However, in typical machine learning applications, we are also inter - ested in tuning and comparing different parameter settings to further improve the performance for making predictions on unseen data. This process is called model selection, with the name referring to a given classification problem for which we want to select the optimal values of tuning parameters (also called hyperparameters). However, if we reuse the same test dataset over and over again during model selection, it will become part of our training data and thus the model will be more likely to overfit. Despite this issue, many people still use the test dataset for model selection, which is not a good machine learning practice. Learning Best Practices for Model Evaluation and Hyperparameter Tuning 176 A better way of using the holdout method for model selection is to separate the data into three parts: a training dataset, a validation dataset, and a test dataset. The training dataset is used to fit the dif- ferent models, and the performance on the validation dataset is then used for model selection. The advantage of having a test dataset that the model hasn’t seen before during the training and model selection steps is that we can obtain a less biased estimate of its ability to generalize to new data. Figure 6.2 illustrates the concept of holdout cross-validation, where we use a validation dataset to repeatedly evaluate the performance of the model after training using different hyperparameter values. Once we are satisfied with the tuning of hyperparameter values, we estimate the model’s generalization performance on the test dataset: Figure 6.2: How to use training, validation, and test datasets A disadvantage of the holdout method is that the performance estimate may be very sensitive to how we partition the training dataset into the training and validation subsets; the estimate will vary for different examples of the data. In the next subsection, we will take a look at a more robust technique for performance estimation, k-fold cross-validation, where we repeat the holdout method k times on k subsets of the training data. K-fold cross-validation In k-fold cross-validation, we randomly split the training dataset into k folds without replacement. Here, k – 1 folds, the so-called training folds, are used for the model training, and one fold, the so-called test fold, is used for performance evaluation. This", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 166, "start_word": 53120, "end_word": 53520, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000167": {"text": "the data. In the next subsection, we will take a look at a more robust technique for performance estimation, k-fold cross-validation, where we repeat the holdout method k times on k subsets of the training data. K-fold cross-validation In k-fold cross-validation, we randomly split the training dataset into k folds without replacement. Here, k – 1 folds, the so-called training folds, are used for the model training, and one fold, the so-called test fold, is used for performance evaluation. This procedure is repeated k times so that we obtain k models and performance estimates. Sampling with and without replacement We looked at an example to illustrate sampling with and without replacement in Chapter 3. If you haven’t read that chapter, or want a refresher, refer to the information box titled Sampling with and without replacement in the Combining multiple decision trees via random forests section. Chapter 6 177 We then calculate the average performance of the models based on the different, independent test folds to obtain a performance estimate that is less sensitive to the sub-partitioning of the training data compared to the holdout method. Typically, we use k-fold cross-validation for model tuning, that is, finding the optimal hyperparameter values that yield a satisfying generalization performance, which is estimated from evaluating the model performance on the test folds. Once we have found satisfactory hyperparameter values, we can retrain the model on the complete training dataset and obtain a final performance estimate using the independent test dataset. The rationale behind fitting a model to the whole training dataset after k-fold cross-validation is that first, we are typically interested in a single, final model (versus k individual models), and second, providing more training examples to a learning algorithm usually results in a more accurate and robust model. Since k-fold cross-validation is a resampling technique without replacement, the advantage of this approach is that in each iteration, each example will be used exactly once, and the training and test folds are disjoint. Furthermore, all test folds are disjoint; that is, there is no overlap between the test folds. Figure 6.3 summarizes the concept behind k-fold cross-validation with k = 10. The training dataset is divided into 10 folds, and during the 10 iterations, 9 folds are used for training, and 1 fold will be used as the test dataset for model evaluation. Also, the estimated performances, E i (for example, classification accuracy or", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 167, "start_word": 53440, "end_word": 53840, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000168": {"text": "once, and the training and test folds are disjoint. Furthermore, all test folds are disjoint; that is, there is no overlap between the test folds. Figure 6.3 summarizes the concept behind k-fold cross-validation with k = 10. The training dataset is divided into 10 folds, and during the 10 iterations, 9 folds are used for training, and 1 fold will be used as the test dataset for model evaluation. Also, the estimated performances, E i (for example, classification accuracy or error), for each fold are then used to calculate the estimated average performance, E, of the model: Figure 6.3: How k-fold cross-validation works In summary, k-fold cross-validation makes better use of the dataset than the holdout method with a validation set, since in k-fold cross-validation all data points are being used for evaluation. A good standard value for k in k-fold cross-validation is 10, as empirical evidence shows. For instance, experiments by Ron Kohavi on various real-world datasets suggest that 10-fold cross-validation offers the best tradeoff between bias and variance (A Study of Cross-Validation and Bootstrap for Accuracy Esti- mation and Model Selection by Kohavi, Ron, International Joint Conference on Artificial Intelligence (IJCAI), 14 (12): 1137-43, 1995, https://www.ijcai.org/Proceedings/95-2/Papers/016.pdf ). Learning Best Practices for Model Evaluation and Hyperparameter Tuning 178 However, if we are working with relatively small training sets, it can be useful to increase the number of folds. If we increase the value of k, more training data will be used in each iteration, which results in a lower pessimistic bias toward estimating the generalization performance by averaging the individ - ual model estimates. However, large values of k will also increase the runtime of the cross-validation algorithm and yield estimates with higher variance, since the training folds will be more similar to each other. On the other hand, if we are working with large datasets, we can choose a smaller value for k, for example, k = 5, and still obtain an accurate estimate of the average performance of the model while reducing the computational cost of refitting and evaluating the model on the different folds. A slight improvement over the standard k-fold cross-validation approach is stratified k-fold cross-val- idation, which can yield better bias and variance estimates, especially in cases of unequal class pro - portions, which has also been shown in the same study by Ron Kohavi referenced previously in this section. In stratified cross-validation, the", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 168, "start_word": 53760, "end_word": 54160, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000169": {"text": "and still obtain an accurate estimate of the average performance of the model while reducing the computational cost of refitting and evaluating the model on the different folds. A slight improvement over the standard k-fold cross-validation approach is stratified k-fold cross-val- idation, which can yield better bias and variance estimates, especially in cases of unequal class pro - portions, which has also been shown in the same study by Ron Kohavi referenced previously in this section. In stratified cross-validation, the class label proportions are preserved in each fold to ensure that each fold is representative of the class proportions in the training dataset, which we will illustrate by using the StratifiedKFold iterator in scikit-learn: >>> import numpy as np >>> from sklearn.model_selection import StratifiedKFold >>> kfold = StratifiedKFold(n_splits= 10).split(X_train, y_train) >>> scores = [] >>> for k, (train, test) in enumerate (kfold): ... pipe_lr.fit(X_train[train], y_train[train]) ... score = pipe_lr.score(X_train[test], y_train[test]) ... scores.append(score) ... print(f'Fold: {k+1:02d}, ' ... f'Class distr.: {np.bincount(y_train[train])} , ' ... f'Acc.: {score:.3f}') Fold: 01, Class distr.: [ 256 153], Acc.: 0.935 Fold: 02, Class distr.: [256 153], Acc.: 0.935 Fold: 03, Class distr.: [256 153], Acc.: 0.957 Fold: 04, Class distr.: [256 153], Acc.: 0.957Leave-one-out cross-validation A special case of k-fold cross-validation is the leave-one-out cross-validation ( LOOCV ) method. In LOOCV , we set the number of folds equal to the number of training examples (k = n) so that only one training example is used for testing during each iteration, which is a recommended approach for working with very small datasets. Chapter 6 179 Fold: 05, Class distr.: [256 153], Acc.: 0.935 Fold: 06, Class distr.: [257 153], Acc.: 0.956 Fold: 07, Class distr.: [257 153], Acc.: 0.978 Fold: 08, Class distr.: [257 153], Acc.: 0.933 Fold: 09, Class distr.: [257 153], Acc.: 0.956 Fold: 10, Class distr.: [257 153], Acc.: 0.956 >>> mean_acc = np.mean(scores) >>> std_acc = np.std(scores) >>> print(f'\\nCV accuracy: {mean_acc: .3f} +/- {std_acc: .3f}') CV accuracy: 0.950 +/- 0.014 First, we initialized the StratifiedKFold iterator from the sklearn.model_selection module with the y_train class labels in the training dataset, and we specified the number of folds via the n_splits parameter. When we used the kfold iterator to loop through the k folds, we used the returned indices in train to fit the logistic regression pipeline that we set up at the beginning of this chapter. Using the pipe_lr pipeline, we ensured that", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 169, "start_word": 54080, "end_word": 54480, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000170": {"text": "+/- {std_acc: .3f}') CV accuracy: 0.950 +/- 0.014 First, we initialized the StratifiedKFold iterator from the sklearn.model_selection module with the y_train class labels in the training dataset, and we specified the number of folds via the n_splits parameter. When we used the kfold iterator to loop through the k folds, we used the returned indices in train to fit the logistic regression pipeline that we set up at the beginning of this chapter. Using the pipe_lr pipeline, we ensured that the examples were scaled properly (for instance, standardized) in each iteration. We then used the test indices to calculate the accuracy score of the model, which we collected in the scores list to calculate the average accuracy and the standard deviation of the estimate. Although the previous code example was useful to illustrate how k-fold cross-validation works, scikit- learn also implements a k-fold cross-validation scorer, which allows us to evaluate our model using stratified k-fold cross-validation less verbosely: >>> from sklearn.model_selection import cross_val_score >>> scores = cross_val_score(estimator=pipe_lr, ... X=X_train, ... y=y_train, ... cv= 10, ... n_jobs= 1) >>> print(f'CV accuracy scores: {scores} ') CV accuracy scores: [ 0.93478261 0.93478261 0.95652174 0.95652174 0.93478261 0.95555556 0.97777778 0.93333333 0.95555556 0.95555556] >>> print(f'CV accuracy: {np.mean(scores): .3f} ' ... f'+/- {np.std(scores): .3f}') CV accuracy: 0.950 +/- 0.014 Learning Best Practices for Model Evaluation and Hyperparameter Tuning 180 An extremely useful feature of the cross_val_score approach is that we can distribute the evalua - tion of the different folds across multiple central processing units (CPUs ) on our machine. If we set the n_jobs parameter to 1, only one CPU will be used to evaluate the performances, just like in our StratifiedKFold example previously. However, by setting n_jobs=2 , we could distribute the 10 rounds of cross-validation to two CPUs (if available on our machine), and by setting n_jobs=-1 , we can use all available CPUs on our machine to do the computation in parallel. Debugging algorithms with learning and validation curves In this section, we will take a look at two very simple yet powerful diagnostic tools that can help us to improve the performance of a learning algorithm: learning curves and validation curves. In the next subsections, we will discuss how we can use learning curves to diagnose whether a learning algorithm has a problem with overfitting (high variance) or underfitting (high bias). Furthermore, we will take a look at validation curves, which can", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 170, "start_word": 54400, "end_word": 54800, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000171": {"text": "algorithms with learning and validation curves In this section, we will take a look at two very simple yet powerful diagnostic tools that can help us to improve the performance of a learning algorithm: learning curves and validation curves. In the next subsections, we will discuss how we can use learning curves to diagnose whether a learning algorithm has a problem with overfitting (high variance) or underfitting (high bias). Furthermore, we will take a look at validation curves, which can help us to address the common issues of learning algorithms. Diagnosing bias and variance problems with learning curves If a model is too complex for a given training dataset—for example, think of a very deep decision tree—the model tends to overfit the training data and does not generalize well to unseen data. Often, it can help to collect more training examples to reduce the degree of overfitting. However, in practice, it can often be very expensive or simply not feasible to collect more data. By plotting the model training and validation accuracies as functions of the training dataset size, we can easily detect whether the model suffers from high variance or high bias, and whether the collection of more data could help to address this problem. Estimating generalization performance Please note that a detailed discussion of how the variance of the generalization perfor - mance is estimated in cross-validation is beyond the scope of this book, but you can refer to a comprehensive article about model evaluation and cross-validation (Model Evalua - tion, Model Selection, and Algorithm Selection in Machine Learning by S. Raschka), which we share at https://arxiv.org/abs/1811.12808. This article also discusses alternative cross-validation techniques, such as the .632 and .632+ bootstrap cross-validation methods. In addition, you can find a detailed discussion in an excellent article by M. Markatou and others (Analysis of Variance of Cross-validation Estimators of the Generalization Error by M. Markatou, H. Tian, S. Biswas, and G. M. Hripcsak, Journal of Machine Learning Research, 6: 1127- 1168, 2005), which is available at https://www.jmlr.org/papers/v6/markatou05a.html . Chapter 6 181 But before we discuss how to plot learning curves in scikit-learn, let’s discuss those two common model issues by walking through the following illustration: Figure 6.4: Common model issues The graph in the upper left shows a model with a high bias. This model has both low training and cross-validation accuracy, which indicates that it underfits the training data.", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 171, "start_word": 54720, "end_word": 55120, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000172": {"text": "G. M. Hripcsak, Journal of Machine Learning Research, 6: 1127- 1168, 2005), which is available at https://www.jmlr.org/papers/v6/markatou05a.html . Chapter 6 181 But before we discuss how to plot learning curves in scikit-learn, let’s discuss those two common model issues by walking through the following illustration: Figure 6.4: Common model issues The graph in the upper left shows a model with a high bias. This model has both low training and cross-validation accuracy, which indicates that it underfits the training data. Common ways to address this issue are to increase the number of model parameters, for example, by collecting or constructing additional features, or by decreasing the degree of regularization, for example, in support vector machine (SVM ) or logistic regression classifiers. The graph in the upper-right shows a model that suffers from high variance, which is indicated by the large gap between the training and cross-validation accuracy. To address this problem of overfitting, we can collect more training data, reduce the complexity of the model, or increase the regularization parameter, for example. For unregularized models, it can also help to decrease the number of features via feature selection (Chapter 4) or feature extraction (Chapter 5) to decrease the degree of overfitting. While collecting more training data usually tends to decrease the chance of overfitting, it may not always help, for example, if the training data is extremely noisy or the model is already very close to optimal. Learning Best Practices for Model Evaluation and Hyperparameter Tuning 182 In the next subsection, we will see how to address those model issues using validation curves, but let’s first see how we can use the learning curve function from scikit-learn to evaluate the model: >>> import matplotlib.pyplot as plt >>> from sklearn.model_selection import learning_curve >>> pipe_lr = make_pipeline(StandardScaler(), ... LogisticRegression(penalty= 'l2', ... max_iter= 10000)) >>> train_sizes, train_scores, test_scores =\\ ... learning_curve(estimator=pipe_lr, ... X=X_train, ... y=y_train, ... train_sizes=np.linspace( ... 0.1, 1.0, 10), ... cv= 10, ... n_jobs= 1) >>> train_mean = np.mean(train_scores, axis= 1) >>> train_std = np.std(train_scores, axis= 1) >>> test_mean = np.mean(test_scores, axis= 1) >>> test_std = np.std(test_scores, axis= 1) >>> plt.plot(train_sizes, train_mean, ... color= 'blue', marker= 'o', ... markersize= 5, label= 'Training accuracy' ) >>> plt.fill_between(train_sizes, ... train_mean + train_std, ... train_mean - train_std, ... alpha= 0.15, color= 'blue') >>> plt.plot(train_sizes, test_mean, ... color= 'green', linestyle= '--', ... marker= 's', markersize= 5, ... label= 'Validation accuracy' ) >>> plt.fill_between(train_sizes, ... test_mean", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 172, "start_word": 55040, "end_word": 55440, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000173": {"text": "10, ... n_jobs= 1) >>> train_mean = np.mean(train_scores, axis= 1) >>> train_std = np.std(train_scores, axis= 1) >>> test_mean = np.mean(test_scores, axis= 1) >>> test_std = np.std(test_scores, axis= 1) >>> plt.plot(train_sizes, train_mean, ... color= 'blue', marker= 'o', ... markersize= 5, label= 'Training accuracy' ) >>> plt.fill_between(train_sizes, ... train_mean + train_std, ... train_mean - train_std, ... alpha= 0.15, color= 'blue') >>> plt.plot(train_sizes, test_mean, ... color= 'green', linestyle= '--', ... marker= 's', markersize= 5, ... label= 'Validation accuracy' ) >>> plt.fill_between(train_sizes, ... test_mean + test_std, ... test_mean - test_std, ... alpha= 0.15, color= 'green') >>> plt.grid() >>> plt.xlabel( 'Number of training examples' ) >>> plt.ylabel( 'Accuracy' ) >>> plt.legend(loc= 'lower right' ) >>> plt.ylim([ 0.8, 1.03]) >>> plt.show() Chapter 6 183 Note that we passed max_iter=10000 as an additional argument when instantiating the LogisticRegression object (which uses 1,000 iterations as a default) to avoid convergence issues for the smaller dataset sizes or extreme regularization parameter values (covered in the next section). After we have successfully executed the preceding code, we will obtain the following learning curve plot: Figure 6.5: A learning curve showing training and validation dataset accuracy by the number of training examples Via the train_sizes parameter in the learning_curve function, we can control the absolute or relative number of training examples that are used to generate the learning curves. Here, we set train_sizes=np.linspace(0.1, 1.0, 10) to use 10 evenly spaced, relative intervals for the training dataset sizes. By default, the learning_curve function uses stratified k-fold cross-validation to cal - culate the cross-validation accuracy of a classifier, and we set k = 10 via the cv parameter for 10-fold stratified cross-validation. Then, we simply calculated the average accuracies from the returned cross-validated training and test scores for the different sizes of the training dataset, which we plotted using Matplotlib’s plot function. Furthermore, we added the standard deviation of the average accuracy to the plot using the fill_between function to indicate the variance of the estimate. As we can see in the preceding learning curve plot, our model performs quite well on both the training and validation datasets if it has seen more than 250 examples during training. We can also see that the training accuracy increases for training datasets with fewer than 250 examples, and the gap between validation and training accuracy widens—an indicator of an increasing degree of overfitting. Addressing over- and underfitting with validation curves Validation curves are a useful", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 173, "start_word": 55360, "end_word": 55760, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000174": {"text": "of the estimate. As we can see in the preceding learning curve plot, our model performs quite well on both the training and validation datasets if it has seen more than 250 examples during training. We can also see that the training accuracy increases for training datasets with fewer than 250 examples, and the gap between validation and training accuracy widens—an indicator of an increasing degree of overfitting. Addressing over- and underfitting with validation curves Validation curves are a useful tool for improving the performance of a model by addressing issues such as overfitting or underfitting. Validation curves are related to learning curves, but instead of plotting the training and test accuracies as functions of the sample size, we vary the values of the model pa - rameters, for example, the inverse regularization parameter, C, in logistic regression. Learning Best Practices for Model Evaluation and Hyperparameter Tuning 184 Let’s go ahead and see how we create validation curves via scikit-learn: >>> from sklearn.model_selection import validation_curve >>> param_range = [ 0.001, 0.01, 0.1, 1.0, 10.0, 100.0] >>> train_scores, test_scores = validation_curve( ... estimator=pipe_lr, ... X=X_train, ... y=y_train, ... param_name= 'logisticregression__C' , ... param_range=param_range, ... cv= 10) >>> train_mean = np.mean(train_scores, axis= 1) >>> train_std = np.std(train_scores, axis= 1) >>> test_mean = np.mean(test_scores, axis= 1) >>> test_std = np.std(test_scores, axis= 1) >>> plt.plot(param_range, train_mean, ... color= 'blue', marker= 'o', ... markersize= 5, label= 'Training accuracy' ) >>> plt.fill_between(param_range, train_mean + train_std, ... train_mean - train_std, alpha= 0.15, ... color= 'blue') >>> plt.plot(param_range, test_mean, ... color= 'green', linestyle= '--', ... marker= 's', markersize= 5, ... label= 'Validation accuracy' ) >>> plt.fill_between(param_range, ... test_mean + test_std, ... test_mean - test_std, ... alpha= 0.15, color= 'green') >>> plt.grid() >>> plt.xscale( 'log') >>> plt.legend(loc= 'lower right' ) >>> plt.xlabel( 'Parameter C' ) >>> plt.ylabel( 'Accuracy' ) >>> plt.ylim([ 0.8, 1.0]) >>> plt.show() Chapter 6 185 Using the preceding code, we obtained the validation curve plot for the parameter C: Figure 6.6: A validation curve plot for the SVM hyperparameter C Similar to the learning_curve function, the validation_curve function uses stratified k-fold cross-val - idation by default to estimate the performance of the classifier. Inside the validation_curve function, we specified the parameter that we wanted to evaluate. In this case, it is C, the inverse regularization parameter of the LogisticRegression classifier, which we wrote as 'logisticregression__C' to ac- cess the LogisticRegression object inside the scikit-learn pipeline for", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 174, "start_word": 55680, "end_word": 56080, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000175": {"text": "the parameter C: Figure 6.6: A validation curve plot for the SVM hyperparameter C Similar to the learning_curve function, the validation_curve function uses stratified k-fold cross-val - idation by default to estimate the performance of the classifier. Inside the validation_curve function, we specified the parameter that we wanted to evaluate. In this case, it is C, the inverse regularization parameter of the LogisticRegression classifier, which we wrote as 'logisticregression__C' to ac- cess the LogisticRegression object inside the scikit-learn pipeline for a specified value range that we set via the param_range parameter. Similar to the learning curve example in the previous section, we plotted the average training and cross-validation accuracies and the corresponding standard deviations. Although the differences in the accuracy for varying values of C are subtle, we can see that the model slightly underfits the data when we increase the regularization strength (small values of C). However, for large values of C, it means lowering the strength of regularization, so the model tends to slightly overfit the data. In this case, the sweet spot appears to be between 0.01 and 0.1 of the C value. Fine-tuning machine learning models via grid search In machine learning, we have two types of parameters: those that are learned from the training data, for example, the weights in logistic regression, and the parameters of a learning algorithm that are op - timized separately. The latter are the tuning parameters (or hyperparameters) of a model, for example, the regularization parameter in logistic regression or the maximum depth parameter of a decision tree. In the previous section, we used validation curves to improve the performance of a model by tuning one of its hyperparameters. In this section, we will take a look at a popular hyperparameter optimi- zation technique called grid search, which can further help to improve the performance of a model by finding the optimal combination of hyperparameter values. Learning Best Practices for Model Evaluation and Hyperparameter Tuning 186 Tuning hyperparameters via grid search The grid search approach is quite simple: it’s a brute-force exhaustive search paradigm where we spec- ify a list of values for different hyperparameters, and the computer evaluates the model performance for each combination to obtain the optimal combination of values from this set: >>> from sklearn.model_selection import GridSearchCV >>> from sklearn.svm import SVC >>> pipe_svc = make_pipeline(StandardScaler(), ... SVC(random_state= 1)) >>> param_range = [ 0.0001, 0.001, 0.01, 0.1,", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 175, "start_word": 56000, "end_word": 56400, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000176": {"text": "Model Evaluation and Hyperparameter Tuning 186 Tuning hyperparameters via grid search The grid search approach is quite simple: it’s a brute-force exhaustive search paradigm where we spec- ify a list of values for different hyperparameters, and the computer evaluates the model performance for each combination to obtain the optimal combination of values from this set: >>> from sklearn.model_selection import GridSearchCV >>> from sklearn.svm import SVC >>> pipe_svc = make_pipeline(StandardScaler(), ... SVC(random_state= 1)) >>> param_range = [ 0.0001, 0.001, 0.01, 0.1, ... 1.0, 10.0, 100.0, 1000.0 ] >>> param_grid = [{ 'svc__C' : param_range, ... 'svc__kernel' : ['linear' ]}, ... { 'svc__C' : param_range, ... 'svc__gamma' : param_range, ... 'svc__kernel' : ['rbf']}] >>> gs = GridSearchCV(estimator=pipe_svc, ... param_grid=param_grid, ... scoring= 'accuracy' , ... cv= 10, ... refit= True, ... n_jobs=- 1) >>> gs = gs.fit(X_train, y_train) >>> print(gs.best_score_) 0.9846153846153847 >>> print(gs.best_params_) {'svc__C': 100.0, 'svc__gamma': 0.001, 'svc__kernel': 'rbf'} Using the preceding code, we initialized a GridSearchCV object from the sklearn.model_selection module to train and tune an SVM pipeline. We set the param_grid parameter of GridSearchCV to a list of dictionaries to specify the parameters that we’d want to tune. For the linear SVM, we only evaluated the inverse regularization parameter, C; for the radial basis function ( RBF ) kernel SVM, we tuned both the svc__C and svc__gamma parameters. Note that the svc__gamma parameter is specific to kernel SVMs. GridSearchCV uses k-fold cross-validation for comparing models trained with different hyperparam- eter settings. Via the cv=10 setting, it will carry out 10-fold cross-validation and compute the average accuracy (via scoring='accuracy' ) across these 10-folds to assess the model performance. We set n_jobs=-1 so that GridSearchCV can use all our processing cores to speed up the grid search by fitting models to the different folds in parallel, but if your machine has problems with this setting, you may change this setting to n_jobs=None for single processing. After we used the training data to perform the grid search, we obtained the score of the best-perform- ing model via the best_score_ attribute and looked at its parameters, which can be accessed via the best_params_ attribute. In this particular case, the RBF kernel SVM model with svc__C = 100.0 yielded the best k-fold cross-validation accuracy: 98.5 percent. Chapter 6 187 Finally, we use the independent test dataset to estimate the performance of the best-selected model, which is available via the best_estimator_ attribute of the GridSearchCV object: >>>", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 176, "start_word": 56320, "end_word": 56720, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000177": {"text": "the grid search, we obtained the score of the best-perform- ing model via the best_score_ attribute and looked at its parameters, which can be accessed via the best_params_ attribute. In this particular case, the RBF kernel SVM model with svc__C = 100.0 yielded the best k-fold cross-validation accuracy: 98.5 percent. Chapter 6 187 Finally, we use the independent test dataset to estimate the performance of the best-selected model, which is available via the best_estimator_ attribute of the GridSearchCV object: >>> clf = gs.best_estimator_ >>> clf.fit(X_train, y_train) >>> print(f'Test accuracy: {clf.score(X_test, y_test): .3f}') Test accuracy: 0.974 Please note that fitting a model with the best settings ( gs.best_estimator_ ) on the training set manual - ly via clf.fit(X_train, y_train) after completing the grid search is not necessary. The GridSearchCV class has a refit parameter, which will refit the gs.best_estimator_ to the whole training set auto - matically if we set refit=True (default). Exploring hyperparameter configurations more widely with randomized search Since grid search is an exhaustive search, it is guaranteed to find the optimal hyperparameter configu - ration if it is contained in the user-specified parameter grid. However, specifying large hyperparameter grids makes grid search very expensive in practice. An alternative approach for sampling different parameter combinations is randomized search. In randomized search, we draw hyperparameter configurations randomly from distributions (or discrete sets). In contrast to grid search, randomized search does not do an exhaustive search over the hyperparameter space. Still, it allows us to explore a wider range of hyperparameter value settings in a more cost- and time-effective manner. This concept is illustrated in Figure 6.7, which shows a fixed grid of nine hyperparameter settings being searched via grid search and randomized search: Figure 6.7: A comparison of grid search and randomized search for sampling nine different hyper - parameter configurations each The main takeaway is that while grid search only explores discrete, user-specified choices, it may miss good hyperparameter configurations if the search space is too scarce. Interested readers can find additional details about randomized search, along with empirical studies, in the following article: Random Search for Hyper-Parameter Optimization by J. Bergstra, Y. Bengio, Journal of Machine Learning Research, pp. 281-305, 2012, https://www.jmlr.org/papers/volume13/bergstra12a/bergstra12a . Learning Best Practices for Model Evaluation and Hyperparameter Tuning 188 Let’s look at how we can use randomized search for tuning an SVM. Scikit-learn implements a RandomizedSearchCV class, which is analogous to the GridSearchCV we", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 177, "start_word": 56640, "end_word": 57040, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000178": {"text": "configurations if the search space is too scarce. Interested readers can find additional details about randomized search, along with empirical studies, in the following article: Random Search for Hyper-Parameter Optimization by J. Bergstra, Y. Bengio, Journal of Machine Learning Research, pp. 281-305, 2012, https://www.jmlr.org/papers/volume13/bergstra12a/bergstra12a . Learning Best Practices for Model Evaluation and Hyperparameter Tuning 188 Let’s look at how we can use randomized search for tuning an SVM. Scikit-learn implements a RandomizedSearchCV class, which is analogous to the GridSearchCV we used in the previous subsec- tion. The main difference is that we can specify distributions as part of our parameter grid and specify the total number of hyperparameter configurations to be evaluated. For example, let’s consider the hyperparameter range we used for several hyperparameters when tuning the SVM in the grid search example in the previous section: >>> param_range = [ 0.0001, 0.001, 0.01, 0.1, ... 1.0, 10.0, 100.0, 1000.0 ] Note that while RandomizedSearchCV can accept similar discrete lists of values as inputs for the pa - rameter grid, which is useful when considering categorical hyperparameters, its main power lies in the fact that we can replace these lists with distributions to sample from. Thus, for example, we may substitute the preceding list with the following distribution from SciPy: >>> param_range = scipy.stats.loguniform( 0.0001, 1000.0 ) For instance, using a loguniform distribution instead of a regular uniform distribution will ensure that in a sufficiently large number of trials, the same number of samples will be drawn from the [0.0001, 0.001] range as, for example, the [10.0, 100.0] range. To check its behavior, we can draw 10 random samples from this distribution via the rvs(10) method, as shown here: >>> np.random.seed( 1) >>> param_range.rvs( 10) array([8.30145146e-02, 1.10222804e+01, 1.00184520e-04, 1.30715777e-02, 1.06485687e-03, 4.42965766e-04, 2.01289666e-03, 2.62376594e-02, 5.98924832e-02, 5.91176467e-01]) Let’s now see the RandomizedSearchCV in action and tune an SVM as we did with GridSearchCV in the previous section: >>> from sklearn.model_selection import RandomizedSearchCV >>> pipe_svc = make_pipeline(StandardScaler(), ... SVC(random_state= 1))Specifying distributions RandomizedSearchCV supports arbitrary distributions as long as we can sample from them by calling the rvs() method. A list of all distributions currently available via scipy. stats can be found here: https://docs.scipy.org/doc/scipy/reference/stats. html#probability-distributions . Chapter 6 189 >>> param_grid = [{ 'svc__C' : param_range, ... 'svc__kernel' : ['linear' ]}, ... { 'svc__C' : param_range, ... 'svc__gamma' : param_range, ... 'svc__kernel' : ['rbf']}] >>> rs = RandomizedSearchCV(estimator=pipe_svc, ... param_distributions=param_grid, ... scoring= 'accuracy' ,", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 178, "start_word": 56960, "end_word": 57360, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000179": {"text": ">>> pipe_svc = make_pipeline(StandardScaler(), ... SVC(random_state= 1))Specifying distributions RandomizedSearchCV supports arbitrary distributions as long as we can sample from them by calling the rvs() method. A list of all distributions currently available via scipy. stats can be found here: https://docs.scipy.org/doc/scipy/reference/stats. html#probability-distributions . Chapter 6 189 >>> param_grid = [{ 'svc__C' : param_range, ... 'svc__kernel' : ['linear' ]}, ... { 'svc__C' : param_range, ... 'svc__gamma' : param_range, ... 'svc__kernel' : ['rbf']}] >>> rs = RandomizedSearchCV(estimator=pipe_svc, ... param_distributions=param_grid, ... scoring= 'accuracy' , ... refit= True, ... n_iter= 20, ... cv= 10, ... random_state= 1, ... n_jobs=- 1) >>> rs = rs.fit(X_train, y_train) >>> print(rs.best_score_) 0.9670531400966184 >>> print(rs.best_params_) {'svc__C': 0.05971247755848464, 'svc__kernel': 'linear'} Based on this code example, we can see that the usage is very similar to GridSearchCV , except that we could use distributions for specifying parameter ranges and specified the number of iterations—20 iterations—by setting n_iter=20 . More resource-efficient hyperparameter search with successive halving Taking the idea of randomized search one step further, scikit-learn implements a successive halving variant, HalvingRandomSearchCV , that makes finding suitable hyperparameter configurations more efficient. Successive halving, given a large set of candidate configurations, successively throws out unpromising hyperparameter configurations until only one configuration remains. We can summarize the procedure via the following steps: 1. Draw a large set of candidate configurations via random sampling 2. Train the models with limited resources, for example, a small subset of the training data (as opposed to using the entire training set) 3. Discard the bottom 50 percent based on predictive performance 4. Go back to step 2 with an increased amount of available resources Learning Best Practices for Model Evaluation and Hyperparameter Tuning 190 The steps are repeated until only one hyperparameter configuration remains. Note that there is also a successive halving implementation for the grid search variant called HalvingGridSearchCV , where all specified hyperparameter configurations are used in step 1 instead of random samples. In scikit-learn 1.0, HalvingRandomSearchCV is still experimental, which is why we have to enable it first: >>> from sklearn.experimental import enable_halving_search_cv (The above code may not work or be supported in future releases.) After enabling the experimental support, we can use randomized search with successive halving as shown in the following: >>> from sklearn.model_selection import HalvingRandomSearchCV >>> hs = HalvingRandomSearchCV(pipe_svc, ... param_distributions=param_grid, ... n_candidates= 'exhaust' , ... resource= 'n_samples' , ... factor= 1.5, ... random_state= 1, ... n_jobs=- 1) The resource='n_samples' (default) setting specifies", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 179, "start_word": 57280, "end_word": 57680, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000180": {"text": "is still experimental, which is why we have to enable it first: >>> from sklearn.experimental import enable_halving_search_cv (The above code may not work or be supported in future releases.) After enabling the experimental support, we can use randomized search with successive halving as shown in the following: >>> from sklearn.model_selection import HalvingRandomSearchCV >>> hs = HalvingRandomSearchCV(pipe_svc, ... param_distributions=param_grid, ... n_candidates= 'exhaust' , ... resource= 'n_samples' , ... factor= 1.5, ... random_state= 1, ... n_jobs=- 1) The resource='n_samples' (default) setting specifies that we consider the training set size as the re - source we vary between the rounds. Via the factor parameter, we can determine how many candidates are eliminated in each round. For example, setting factor=2 eliminates half of the candidates, and set - ting factor=1.5 means that only 100%/1.5 ≈ 66% of the candidates make it into the next round. Instead of choosing a fixed number of iterations as in RandomizedSearchCV , we set n_candidates='exhaust' (default), which will sample the number of hyperparameter configurations such that the maximum number of resources (here: training examples) are used in the last round. We can then carry out the search similar to RandomizedSearchCV : >>> hs = hs.fit(X_train, y_train) >>> print(hs.best_score_) 0.9617647058823529 >>> print(hs.best_params_) {'svc__C': 4.934834261073341, 'svc__kernel': 'linear'} Chapter 6 191 >>> clf = hs.best_estimator_ >>> print(f'Test accuracy: {hs.score(X_test, y_test): .3f}') Test accuracy: 0.982 If we compare the results from GridSearchCV and RandomizedSearchCV from the previous two sub - sections with the model from HalvingRandomSearchCV , we can see that the latter yields a model that performs slightly better on the test set (98.2 percent accuracy as opposed to 97.4 percent). Algorithm selection with nested cross-validation Using k-fold cross-validation in combination with grid search or randomized search is a useful ap - proach for fine-tuning the performance of a machine learning model by varying its hyperparam - eter values, as we saw in the previous subsections. If we want to select among different machine learning algorithms, though, another recommended approach is nested cross-validation. In a nice study on the bias in error estimation, Sudhir Varma and Richard Simon concluded that the true error of the estimate is almost unbiased relative to the test dataset when nested cross-validation is used (Bias in Error Estimation When Using Cross-Validation for Model Selection by S. Varma and R. Si- mon, BMC Bioinformatics, 7(1): 91, 2006, https://bmcbioinformatics.biomedcentral.com/articl es/10.1186/1471-2105-7-91 ).Hyperparameter tuning with hyperopt Another popular library for hyperparameter", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 180, "start_word": 57600, "end_word": 58000, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000181": {"text": "different machine learning algorithms, though, another recommended approach is nested cross-validation. In a nice study on the bias in error estimation, Sudhir Varma and Richard Simon concluded that the true error of the estimate is almost unbiased relative to the test dataset when nested cross-validation is used (Bias in Error Estimation When Using Cross-Validation for Model Selection by S. Varma and R. Si- mon, BMC Bioinformatics, 7(1): 91, 2006, https://bmcbioinformatics.biomedcentral.com/articl es/10.1186/1471-2105-7-91 ).Hyperparameter tuning with hyperopt Another popular library for hyperparameter optimization is hyperopt (https://github. com/hyperopt/hyperopt ), which implements several different methods for hyperpa - rameter optimization, including randomized search and the Tree-structured Parzen Es- timators (TPE ) method. TPE is a Bayesian optimization method based on a probabilistic model that is continuously updated based on past hyperparameter evaluations and the associated performance scores instead of regarding these evaluations as independent events. You can find out more about TPE in Algorithms for Hyper-Parameter Optimization. Bergstra J, Bardenet R, Bengio Y, Kegl B. NeurIPS 2011. pp. 2546–2554, https://dl.acm. org/doi/10.5555/2986459.2986743 . While hyperopt provides a general-purpose interface for hyperparameter optimization, there is also a scikit-learn-specific package called hyperopt-sklearn for additional conve - nience: https://github.com/hyperopt/hyperopt-sklearn . Learning Best Practices for Model Evaluation and Hyperparameter Tuning 192 In nested cross-validation, we have an outer k-fold cross-validation loop to split the data into training and test folds, and an inner loop is used to select the model using k-fold cross-validation on the training fold. After model selection, the test fold is then used to evaluate the model performance. Figure 6.8 explains the concept of nested cross-validation with only five outer and two inner folds, which can be useful for large datasets where computational performance is important; this particular type of nested cross-validation is also known as 5×2 cross-validation: Figure 6.8: The concept of nested cross-validation In scikit-learn, we can perform nested cross-validation with grid search as follows: >>> param_range = [ 0.0001, 0.001, 0.01, 0.1, ... 1.0, 10.0, 100.0, 1000.0 ] >>> param_grid = [{ 'svc__C' : param_range, ... 'svc__kernel' : ['linear' ]}, ... { 'svc__C' : param_range, ... 'svc__gamma' : param_range, ... 'svc__kernel' : ['rbf']}] >>> gs = GridSearchCV(estimator=pipe_svc, ... param_grid=param_grid, ... scoring= 'accuracy' , ... cv= 2) Chapter 6 193 >>> scores = cross_val_score(gs, X_train, y_train, ... scoring= 'accuracy' , cv=5) >>> print(f'CV accuracy: {np.mean(scores): .3f} ' ... f'+/- {np.std(scores): .3f}') CV accuracy: 0.974 +/- 0.015 The returned average cross-validation accuracy gives us a", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 181, "start_word": 57920, "end_word": 58320, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000182": {"text": "1.0, 10.0, 100.0, 1000.0 ] >>> param_grid = [{ 'svc__C' : param_range, ... 'svc__kernel' : ['linear' ]}, ... { 'svc__C' : param_range, ... 'svc__gamma' : param_range, ... 'svc__kernel' : ['rbf']}] >>> gs = GridSearchCV(estimator=pipe_svc, ... param_grid=param_grid, ... scoring= 'accuracy' , ... cv= 2) Chapter 6 193 >>> scores = cross_val_score(gs, X_train, y_train, ... scoring= 'accuracy' , cv=5) >>> print(f'CV accuracy: {np.mean(scores): .3f} ' ... f'+/- {np.std(scores): .3f}') CV accuracy: 0.974 +/- 0.015 The returned average cross-validation accuracy gives us a good estimate of what to expect if we tune the hyperparameters of a model and use it on unseen data. For example, we can use the nested cross-validation approach to compare an SVM model to a simple decision tree classifier; for simplicity, we will only tune its depth parameter: >>> from sklearn.tree import DecisionTreeClassifier >>> gs = GridSearchCV( ... estimator=DecisionTreeClassifier(random_state= 0), ... param_grid=[{ 'max_depth' : [1, 2, 3, 4, 5, 6, 7, None ]}], ... scoring= 'accuracy' , ... cv= 2 ... ) >>> scores = cross_val_score(gs, X_train, y_train, ... scoring= 'accuracy' , cv=5) >>> print(f'CV accuracy: {np.mean(scores): .3f} ' ... f'+/- {np.std(scores): .3f}') CV accuracy: 0.934 +/- 0.016 As we can see, the nested cross-validation performance of the SVM model (97.4 percent) is notably better than the performance of the decision tree (93.4 percent), and thus, we’d expect that it might be the better choice to classify new data that comes from the same population as this particular dataset. Looking at different performance evaluation metrics In the previous sections and chapters, we evaluated different machine learning models using predic- tion accuracy, which is a useful metric with which to quantify the performance of a model in general. However, there are several other performance metrics that can be used to measure a model’s relevance, such as precision, recall, the F1 score, and Matthews correlation coefficient (MCC ). Reading a confusion matrix Before we get into the details of different scoring metrics, let’s take a look at a confusion matrix, a matrix that lays out the performance of a learning algorithm. Learning Best Practices for Model Evaluation and Hyperparameter Tuning 194 A confusion matrix is simply a square matrix that reports the counts of the true positive ( TP), true neg - ative ( TN), false positive ( FP), and false negative ( FN) predictions of a classifier, as shown in Figure 6.9: Figure 6.9: The confusion matrix Although these metrics", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 182, "start_word": 58240, "end_word": 58640, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000183": {"text": "metrics, let’s take a look at a confusion matrix, a matrix that lays out the performance of a learning algorithm. Learning Best Practices for Model Evaluation and Hyperparameter Tuning 194 A confusion matrix is simply a square matrix that reports the counts of the true positive ( TP), true neg - ative ( TN), false positive ( FP), and false negative ( FN) predictions of a classifier, as shown in Figure 6.9: Figure 6.9: The confusion matrix Although these metrics can be easily computed manually by comparing the actual and predicted class labels, scikit-learn provides a convenient confusion_matrix function that we can use, as follows: >>> from sklearn.metrics import confusion_matrix >>> pipe_svc.fit(X_train, y_train) >>> y_pred = pipe_svc.predict(X_test) >>> confmat = confusion_matrix(y_true=y_test, y_pred=y_pred) >>> print(confmat) [[71 1] [ 2 40]] The array that was returned after executing the code provides us with information about the different types of error the classifier made on the test dataset. We can map this information onto the confusion matrix illustration in Figure 6.9 using Matplotlib’s matshow function: >>> fig, ax = plt.subplots(figsize=( 2.5, 2.5)) >>> ax.matshow(confmat, cmap=plt.cm.Blues, alpha= 0.3) >>> for i in range (confmat.shape[ 0]): ... for j in range (confmat.shape[ 1]): ... ax.text(x=j, y=i, s=confmat[i, j], ... va= 'center' , ha='center' ) >>> ax.xaxis.set_ticks_position( 'bottom' ) >>> plt.xlabel( 'Predicted label' ) >>> plt.ylabel( 'True label' ) >>> plt.show() Chapter 6 195 Now, the following confusion matrix plot, with the added labels, should make the results a little bit easier to interpret: Figure 6.10: A confusion matrix for our data Assuming that class 1 (malignant) is the positive class in this example, our model correctly classified 71 of the examples that belong to class 0 (TN) and 40 examples that belong to class 1 (TP), respectively. However, our model also incorrectly misclassified two examples from class 1 as class 0 (FN), and it predicted that one example is malignant although it is a benign tumor (FP). In the next subsection, we will learn how we can use this information to calculate various error metrics. Optimizing the precision and recall of a classification model Both the prediction error (ERR) and accuracy (ACC ) provide general information about how many examples are misclassified. The error can be understood as the sum of all false predictions divided by the number of total predictions, and the accuracy is calculated as the sum of correct predictions divided by the", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 183, "start_word": 58560, "end_word": 58960, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000184": {"text": "tumor (FP). In the next subsection, we will learn how we can use this information to calculate various error metrics. Optimizing the precision and recall of a classification model Both the prediction error (ERR) and accuracy (ACC ) provide general information about how many examples are misclassified. The error can be understood as the sum of all false predictions divided by the number of total predictions, and the accuracy is calculated as the sum of correct predictions divided by the total number of predictions, respectively: 𝐸𝐸𝐸𝐸𝐸𝐸=𝐹𝐹𝐹𝐹+𝐹𝐹𝐹𝐹 𝐹𝐹𝐹𝐹+𝐹𝐹𝐹𝐹+𝑇𝑇𝐹𝐹+𝑇𝑇𝐹𝐹 The prediction accuracy can then be calculated directly from the error: 𝐴𝐴𝐴𝐴𝐴𝐴 𝐴𝑇𝑇𝑇𝑇+𝑇𝑇𝑇𝑇 𝐹𝐹𝑇𝑇+𝐹𝐹𝑇𝑇+𝑇𝑇𝑇𝑇+𝑇𝑇𝑇𝑇𝐴1−𝐸𝐸𝐸𝐸𝐸𝐸 The true positive rate (TPR ) and false positive rate (FPR ) are performance metrics that are especially useful for imbalanced class problems: 𝐹𝐹𝐹𝐹𝐹𝐹 𝐹𝐹𝐹𝐹𝐹 𝑁𝑁𝐹𝐹𝐹𝐹𝐹 𝐹𝐹𝐹𝐹+𝑇𝑇𝑁𝑁 𝑇𝑇𝐹𝐹𝐹𝐹𝐹𝑇𝑇𝐹𝐹 𝐹𝐹𝐹𝑇𝑇𝐹𝐹 𝐹𝐹𝑁𝑁+𝑇𝑇𝐹𝐹 Learning Best Practices for Model Evaluation and Hyperparameter Tuning 196 In tumor diagnosis, for example, we are more concerned about the detection of malignant tumors in order to help a patient with the appropriate treatment. However, it is also important to decrease the number of benign tumors incorrectly classified as malignant (FP) to not unnecessarily concern patients. In contrast to the FPR, the TPR provides useful information about the fraction of positive (or relevant) examples that were correctly identified out of the total pool of positives (P). The performance metrics precision (PRE ) and recall (REC ) are related to those TP and TN rates, and in fact, REC is synonymous with TPR: 𝑅𝑅𝑅𝑅𝑅𝑅=𝑇𝑇𝑇𝑇𝑅𝑅=𝑇𝑇𝑇𝑇 𝑇𝑇=𝑇𝑇𝑇𝑇 𝐹𝐹𝐹𝐹+𝑇𝑇𝑇𝑇 In other words, recall quantifies how many of the relevant records (the positives) are captured as such (the true positives). Precision quantifies how many of the records predicted as relevant (the sum of true and false positives) are actually relevant (true positives): 𝑃𝑃𝑃𝑃𝑃𝑃 𝑃𝑇𝑇𝑃𝑃 𝑇𝑇𝑃𝑃+𝐹𝐹𝑃𝑃 Revisiting the malignant tumor detection example, optimizing for recall helps with minimizing the chance of not detecting a malignant tumor. However, this comes at the cost of predicting malignant tumors in patients although the patients are healthy (a high number of FPs). If we optimize for preci- sion, on the other hand, we emphasize correctness if we predict that a patient has a malignant tumor. However, this comes at the cost of missing malignant tumors more frequently (a high number of FNs). To balance the up- and downsides of optimizing PRE and REC, the harmonic mean of PRE and REC is used, the so-called F1 score: 𝐹𝐹𝐹 𝐹", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 184, "start_word": 58880, "end_word": 59280, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000185": {"text": "malignant tumors in patients although the patients are healthy (a high number of FPs). If we optimize for preci- sion, on the other hand, we emphasize correctness if we predict that a patient has a malignant tumor. However, this comes at the cost of missing malignant tumors more frequently (a high number of FNs). To balance the up- and downsides of optimizing PRE and REC, the harmonic mean of PRE and REC is used, the so-called F1 score: 𝐹𝐹𝐹 𝐹 𝐹𝑃𝑃𝑃𝑃𝑃𝑃 𝑃𝑃𝑃𝑃𝑃𝑅𝑅 𝑃𝑃𝑃𝑃𝑃𝑃 𝑃𝑃𝑃𝑃𝑃𝑅𝑅 Lastly, a measure that summarizes a confusion matrix is the MCC, which is especially popular in biological research contexts. The MCC is calculated as follows: 𝑀𝑀𝑀𝑀𝑀𝑀=𝑇𝑇𝑇𝑇×𝑇𝑇𝑇𝑇−𝐹𝐹𝑇𝑇×𝐹𝐹𝑇𝑇 √(𝑇𝑇𝑇𝑇+𝐹𝐹𝑇𝑇)(𝑇𝑇𝑇𝑇+𝐹𝐹𝑇𝑇)(𝑇𝑇𝑇𝑇+𝐹𝐹𝑇𝑇)(𝑇𝑇𝑇𝑇+𝐹𝐹𝑇𝑇) Further reading on precision and recall If you are interested in a more thorough discussion of the different performance metrics, such as precision and recall, read David M. W . Powers’ technical report Evaluation: From Precision, Recall and F-Factor to ROC, Informedness, Markedness & Correlation, which is freely available at https://arxiv.org/abs/2010.16061 . Chapter 6 197 In contrast to PRE, REC, and the F1 score, the MCC ranges between –1 and 1, and it takes all elements of a confusion matrix into account—for instance, the F1 score does not involve the TN. While the MCC values are harder to interpret than the F1 score, it is regarded as a superior metric, as described in the following article: The advantages of the Matthews correlation coefficient (MCC) over F1 score and accuracy in binary classification evaluation by D. Chicco and G. Jurman, BMC Genomics. pp. 281-305, 2012, https:// bmcgenomics.biomedcentral.com/articles/10.1186/s12864-019-6413-7 . Those scoring metrics are all implemented in scikit-learn and can be imported from the sklearn. metrics module as shown in the following snippet: >>> from sklearn.metrics import precision_score >>> from sklearn.metrics import recall_score, f1_score >>> from sklearn.metrics import matthews_corrcoef >>> pre_val = precision_score(y_true=y_test, y_pred=y_pred) >>> print(f'Precision: {pre_val: .3f}') Precision: 0.976 >>> rec_val = recall_score(y_true=y_test, y_pred=y_pred) >>> print(f'Recall: {rec_val: .3f}') Recall: 0.952 >>> f1_val = f1_score(y_true=y_test, y_pred=y_pred) >>> print(f'F1: {f1_val: .3f}') F1: 0.964 >>> mcc_val = matthews_corrcoef(y_true=y_test, y_pred=y_pred) >>> print(f'MCC: {mcc_val: .3f}') MCC: 0.943 Furthermore, we can use a different scoring metric than accuracy in the GridSearchCV via the scoring parameter. A complete list of the different values that are accepted by the scoring parameter can be found at http://scikit-learn.org/stable/modules/model_evaluation.html . Remember that the positive class in scikit-learn is the class that is labeled as class 1. If we want to specify a", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 185, "start_word": 59200, "end_word": 59600, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000186": {"text": "f1_val = f1_score(y_true=y_test, y_pred=y_pred) >>> print(f'F1: {f1_val: .3f}') F1: 0.964 >>> mcc_val = matthews_corrcoef(y_true=y_test, y_pred=y_pred) >>> print(f'MCC: {mcc_val: .3f}') MCC: 0.943 Furthermore, we can use a different scoring metric than accuracy in the GridSearchCV via the scoring parameter. A complete list of the different values that are accepted by the scoring parameter can be found at http://scikit-learn.org/stable/modules/model_evaluation.html . Remember that the positive class in scikit-learn is the class that is labeled as class 1. If we want to specify a different positive label, we can construct our own scorer via the make_scorer function, which we can then directly provide as an argument to the scoring parameter in GridSearchCV (in this ex - ample, using the f1_score as a metric): >>> from sklearn.metrics import make_scorer >>> c_gamma_range = [ 0.01, 0.1, 1.0, 10.0] >>> param_grid = [{ 'svc__C' : c_gamma_range, ... 'svc__kernel' : ['linear' ]}, ... { 'svc__C' : c_gamma_range, ... 'svc__gamma' : c_gamma_range, ... 'svc__kernel' : ['rbf']}] Learning Best Practices for Model Evaluation and Hyperparameter Tuning 198 >>> scorer = make_scorer(f1_score, pos_label= 0) >>> gs = GridSearchCV(estimator=pipe_svc, ... param_grid=param_grid, ... scoring=scorer, ... cv= 10) >>> gs = gs.fit(X_train, y_train) >>> print(gs.best_score_) 0.986202145696 >>> print(gs.best_params_) {'svc__C': 10.0, 'svc__gamma': 0.01, 'svc__kernel': 'rbf'} Plotting a receiver operating characteristic Receiver operating characteristic ( ROC ) graphs are useful tools to select models for classification based on their performance with respect to the FPR and TPR, which are computed by shifting the decision threshold of the classifier. The diagonal of a ROC graph can be interpreted as random guessing, and classification models that fall below the diagonal are considered as worse than random guessing. A perfect classifier would fall into the top-left corner of the graph with a TPR of 1 and an FPR of 0. Based on the ROC curve, we can then compute the so-called ROC area under the curve (ROC AUC ) to characterize the performance of a classification model. Similar to ROC curves, we can compute precision-recall curves for different probability thresholds of a classifier. A function for plotting those precision-recall curves is also implemented in scikit-learn and is documented at http://scikit-learn.org/stable/modules/generated/sklearn.metrics. precision_recall_curve.html . Executing the following code example, we will plot a ROC curve of a classifier that only uses two fea - tures from the Breast Cancer Wisconsin dataset to predict whether a tumor is benign or malignant. Although we are going to use the same logistic regression pipeline", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 186, "start_word": 59520, "end_word": 59920, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000187": {"text": "ROC curves, we can compute precision-recall curves for different probability thresholds of a classifier. A function for plotting those precision-recall curves is also implemented in scikit-learn and is documented at http://scikit-learn.org/stable/modules/generated/sklearn.metrics. precision_recall_curve.html . Executing the following code example, we will plot a ROC curve of a classifier that only uses two fea - tures from the Breast Cancer Wisconsin dataset to predict whether a tumor is benign or malignant. Although we are going to use the same logistic regression pipeline that we defined previously, we are only using two features this time. This is to make the classification task more challenging for the classifier, by withholding useful information contained in the other features, so that the resulting ROC curve becomes visually more interesting. For similar reasons, we are also reducing the number of folds in the StratifiedKFold validator to three. The code is as follows: >>> from sklearn.metrics import roc_curve, auc >>> from numpy import interp >>> pipe_lr = make_pipeline( ... StandardScaler(), ... PCA(n_components= 2), ... LogisticRegression(penalty= 'l2', random_state= 1, ... solver= 'lbfgs', C=100.0) ... ) >>> X_train2 = X_train[:, [ 4, 14]] Chapter 6 199 >>> cv = list(StratifiedKFold(n_splits= 3).split(X_train, y_train)) >>> fig = plt.figure(figsize=( 7, 5)) >>> mean_tpr = 0.0 >>> mean_fpr = np.linspace( 0, 1, 100 ) >>> all_tpr = [] >>> for i, (train, test) in enumerate (cv): ... probas = pipe_lr.fit( ... X_train2[train], ... y_train[train] ... ).predict_proba(X_train2[test]) ... fpr, tpr, thresholds = roc_curve(y_train[test], ... probas[:, 1], ... pos_label= 1) ... mean_tpr += interp(mean_fpr, fpr, tpr) ... mean_tpr[ 0] = 0.0 ... roc_auc = auc(fpr, tpr) ... plt.plot(fpr, ... tpr, ... label= f'ROC fold {i+1} (area = {roc_auc: .2f})') >>> plt.plot([ 0, 1], ... [ 0, 1], ... linestyle= '--', ... color=( 0.6, 0.6, 0.6), ... label= 'Random guessing (area=0.5)' ) >>> mean_tpr /= len(cv) >>> mean_tpr[- 1] = 1.0 >>> mean_auc = auc(mean_fpr, mean_tpr) >>> plt.plot(mean_fpr, mean_tpr, 'k--', ... label= f'Mean ROC (area = {mean_auc: .2f})', lw= 2) >>> plt.plot([ 0, 0, 1], ... [ 0, 1, 1], ... linestyle= ':', ... color= 'black', ... label= 'Perfect performance (area=1.0)' ) >>> plt.xlim([- 0.05, 1.05]) >>> plt.ylim([- 0.05, 1.05]) >>> plt.xlabel( 'False positive rate' ) >>> plt.ylabel( 'True positive rate' ) >>> plt.legend(loc= 'lower right' ) >>> plt.show() Learning Best Practices for Model Evaluation and Hyperparameter Tuning 200 In the preceding code example, we used the already familiar StratifiedKFold class from scikit-learn and calculated the ROC", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 187, "start_word": 59840, "end_word": 60240, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000188": {"text": ".2f})', lw= 2) >>> plt.plot([ 0, 0, 1], ... [ 0, 1, 1], ... linestyle= ':', ... color= 'black', ... label= 'Perfect performance (area=1.0)' ) >>> plt.xlim([- 0.05, 1.05]) >>> plt.ylim([- 0.05, 1.05]) >>> plt.xlabel( 'False positive rate' ) >>> plt.ylabel( 'True positive rate' ) >>> plt.legend(loc= 'lower right' ) >>> plt.show() Learning Best Practices for Model Evaluation and Hyperparameter Tuning 200 In the preceding code example, we used the already familiar StratifiedKFold class from scikit-learn and calculated the ROC performance of the LogisticRegression classifier in our pipe_lr pipeline using the roc_curve function from the sklearn.metrics module separately for each iteration. Fur - thermore, we interpolated the average ROC curve from the three folds via the interp function that we imported from SciPy and calculated the area under the curve via the auc function. The resulting ROC curve indicates that there is a certain degree of variance between the different folds, and the average ROC AUC (0.76) falls between a perfect score (1.0) and random guessing (0.5): Figure 6.11: The ROC plot Note that if we are just interested in the ROC AUC score, we could also directly import the roc_auc_ score function from the sklearn.metrics submodule, which can be used similarly to the other scoring functions (for example, precision_score ) that were introduced in the previous sections. Reporting the performance of a classifier as the ROC AUC can yield further insights into a classifier’s performance with respect to imbalanced samples. However, while the accuracy score can be inter - preted as a single cutoff point on a ROC curve, A. P. Bradley showed that the ROC AUC and accuracy metrics mostly agree with each other: The Use of the Area Under the ROC Curve in the Evaluation of Ma- chine Learning Algorithms by A. P. Bradley, Pattern Recognition, 30(7): 1145-1159, 1997, https://reader. elsevier.com/reader/sd/pii/S0031320396001422 . Scoring metrics for multiclass classification The scoring metrics that we’ve discussed so far are specific to binary classification systems. However, scikit-learn also implements macro and micro averaging methods to extend those scoring metrics to multiclass problems via one-vs.-all (OvA ) classification. The micro-average is calculated from the individual TPs, TNs, FPs, and FNs of the system. For example, the micro-average of the precision score in a k-class system can be calculated as follows: 𝑃𝑃𝑃𝑃𝑃𝑃𝑚𝑚𝑚𝑚𝑚𝑚𝑚𝑚𝑚𝑚=𝑇𝑇𝑃𝑃1+⋯+𝑇𝑇𝑃𝑃𝑘𝑘 𝑇𝑇𝑃𝑃1+⋯+𝑇𝑇𝑃𝑃𝑘𝑘+𝐹𝐹𝑃𝑃1+⋯+𝐹𝐹𝑃𝑃𝑘𝑘 Chapter 6 201 The macro-average is simply calculated as the average scores of the different systems: 𝑃𝑃𝑃𝑃𝑃𝑃𝑚𝑚𝑚𝑚𝑚𝑚𝑚𝑚𝑚𝑚=𝑃𝑃𝑃𝑃𝑃𝑃1+⋯+𝑃𝑃𝑃𝑃𝑃𝑃 𝑘𝑘 𝑘𝑘 Micro-averaging", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 188, "start_word": 60160, "end_word": 60560, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000189": {"text": "to binary classification systems. However, scikit-learn also implements macro and micro averaging methods to extend those scoring metrics to multiclass problems via one-vs.-all (OvA ) classification. The micro-average is calculated from the individual TPs, TNs, FPs, and FNs of the system. For example, the micro-average of the precision score in a k-class system can be calculated as follows: 𝑃𝑃𝑃𝑃𝑃𝑃𝑚𝑚𝑚𝑚𝑚𝑚𝑚𝑚𝑚𝑚=𝑇𝑇𝑃𝑃1+⋯+𝑇𝑇𝑃𝑃𝑘𝑘 𝑇𝑇𝑃𝑃1+⋯+𝑇𝑇𝑃𝑃𝑘𝑘+𝐹𝐹𝑃𝑃1+⋯+𝐹𝐹𝑃𝑃𝑘𝑘 Chapter 6 201 The macro-average is simply calculated as the average scores of the different systems: 𝑃𝑃𝑃𝑃𝑃𝑃𝑚𝑚𝑚𝑚𝑚𝑚𝑚𝑚𝑚𝑚=𝑃𝑃𝑃𝑃𝑃𝑃1+⋯+𝑃𝑃𝑃𝑃𝑃𝑃 𝑘𝑘 𝑘𝑘 Micro-averaging is useful if we want to weight each instance or prediction equally, whereas macro-av - eraging weights all classes equally to evaluate the overall performance of a classifier with regard to the most frequent class labels. If we are using binary performance metrics to evaluate multiclass classification models in scikit-learn, a normalized or weighted variant of the macro-average is used by default. The weighted macro-av - erage is calculated by weighting the score of each class label by the number of true instances when calculating the average. The weighted macro-average is useful if we are dealing with class imbalances, that is, different numbers of instances for each label. While the weighted macro-average is the default for multiclass problems in scikit-learn, we can specify the averaging method via the average parameter inside the different scoring functions that we import from the sklearn.metrics module, for example, the precision_score or make_scorer functions: >>> pre_scorer = make_scorer(score_func=precision_score, ... pos_label= 1, ... greater_is_better= True, ... average= 'micro') Dealing with class imbalance We’ve mentioned class imbalances several times throughout this chapter, and yet we haven’t actually discussed how to deal with such scenarios appropriately if they occur. Class imbalance is a quite com- mon problem when working with real-world data—examples from one class or multiple classes are over-represented in a dataset. We can think of several domains where this may occur, such as spam filtering, fraud detection, or screening for diseases. Imagine that the Breast Cancer Wisconsin dataset that we’ve been working with in this chapter con- sisted of 90 percent healthy patients. In this case, we could achieve 90 percent accuracy on the test dataset by just predicting the majority class (benign tumor) for all examples, without the help of a supervised machine learning algorithm. Thus, training a model on such a dataset that achieves ap - proximately 90 percent test accuracy would mean our model hasn’t learned anything useful from the features provided in", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 189, "start_word": 60480, "end_word": 60880, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000190": {"text": "Wisconsin dataset that we’ve been working with in this chapter con- sisted of 90 percent healthy patients. In this case, we could achieve 90 percent accuracy on the test dataset by just predicting the majority class (benign tumor) for all examples, without the help of a supervised machine learning algorithm. Thus, training a model on such a dataset that achieves ap - proximately 90 percent test accuracy would mean our model hasn’t learned anything useful from the features provided in this dataset. In this section, we will briefly go over some of the techniques that could help with imbalanced data - sets. But before we discuss different methods to approach this problem, let’s create an imbalanced dataset from our dataset, which originally consisted of 357 benign tumors (class 0) and 212 malignant tumors (class 1): >>> X_imb = np.vstack((X[y == 0], X[y == 1][:40])) >>> y_imb = np.hstack((y[y == 0], y[y == 1][:40])) Learning Best Practices for Model Evaluation and Hyperparameter Tuning 202 In this code snippet, we took all 357 benign tumor examples and stacked them with the first 40 ma - lignant examples to create a stark class imbalance. If we were to compute the accuracy of a model that always predicts the majority class (benign, class 0), we would achieve a prediction accuracy of approximately 90 percent: >>> y_pred = np.zeros(y_imb.shape[ 0]) >>> np.mean(y_pred == y_imb) * 100 89.92443324937027 Thus, when we fit classifiers on such datasets, it would make sense to focus on other metrics than accuracy when comparing different models, such as precision, recall, the ROC curve—whatever we care most about in our application. For instance, our priority might be to identify the majority of pa - tients with malignant cancer to recommend an additional screening, so recall should be our metric of choice. In spam filtering, where we don’t want to label emails as spam if the system is not very certain, precision might be a more appropriate metric. Aside from evaluating machine learning models, class imbalance influences a learning algorithm during model fitting itself. Since machine learning algorithms typically optimize a reward or loss function that is computed as a sum over the training examples that it sees during fitting, the decision rule is likely going to be biased toward the majority class. In other words, the algorithm implicitly learns a model that optimizes the predictions based on the most abundant class in", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 190, "start_word": 60800, "end_word": 61200, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000191": {"text": "be a more appropriate metric. Aside from evaluating machine learning models, class imbalance influences a learning algorithm during model fitting itself. Since machine learning algorithms typically optimize a reward or loss function that is computed as a sum over the training examples that it sees during fitting, the decision rule is likely going to be biased toward the majority class. In other words, the algorithm implicitly learns a model that optimizes the predictions based on the most abundant class in the dataset to minimize the loss or maximize the reward during training. One way to deal with imbalanced class proportions during model fitting is to assign a larger penalty to wrong predictions on the minority class. Via scikit-learn, adjusting such a penalty is as convenient as setting the class_weight parameter to class_weight='balanced' , which is implemented for most classifiers. Other popular strategies for dealing with class imbalance include upsampling the minority class, downsampling the majority class, and the generation of synthetic training examples. Unfortunately, there’s no universally best solution or technique that works best across different problem domains. Thus, in practice, it is recommended to try out different strategies on a given problem, evaluate the results, and choose the technique that seems most appropriate. The scikit-learn library implements a simple resample function that can help with the upsampling of the minority class by drawing new samples from the dataset with replacement. The following code will take the minority class from our imbalanced Breast Cancer Wisconsin dataset (here, class 1) and repeatedly draw new samples from it until it contains the same number of examples as class label 0: >>> from sklearn.utils import resample >>> print('Number of class 1 examples before:' , ... X_imb[y_imb == 1].shape[ 0]) Number of class 1 examples before: 40 >>> X_upsampled, y_upsampled = resample( ... X_imb[y_imb == 1], Chapter 6 203 ... y_imb[y_imb == 1], ... replace= True, ... n_samples=X_imb[y_imb == 0].shape[ 0], ... random_state= 123) >>> print('Number of class 1 examples after:' , ... X_upsampled.shape[ 0]) Number of class 1 examples after: 357 After resampling, we can then stack the original class 0 samples with the upsampled class 1 subset to obtain a balanced dataset as follows: >>> X_bal = np.vstack((X[y == 0], X_upsampled)) >>> y_bal = np.hstack((y[y == 0], y_upsampled)) Consequently, a majority vote prediction rule would only achieve 50 percent accuracy: >>> y_pred = np.zeros(y_bal.shape[ 0]) >>> np.mean(y_pred == y_bal) * 100 50", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 191, "start_word": 61120, "end_word": 61520, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000192": {"text": ">>> print('Number of class 1 examples after:' , ... X_upsampled.shape[ 0]) Number of class 1 examples after: 357 After resampling, we can then stack the original class 0 samples with the upsampled class 1 subset to obtain a balanced dataset as follows: >>> X_bal = np.vstack((X[y == 0], X_upsampled)) >>> y_bal = np.hstack((y[y == 0], y_upsampled)) Consequently, a majority vote prediction rule would only achieve 50 percent accuracy: >>> y_pred = np.zeros(y_bal.shape[ 0]) >>> np.mean(y_pred == y_bal) * 100 50 Similarly, we could downsample the majority class by removing training examples from the dataset. To perform downsampling using the resample function, we could simply swap the class 1 label with class 0 in the previous code example and vice versa. Summary At the beginning of this chapter, we discussed how to chain different transformation techniques and classifiers in convenient model pipelines that help us to train and evaluate machine learning models more efficiently. We then used those pipelines to perform k-fold cross-validation, one of the essential techniques for model selection and evaluation. Using k-fold cross-validation, we plotted learning and validation curves to diagnose common problems of learning algorithms, such as overfitting and underfitting.Generating new training data to address class imbalance Another technique for dealing with class imbalance is the generation of synthetic training examples, which is beyond the scope of this book. Probably the most widely used algorithm for synthetic training data generation is Synthetic Minority Over-sampling Technique (SMOTE ), and you can learn more about this technique in the original research article by Nitesh Chawla and others: SMOTE: Synthetic Minority Over-sampling Technique, Journal of Artificial Intelligence Research, 16: 321-357, 2002, which is available at https://www.jair. org/index.php/jair/article/view/10302. It is also highly recommended to check out imbalanced-learn, a Python library that is entirely focused on imbalanced datasets, including an implementation of SMOTE. You can learn more about imbalanced-learn at https://github.com/scikit-learn-contrib/imbalanced-learn . Learning Best Practices for Model Evaluation and Hyperparameter Tuning 204 Using grid search, randomized search, and successive halving, we further fine-tuned our model. We then used confusion matrices and various performance metrics to evaluate and optimize a model’s performance for specific problem tasks. Finally, we concluded this chapter by discussing different methods for dealing with imbalanced data, which is a common problem in many real-world applica - tions. Now, you should be well equipped with the essential techniques to build supervised machine learning models for classification successfully. In the next", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 192, "start_word": 61440, "end_word": 61840, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000193": {"text": "Using grid search, randomized search, and successive halving, we further fine-tuned our model. We then used confusion matrices and various performance metrics to evaluate and optimize a model’s performance for specific problem tasks. Finally, we concluded this chapter by discussing different methods for dealing with imbalanced data, which is a common problem in many real-world applica - tions. Now, you should be well equipped with the essential techniques to build supervised machine learning models for classification successfully. In the next chapter, we will look at ensemble methods: methods that allow us to combine multiple models and classification algorithms to boost the predictive performance of a machine learning system even further. Join our book’s Discord space Join the book’s Discord workspace for a monthly Ask me Anything session with the authors: https://packt.link/MLwPyTorch 7 Combining Different Models for Ensemble Learning In the previous chapter, we focused on the best practices for tuning and evaluating different models for classification. In this chapter, we will build upon those techniques and explore different methods for constructing a set of classifiers that can often have a better predictive performance than any of its individual members. We will learn how to do the following: • Make predictions based on majority voting • Use bagging to reduce overfitting by drawing random combinations of the training dataset with repetition • Apply boosting to build powerful models from weak learners that learn from their mistakes Learning with ensembles The goal of ensemble methods is to combine different classifiers into a meta-classifier that has better generalization performance than each individual classifier alone. For example, assuming that we col- lected predictions from 10 experts, ensemble methods would allow us to strategically combine those predictions by the 10 experts to come up with a prediction that was more accurate and robust than the predictions by each individual expert. As you will see later in this chapter, there are several different approaches for creating an ensemble of classifiers. This section will introduce a basic explanation of how ensembles work and why they are typically recognized for yielding a good generalization performance. In this chapter, we will focus on the most popular ensemble methods that use the majority voting principle. Majority voting simply means that we select the class label that has been predicted by the majority of classifiers, that is, received more than 50 percent of the votes. Strictly speaking, the term “majority vote”", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 193, "start_word": 61760, "end_word": 62160, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000194": {"text": "an ensemble of classifiers. This section will introduce a basic explanation of how ensembles work and why they are typically recognized for yielding a good generalization performance. In this chapter, we will focus on the most popular ensemble methods that use the majority voting principle. Majority voting simply means that we select the class label that has been predicted by the majority of classifiers, that is, received more than 50 percent of the votes. Strictly speaking, the term “majority vote” refers to binary class settings only. However, it is easy to generalize the majority voting principle to multiclass settings, which is known as plurality voting. (In the UK, people distinguish between majority and plurality voting via the terms “absolute” and “relative” majority, respectively.) Combining Different Models for Ensemble Learning 206 Here, we select the class label that received the most votes (the mode). Figure 7.1 illustrates the concept of majority and plurality voting for an ensemble of 10 classifiers, where each unique symbol (triangle, square, and circle) represents a unique class label: Figure 7.1: The different voting concepts Using the training dataset, we start by training m different classifiers (C 1, ..., Cm). Depending on the technique, the ensemble can be built from different classification algorithms, for example, decision trees, support vector machines, logistic regression classifiers, and so on. Alternatively, we can also use the same base classification algorithm, fitting different subsets of the training dataset. One prominent example of this approach is the random forest algorithm combining different decision tree classifiers, which we covered in Chapter 3, A Tour of Machine Learning Classifiers Using Scikit-Learn. Figure 7.2 illustrates the concept of a general ensemble approach using majority voting: Figure 7.2: A general ensemble approach To predict a class label via simple majority or plurality voting, we can combine the predicted class labels of each individual classifier, C j, and select the class label, 𝑦𝑦𝑦 , that received the most votes: 𝑦𝑦 𝑦 𝑦 𝑦𝑦𝑦𝑦 {𝐶𝐶1(𝒙𝒙),𝐶𝐶2(𝒙𝒙),…,𝐶𝐶𝑚𝑚(𝒙𝒙)} (In statistics, the mode is the most frequent event or result in a set. For example, mode{1, 2, 1, 1, 2, 4, 5, 4} = 1.) Chapter 7 207 For example, in a binary classification task where class1 = –1 and class2 = +1, we can write the majority vote prediction as follows: 𝐶𝐶(𝒙𝒙)=sign [∑𝐶𝐶 𝑗𝑗(𝒙𝒙)𝑚𝑚 𝑗𝑗]={1if ∑𝐶𝐶 𝑗𝑗(𝒙𝒙)≥0 𝑗𝑗 −1 otherwise To illustrate why ensemble methods can work better than individual classifiers alone,", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 194, "start_word": 62080, "end_word": 62480, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000195": {"text": "votes: 𝑦𝑦 𝑦 𝑦 𝑦𝑦𝑦𝑦 {𝐶𝐶1(𝒙𝒙),𝐶𝐶2(𝒙𝒙),…,𝐶𝐶𝑚𝑚(𝒙𝒙)} (In statistics, the mode is the most frequent event or result in a set. For example, mode{1, 2, 1, 1, 2, 4, 5, 4} = 1.) Chapter 7 207 For example, in a binary classification task where class1 = –1 and class2 = +1, we can write the majority vote prediction as follows: 𝐶𝐶(𝒙𝒙)=sign [∑𝐶𝐶 𝑗𝑗(𝒙𝒙)𝑚𝑚 𝑗𝑗]={1if ∑𝐶𝐶 𝑗𝑗(𝒙𝒙)≥0 𝑗𝑗 −1 otherwise To illustrate why ensemble methods can work better than individual classifiers alone, let’s apply some concepts of combinatorics. For the following example, we will make the assumption that all n-base classifiers for a binary classification task have an equal error rate, 𝜀𝜀 . Furthermore, we will assume that the classifiers are independent and the error rates are not correlated. Under those assumptions, we can simply express the error probability of an ensemble of base classifiers as a probability mass function of a binomial distribution: 𝑃𝑃(𝑦𝑦𝑦𝑦𝑦)=∑⟨𝑛𝑛 𝑦𝑦⟩𝜀𝜀𝑘𝑘(1−𝜀𝜀)𝑛𝑛𝑛𝑘𝑘𝑛𝑛 𝑘𝑘=𝜀𝜀ensemble Here, ⟨𝑛𝑛 𝑘𝑘⟩ is the binomial coefficient n choose k. In other words, we compute the probability that the prediction of the ensemble is wrong. Now, let’s take a look at a more concrete example of 11 base classifiers (n = 11), where each classifier has an error rate of 0.25 ( 𝜀𝜀 𝜀 𝜀𝜀25 ): 𝑃𝑃(𝑦𝑦𝑦𝑦𝑦)=∑⟨11 𝑦𝑦⟩0.25𝑘𝑘(1−0.25)11−𝑘𝑘11 𝑘𝑘𝑘𝑘= 0.034 As you can see, the error rate of the ensemble (0.034) is much lower than the error rate of each indi- vidual classifier (0.25) if all the assumptions are met. Note that, in this simplified illustration, a 50-50 split by an even number of classifiers, n, is treated as an error, whereas this is only true half of the time. To compare such an idealistic ensemble classifier to a base classifier over a range of different base error rates, let’s implement the probability mass function in Python: >>> from scipy.special import comb >>> import math >>> def ensemble_error (n_classifier, error):The binomial coefficient The binomial coefficient refers to the number of ways we can choose subsets of k unordered elements from a set of size n; thus, it is often called “n choose k.” Since the order does not matter here, the binomial coefficient is also sometimes referred to as combination or combinatorial number, and in its unabbreviated form, it is written as follows: 𝑛𝑛𝑛 (𝑛𝑛𝑛𝑛𝑛)𝑛𝑛𝑛𝑛 Here, the symbol (!) stands for factorial—for example, 3! = 3×2×1 = 6. Combining Different Models for Ensemble Learning 208", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 195, "start_word": 62400, "end_word": 62800, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000196": {"text": "refers to the number of ways we can choose subsets of k unordered elements from a set of size n; thus, it is often called “n choose k.” Since the order does not matter here, the binomial coefficient is also sometimes referred to as combination or combinatorial number, and in its unabbreviated form, it is written as follows: 𝑛𝑛𝑛 (𝑛𝑛𝑛𝑛𝑛)𝑛𝑛𝑛𝑛 Here, the symbol (!) stands for factorial—for example, 3! = 3×2×1 = 6. Combining Different Models for Ensemble Learning 208 ... k_start = int(math.ceil(n_classifier / 2.)) ... probs = [comb(n_classifier, k) * ... error**k * ... ( 1-error)**(n_classifier - k) ... for k in range (k_start, n_classifier + 1)] ... return sum(probs) >>> ensemble_error(n_classifier= 11, error= 0.25) 0.03432750701904297 After we have implemented the ensemble_error function, we can compute the ensemble error rates for a range of different base errors from 0.0 to 1.0 to visualize the relationship between ensemble and base errors in a line graph: >>> import numpy as np >>> import matplotlib.pyplot as plt >>> error_range = np.arange( 0.0, 1.01, 0.01) >>> ens_errors = [ensemble_error(n_classifier= 11, error=error) ... for error in error_range] >>> plt.plot(error_range, ens_errors, ... label= 'Ensemble error' , ... linewidth= 2) >>> plt.plot(error_range, error_range, ... linestyle= '--', label= 'Base error' , ... linewidth= 2) >>> plt.xlabel( 'Base error' ) >>> plt.ylabel( 'Base/Ensemble error' ) >>> plt.legend(loc= 'upper left' ) >>> plt.grid(alpha= 0.5) >>> plt.show() As you can see in the resulting plot, the error probability of an ensemble is always better than the error of an individual base classifier, as long as the base classifiers perform better than random guessing (𝜀𝜀 𝜀 𝜀𝜀𝜀 ). Chapter 7 209 Note that the y axis depicts the base error (dotted line) as well as the ensemble error (continuous line): Figure 7.3: A plot of the ensemble error versus the base error Combining classifiers via majority vote After the short introduction to ensemble learning in the previous section, let’s start with a warm-up exercise and implement a simple ensemble classifier for majority voting in Python. Implementing a simple majority vote classifier The algorithm that we are going to implement in this section will allow us to combine different clas- sification algorithms associated with individual weights for confidence. Our goal is to build a stronger meta-classifier that balances out the individual classifiers’ weaknesses on a particular dataset. In more precise mathematical terms, we can write the weighted majority vote as follows:", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 196, "start_word": 62720, "end_word": 63120, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000197": {"text": "with a warm-up exercise and implement a simple ensemble classifier for majority voting in Python. Implementing a simple majority vote classifier The algorithm that we are going to implement in this section will allow us to combine different clas- sification algorithms associated with individual weights for confidence. Our goal is to build a stronger meta-classifier that balances out the individual classifiers’ weaknesses on a particular dataset. In more precise mathematical terms, we can write the weighted majority vote as follows: 𝑦𝑦 𝑦 𝑦 𝑦𝑦𝑦𝑦𝑦𝑦𝑦 𝑖𝑖∑𝑤𝑤𝑗𝑗𝜒𝜒𝐴𝐴(𝐶𝐶𝑗𝑗(𝒙𝒙)𝑦𝑖𝑖𝑖𝑚𝑚 𝑗𝑗𝑗𝑗 Plurality voting Although the majority voting algorithm that we will discuss in this section also general- izes to multiclass settings via plurality voting, the term “majority voting” will be used for simplicity, as is often the case in the literature. Combining Different Models for Ensemble Learning 210 Here, wj is a weight associated with a base classifier, C j; 𝑦𝑦𝑦 is the predicted class label of the ensemble; A is the set of unique class labels; 𝜒𝜒𝐴𝐴 (Greek chi) is the characteristic function or indicator function, which returns 1 if the predicted class of the jth classifier matches i (C j(x) = i). For equal weights, we can simplify this equation and write it as follows: 𝑦𝑦 𝑦 𝑦 𝑦𝑦𝑦𝑦 {𝐶𝐶1(𝒙𝒙),𝐶𝐶2(𝒙𝒙),…,𝐶𝐶𝑚𝑚(𝒙𝒙)} To better understand the concept of weighting, we will now take a look at a more concrete example. Let’s assume that we have an ensemble of three base classifiers, 𝐶𝐶𝑗𝑗(𝑗𝑗𝑗{1,2,3}) , and we want to predict the class label, 𝐶𝐶𝑗𝑗(𝒙𝒙)∈{0,1} , of a given example, x. Two out of three base classifiers predict the class label 0, and one, C 3, predicts that the example belongs to class 1. If we weight the predictions of each base classifier equally, the majority vote predicts that the example belongs to class 0: 𝐶𝐶1(𝒙𝒙)→ 0, 𝐶𝐶 2(𝒙𝒙)→ 0, 𝐶𝐶 3(𝒙𝒙)→1 𝑦𝑦 𝑦 𝑦 𝑦𝑦𝑦𝑦 {0, 0, 1 }𝑦0 Now, let’s assign a weight of 0.6 to C 3, and let’s weight C 1 and C 2 by a coefficient of 0.2: 𝑦𝑦 𝑦 𝑦 𝑦𝑦𝑦𝑦𝑦𝑦𝑦 𝑖𝑖∑𝑤𝑤𝑗𝑗𝜒𝜒𝐴𝐴(𝐶𝐶𝑗𝑗(𝒙𝒙)𝑦𝑖𝑖𝑖𝑚𝑚 𝑗𝑗𝑗𝑗 𝑦 𝑦 𝑦𝑦𝑦𝑦𝑦𝑦𝑦 𝑖𝑖[0.2×𝑖𝑖 0+0.2×𝑖𝑖 0,0.6×𝑖𝑖 𝑗]𝑦1 More simply, since 3×0.2 = 0.6, we can say that the prediction made by C 3 has three times more weight than the predictions by C 1 or C 2, which we can write as follows: 𝑦𝑦 𝑦 𝑦 𝑦𝑦𝑦𝑦 {0,0,1,1,1 }𝑦1 To translate the concept of the weighted majority vote into", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 197, "start_word": 63040, "end_word": 63440, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000198": {"text": "C 3, and let’s weight C 1 and C 2 by a coefficient of 0.2: 𝑦𝑦 𝑦 𝑦 𝑦𝑦𝑦𝑦𝑦𝑦𝑦 𝑖𝑖∑𝑤𝑤𝑗𝑗𝜒𝜒𝐴𝐴(𝐶𝐶𝑗𝑗(𝒙𝒙)𝑦𝑖𝑖𝑖𝑚𝑚 𝑗𝑗𝑗𝑗 𝑦 𝑦 𝑦𝑦𝑦𝑦𝑦𝑦𝑦 𝑖𝑖[0.2×𝑖𝑖 0+0.2×𝑖𝑖 0,0.6×𝑖𝑖 𝑗]𝑦1 More simply, since 3×0.2 = 0.6, we can say that the prediction made by C 3 has three times more weight than the predictions by C 1 or C 2, which we can write as follows: 𝑦𝑦 𝑦 𝑦 𝑦𝑦𝑦𝑦 {0,0,1,1,1 }𝑦1 To translate the concept of the weighted majority vote into Python code, we can use NumPy’s con- venient argmax and bincount functions, where bincount counts the number of occurrences of each class label. The argmax function then returns the index position of the highest count, corresponding to the majority class label (this assumes that class labels start at 0): >>> import numpy as np >>> np.argmax(np.bincount([ 0, 0, 1], ... weights=[ 0.2, 0.2, 0.6])) 1 As you will remember from the discussion on logistic regression in Chapter 3, certain classifiers in scikit-learn can also return the probability of a predicted class label via the predict_proba method. Using the predicted class probabilities instead of the class labels for majority voting can be useful if the classifiers in our ensemble are well calibrated. The modified version of the majority vote for predicting class labels from probabilities can be written as follows: 𝑦𝑦 𝑦 𝑦 𝑦𝑦𝑦𝑦𝑦𝑦𝑦 𝑖𝑖∑𝑤𝑤𝑗𝑗𝑝𝑝𝑖𝑖𝑗𝑗𝑚𝑚 𝑗𝑗𝑗𝑗 Chapter 7 211 Here, p ij is the predicted probability of the jth classifier for class label i. To continue with our previous example, let’s assume that we have a binary classification problem with class labels 𝑖𝑖𝑖{0,1} and an ensemble of three classifiers, 𝐶𝐶𝑗𝑗(𝑗𝑗𝑗{1,2,3}) . Let’s assume that the classifiers C j return the following class membership probabilities for a particular example, x: 𝐶𝐶1(𝒙𝒙)→[0.9, 0.1 ], 𝐶𝐶 2(𝒙𝒙)→[0.8, 0.2 ], 𝐶𝐶 3(𝒙𝒙)→[0.4, 0.6 ] Using the same weights as previously (0.2, 0.2, and 0.6), we can then calculate the individual class probabilities as follows: 𝑝𝑝(𝑖𝑖0|𝒙𝒙)= 0.2×0.9+0.2×0.8+0.6×0.4 = 0. 58 𝑝𝑝(𝑖𝑖1|𝒙𝒙)= 0.2×0.1+0.2×0.2+0.6×0.6 = 0. 42 𝑦𝑦 𝑦=𝑦𝑦𝑦𝑦𝑦𝑦𝑦 𝑖𝑖[𝑝𝑝(𝑖𝑖0|𝒙𝒙),𝑝𝑝(𝑖𝑖1|𝒙𝒙)]=0 To implement the weighted majority vote based on class probabilities, we can again make use of NumPy, using np.average and np.argmax : >>> ex = np.array([[ 0.9, 0.1], ... [ 0.8, 0.2], ... [ 0.4, 0.6]]) >>> p = np.average(ex, axis= 0, weights=[ 0.2, 0.2, 0.6]) >>> p array([0.58, 0.42]) >>> np.argmax(p) 0 Putting everything together, let’s now implement MajorityVoteClassifier in Python: from sklearn.base import BaseEstimator from sklearn.base", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 198, "start_word": 63360, "end_word": 63760, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000199": {"text": "0.2×0.9+0.2×0.8+0.6×0.4 = 0. 58 𝑝𝑝(𝑖𝑖1|𝒙𝒙)= 0.2×0.1+0.2×0.2+0.6×0.6 = 0. 42 𝑦𝑦 𝑦=𝑦𝑦𝑦𝑦𝑦𝑦𝑦 𝑖𝑖[𝑝𝑝(𝑖𝑖0|𝒙𝒙),𝑝𝑝(𝑖𝑖1|𝒙𝒙)]=0 To implement the weighted majority vote based on class probabilities, we can again make use of NumPy, using np.average and np.argmax : >>> ex = np.array([[ 0.9, 0.1], ... [ 0.8, 0.2], ... [ 0.4, 0.6]]) >>> p = np.average(ex, axis= 0, weights=[ 0.2, 0.2, 0.6]) >>> p array([0.58, 0.42]) >>> np.argmax(p) 0 Putting everything together, let’s now implement MajorityVoteClassifier in Python: from sklearn.base import BaseEstimator from sklearn.base import ClassifierMixin from sklearn.preprocessing import LabelEncoder from sklearn.base import clone from sklearn.pipeline import _name_estimators import numpy as np import operator class MajorityVoteClassifier (BaseEstimator, ClassifierMixin): def __init__ (self, classifiers, vote= 'classlabel' , weights= None): self.classifiers = classifiers self.named_classifiers = { key: value for key, value in _name_estimators(classifiers) } self.vote = vote Combining Different Models for Ensemble Learning 212 self.weights = weights def fit(self, X, y): if self.vote not in ('probability' , 'classlabel' ): raise ValueError( f\"vote must be 'probability' \" f\"or 'classlabel'\" f\"; got (vote= {self.vote} )\") if self.weights and len(self.weights) != len(self.classifiers): raise ValueError( f'Number of classifiers and' f' weights must be equal' f'; got {len(self.weights)} weights,' f' {len(self.classifiers)} classifiers' ) # Use LabelEncoder to ensure class labels start # with 0, which is important for np.argmax # call in self.predict self.lablenc_ = LabelEncoder() self.lablenc_.fit(y) self.classes_ = self.lablenc_.classes_ self.classifiers_ = [] for clf in self.classifiers: fitted_clf = clone(clf).fit(X, self.lablenc_.transform(y)) self.classifiers_.append(fitted_clf) return self We’ve added a lot of comments to the code to explain the individual parts. However, before we im- plement the remaining methods, let’s take a quick break and discuss some of the code that may look confusing at first. We used the BaseEstimator and ClassifierMixin parent classes to get some base functionality for free, including the get_params and set_params methods to set and return the classi- fier’s parameters, as well as the score method to calculate the prediction accuracy. Next, we will add the predict method to predict the class label via a majority vote based on the class labels if we initialize a new MajorityVoteClassifier object with vote='classlabel' . Alternatively, we will be able to initialize the ensemble classifier with vote='probability' to predict the class label based on the class membership probabilities. Furthermore, we will also add a predict_proba method to return the averaged probabilities, which is useful when computing the receiver operating characteristic area under the curve (ROC AUC ): def predict (self, X): if self.vote", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 199, "start_word": 63680, "end_word": 64080, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000200": {"text": "the class label via a majority vote based on the class labels if we initialize a new MajorityVoteClassifier object with vote='classlabel' . Alternatively, we will be able to initialize the ensemble classifier with vote='probability' to predict the class label based on the class membership probabilities. Furthermore, we will also add a predict_proba method to return the averaged probabilities, which is useful when computing the receiver operating characteristic area under the curve (ROC AUC ): def predict (self, X): if self.vote == 'probability' : maj_vote = np.argmax(self.predict_proba(X), axis= 1) else: # 'classlabel' vote Chapter 7 213 # Collect results from clf.predict calls predictions = np.asarray([ clf.predict(X) for clf in self.classifiers_ ]).T maj_vote = np.apply_along_axis( lambda x: np.argmax( np.bincount(x, weights=self.weights) ), axis= 1, arr=predictions ) maj_vote = self.lablenc_.inverse_transform(maj_vote) return maj_vote def predict_proba (self, X): probas = np.asarray([clf.predict_proba(X) for clf in self.classifiers_]) avg_proba = np.average(probas, axis= 0, weights=self.weights) return avg_proba def get_params (self, deep= True): if not deep: return super().get_params(deep= False) else: out = self.named_classifiers.copy() for name, step in self.named_classifiers.items(): for key, value in step.get_params( deep= True).items(): out[ f'{name} __{key}'] = value return out Also, note that we defined our own modified version of the get_params method to use the _name_ estimators function to access the parameters of individual classifiers in the ensemble; this may look a little bit complicated at first, but it will make perfect sense when we use grid search for hyperpa - rameter tuning in later sections. Combining Different Models for Ensemble Learning 214 Using the majority voting principle to make predictions Now it is time to put the MajorityVoteClassifier that we implemented in the previous section into action. But first, let’s prepare a dataset that we can test it on. Since we are already familiar with techniques to load datasets from CSV files, we will take a shortcut and load the Iris dataset from scikit-learn’s datasets module. Furthermore, we will only select two features, sepal width and pet - al length, to make the classification task more challenging for illustration purposes. Although our MajorityVoteClassifier generalizes to multiclass problems, we will only classify flower examples from the Iris-versicolor and Iris-virginica classes, with which we will compute the ROC AUC later. The code is as follows: >>> from sklearn import datasets >>> from sklearn.model_selection import train_test_split >>> from sklearn.preprocessing import StandardScaler >>> from sklearn.preprocessing import LabelEncoder >>> iris = datasets.load_iris() >>> X, y = iris.data[ 50:, [1, 2]], iris.target[ 50:]", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 200, "start_word": 64000, "end_word": 64400, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000201": {"text": "- al length, to make the classification task more challenging for illustration purposes. Although our MajorityVoteClassifier generalizes to multiclass problems, we will only classify flower examples from the Iris-versicolor and Iris-virginica classes, with which we will compute the ROC AUC later. The code is as follows: >>> from sklearn import datasets >>> from sklearn.model_selection import train_test_split >>> from sklearn.preprocessing import StandardScaler >>> from sklearn.preprocessing import LabelEncoder >>> iris = datasets.load_iris() >>> X, y = iris.data[ 50:, [1, 2]], iris.target[ 50:] >>> le = LabelEncoder() >>> y = le.fit_transform(y)VotingClassifier in scikit-learn Although the MajorityVoteClassifier implementation is very useful for demonstration purposes, we implemented a more sophisticated version of this majority vote classifier in scikit-learn based on the implementation in the first edition of this book. The ensemble classifier is available as sklearn.ensemble.VotingClassifier in scikit-learn version 0.17 and newer. You can find out more about VotingClassifier at https://scikit- learn.org/stable/modules/generated/sklearn.ensemble.VotingClassifier.html Class membership probabilities from decision trees Note that scikit-learn uses the predict_proba method (if applicable) to compute the ROC AUC score. In Chapter 3, we saw how the class probabilities are computed in logistic regression models. In decision trees, the probabilities are calculated from a frequency vector that is created for each node at training time. The vector collects the frequency values of each class label computed from the class label distribution at that node. Then, the frequencies are normalized so that they sum up to 1. Similarly, the class labels of the k-nearest neighbors are aggregated to return the normalized class label frequencies in the k-nearest neighbors algorithm. Although the normalized probabilities returned by both the decision tree and k-nearest neighbors classifier may look similar to the probabilities obtained from a logistic regression model, we have to be aware that they are actually not derived from probability mass functions. Chapter 7 215 Next, we will split the Iris examples into 50 percent training and 50 percent test data: >>> X_train, X_test, y_train, y_test =\\ ... train_test_split(X, y, ... test_size= 0.5, ... random_state= 1, ... stratify=y) Using the training dataset, we now will train three different classifiers: • Logistic regression classifier • Decision tree classifier • k-nearest neighbors classifier We will then evaluate the model performance of each classifier via 10-fold cross-validation on the training dataset before we combine them into an ensemble classifier: >>> from sklearn.model_selection import cross_val_score >>> from sklearn.linear_model import LogisticRegression >>> from sklearn.tree import DecisionTreeClassifier >>> from sklearn.neighbors import", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 201, "start_word": 64320, "end_word": 64720, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000202": {"text": "y_test =\\ ... train_test_split(X, y, ... test_size= 0.5, ... random_state= 1, ... stratify=y) Using the training dataset, we now will train three different classifiers: • Logistic regression classifier • Decision tree classifier • k-nearest neighbors classifier We will then evaluate the model performance of each classifier via 10-fold cross-validation on the training dataset before we combine them into an ensemble classifier: >>> from sklearn.model_selection import cross_val_score >>> from sklearn.linear_model import LogisticRegression >>> from sklearn.tree import DecisionTreeClassifier >>> from sklearn.neighbors import KNeighborsClassifier >>> from sklearn.pipeline import Pipeline >>> import numpy as np >>> clf1 = LogisticRegression(penalty= 'l2', ... C= 0.001, ... solver= 'lbfgs', ... random_state= 1) >>> clf2 = DecisionTreeClassifier(max_depth= 1, ... criterion= 'entropy' , ... random_state= 0) >>> clf3 = KNeighborsClassifier(n_neighbors= 1, ... p= 2, ... metric= 'minkowski' ) >>> pipe1 = Pipeline([[ 'sc', StandardScaler()], ... [ 'clf', clf1]]) >>> pipe3 = Pipeline([[ 'sc', StandardScaler()], ... [ 'clf', clf3]]) >>> clf_labels = [ 'Logistic regression' , 'Decision tree' , 'KNN'] >>> print('10-fold cross validation:\\n' ) >>> for clf, label in zip([pipe1, clf2, pipe3], clf_labels): ... scores = cross_val_score(estimator=clf, ... X=X_train, ... y=y_train, Combining Different Models for Ensemble Learning 216 ... cv= 10, ... scoring= 'roc_auc' ) ... print(f'ROC AUC: {scores.mean(): .2f} ' ... f'(+/- {scores.std(): .2f}) [{label}]') The output that we receive, as shown in the following snippet, shows that the predictive performances of the individual classifiers are almost equal: 10-fold cross validation: ROC AUC: 0.92 (+/- 0.15) [Logistic regression] ROC AUC: 0.87 (+/- 0.18) [Decision tree] ROC AUC: 0.85 (+/- 0.13) [KNN] You may be wondering why we trained the logistic regression and k-nearest neighbors classifier as part of a pipeline. The reason behind it is that, as discussed in Chapter 3, both the logistic regression and k-nearest neighbors algorithms (using the Euclidean distance metric) are not scale-invariant, in contrast to decision trees. Although the Iris features are all measured on the same scale (cm), it is a good habit to work with standardized features. Now, let’s move on to the more exciting part and combine the individual classifiers for majority rule voting in our MajorityVoteClassifier : >>> mv_clf = MajorityVoteClassifier( ... classifiers=[pipe1, clf2, pipe3] ... ) >>> clf_labels += [ 'Majority voting' ] >>> all_clf = [pipe1, clf2, pipe3, mv_clf] >>> for clf, label in zip(all_clf, clf_labels): ... scores = cross_val_score(estimator=clf, ... X=X_train, ... y=y_train, ... cv= 10, ... scoring= 'roc_auc' ) ... print(f'ROC AUC: {scores.mean(): .2f} '", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 202, "start_word": 64640, "end_word": 65040, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000203": {"text": "habit to work with standardized features. Now, let’s move on to the more exciting part and combine the individual classifiers for majority rule voting in our MajorityVoteClassifier : >>> mv_clf = MajorityVoteClassifier( ... classifiers=[pipe1, clf2, pipe3] ... ) >>> clf_labels += [ 'Majority voting' ] >>> all_clf = [pipe1, clf2, pipe3, mv_clf] >>> for clf, label in zip(all_clf, clf_labels): ... scores = cross_val_score(estimator=clf, ... X=X_train, ... y=y_train, ... cv= 10, ... scoring= 'roc_auc' ) ... print(f'ROC AUC: {scores.mean(): .2f} ' ... f'(+/- {scores.std(): .2f}) [{label}]') ROC AUC: 0.92 (+/- 0.15) [Logistic regression] ROC AUC: 0.87 (+/- 0.18) [Decision tree] ROC AUC: 0.85 (+/- 0.13) [KNN] ROC AUC: 0.98 (+/- 0.05) [Majority voting] Chapter 7 217 As you can see, the performance of MajorityVotingClassifier has improved over the individual classifiers in the 10-fold cross-validation evaluation. Evaluating and tuning the ensemble classifier In this section, we are going to compute the ROC curves from the test dataset to check that MajorityVoteClassifier generalizes well with unseen data. We must remember that the test data - set is not to be used for model selection; its purpose is merely to report an unbiased estimate of the generalization performance of a classifier system: >>> from sklearn.metrics import roc_curve >>> from sklearn.metrics import auc >>> colors = [ 'black', 'orange' , 'blue' , 'green' ] >>> linestyles = [ ':', '--', '-.', '-'] >>> for clf, label, clr, ls \\ ... in zip(all_clf, clf_labels, colors, linestyles): ... # assuming the label of the positive class is 1 ... y_pred = clf.fit(X_train, ... y_train).predict_proba(X_test)[:, 1] ... fpr, tpr, thresholds = roc_curve(y_true=y_test, ... y_score=y_pred) ... roc_auc = auc(x=fpr, y=tpr) ... plt.plot(fpr, tpr, ... color=clr, ... linestyle=ls, ... label= f'{label} (auc = {roc_auc: .2f})') >>> plt.legend(loc= 'lower right' ) >>> plt.plot([ 0, 1], [ 0, 1], ... linestyle= '--', ... color= 'gray', ... linewidth= 2) >>> plt.xlim([- 0.1, 1.1]) >>> plt.ylim([- 0.1, 1.1]) >>> plt.grid(alpha= 0.5) >>> plt.xlabel( 'False positive rate (FPR)' ) >>> plt.ylabel( 'True positive rate (TPR)' ) >>> plt.show() Combining Different Models for Ensemble Learning 218 As you can see in the resulting ROC, the ensemble classifier also performs well on the test dataset (ROC AUC = 0.95). However, you can see that the logistic regression classifier performs similarly well on the same dataset, which is probably due to the high variance (in this case, the sensitivity of how we split the dataset) given the small", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 203, "start_word": 64960, "end_word": 65360, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000204": {"text": "positive rate (FPR)' ) >>> plt.ylabel( 'True positive rate (TPR)' ) >>> plt.show() Combining Different Models for Ensemble Learning 218 As you can see in the resulting ROC, the ensemble classifier also performs well on the test dataset (ROC AUC = 0.95). However, you can see that the logistic regression classifier performs similarly well on the same dataset, which is probably due to the high variance (in this case, the sensitivity of how we split the dataset) given the small size of the dataset: Figure 7.4: The ROC curve for the different classifiers Since we only selected two features for the classification examples, it would be interesting to see what the decision region of the ensemble classifier actually looks like. Although it is not necessary to standardize the training features prior to model fitting, because our logistic regression and k-nearest neighbors pipelines will automatically take care of it, we will stan- dardize the training dataset so that the decision regions of the decision tree will be on the same scale for visual purposes. The code is as follows: >>> sc = StandardScaler() >>> X_train_std = sc.fit_transform(X_train) >>> from itertools import product >>> x_min = X_train_std[:, 0].min() - 1 >>> x_max = X_train_std[:, 0].max() + 1 >>> y_min = X_train_std[:, 1].min() - 1 >>> >>> y_max = X_train_std[:, 1].max() + 1 Chapter 7 219 >>> xx, yy = np.meshgrid(np.arange(x_min, x_max, 0.1), ... np.arange(y_min, y_max, 0.1)) >>> f, axarr = plt.subplots(nrows= 2, ncols= 2, ... sharex= 'col', ... sharey= 'row', ... figsize=( 7, 5)) >>> for idx, clf, tt in zip(product([ 0, 1], [ 0, 1]), ... all_clf, clf_labels): ... clf.fit(X_train_std, y_train) ... Z = clf.predict(np.c_[xx.ravel(), yy.ravel()]) ... Z = Z.reshape(xx.shape) ... axarr[idx[ 0], idx[ 1]].contourf(xx, yy, Z, alpha= 0.3) ... axarr[idx[ 0], idx[ 1]].scatter(X_train_std[y_train== 0, 0], ... X_train_std[y_train== 0, 1], ... c= 'blue', ... marker= '^', ... s= 50) ... axarr[idx[ 0], idx[ 1]].scatter(X_train_std[y_train== 1, 0], ... X_train_std[y_train== 1, 1], ... c= 'green', ... marker= 'o', ... s= 50) ... axarr[idx[ 0], idx[ 1]].set_title(tt) >>> plt.text(- 3.5, -5., ... s= 'Sepal width [standardized]' , ... ha= 'center' , va='center' , fontsize= 12) >>> plt.text(- 12.5, 4.5, ... s= 'Petal length [standardized]' , ... ha= 'center' , va='center' , ... fontsize= 12, rotation= 90) >>> plt.show() Interestingly, but also as expected, the decision regions of the ensemble classifier seem to be a hy - brid of the decision regions from the individual", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 204, "start_word": 65280, "end_word": 65680, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000205": {"text": "c= 'green', ... marker= 'o', ... s= 50) ... axarr[idx[ 0], idx[ 1]].set_title(tt) >>> plt.text(- 3.5, -5., ... s= 'Sepal width [standardized]' , ... ha= 'center' , va='center' , fontsize= 12) >>> plt.text(- 12.5, 4.5, ... s= 'Petal length [standardized]' , ... ha= 'center' , va='center' , ... fontsize= 12, rotation= 90) >>> plt.show() Interestingly, but also as expected, the decision regions of the ensemble classifier seem to be a hy - brid of the decision regions from the individual classifiers. At first glance, the majority vote decision boundary looks a lot like the decision of the decision tree stump, which is orthogonal to the y axis for sepal width ≥ 1. Combining Different Models for Ensemble Learning 220 However, you can also notice the nonlinearity from the k-nearest neighbor classifier mixed in: Figure 7.5: The decision boundaries for the different classifiers Before we tune the individual classifier’s parameters for ensemble classification, let’s call the get_ params method to get a basic idea of how we can access the individual parameters inside a GridSearchCV object: >>> mv_clf.get_params() {'decisiontreeclassifier': DecisionTreeClassifier(class_weight=None, criterion='entropy', max_depth=1, max_features=None, max_leaf_nodes=None, min_samples_leaf=1, min_samples_split=2, min_weight_fraction_leaf=0.0, random_state=0, splitter='best'), 'decisiontreeclassifier__class_weight': None, 'decisiontreeclassifier__criterion': 'entropy', [...] 'decisiontreeclassifier__random_state': 0, 'decisiontreeclassifier__splitter': 'best', 'pipeline-1': Pipeline(steps=[('sc', StandardScaler(copy=True, with_mean=True, with_std=True)), ('clf', LogisticRegression(C=0.001, Chapter 7 221 class_weight=None, dual=False, fit_intercept=True, intercept_scaling=1, max_iter=100, multi_class='ovr', penalty='l2', random_state=0, solver='liblinear', tol=0.0001, verbose=0))]), 'pipeline-1__clf': LogisticRegression(C=0.001, class_weight=None, dual=False, fit_intercept=True, intercept_scaling=1, max_iter=100, multi_class='ovr', penalty='l2', random_state=0, solver='liblinear', tol=0.0001, verbose=0), 'pipeline-1__clf__C': 0.001, 'pipeline-1__clf__class_weight': None, 'pipeline-1__clf__dual': False, [...] 'pipeline-1__sc__with_std': True, 'pipeline-2': Pipeline(steps=[('sc', StandardScaler(copy=True, with_mean=True, with_std=True)), ('clf', KNeighborsClassifier(algorithm='auto', leaf_size=30, metric='minkowski', metric_params=None, n_neighbors=1, p=2, weights='uniform'))]), 'pipeline-2__clf': KNeighborsClassifier(algorithm='auto', leaf_size=30, metric='minkowski', metric_params=None, n_neighbors=1, p=2, weights='uniform'), 'pipeline-2__clf__algorithm': 'auto', [...] 'pipeline-2__sc__with_std': True} Combining Different Models for Ensemble Learning 222 Based on the values returned by the get_params method, we now know how to access the individual classifier’s attributes. Let’s now tune the inverse regularization parameter, C, of the logistic regression classifier and the decision tree depth via a grid search for demonstration purposes: >>> from sklearn.model_selection import GridSearchCV >>> params = { 'decisiontreeclassifier__max_depth' : [1, 2], ... 'pipeline-1__clf__C' : [0.001, 0.1, 100.0]} >>> grid = GridSearchCV(estimator=mv_clf, ... param_grid=params, ... cv= 10, ... scoring= 'roc_auc' ) >>> grid.fit(X_train, y_train) After the grid search has completed, we can print the different hyperparameter value combinations and the average ROC AUC scores computed via 10-fold cross-validation as follows: >>> for r, _ in enumerate (grid.cv_results_[ 'mean_test_score' ]): ... mean_score = grid.cv_results_[ 'mean_test_score' ][r] ... std_dev = grid.cv_results_[ 'std_test_score' ][r] ...", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 205, "start_word": 65600, "end_word": 66000, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000206": {"text": "import GridSearchCV >>> params = { 'decisiontreeclassifier__max_depth' : [1, 2], ... 'pipeline-1__clf__C' : [0.001, 0.1, 100.0]} >>> grid = GridSearchCV(estimator=mv_clf, ... param_grid=params, ... cv= 10, ... scoring= 'roc_auc' ) >>> grid.fit(X_train, y_train) After the grid search has completed, we can print the different hyperparameter value combinations and the average ROC AUC scores computed via 10-fold cross-validation as follows: >>> for r, _ in enumerate (grid.cv_results_[ 'mean_test_score' ]): ... mean_score = grid.cv_results_[ 'mean_test_score' ][r] ... std_dev = grid.cv_results_[ 'std_test_score' ][r] ... params = grid.cv_results_[ 'params' ][r] ... print(f'{mean_score: .3f} +/- {std_dev: .2f} {params} ') 0.983 +/- 0.05 {'decisiontreeclassifier__max_depth': 1, 'pipeline-1__clf__C': 0.001} 0.983 +/- 0.05 {'decisiontreeclassifier__max_depth': 1, 'pipeline-1__clf__C': 0.1} 0.967 +/- 0.10 {'decisiontreeclassifier__max_depth': 1, 'pipeline-1__clf__C': 100.0} 0.983 +/- 0.05 {'decisiontreeclassifier__max_depth': 2, 'pipeline-1__clf__C': 0.001} 0.983 +/- 0.05 {'decisiontreeclassifier__max_depth': 2, 'pipeline-1__clf__C': 0.1} 0.967 +/- 0.10 {'decisiontreeclassifier__max_depth': 2, 'pipeline-1__clf__C': 100.0} >>> print(f'Best parameters: {grid.best_params_} ') Best parameters: {'decisiontreeclassifier__max_depth': 1, 'pipeline-1__clf__C': 0.001} >>> print(f'ROC AUC : {grid.best_score_: .2f}') ROC AUC: 0.98 Chapter 7 223 As you can see, we get the best cross-validation results when we choose a lower regularization strength (C=0.001 ), whereas the tree depth does not seem to affect the performance at all, suggesting that a decision stump is sufficient to separate the data. To remind ourselves that it is a bad practice to use the test dataset more than once for model evaluation, we are not going to estimate the generalization performance of the tuned hyperparameters in this section. We will move on swiftly to an alternative approach for ensemble learning: bagging. Bagging – building an ensemble of classifiers from bootstrap samples Bagging is an ensemble learning technique that is closely related to the MajorityVoteClassifier that we implemented in the previous section. However, instead of using the same training dataset to fit the individual classifiers in the ensemble, we draw bootstrap samples (random samples with replacement) from the initial training dataset, which is why bagging is also known as bootstrap aggregating.Building ensembles using stacking The majority vote approach we implemented in this section is not to be confused with stacking. The stacking algorithm can be understood as a two-level ensemble, where the first level consists of individual classifiers that feed their predictions to the second lev - el, where another classifier (typically logistic regression) is fit to the level-one classifier predictions to make the final predictions. For more information on stacking, see the following resources: • The stacking algorithm has been described", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 206, "start_word": 65920, "end_word": 66320, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000207": {"text": "using stacking The majority vote approach we implemented in this section is not to be confused with stacking. The stacking algorithm can be understood as a two-level ensemble, where the first level consists of individual classifiers that feed their predictions to the second lev - el, where another classifier (typically logistic regression) is fit to the level-one classifier predictions to make the final predictions. For more information on stacking, see the following resources: • The stacking algorithm has been described in more detail by David H. Wolp - ert in Stacked generalization , Neural Networks , 5(2):241–259, 1992 ( https://www. sciencedirect.com/science/article/pii/S0893608005800231 ). • Interested readers can find our video tutorial about stacking on YouTube at https://www.youtube.com/watch?v=8T2emza6g80 . • A scikit-learn compatible version of a stacking classifier is available from mlxtend: http://rasbt.github.io/mlxtend/user_guide/classifier/ StackingCVClassifier/ . • Also, a StackingClassifier has recently been added to scikit-learn (available in version 0.22 and newer); for more information, please see the documentation at https://scikit-learn.org/stable/modules/generated/sklearn.ensemble. StackingClassifier.html . Combining Different Models for Ensemble Learning 224 The concept of bagging is summarized in Figure 7.6: Figure 7.6: The concept of bagging In the following subsections, we will work through a simple example of bagging by hand and use scikit-learn for classifying wine examples. Bagging in a nutshell To provide a more concrete example of how the bootstrap aggregating of a bagging classifier works, let’s consider the example shown in Figure 7.7. Here, we have seven different training instances (de - noted as indices 1-7) that are sampled randomly with replacement in each round of bagging. Each bootstrap sample is then used to fit a classifier, C j, which is most typically an unpruned decision tree: Figure 7.7: An example of bagging Chapter 7 225 As you can see from Figure 7.7, each classifier receives a random subset of examples from the training dataset. We denote these random samples obtained via bagging as Bagging round 1, Bagging round 2, and so on. Each subset contains a certain portion of duplicates and some of the original examples don’t appear in a resampled dataset at all due to sampling with replacement. Once the individual classifiers are fit to the bootstrap samples, the predictions are combined using majority voting. Note that bagging is also related to the random forest classifier that we introduced in Chapter 3. In fact, random forests are a special case of bagging where we also use random feature subsets", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 207, "start_word": 66240, "end_word": 66640, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000208": {"text": "so on. Each subset contains a certain portion of duplicates and some of the original examples don’t appear in a resampled dataset at all due to sampling with replacement. Once the individual classifiers are fit to the bootstrap samples, the predictions are combined using majority voting. Note that bagging is also related to the random forest classifier that we introduced in Chapter 3. In fact, random forests are a special case of bagging where we also use random feature subsets when fitting the individual decision trees. Applying bagging to classify examples in the Wine dataset To see bagging in action, let’s create a more complex classification problem using the Wine dataset that was introduced in Chapter 4, Building Good Training Datasets – Data Preprocessing. Here, we will only consider the Wine classes 2 and 3, and we will select two features – Alcohol and OD280/OD315 of diluted wines : >>> import pandas as pd >>> df_wine = pd.read_csv( 'https://archive.ics.uci.edu/ml/' ... 'machine-learning-databases/' ... 'wine/wine.data' , ... header= None) >>> df_wine.columns = [ 'Class label' , 'Alcohol' , ... 'Malic acid' , 'Ash', ... 'Alcalinity of ash' , ... 'Magnesium' , 'Total phenols' , ... 'Flavanoids' , 'Nonflavanoid phenols' , ... 'Proanthocyanins' , ... 'Color intensity' , 'Hue', ... 'OD280/OD315 of diluted wines' , ... 'Proline' ] >>> # drop 1 class >>> df_wine = df_wine[df_wine[ 'Class label' ] != 1] >>> y = df_wine[ 'Class label' ].values >>> X = df_wine[[ 'Alcohol' , ... 'OD280/OD315 of diluted wines' ]].valuesModel ensembles using bagging Bagging was first proposed by Leo Breiman in a technical report in 1994; he also showed that bagging can improve the accuracy of unstable models and decrease the degree of overfitting. We highly recommend that you read about his research in Bagging predictors by L. Breiman, Machine Learning, 24(2):123–140, 1996, which is freely available online, to learn more details about bagging. Combining Different Models for Ensemble Learning 226 Next, we will encode the class labels into binary format and split the dataset into 80 percent training and 20 percent test datasets: >>> from sklearn.preprocessing import LabelEncoder >>> from sklearn.model_selection import train_test_split >>> le = LabelEncoder() >>> y = le.fit_transform(y) >>> X_train, X_test, y_train, y_test =\\ ... train_test_split(X, y, ... test_size= 0.2, ... random_state= 1, ... stratify=y) A BaggingClassifier algorithm is already implemented in scikit-learn, which we can import from the ensemble submodule. Here, we will use an unpruned decision", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 208, "start_word": 66560, "end_word": 66960, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000209": {"text": "we will encode the class labels into binary format and split the dataset into 80 percent training and 20 percent test datasets: >>> from sklearn.preprocessing import LabelEncoder >>> from sklearn.model_selection import train_test_split >>> le = LabelEncoder() >>> y = le.fit_transform(y) >>> X_train, X_test, y_train, y_test =\\ ... train_test_split(X, y, ... test_size= 0.2, ... random_state= 1, ... stratify=y) A BaggingClassifier algorithm is already implemented in scikit-learn, which we can import from the ensemble submodule. Here, we will use an unpruned decision tree as the base classifier and create an ensemble of 500 decision trees fit on different bootstrap samples of the training dataset: >>> from sklearn.ensemble import BaggingClassifier >>> tree = DecisionTreeClassifier(criterion= 'entropy' , ... random_state= 1, ... max_depth= None) >>> bag = BaggingClassifier(base_estimator=tree, ... n_estimators= 500, ... max_samples= 1.0, ... max_features= 1.0, ... bootstrap= True,Obtaining the Wine dataset You can find a copy of the Wine dataset (and all other datasets used in this book) in the code bundle of this book, which you can use if you are working offline or the UCI server at https://archive.ics.uci.edu/ml/machine-learning-databases/wine/wine.data is temporarily unavailable. For instance, to load the Wine dataset from a local directory, take the following lines: df = pd.read_csv( 'https://archive.ics.uci.edu/ml/' 'machine-learning-databases' '/wine/wine.data' , header= None) and replace them with these: df = pd.read_csv( 'your/local/path/to/wine.data' , header= None) Chapter 7 227 ... bootstrap_features= False, ... n_jobs= 1, ... random_state= 1) Next, we will calculate the accuracy score of the prediction on the training and test datasets to com- pare the performance of the bagging classifier to the performance of a single unpruned decision tree: >>> from sklearn.metrics import accuracy_score >>> tree = tree.fit(X_train, y_train) >>> y_train_pred = tree.predict(X_train) >>> y_test_pred = tree.predict(X_test) >>> tree_train = accuracy_score(y_train, y_train_pred) >>> tree_test = accuracy_score(y_test, y_test_pred) >>> print(f'Decision tree train/test accuracies ' ... f'{tree_train: .3f}/{tree_test: .3f}') Decision tree train/test accuracies 1.000/0.833 Based on the accuracy values that we printed here, the unpruned decision tree predicts all the class labels of the training examples correctly; however, the substantially lower test accuracy indicates high variance (overfitting) of the model: >>> bag = bag.fit(X_train, y_train) >>> y_train_pred = bag.predict(X_train) >>> y_test_pred = bag.predict(X_test) >>> bag_train = accuracy_score(y_train, y_train_pred) >>> bag_test = accuracy_score(y_test, y_test_pred) >>> print(f'Bagging train/test accuracies ' ... f'{bag_train: .3f}/{bag_test: .3f}') Bagging train/test accuracies 1.000/0.917 Although the training accuracies of the decision tree and bagging classifier are similar on the training dataset (both 100 percent), we can see", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 209, "start_word": 66880, "end_word": 67280, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000210": {"text": "the class labels of the training examples correctly; however, the substantially lower test accuracy indicates high variance (overfitting) of the model: >>> bag = bag.fit(X_train, y_train) >>> y_train_pred = bag.predict(X_train) >>> y_test_pred = bag.predict(X_test) >>> bag_train = accuracy_score(y_train, y_train_pred) >>> bag_test = accuracy_score(y_test, y_test_pred) >>> print(f'Bagging train/test accuracies ' ... f'{bag_train: .3f}/{bag_test: .3f}') Bagging train/test accuracies 1.000/0.917 Although the training accuracies of the decision tree and bagging classifier are similar on the training dataset (both 100 percent), we can see that the bagging classifier has a slightly better generalization performance, as estimated on the test dataset. Next, let’s compare the decision regions between the decision tree and the bagging classifier: >>> x_min = X_train[:, 0].min() - 1 >>> x_max = X_train[:, 0].max() + 1 >>> y_min = X_train[:, 1].min() - 1 >>> y_max = X_train[:, 1].max() + 1 >>> xx, yy = np.meshgrid(np.arange(x_min, x_max, 0.1), ... np.arange(y_min, y_max, 0.1)) >>> f, axarr = plt.subplots(nrows= 1, ncols= 2, ... sharex= 'col', ... sharey= 'row', Combining Different Models for Ensemble Learning 228 ... figsize=( 8, 3)) >>> for idx, clf, tt in zip([0, 1], ... [tree, bag], ... [ 'Decision tree' , 'Bagging' ]): ... clf.fit(X_train, y_train) ... ... Z = clf.predict(np.c_[xx.ravel(), yy.ravel()]) ... Z = Z.reshape(xx.shape) ... axarr[idx].contourf(xx, yy, Z, alpha= 0.3) ... axarr[idx].scatter(X_train[y_train== 0, 0], ... X_train[y_train== 0, 1], ... c= 'blue', marker= '^') ... axarr[idx].scatter(X_train[y_train== 1, 0], ... X_train[y_train== 1, 1], ... c= 'green', marker= 'o') ... axarr[idx].set_title(tt) >>> axarr[0].set_ylabel( 'Alcohol' , fontsize= 12) >>> plt.tight_layout() >>> plt.text( 0, -0.2, ... s= 'OD280/OD315 of diluted wines' , ... ha= 'center' , ... va= 'center' , ... fontsize= 12, ... transform=axarr[ 1].transAxes) >>> plt.show() As we can see in the resulting plot, the piece-wise linear decision boundary of the three-node deep decision tree looks smoother in the bagging ensemble: Figure 7.8: The piece-wise linear decision boundary of a decision tree versus bagging Chapter 7 229 We only looked at a very simple bagging example in this section. In practice, more complex classifi- cation tasks and a dataset’s high dimensionality can easily lead to overfitting in single decision trees, and this is where the bagging algorithm can really play to its strengths. Finally, we must note that the bagging algorithm can be an effective approach to reducing the variance of a model. However, bagging is ineffective in reducing model bias, that is, models that are too simple to capture the trends", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 210, "start_word": 67200, "end_word": 67600, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000211": {"text": "very simple bagging example in this section. In practice, more complex classifi- cation tasks and a dataset’s high dimensionality can easily lead to overfitting in single decision trees, and this is where the bagging algorithm can really play to its strengths. Finally, we must note that the bagging algorithm can be an effective approach to reducing the variance of a model. However, bagging is ineffective in reducing model bias, that is, models that are too simple to capture the trends in the data well. This is why we want to perform bagging on an ensemble of classifiers with low bias, for example, unpruned decision trees. Leveraging weak learners via adaptive boosting In this last section about ensemble methods, we will discuss boosting , with a special focus on its most common implementation: Adaptive Boosting (AdaBoost). In boosting, the ensemble consists of very simple base classifiers, also often referred to as weak learners, which often only have a slight performance advantage over random guessing—a typical example of a weak learner is a decision tree stump. The key concept behind boosting is to focus on training examples that are hard to classify, that is, to let the weak learners subsequently learn from misclassified training examples to improve the performance of the ensemble. The following subsections will introduce the algorithmic procedure behind the general concept of boosting and AdaBoost. Lastly, we will use scikit-learn for a practical classification example. How adaptive boosting works In contrast to bagging, the initial formulation of the boosting algorithm uses random subsets of train- ing examples drawn from the training dataset without replacement; the original boosting procedure can be summarized in the following four key steps: 1. Draw a random subset (sample) of training examples, d 1, without replacement from the training dataset, D, to train a weak learner, C 1. 2. Draw a second random training subset, d 2, without replacement from the training dataset and add 50 percent of the examples that were previously misclassified to train a weak learner, C 2.AdaBoost recognition The original idea behind AdaBoost was formulated by Robert E. Schapire in 1990 in The Strength of Weak Learnability, Machine Learning, 5(2): 197-227, 1990, URL: http://rob. schapire.net/papers/strengthofweak.pdf . After Robert Schapire and Yoav Freund presented the AdaBoost algorithm in the Proceedings of the Thirteenth International Confer- ence (ICML 1996), AdaBoost became one of the most widely used ensemble methods in the years that", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 211, "start_word": 67520, "end_word": 67920, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000212": {"text": "50 percent of the examples that were previously misclassified to train a weak learner, C 2.AdaBoost recognition The original idea behind AdaBoost was formulated by Robert E. Schapire in 1990 in The Strength of Weak Learnability, Machine Learning, 5(2): 197-227, 1990, URL: http://rob. schapire.net/papers/strengthofweak.pdf . After Robert Schapire and Yoav Freund presented the AdaBoost algorithm in the Proceedings of the Thirteenth International Confer- ence (ICML 1996), AdaBoost became one of the most widely used ensemble methods in the years that followed (Experiments with a New Boosting Algorithm by Y. Freund, R. E. Schapire, and others, ICML, volume 96, 148-156, 1996). In 2003, Freund and Schapire received the Gödel Prize for their groundbreaking work, which is a prestigious prize for the most out- standing publications in the field of computer science. Combining Different Models for Ensemble Learning 230 3. Find the training examples, d 3, in the training dataset, D, which C 1 and C 2 disagree upon, to train a third weak learner, C 3. 4. Combine the weak learners C 1, C 2, and C 3 via majority voting. As discussed by Leo Breiman (Bias, variance, and arcing classifiers, 1996), boosting can lead to a decrease in bias as well as variance compared to bagging models. In practice, however, boosting algorithms such as AdaBoost are also known for their high variance, that is, the tendency to overfit the training data (An improvement of AdaBoost to avoid overfitting by G. Raetsch, T. Onoda, and K. R. Mueller. Proceedings of the International Conference on Neural Information Processing, CiteSeer, 1998). In contrast to the original boosting procedure described here, AdaBoost uses the complete training dataset to train the weak learners, where the training examples are reweighted in each iteration to build a strong classifier that learns from the mistakes of the previous weak learners in the ensemble. Before we dive deeper into the specific details of the AdaBoost algorithm, let’s take a look at Figure 7.9 to get a better grasp of the basic concept behind AdaBoost: Figure 7.9: The concept of AdaBoost to improve weak learners To walk through the AdaBoost illustration step by step, we will start with subfigure 1, which represents a training dataset for binary classification where all training examples are assigned equal weights. Based on this training dataset, we train a decision stump (shown as a dashed line) that tries to classify the examples of the two", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 212, "start_word": 67840, "end_word": 68240, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000213": {"text": "look at Figure 7.9 to get a better grasp of the basic concept behind AdaBoost: Figure 7.9: The concept of AdaBoost to improve weak learners To walk through the AdaBoost illustration step by step, we will start with subfigure 1, which represents a training dataset for binary classification where all training examples are assigned equal weights. Based on this training dataset, we train a decision stump (shown as a dashed line) that tries to classify the examples of the two classes (triangles and circles), as well as possibly minimizing the loss function (or the impurity score in the special case of decision tree ensembles). For the next round (subfigure 2 ), we assign a larger weight to the two previously misclassified examples (circles). Furthermore, we lower the weight of the correctly classified examples. The next decision stump will now be more focused on the training examples that have the largest weights—the training examples that are supposedly hard to classify. Chapter 7 231 The weak learner shown in subfigure 2 misclassifies three different examples from the circle class, which are then assigned a larger weight, as shown in subfigure 3. Assuming that our AdaBoost ensemble only consists of three rounds of boosting, we then combine the three weak learners trained on different reweighted training subsets by a weighted majority vote, as shown in subfigure 4. Now that we have a better understanding of the basic concept of AdaBoost, let’s take a more detailed look at the algorithm using pseudo code. For clarity, we will denote element-wise multiplication by the cross symbol (×) and the dot-product between two vectors by a dot symbol (⋅): 1. Set the weight vector, w, to uniform weights, where ∑𝑤𝑤𝑖𝑖𝑖𝑖=1 . 2. For j in m boosting rounds, do the following: a. Train a weighted weak learner: C j = train(X, y, w). b. Predict class labels: 𝒚𝒚̂= predict(𝐶𝐶 𝑗𝑗,𝑿𝑿𝑿 . c. Compute the weighted error rate: 𝜀𝜀𝜀𝜀𝜀𝜀(𝒚𝒚̂≠𝒚𝒚) . d. Compute the coefficient: 𝛼𝛼𝑗𝑗= 0.5log1−𝜀𝜀 𝜀𝜀 . e. Update the weights: 𝒘𝒘 𝒘 𝒘𝒘𝒘𝒘𝒘𝒘𝒘𝒘𝒘𝒘 𝑗𝑗𝒘𝒚𝒚̂𝒘𝒚𝒚𝒚 . f. Normalize the weights to sum to 1: 𝒘𝒘𝒘𝒘𝒘∑𝑤𝑤𝑖𝑖𝑖𝑖⁄ . 3. Compute the final prediction: 𝒚𝒚̂=(∑(𝛼𝛼𝑗𝑗×predict(𝐶𝐶 𝑗𝑗,𝑿𝑿𝑿𝑿 𝑿 𝑿𝑚𝑚 𝑗𝑗𝑗𝑗 𝑿 . Note that the expression (𝒚𝒚̂≠𝒚𝒚) in step 2c refers to a binary vector consisting of 1s and 0s, where a 1 is assigned if the prediction is incorrect and 0 is assigned otherwise. Although the AdaBoost algorithm seems to", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 213, "start_word": 68160, "end_word": 68560, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000214": {"text": "𝜀𝜀𝜀𝜀𝜀𝜀(𝒚𝒚̂≠𝒚𝒚) . d. Compute the coefficient: 𝛼𝛼𝑗𝑗= 0.5log1−𝜀𝜀 𝜀𝜀 . e. Update the weights: 𝒘𝒘 𝒘 𝒘𝒘𝒘𝒘𝒘𝒘𝒘𝒘𝒘𝒘 𝑗𝑗𝒘𝒚𝒚̂𝒘𝒚𝒚𝒚 . f. Normalize the weights to sum to 1: 𝒘𝒘𝒘𝒘𝒘∑𝑤𝑤𝑖𝑖𝑖𝑖⁄ . 3. Compute the final prediction: 𝒚𝒚̂=(∑(𝛼𝛼𝑗𝑗×predict(𝐶𝐶 𝑗𝑗,𝑿𝑿𝑿𝑿 𝑿 𝑿𝑚𝑚 𝑗𝑗𝑗𝑗 𝑿 . Note that the expression (𝒚𝒚̂≠𝒚𝒚) in step 2c refers to a binary vector consisting of 1s and 0s, where a 1 is assigned if the prediction is incorrect and 0 is assigned otherwise. Although the AdaBoost algorithm seems to be pretty straightforward, let’s walk through a more con- crete example using a training dataset consisting of 10 training examples, as illustrated in Figure 7.10: Figure 7.10: Running 10 training examples through the AdaBoost algorithm Combining Different Models for Ensemble Learning 232 The first column of the table depicts the indices of training examples 1 to 10. In the second column, you can see the feature values of the individual samples, assuming this is a one-dimensional dataset. The third column shows the true class label, yi, for each training sample, xi, where 𝑦𝑦𝑖𝑖∈{1,−1} . The initial weights are shown in the fourth column; we initialize the weights uniformly (assigning the same constant value) and normalize them to sum to 1. In the case of the 10-sample training dataset, we therefore assign 0.1 to each weight, wi, in the weight vector, w. The predicted class labels, 𝒚𝒚̂ , are shown in the fifth column, assuming that our splitting criterion is 𝑥𝑥 𝑥 𝑥𝑥𝑥 . The last column of the table then shows the updated weights based on the update rules that we defined in the pseudo code. Since the computation of the weight updates may look a little bit complicated at first, we will now follow the calculation step by step. We will start by computing the weighted error rate, 𝜀𝜀 (epsilon ), as described in step 2c: >>> y = np.array([ 1, 1, 1, - 1, -1, -1, 1, 1, 1, -1]) >>> yhat = np.array([ 1, 1, 1, - 1, -1, -1, -1, -1, -1, -1]) >>> correct = (y == yhat) >>> weights = np.full( 10, 0.1) >>> print(weights) [0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1] >>> epsilon = np.mean(~correct) >>> print(epsilon) 0.3 Note that correct is a Boolean array consisting of True and False values where True indicates that a prediction is correct. Via ~correct , we invert the array such that np.mean(~correct) computes", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 214, "start_word": 68480, "end_word": 68880, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000215": {"text": "1, -1]) >>> yhat = np.array([ 1, 1, 1, - 1, -1, -1, -1, -1, -1, -1]) >>> correct = (y == yhat) >>> weights = np.full( 10, 0.1) >>> print(weights) [0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1] >>> epsilon = np.mean(~correct) >>> print(epsilon) 0.3 Note that correct is a Boolean array consisting of True and False values where True indicates that a prediction is correct. Via ~correct , we invert the array such that np.mean(~correct) computes the proportion of incorrect predictions ( True counts as the value 1 and False as 0), that is, the classifica - tion error. Next, we will compute the coefficient, 𝛼𝛼𝑗𝑗 —shown in step 2d—which will later be used in step 2e to update the weights, as well as for the weights in the majority vote prediction (step 3): >>> alpha_j = 0.5 * np.log(( 1-epsilon) / epsilon) >>> print(alpha_j) 0.42364893019360184 After we have computed the coefficient, 𝛼𝛼𝑗𝑗 (alpha_j ), we can now update the weight vector using the following equation: 𝒘𝒘 𝒘 𝒘𝒘𝒘𝒘𝒘𝒘𝒘𝒘𝒘𝒘 𝑗𝑗𝒘𝒚𝒚̂𝒘𝒚𝒚𝒚 Here, 𝒚𝒚̂×𝒚𝒚 is an element-wise multiplication between the vectors of the predicted and true class labels, respectively. Thus, if a prediction, 𝑦𝑦𝑦𝑖𝑖 , is correct, 𝑦𝑦𝑦𝑖𝑖×𝑦𝑦𝑖𝑖 will have a positive sign so that we decrease the ith weight, since 𝛼𝛼𝑗𝑗 is a positive number as well: >>> update_if_correct = 0.1 * np.exp(-alpha_j * 1 * 1) >>> print(update_if_correct) 0.06546536707079771 Chapter 7 233 Similarly, we will increase the ith weight if 𝑦𝑦𝑦𝑖𝑖 predicted the label incorrectly, like this: >>> update_if_wrong_1 = 0.1 * np.exp(-alpha_j * 1 * -1) >>> print(update_if_wrong_1) 0.1527525231651947 Alternatively, it’s like this: >>> update_if_wrong_2 = 0.1 * np.exp(-alpha_j * 1 * -1) >>> print(update_if_wrong_2) We can use these values to update the weights as follows: >>> weights = np.where(correct == 1, ... update_if_correct, ... update_if_wrong_1) >>> print(weights) array([0.06546537, 0.06546537, 0.06546537, 0.06546537, 0.06546537, 0.06546537, 0.15275252, 0.15275252, 0.15275252, 0.06546537]) The code above assigned the update_if_correct value to all correct predictions and the update_if_ wrong_1 value to all wrong predictions. We omitted using update_if_wrong_2 for simplicity, since it is similar to update_if_wrong_1 anyway. After we have updated each weight in the weight vector, we normalize the weights so that they sum up to 1 (step 2f): 𝒘𝒘𝒘𝒘𝒘 ∑𝑤𝑤𝑖𝑖𝑖𝑖 In code, we can accomplish that as follows: >>> normalized_weights = weights / np. sum(weights) >>> print(normalized_weights) [0.07142857 0.07142857 0.07142857 0.07142857 0.07142857 0.07142857 0.16666667 0.16666667 0.16666667 0.07142857] Thus, each", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 215, "start_word": 68800, "end_word": 69200, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000216": {"text": "to all correct predictions and the update_if_ wrong_1 value to all wrong predictions. We omitted using update_if_wrong_2 for simplicity, since it is similar to update_if_wrong_1 anyway. After we have updated each weight in the weight vector, we normalize the weights so that they sum up to 1 (step 2f): 𝒘𝒘𝒘𝒘𝒘 ∑𝑤𝑤𝑖𝑖𝑖𝑖 In code, we can accomplish that as follows: >>> normalized_weights = weights / np. sum(weights) >>> print(normalized_weights) [0.07142857 0.07142857 0.07142857 0.07142857 0.07142857 0.07142857 0.16666667 0.16666667 0.16666667 0.07142857] Thus, each weight that corresponds to a correctly classified example will be reduced from the initial value of 0.1 to 0.0714 for the next round of boosting. Similarly, the weights of the incorrectly classified examples will increase from 0.1 to 0.1667. Applying AdaBoost using scikit-learn The previous subsection introduced AdaBoost in a nutshell. Skipping to the more practical part, let’s now train an AdaBoost ensemble classifier via scikit-learn. We will use the same Wine subset that we used in the previous section to train the bagging meta-classifier. Combining Different Models for Ensemble Learning 234 Via the base_estimator attribute, we will train the AdaBoostClassifier on 500 decision tree stumps: >>> from sklearn.ensemble import AdaBoostClassifier >>> tree = DecisionTreeClassifier(criterion= 'entropy' , ... random_state= 1, ... max_depth= 1) >>> ada = AdaBoostClassifier(base_estimator=tree, ... n_estimators= 500, ... learning_rate= 0.1, ... random_state= 1) >>> tree = tree.fit(X_train, y_train) >>> y_train_pred = tree.predict(X_train) >>> y_test_pred = tree.predict(X_test) >>> tree_train = accuracy_score(y_train, y_train_pred) >>> tree_test = accuracy_score(y_test, y_test_pred) >>> print(f'Decision tree train/test accuracies ' ... f'{tree_train: .3f}/{tree_test: .3f}') Decision tree train/test accuracies 0.916/0.875 As you can see, the decision tree stump seems to underfit the training data in contrast to the unpruned decision tree that we saw in the previous section: >>> ada = ada.fit(X_train, y_train) >>> y_train_pred = ada.predict(X_train) >>> y_test_pred = ada.predict(X_test) >>> ada_train = accuracy_score(y_train, y_train_pred) >>> ada_test = accuracy_score(y_test, y_test_pred) >>> print(f'AdaBoost train/test accuracies ' ... f'{ada_train: .3f}/{ada_test: .3f}') AdaBoost train/test accuracies 1.000/0.917 Here, you can see that the AdaBoost model predicts all class labels of the training dataset correctly and also shows a slightly improved test dataset performance compared to the decision tree stump. However, you can also see that we introduced additional variance with our attempt to reduce the model bias—a greater gap between training and test performance. Although we used another simple example for demonstration purposes, we can see that the perfor - mance of the AdaBoost classifier is slightly improved compared", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 216, "start_word": 69120, "end_word": 69520, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000217": {"text": "can see that the AdaBoost model predicts all class labels of the training dataset correctly and also shows a slightly improved test dataset performance compared to the decision tree stump. However, you can also see that we introduced additional variance with our attempt to reduce the model bias—a greater gap between training and test performance. Although we used another simple example for demonstration purposes, we can see that the perfor - mance of the AdaBoost classifier is slightly improved compared to the decision stump and achieved very similar accuracy scores as the bagging classifier that we trained in the previous section. However, we must note that it is considered bad practice to select a model based on the repeated usage of the test dataset. The estimate of the generalization performance may be overoptimistic, which we discussed in more detail in Chapter 6, Learning Best Practices for Model Evaluation and Hyperparameter Tuning. Chapter 7 235 Lastly, let’s check what the decision regions look like: >>> x_min = X_train[:, 0].min() - 1 >>> x_max = X_train[:, 0].max() + 1 >>> y_min = X_train[:, 1].min() - 1 >>> y_max = X_train[:, 1].max() + 1 >>> xx, yy = np.meshgrid(np.arange(x_min, x_max, 0.1), ... np.arange(y_min, y_max, 0.1)) >>> f, axarr = plt.subplots( 1, 2, ... sharex= 'col', ... sharey= 'row', ... figsize=( 8, 3)) >>> for idx, clf, tt in zip([0, 1], ... [tree, ada], ... [ 'Decision tree' , 'AdaBoost' ]): ... clf.fit(X_train, y_train) ... Z = clf.predict(np.c_[xx.ravel(), yy.ravel()]) ... Z = Z.reshape(xx.shape) ... axarr[idx].contourf(xx, yy, Z, alpha= 0.3) ... axarr[idx].scatter(X_train[y_train== 0, 0], ... X_train[y_train== 0, 1], ... c= 'blue', ... marker= '^') ... axarr[idx].scatter(X_train[y_train== 1, 0], ... X_train[y_train== 1, 1], ... c= 'green', ... marker= 'o') ... axarr[idx].set_title(tt) ... axarr[ 0].set_ylabel( 'Alcohol' , fontsize= 12) >>> plt.tight_layout() >>> plt.text( 0, -0.2, ... s= 'OD280/OD315 of diluted wines' , ... ha= 'center' , ... va= 'center' , ... fontsize= 12, ... transform=axarr[ 1].transAxes) >>> plt.show() Combining Different Models for Ensemble Learning 236 By looking at the decision regions, you can see that the decision boundary of the AdaBoost model is substantially more complex than the decision boundary of the decision stump. In addition, note that the AdaBoost model separates the feature space very similarly to the bagging classifier that we trained in the previous section: Figure 7.11: The decision boundaries of the decision tree versus AdaBoost As concluding remarks about ensemble techniques, it is", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 217, "start_word": 69440, "end_word": 69840, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000218": {"text": "plt.show() Combining Different Models for Ensemble Learning 236 By looking at the decision regions, you can see that the decision boundary of the AdaBoost model is substantially more complex than the decision boundary of the decision stump. In addition, note that the AdaBoost model separates the feature space very similarly to the bagging classifier that we trained in the previous section: Figure 7.11: The decision boundaries of the decision tree versus AdaBoost As concluding remarks about ensemble techniques, it is worth noting that ensemble learning increases the computational complexity compared to individual classifiers. In practice, we need to think care - fully about whether we want to pay the price of increased computational costs for an often relatively modest improvement in predictive performance. An often-cited example of this tradeoff is the famous $1 million Netflix Prize, which was won using ensemble techniques. The details about the algorithm were published in The BigChaos Solution to the Netflix Grand Prize by A. Toescher, M. Jahrer, and R. M. Bell, Netflix Prize documentation, 2009, which is available at http://www.stat.osu.edu/~dmsl/GrandPrize2009_BPC_BigChaos.pdf . The winning team received the $1 million grand prize money; however, Netflix never implemented their model due to its complexity, which made it infeasible for a real-world application: “We evaluated some of the new methods offline but the additional accuracy gains that we measured did not seem to justify the engineering effort needed to bring them into a production environment.” http://techblog.netflix.com/2012/04/netflix-recommendations-beyond-5- stars.html Chapter 7 237 Gradient boosting – training an ensemble based on loss gradients Gradient boosting is another variant of the boosting concept introduced in the previous section, that is, successively training weak learners to create a strong ensemble. Gradient boosting is an extremely important topic because it forms the basis of popular machine learning algorithms such as XGBoost, which is well-known for winning Kaggle competitions. The gradient boosting algorithm may appear a bit daunting at first. So, in the following subsections, we will cover it step by step, starting with a general overview. Then, we will see how gradient boosting is used for classification and walk through an example. Finally, after we’ve introduced the fundamental concepts of gradient boosting, we will take a brief look at popular implementations, such as XGBoost, and we will see how we can use gradient boosting in practice. Comparing AdaBoost with gradient boosting Fundamentally, gradient boosting is very similar to AdaBoost, which we discussed previously in", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 218, "start_word": 69760, "end_word": 70160, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000219": {"text": "we will cover it step by step, starting with a general overview. Then, we will see how gradient boosting is used for classification and walk through an example. Finally, after we’ve introduced the fundamental concepts of gradient boosting, we will take a brief look at popular implementations, such as XGBoost, and we will see how we can use gradient boosting in practice. Comparing AdaBoost with gradient boosting Fundamentally, gradient boosting is very similar to AdaBoost, which we discussed previously in this chapter. AdaBoost trains decision tree stumps based on errors of the previous decision tree stump. In particular, the errors are used to compute sample weights in each round as well as for computing a clas - sifier weight for each decision tree stump when combining the individual stumps into an ensemble. We stop training once a maximum number of iterations (decision tree stumps) is reached. Like AdaBoost, gradient boosting fits decision trees in an iterative fashion using prediction errors. However, gradient boosting trees are usually deeper than decision tree stumps and have typically a maximum depth of 3 to 6 (or a maximum number of 8 to 64 leaf nodes). Also, in contrast to AdaBoost, gradient boosting does not use the prediction errors for assigning sample weights; they are used directly to form the target variable for fitting the next tree. Moreover, instead of having an individual weighting term for each tree, like in AdaBoost, gradient boosting uses a global learning rate that is the same for each tree. As you can see, AdaBoost and gradient boosting share several similarities but differ in certain key as- pects. In the following subsection, we will sketch the general outline of the gradient boosting algorithm. Outlining the general gradient boosting algorithm In this section, we will look at gradient boosting for classification. For simplicity, we will look at a binary classification example. Interested readers can find the generalization to the multi-class setting with logistic loss in Section 4.6. Multiclass logistic regression and classification of the original gradient boosting paper written by Friedman in 2001, Greedy function approximation: A gradient boosting ma- chine, https://projecteuclid.org/journals/annals-of-statistics/volume-29/issue-5/Greedy- function-approximation-A-gradient-boostingmachine/10.1214/aos/1013203451.full . Combining Different Models for Ensemble Learning 238 In essence, gradient boosting builds a series of trees, where each tree is fit on the error—the difference between the label and the predicted value—of the previous tree. In each round, the tree ensemble improves as we are nudging each", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 219, "start_word": 70080, "end_word": 70480, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000220": {"text": "with logistic loss in Section 4.6. Multiclass logistic regression and classification of the original gradient boosting paper written by Friedman in 2001, Greedy function approximation: A gradient boosting ma- chine, https://projecteuclid.org/journals/annals-of-statistics/volume-29/issue-5/Greedy- function-approximation-A-gradient-boostingmachine/10.1214/aos/1013203451.full . Combining Different Models for Ensemble Learning 238 In essence, gradient boosting builds a series of trees, where each tree is fit on the error—the difference between the label and the predicted value—of the previous tree. In each round, the tree ensemble improves as we are nudging each tree more in the right direction via small updates. These updates are based on a loss gradient, which is how gradient boosting got its name. The following steps will introduce the general algorithm behind gradient boosting. After illustrating the main steps, we will dive into some of its parts in more detail and walk through a hands-on example in the next subsections. 1. Initialize a model to return a constant prediction value. For this, we use a decision tree root node; that is, a decision tree with a single leaf node. We denote the value returned by the tree as 𝑦𝑦𝑦 , and we find this value by minimizing a differentiable loss function L that we will define later: 𝐹𝐹0(𝑥𝑥)= arg min 𝑦𝑦̂∑𝐿𝐿 (𝑦𝑦𝑖𝑖, 𝑦𝑦̂)𝑛𝑛 𝑖𝑖𝑖𝑖 Here, n refers to the n training examples in our dataset. 2. For each tree m = 1, ..., M, where M is a user-specified total number of trees, we carry out the following computations outlined in steps 2a to 2d below: a. Compute the difference between a predicted value 𝐹𝐹(𝑥𝑥𝑖𝑖)= 𝑦𝑦𝑦𝑖𝑖 and the class label y i. This value is sometimes called the pseudo-response or pseudo-residual. More formally, we can write this pseudo-residual as the negative gradient of the loss function with respect to the predicted values: 𝑟𝑟𝑖𝑖𝑖𝑖= −[𝜕𝜕𝜕𝜕(𝑦𝑦𝑖𝑖,𝐹𝐹(𝑥𝑥𝑖𝑖)) 𝜕𝜕𝐹𝐹(𝑥𝑥𝑖𝑖)] 𝐹𝐹(𝑥𝑥)=𝐹𝐹𝑚𝑚𝑚𝑚 (𝑥𝑥) for 𝑖𝑖=𝑖,𝑖,𝑖𝑖 Note that in the notation above F(x) is the prediction of the previous tree, F m–1(x). So, in the first round, this refers to the constant value from the tree (single leaf node) from step 1. b. Fit a tree to the pseudo-residuals r im. We use the notation R jm to denote the j = 1 ... J m leaf nodes of the resulting tree in iteration m.Gradient boosting for regression Note that the procedure behind gradient boosting is a bit more complicated than AdaBoost. We omit a simpler regression example, which was given in Friedman’s paper, for", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 220, "start_word": 70400, "end_word": 70800, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000221": {"text": "first round, this refers to the constant value from the tree (single leaf node) from step 1. b. Fit a tree to the pseudo-residuals r im. We use the notation R jm to denote the j = 1 ... J m leaf nodes of the resulting tree in iteration m.Gradient boosting for regression Note that the procedure behind gradient boosting is a bit more complicated than AdaBoost. We omit a simpler regression example, which was given in Friedman’s paper, for brevity, but interested readers are encouraged to also consider my complementary video tutorial on gradient boosting for regression, which is available at: https://www.youtube.com/ watch?v=zblsrxc7XpM . Chapter 7 239 c. For each leaf node R jm, we compute the following output value: 𝛾𝛾𝑗𝑗𝑗𝑗= arg min 𝛾𝛾∑𝐿𝐿 (𝑦𝑦𝑖𝑖,𝐹𝐹𝑗𝑗𝑚𝑚(𝑥𝑥𝑖𝑖)+𝛾𝛾) 𝑥𝑥𝑖𝑖∈𝑅𝑅𝑗𝑗𝑗𝑗 In the next subsection, we will dive deeper into how this 𝛾𝛾𝑗𝑗𝑗𝑗 is computed by minimizing the loss function. At this point, we can already note that leaf nodes R jm may contain more than one training example, hence the summation. d. Update the model by adding the output values 𝛾𝛾𝑚𝑚 to the previous tree: 𝐹𝐹𝑚𝑚(𝑥𝑥)=𝐹𝐹𝑚𝑚𝑚𝑚(𝑥𝑥)+𝜂𝜂𝜂𝜂𝑚𝑚 However, instead of adding the full predicted values of the current tree 𝛾𝛾𝑚𝑚 to the previ- ous tree 𝐹𝐹𝑚𝑚𝑚𝑚 , we scale 𝛾𝛾𝑚𝑚 by a learning rate 𝜂𝜂 , which is typically a small value between 0.01 and 1. In other words, we update the model incrementally by taking small steps, which helps avoid overfitting. Now, after looking at the general structure of gradient boosting, we will adopt these mechanics to look at gradient boosting for classification. Explaining the gradient boosting algorithm for classification In this subsection, we will go over the details for implementing the gradient boosting algorithm for binary classification. In this context, we will be using the logistic loss function that we introduced for logistic regression in Chapter 3, A Tour of Machine Learning Classifiers Using Scikit-Learn. For a single training example, we can specify the logistic loss as follows: 𝐿𝐿𝑖𝑖= −𝑦𝑦𝑖𝑖log𝑝𝑝𝑖𝑖+(1−𝑦𝑦𝑖𝑖)log(1−𝑝𝑝𝑖𝑖) In Chapter 3, we also introduced the log(odds): 𝑦𝑦𝑦 𝑦 𝑦 𝑦 𝑦(𝑦dds)𝑦 𝑦𝑦𝑦(𝑝𝑝 1−𝑝𝑝) For reasons that will make sense later, we will use these log(odds) to rewrite the logistic function as follows (omitting intermediate steps here): 𝐿𝐿𝑖𝑖= log(1+𝑒𝑒𝑦𝑦̂𝑖𝑖)−𝑦𝑦𝑖𝑖𝑦𝑦̂𝑖𝑖 Now, we can define the partial derivative of the loss function with respect to these log(odds), 𝑦𝑦𝑦 . The derivative of this loss function with respect to the log(odds) is: 𝜕𝜕𝜕𝜕𝑖𝑖 𝜕𝜕", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 221, "start_word": 70720, "end_word": 71120, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000222": {"text": "specify the logistic loss as follows: 𝐿𝐿𝑖𝑖= −𝑦𝑦𝑖𝑖log𝑝𝑝𝑖𝑖+(1−𝑦𝑦𝑖𝑖)log(1−𝑝𝑝𝑖𝑖) In Chapter 3, we also introduced the log(odds): 𝑦𝑦𝑦 𝑦 𝑦 𝑦 𝑦(𝑦dds)𝑦 𝑦𝑦𝑦(𝑝𝑝 1−𝑝𝑝) For reasons that will make sense later, we will use these log(odds) to rewrite the logistic function as follows (omitting intermediate steps here): 𝐿𝐿𝑖𝑖= log(1+𝑒𝑒𝑦𝑦̂𝑖𝑖)−𝑦𝑦𝑖𝑖𝑦𝑦̂𝑖𝑖 Now, we can define the partial derivative of the loss function with respect to these log(odds), 𝑦𝑦𝑦 . The derivative of this loss function with respect to the log(odds) is: 𝜕𝜕𝜕𝜕𝑖𝑖 𝜕𝜕 𝜕𝜕𝜕𝑖𝑖=𝑒𝑒𝑦𝑦𝜕𝑖𝑖 1+𝑒𝑒𝑦𝑦𝜕𝑖𝑖−𝜕𝜕𝑖𝑖=𝑝𝑝𝑖𝑖−𝜕𝜕𝑖𝑖 Combining Different Models for Ensemble Learning 240 After specifying these mathematical definitions, let us now revisit the general gradient boosting steps 1 to 2d from the previous section and reformulate them for this binary classification scenario. 1. Create a root node that minimizes the logistic loss. It turns out that the loss is minimized if the root node returns the log(odds), 𝑦𝑦𝑦 . 2. For each tree m = 1, ..., M, where M is a user-specified number of total trees, we carry out the following computations outlined in steps 2a to 2d: a. We convert the log(odds) into a probability using the familiar logistic function that we used in logistic regression (in Chapter 3): 𝑝𝑝𝑝1 1+𝑒𝑒−𝑦𝑦̂ Then, we compute the pseudo-residual, which is the negative partial derivative of the loss with respect to the log(odds), which turns out to be the difference between the class label and the predicted probability: −𝜕𝜕𝜕𝜕𝑖𝑖 𝜕𝜕 𝜕𝜕𝜕𝑖𝑖=𝜕𝜕𝑖𝑖−𝑝𝑝𝑖𝑖 b. Fit a new tree to the pseudo-residuals. c. For each leaf node R jm, compute a value 𝛾𝛾𝑗𝑗𝑗𝑗 that minimizes the logistic loss function. This includes a summarization step for dealing with leaf nodes that contain multiple training examples: 𝛾𝛾𝑗𝑗𝑗𝑗= arg min 𝛾𝛾∑𝐿𝐿 (𝑦𝑦𝑖𝑖,𝐹𝐹𝑗𝑗𝑚𝑚(𝑥𝑥𝑖𝑖)+𝛾𝛾) 𝑥𝑥𝑖𝑖∈𝑅𝑅𝑗𝑗𝑗𝑗 = log(1 + 𝑒𝑒𝑦𝑦̂𝑖𝑖+𝛾𝛾)−𝑦𝑦 𝑖𝑖(𝑦𝑦̂𝑖𝑖+𝛾𝛾) Skipping over intermediate mathematical details, this results in the following: 𝛾𝛾𝑗𝑗𝑗𝑗=∑𝑦𝑦𝑖𝑖−𝑝𝑝𝑖𝑖𝑖𝑖 ∑𝑝𝑝𝑖𝑖(𝑖𝑖−𝑝𝑝𝑖𝑖)𝑖𝑖 Note that the summation here is only over the examples at the node corresponding to the leaf node R jm and not the complete training set. d. Update the model by adding the gamma value from step 2c with learning rate 𝜂𝜂 : 𝐹𝐹𝑚𝑚(𝑥𝑥)=𝐹𝐹𝑚𝑚𝑚𝑚(𝑥𝑥)+𝜂𝜂𝜂𝜂𝑚𝑚 Chapter 7 241 In this section, we adopted the general gradient boosting algorithm and specified it for binary classi- fication, for instance, by replacing the generic loss function with the logistic loss and the predicted values with the log(odds). However, many of the individual steps may still seem very abstract, and in the next section, we will", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 222, "start_word": 71040, "end_word": 71440, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000223": {"text": "not the complete training set. d. Update the model by adding the gamma value from step 2c with learning rate 𝜂𝜂 : 𝐹𝐹𝑚𝑚(𝑥𝑥)=𝐹𝐹𝑚𝑚𝑚𝑚(𝑥𝑥)+𝜂𝜂𝜂𝜂𝑚𝑚 Chapter 7 241 In this section, we adopted the general gradient boosting algorithm and specified it for binary classi- fication, for instance, by replacing the generic loss function with the logistic loss and the predicted values with the log(odds). However, many of the individual steps may still seem very abstract, and in the next section, we will apply these steps to a concrete example. Illustrating gradient boosting for classification The previous two subsections went over the condensed mathematical details of the gradient boosting algorithm for binary classification. To make these concepts clearer, let’s apply it to a small toy example, that is, a training dataset of the following three examples shown in Figure 7.12: Figure 7.12: Toy dataset for explaining gradient boosting Let’s start with step 1, constructing the root node and computing the log(odds), and step 2a, converting the log(odds) into class-membership probabilities and computing the pseudo-residuals. Note that based on what we have learned in Chapter 3, the odds can be computed as the number of successes divided by the number of failures. Here, we regard label 1 as success and label 0 as failure, so the odds are computed as: odds = 2/1. Carrying out steps 1 and 2a, we get the following results shown in Figure 7.13: Figure 7.13: Results from the first round of applying step 1 and step 2aOutputting log(odds) vs probabilities Why do the trees return log(odds) values and not probabilities? This is because we cannot just add up probability values and arrive at a meaningful result. (So, technically speaking, gradient boosting for classification uses regression trees.) Combining Different Models for Ensemble Learning 242 Next, in step 2b, we fit a new tree on the pseudo-residuals r. Then, in step 2c, we compute the output values, 𝛾𝛾 , for this tree as shown in Figure 7.14: Figure 7.14: An illustration of steps 2b and 2c, which fits a tree to the residuals and computes the output values for each leaf node (Note that we artificially limit the tree to have only two leaf nodes, which helps illustrate what happens if a leaf node contains more than one example.) Then, in the final step 2d, we update the previous model and the current model. Assuming a learning rate of 𝜂𝜂 𝜂", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 223, "start_word": 71360, "end_word": 71760, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000224": {"text": "tree as shown in Figure 7.14: Figure 7.14: An illustration of steps 2b and 2c, which fits a tree to the residuals and computes the output values for each leaf node (Note that we artificially limit the tree to have only two leaf nodes, which helps illustrate what happens if a leaf node contains more than one example.) Then, in the final step 2d, we update the previous model and the current model. Assuming a learning rate of 𝜂𝜂 𝜂 𝜂𝜂𝜂 , the resulting prediction for the first training example is shown in Figure 7.15: Figure 7.15: The update of the previous model shown in the context of the first training example Chapter 7 243 Now that we have completed steps 2a to 2d of the first round, m = 1, we can proceed to execute steps 2a to 2d for the second round, m = 2. In the second round, we use the log(odds) returned by the updated model, for example, 𝐹𝐹1(𝑥𝑥1)= 0.839 , as input to step 2A. The new values we obtain in the second round are shown in Figure 7.16: Figure 7.16: Values from the second round next to the values from the first round We can already see that the predicted probabilities are higher for the positive class and lower for the negative class. Consequently, the residuals are getting smaller, too. Note that the process of steps 2a to 2d is repeated until we have fit M trees or the residuals are smaller than a user-specified threshold value. Then, once the gradient boosting algorithm has completed, we can use it to predict the class labels by thresholding the probability values of the final model, FM(x) at 0.5, like logistic regression in Chapter 3. However, in contrast to logistic regression, gradient boosting consists of multiple trees and produces nonlinear decision boundaries. In the next section, we will look at how gradient boosting looks in action. Using XGBoost After covering the nitty-gritty details behind gradient boosting, let’s finally look at how we can use gradient boosting code implementations. In scikit-learn, gradient boosting is implemented as sklearn.ensemble.GradientBoostingClassifier (see https://scikit-learn.org/stable/modules/generated/sklearn.ensemble. GradientBoostingClassifier.html for more details). It is important to note that gradient boosting is a sequential process that can be slow to train. However, in recent years a more popular implemen- tation of gradient boosting has emerged, namely, XGBoost. XGBoost proposed several tricks and approximations that speed up the training", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 224, "start_word": 71680, "end_word": 72080, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000225": {"text": "XGBoost After covering the nitty-gritty details behind gradient boosting, let’s finally look at how we can use gradient boosting code implementations. In scikit-learn, gradient boosting is implemented as sklearn.ensemble.GradientBoostingClassifier (see https://scikit-learn.org/stable/modules/generated/sklearn.ensemble. GradientBoostingClassifier.html for more details). It is important to note that gradient boosting is a sequential process that can be slow to train. However, in recent years a more popular implemen- tation of gradient boosting has emerged, namely, XGBoost. XGBoost proposed several tricks and approximations that speed up the training process substantially. Hence, the name XGBoost, which stands for extreme gradient boosting. Moreover, these approxima - tions and tricks result in very good predictive performances. In fact, XGBoost gained popularity as it has been the winning solution for many Kaggle competitions. Next to XGBoost, there are also other popular implementations of gradient boosting, for ex - ample, LightGBM and CatBoost. Inspired by LightGBM, scikit-learn now also implements a HistGradientBoostingClassifier , which is more performant than the original gradient boosting classifier ( GradientBoostingClassifier ). Combining Different Models for Ensemble Learning 244 You can find more details about these methods via the resources below: • XGBoost : https://xgboost.readthedocs.io/en/stable/ • LightGBM : https://lightgbm.readthedocs.io/en/latest/ • CatBoost : https://catboost.ai • HistGradientBoostingClassifier : https://scikit-learn.org/stable/modules/generated/ sklearn.ensemble.HistGradientBoostingClassifier.html However, since XGBoost is still among the most popular gradient boosting implementations, we will see how we can use it in practice. First, we need to install it, for example via pip: pip install xgboost Fortunately, XGBoost’s XGBClassifier follows the scikit-learn API. So, using it is relatively straight- forward: >>> import xgboost as xgb >>> model = xgb.XGBClassifier(n_estimators= 1000, learning_rate= 0.01, ... max_depth= 4, random_state= 1, ... use_label_encoder= False) >>> gbm = model.fit(X_train, y_train) >>> y_train_pred = gbm.predict(X_train) >>> y_test_pred = gbm.predict(X_test) >>> gbm_train = accuracy_score(y_train, y_train_pred) >>> gbm_test = accuracy_score(y_test, y_test_pred) >>> print(f'XGboost train/test accuracies ' ... f'{gbm_train: .3f}/{gbm_test: .3f}') XGboost train/test accuracies 0.968/0.917 Here, we fit the gradient boosting classifier with 1,000 trees (rounds) and a learning rate of 0.01. Typi- cally, a learning rate between 0.01 and 0.1 is recommended. However, remember that the learning rate is used for scaling the predictions from the individual rounds. So, intuitively, the lower the learning rate, the more estimators are required to achieve accurate predictions. Installing XGBoost For this chapter, we used XGBoost version 1.5.0, which can be installed via: pip install XGBoost==1.5.0 You can find more information about the installation details at https://xgboost. readthedocs.io/en/stable/install.html Chapter 7 245 Next, we have", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 225, "start_word": 72000, "end_word": 72400, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000226": {"text": "0.01. Typi- cally, a learning rate between 0.01 and 0.1 is recommended. However, remember that the learning rate is used for scaling the predictions from the individual rounds. So, intuitively, the lower the learning rate, the more estimators are required to achieve accurate predictions. Installing XGBoost For this chapter, we used XGBoost version 1.5.0, which can be installed via: pip install XGBoost==1.5.0 You can find more information about the installation details at https://xgboost. readthedocs.io/en/stable/install.html Chapter 7 245 Next, we have the max_depth for the individual decision trees, which we set to 4. Since we are still boosting weak learners, a value between 2 and 6 is reasonable, but larger values may also work well depending on the dataset. Finally, use_label_encoder=False disables a warning message which informs users that XGBoost is not converting labels by default anymore, and it expects users to provide labels in an integer format starting with label 0. (There is nothing to worry about here, since we have been following this format throughout this book.) There are many more settings available, and a detailed discussion is out of the scope of this book. However, interested readers can find more details in the original documentation at https://xgboost. readthedocs.io/en/latest/python/python_api.html#xgboost.XGBClassifier . Summary In this chapter, we looked at some of the most popular and widely used techniques for ensemble learning. Ensemble methods combine different classification models to cancel out their individual weaknesses, which often results in stable and well-performing models that are very attractive for industrial applications as well as machine learning competitions. At the beginning of this chapter, we implemented MajorityVoteClassifier in Python, which allows us to combine different algorithms for classification. We then looked at bagging, a useful technique for reducing the variance of a model by drawing random bootstrap samples from the training dataset and combining the individually trained classifiers via majority vote. Lastly, we learned about boosting in the form of AdaBoost and gradient boosting, which are algorithms based on training weak learners that subsequently learn from mistakes. Throughout the previous chapters, we learned a lot about different learning algorithms, tuning, and evaluation techniques. In the next chapter, we will look at a particular application of machine learn- ing, sentiment analysis, which has become an interesting topic in the internet and social media era. Join our book’s Discord space Join the book’s Discord workspace for a monthly Ask me Anything session with the authors: https://packt.link/MLwPyTorch 8", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 226, "start_word": 72320, "end_word": 72720, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000227": {"text": "are algorithms based on training weak learners that subsequently learn from mistakes. Throughout the previous chapters, we learned a lot about different learning algorithms, tuning, and evaluation techniques. In the next chapter, we will look at a particular application of machine learn- ing, sentiment analysis, which has become an interesting topic in the internet and social media era. Join our book’s Discord space Join the book’s Discord workspace for a monthly Ask me Anything session with the authors: https://packt.link/MLwPyTorch 8 Applying Machine Learning to Sentiment Analysis In the modern internet and social media age, people’s opinions, reviews, and recommendations have become a valuable resource for political science and businesses. Thanks to modern technologies, we are now able to collect and analyze such data most efficiently. In this chapter, we will delve into a subfield of natural language processing ( NLP ) called sentiment analysis and learn how to use machine learning algorithms to classify documents based on their sentiment: the attitude of the writer. In particular, we are going to work with a dataset of 50,000 movie reviews from the Internet Movie Database (IMDb) and build a predictor that can distinguish between positive and negative reviews. The topics that we will cover in this chapter include the following: • Cleaning and preparing text data • Building feature vectors from text documents • Training a machine learning model to classify positive and negative movie reviews • Working with large text datasets using out-of-core learning • Inferring topics from document collections for categorization Preparing the IMDb movie review data for text processing As mentioned, sentiment analysis, sometimes also called opinion mining, is a popular subdiscipline of the broader field of NLP; it is concerned with analyzing the sentiment of documents. A popular task in sentiment analysis is the classification of documents based on the expressed opinions or emotions of the authors with regard to a particular topic. Applying Machine Learning to Sentiment Analysis 248 In this chapter, we will be working with a large dataset of movie reviews from IMDb that has been collected by Andrew Maas and others (Learning Word Vectors for Sentiment Analysis by A. L. Maas, R. E. Daly, P. T. Pham, D. Huang, A. Y. Ng, and C. Potts, Proceedings of the 49th Annual Meeting of the Association for Computational Linguistics: Human Language Technologies, pages 142–150, Portland, Oregon, USA, Association for Computational Linguistics, June 2011). The movie review", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 227, "start_word": 72640, "end_word": 73040, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000228": {"text": "Analysis 248 In this chapter, we will be working with a large dataset of movie reviews from IMDb that has been collected by Andrew Maas and others (Learning Word Vectors for Sentiment Analysis by A. L. Maas, R. E. Daly, P. T. Pham, D. Huang, A. Y. Ng, and C. Potts, Proceedings of the 49th Annual Meeting of the Association for Computational Linguistics: Human Language Technologies, pages 142–150, Portland, Oregon, USA, Association for Computational Linguistics, June 2011). The movie review dataset consists of 50,000 polar movie reviews that are labeled as either positive or negative; here, positive means that a movie was rated with more than six stars on IMDb, and negative means that a movie was rated with fewer than five stars on IMDb. In the following sections, we will download the dataset, preprocess it into a useable format for machine learning tools, and extract meaningful information from a subset of these movie reviews to build a machine learning model that can predict whether a certain reviewer liked or disliked a movie. Obtaining the movie review dataset A compressed archive of the movie review dataset (84.1 MB) can be downloaded from http:// ai.stanford.edu/~amaas/data/sentiment/ as a gzip-compressed tarball archive: • If you are working with Linux or macOS, you can open a new terminal window, cd into the download directory, and execute tar -zxf aclImdb_v1.tar.gz to decompress the dataset. • If you are working with Windows, you can download a free archiver, such as 7-Zip ( http:// www.7-zip.org ), to extract the files from the download archive. • Alternatively, you can unpack the gzip-compressed tarball archive directly in Python as follows: >>> import tarfile >>> with tarfile. open('aclImdb_v1.tar.gz' , 'r:gz' ) as tar: ... tar.extractall() Preprocessing the movie dataset into a more convenient format Having successfully extracted the dataset, we will now assemble the individual text documents from the decompressed download archive into a single CSV file. In the following code section, we will be reading the movie reviews into a pandas DataFrame object, which can take up to 10 minutes on a standard desktop computer. To visualize the progress and estimated time until completion, we will use the Python Progress Indica - tor (PyPrind , https://pypi.python.org/pypi/PyPrind/ ) package, which was developed several years ago for such purposes. PyPrind can be installed by executing the pip install pyprind command: >>> import pyprind >>> import pandas as pd >>> import os", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 228, "start_word": 72960, "end_word": 73360, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000229": {"text": "code section, we will be reading the movie reviews into a pandas DataFrame object, which can take up to 10 minutes on a standard desktop computer. To visualize the progress and estimated time until completion, we will use the Python Progress Indica - tor (PyPrind , https://pypi.python.org/pypi/PyPrind/ ) package, which was developed several years ago for such purposes. PyPrind can be installed by executing the pip install pyprind command: >>> import pyprind >>> import pandas as pd >>> import os >>> import sys >>> # change the 'basepath' to the directory of the >>> # unzipped movie dataset >>> basepath = 'aclImdb' Chapter 8 249 >>> >>> labels = { 'pos': 1, 'neg' : 0} >>> pbar = pyprind.ProgBar( 50000, stream=sys.stdout) >>> df = pd.DataFrame() >>> for s in ('test' , 'train' ): ... for l in ('pos' , 'neg'): ... path = os.path.join(basepath, s, l) ... for file in sorted (os.listdir(path)): ... with open(os.path.join(path, file), ... 'r', encoding= 'utf-8') as infile: ... txt = infile.read() ... df = df.append([[txt, labels[l]]], ... ignore_index= True) ... pbar.update() >>> df.columns = [ 'review' , 'sentiment' ] 0% 100% [##############################] | ETA: 00:00:00 Total time elapsed: 00:00:25 In the preceding code, we first initialized a new progress bar object, pbar , with 50,000 iterations, which was the number of documents we were going to read in. Using the nested for loops, we iterated over the train and test subdirectories in the main aclImdb directory and read the individual text files from the pos and neg subdirectories that we eventually appended to the df pandas DataFrame , together with an integer class label (1 = positive and 0 = negative). Since the class labels in the assembled dataset are sorted, we will now shuffle the DataFrame using the permutation function from the np.random submodule—this will be useful for splitting the dataset into training and test datasets in later sections, when we will stream the data from our local drive directly. For our own convenience, we will also store the assembled and shuffled movie review dataset as a CSV file: >>> import numpy as np >>> np.random.seed( 0) >>> df = df.reindex(np.random.permutation(df.index)) >>> df.to_csv( 'movie_data.csv' , index= False, encoding= 'utf-8') Since we are going to use this dataset later in this chapter, let’s quickly confirm that we have success- fully saved the data in the right format by reading in the CSV and printing an", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 229, "start_word": 73280, "end_word": 73680, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000230": {"text": "data from our local drive directly. For our own convenience, we will also store the assembled and shuffled movie review dataset as a CSV file: >>> import numpy as np >>> np.random.seed( 0) >>> df = df.reindex(np.random.permutation(df.index)) >>> df.to_csv( 'movie_data.csv' , index= False, encoding= 'utf-8') Since we are going to use this dataset later in this chapter, let’s quickly confirm that we have success- fully saved the data in the right format by reading in the CSV and printing an excerpt of the first three examples: >>> df = pd.read_csv( 'movie_data.csv' , encoding= 'utf-8') >>> # the following column renaming is necessary on some computers: >>> df = df.rename(columns={ \"0\": \"review\" , \"1\": \"sentiment\" }) >>> df.head( 3) Applying Machine Learning to Sentiment Analysis 250 If you are running the code examples in a Jupyter notebook, you should now see the first three exam- ples of the dataset, as shown in Figure 8.1: Figure 8.1: The first three rows of the movie review dataset As a sanity check, before we proceed to the next section, let’s make sure that the DataFrame contains all 50,000 rows: >>> df.shape (50000, 2) Introducing the bag-of-words model You may remember from Chapter 4, Building Good Training Datasets – Data Preprocessing, that we have to convert categorical data, such as text or words, into a numerical form before we can pass it on to a machine learning algorithm. In this section, we will introduce the bag-of-words model, which allows us to represent text as numerical feature vectors. The idea behind bag-of-words is quite simple and can be summarized as follows: 1. We create a vocabulary of unique tokens—for example, words—from the entire set of documents. 2. We construct a feature vector from each document that contains the counts of how often each word occurs in the particular document. Since the unique words in each document represent only a small subset of all the words in the bag-of- words vocabulary, the feature vectors will mostly consist of zeros, which is why we call them sparse . Do not worry if this sounds too abstract; in the following subsections, we will walk through the process of creating a simple bag-of-words model step by step. Transforming words into feature vectors To construct a bag-of-words model based on the word counts in the respective documents, we can use the CountVectorizer class implemented in scikit-learn. As you will see in", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 230, "start_word": 73600, "end_word": 74000, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000231": {"text": "the bag-of- words vocabulary, the feature vectors will mostly consist of zeros, which is why we call them sparse . Do not worry if this sounds too abstract; in the following subsections, we will walk through the process of creating a simple bag-of-words model step by step. Transforming words into feature vectors To construct a bag-of-words model based on the word counts in the respective documents, we can use the CountVectorizer class implemented in scikit-learn. As you will see in the following code section, CountVectorizer takes an array of text data, which can be documents or sentences, and constructs the bag-of-words model for us: >>> import numpy as np >>> from sklearn.feature_extraction.text import CountVectorizer >>> count = CountVectorizer() >>> docs = np.array([ 'The sun is shining' , Chapter 8 251 ... 'The weather is sweet' , ... 'The sun is shining, the weather is sweet,' ... 'and one and one is two' ]) >>> bag = count.fit_transform(docs) By calling the fit_transform method on CountVectorizer , we constructed the vocabulary of the bag-of-words model and transformed the following three sentences into sparse feature vectors: • 'The sun is shining' • 'The weather is sweet' • 'The sun is shining, the weather is sweet, and one and one is two' Now, let’s print the contents of the vocabulary to get a better understanding of the underlying concepts: >>> print(count.vocabulary_) {'and': 0, 'two': 7, 'shining': 3, 'one': 2, 'sun': 4, 'weather': 8, 'the': 6, 'sweet': 5, 'is': 1} As you can see from executing the preceding command, the vocabulary is stored in a Python dictionary that maps the unique words to integer indices. Next, let’s print the feature vectors that we just created: >>> print(bag.toarray()) [[0 1 0 1 1 0 1 0 0] [0 1 0 0 0 1 1 0 1] [2 3 2 1 1 1 2 1 1]] Each index position in the feature vectors shown here corresponds to the integer values that are stored as dictionary items in the CountVectorizer vocabulary. For example, the first feature at index position 0 resembles the count of the word 'and' , which only occurs in the last document, and the word 'is' , at index position 1 (the second feature in the document vectors), occurs in all three sentences. These values in the feature vectors are also called the raw term frequencies: tf(t, d)—the number of times a term, t, occurs", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 231, "start_word": 73920, "end_word": 74320, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000232": {"text": "the integer values that are stored as dictionary items in the CountVectorizer vocabulary. For example, the first feature at index position 0 resembles the count of the word 'and' , which only occurs in the last document, and the word 'is' , at index position 1 (the second feature in the document vectors), occurs in all three sentences. These values in the feature vectors are also called the raw term frequencies: tf(t, d)—the number of times a term, t, occurs in a document, d. It should be noted that, in the bag-of-words model, the word or term order in a sentence or document does not matter. The order in which the term frequencies appear in the feature vector is derived from the vocabulary indices, which are usually assigned alphabetically. Applying Machine Learning to Sentiment Analysis 252 Assessing word relevancy via term frequency-inverse document frequency When we are analyzing text data, we often encounter words that occur across multiple documents from both classes. These frequently occurring words typically don’t contain useful or discriminatory information. In this subsection, you will learn about a useful technique called the term frequency-in- verse document frequency ( tf-idf), which can be used to downweight these frequently occurring words in the feature vectors. The tf-idf can be defined as the product of the term frequency and the inverse document frequency: tf-idf(t, d) = tf (t, d) × idf(t, d) Here, tf(t, d) is the term frequency that we introduced in the previous section, and idf( t, d) is the inverse document frequency, which can be calculated as follows: 𝑖𝑖𝑖𝑖𝑖𝑖(𝑡𝑡𝑡𝑖𝑖)= log𝑛𝑛𝑑𝑑 1+𝑖𝑖𝑖𝑖(𝑖𝑖𝑡𝑡𝑡) Here, nd is the total number of documents, and df(d, t) is the number of documents, d, that contain the term t. Note that adding the constant 1 to the denominator is optional and serves the purpose of assigning a non-zero value to terms that occur in none of the training examples; the log is used to ensure that low document frequencies are not given too much weight.N-gram models The sequence of items in the bag-of-words model that we just created is also called the 1-gram or unigram model—each item or token in the vocabulary represents a single word. More generally, the contiguous sequences of items in NLP—words, letters, or symbols—are also called n-grams. The choice of the number, n, in the n-gram model depends on the particular application; for example, a study by Ioannis Kanaris", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 232, "start_word": 74240, "end_word": 74640, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000233": {"text": "to ensure that low document frequencies are not given too much weight.N-gram models The sequence of items in the bag-of-words model that we just created is also called the 1-gram or unigram model—each item or token in the vocabulary represents a single word. More generally, the contiguous sequences of items in NLP—words, letters, or symbols—are also called n-grams. The choice of the number, n, in the n-gram model depends on the particular application; for example, a study by Ioannis Kanaris and others revealed that n-grams of size 3 and 4 yield good performances in the anti-spam filtering of email mes- sages (Words versus character n-grams for anti-spam filtering by Ioannis Kanaris, Konstantinos Kanaris, Ioannis Houvardas, and Efstathios Stamatatos, International Journal on Artificial Intelligence Tools, World Scientific Publishing Company, 16(06): 1047-1067, 2007). To summarize the concept of the n-gram representation, the 1-gram and 2-gram repre - sentations of our first document, “the sun is shining”, would be constructed as follows: • 1-gram: “the”, “sun”, “is”, “shining” • 2-gram: “the sun”, “sun is”, “is shining” The CountVectorizer class in scikit-learn allows us to use different n-gram models via its ngram_range parameter. While a 1-gram representation is used by default, we could switch to a 2-gram representation by initializing a new CountVectorizer instance with ngram_range=(2,2) . Chapter 8 253 The scikit-learn library implements yet another transformer, the TfidfTransformer class, which takes the raw term frequencies from the CountVectorizer class as input and transforms them into tf-idfs: >>> from sklearn.feature_extraction.text import TfidfTransformer >>> tfidf = TfidfTransformer(use_idf= True, ... norm= 'l2', ... smooth_idf= True) >>> np.set_printoptions(precision= 2) >>> print(tfidf.fit_transform(count.fit_transform(docs)) ... .toarray()) [[ 0. 0.43 0. 0.56 0.56 0. 0.43 0. 0. ] [ 0. 0.43 0. 0. 0. 0.56 0.43 0. 0.56] [ 0.5 0.45 0.5 0.19 0.19 0.19 0.3 0.25 0.19]] As you saw in the previous subsection, the word 'is' had the largest term frequency in the third document, being the most frequently occurring word. However, after transforming the same feature vector into tf-idfs, the word 'is' is now associated with a relatively small tf-idf (0.45) in the third document, since it is also present in the first and second document and thus is unlikely to contain any useful discriminatory information. However, if we’d manually calculated the tf-idfs of the individual terms in our feature vectors, we would have noticed that TfidfTransformer calculates the tf-idfs slightly differently compared to the standard textbook equations", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 233, "start_word": 74560, "end_word": 74960, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000234": {"text": "occurring word. However, after transforming the same feature vector into tf-idfs, the word 'is' is now associated with a relatively small tf-idf (0.45) in the third document, since it is also present in the first and second document and thus is unlikely to contain any useful discriminatory information. However, if we’d manually calculated the tf-idfs of the individual terms in our feature vectors, we would have noticed that TfidfTransformer calculates the tf-idfs slightly differently compared to the standard textbook equations that we defined previously. The equation for the inverse document frequency implemented in scikit-learn is computed as follows: 𝑖𝑖𝑖𝑖𝑖𝑖(𝑡𝑡𝑡𝑖𝑖)= log1+𝑛𝑛𝑑𝑑 1+𝑖𝑖𝑖𝑖(𝑖𝑖𝑡𝑡𝑡) Similarly, the tf-idf computed in scikit-learn deviates slightly from the default equation we defined earlier: tf-idf(t, d) = tf (t, d) × (idf(t, d) + 1) Note that the “+1” in the previous idf equation is due to setting smooth_idf=True in the previous code example, which is helpful for assigning zero weight (that is, idf(t, d) = log(1) = 0) to terms that occur in all documents. While it is also more typical to normalize the raw term frequencies before calculating the tf-idfs, the TfidfTransformer class normalizes the tf-idfs directly. By default ( norm='l2' ), scikit-learn’s TfidfTransformer applies the L2-normalization, which returns a vector of length 1 by dividing an unnormalized feature vector, v, by its L2-norm: 𝑣𝑣𝑛𝑛𝑛𝑛𝑛𝑛𝑛𝑛=𝑣𝑣 ‖𝑣𝑣‖2=𝑣𝑣 √𝑣𝑣12+𝑣𝑣22+⋯+𝑣𝑣 𝑛𝑛2=𝑣𝑣 (∑𝑣𝑣𝑖𝑖2𝑛𝑛 𝑖𝑖𝑖1)1/2 Applying Machine Learning to Sentiment Analysis 254 To make sure that we understand how TfidfTransformer works, let’s walk through an example and calculate the tf-idf of the word 'is' in the third document. The word 'is' has a term frequency of 3 (tf = 3) in the third document, and the document frequency of this term is 3 since the term 'is' occurs in all three documents (df = 3). Thus, we can calculate the inverse document frequency as follows: 𝑖𝑖𝑖𝑖𝑖𝑖(\"is\",𝑖𝑖3)= log1+3 1+3=0 Now, in order to calculate the tf-idf, we simply need to add 1 to the inverse document frequency and multiply it by the term frequency: 𝑡𝑡𝑡𝑡-𝑖𝑖𝑖𝑖𝑡𝑡(\"is\",𝑖𝑖3)=3×(0+1)=3 If we repeated this calculation for all terms in the third document, we’d obtain the following tf-idf vectors: [3.39, 3.0, 3.39, 1.29, 1.29, 1.29, 2.0, 1.69, 1.29] . However, notice that the values in this feature vector are different from the values that we obtained from TfidfTransformer that we used previously. The final step that we are missing in this tf-idf calculation is the L2-normalization, which can", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 234, "start_word": 74880, "end_word": 75280, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000235": {"text": "to the inverse document frequency and multiply it by the term frequency: 𝑡𝑡𝑡𝑡-𝑖𝑖𝑖𝑖𝑡𝑡(\"is\",𝑖𝑖3)=3×(0+1)=3 If we repeated this calculation for all terms in the third document, we’d obtain the following tf-idf vectors: [3.39, 3.0, 3.39, 1.29, 1.29, 1.29, 2.0, 1.69, 1.29] . However, notice that the values in this feature vector are different from the values that we obtained from TfidfTransformer that we used previously. The final step that we are missing in this tf-idf calculation is the L2-normalization, which can be applied as follows: 𝑡𝑡𝑡𝑡-𝑖𝑖𝑖𝑖𝑡𝑡(𝑖𝑖3)𝑛𝑛𝑛𝑛𝑛𝑛𝑛𝑛 =[3.39, 3.0, 3. 39, 1. 29, 1. 29, 1. 29, 2.0, 1. 69, 1. 29] √3.392+ 3.02+ 3. 392+ 1. 292+ 1. 292+ 1. 292+ 2.02+ 1. 692+ 1. 292 = [0.5, 0. 45, 0.5, 0. 19, 0. 19, 0.19, 0.3, 0. 25, 0. 19] 𝑡𝑡𝑡𝑡-𝑖𝑖𝑖𝑖𝑡𝑡(\"is\", 𝑖𝑖3)= 0. 45 As you can see, the results now match the results returned by scikit-learn’s TfidfTransformer , and since you now understand how tf-idfs are calculated, let’s proceed to the next section and apply those concepts to the movie review dataset. Cleaning text data In the previous subsections, we learned about the bag-of-words model, term frequencies, and tf-idfs. However, the first important step—before we build our bag-of-words model—is to clean the text data by stripping it of all unwanted characters. To illustrate why this is important, let’s display the last 50 characters from the first document in the reshuffled movie review dataset: >>> df.loc[ 0, 'review' ][-50:] 'is seven.<br /><br />Title (Brazil): Not Available' As you can see here, the text contains HTML markup as well as punctuation and other non-letter characters. While HTML markup does not contain many useful semantics, punctuation marks can represent useful, additional information in certain NLP contexts. However, for simplicity, we will now remove all punctuation marks except for emoticon characters, such as :), since those are certainly useful for sentiment analysis. Chapter 8 255 To accomplish this task, we will use Python’s regular expression (regex ) library, re, as shown here: >>> import re >>> def preprocessor (text): ... text = re.sub( '<[^>]*>' , '', text) ... emoticons = re.findall( '(?::|;|=)(?:-)?(?:\\)|\\(|D|P)' , ... text) ... text = (re.sub( '[\\W]+', ' ', text.lower()) + ... ' '.join(emoticons).replace( '-', '')) ... return text Via the first regex, <[^>]*> , in the preceding code section, we tried to remove all of the HTML markup from the movie reviews. Although many programmers generally advise against the", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 235, "start_word": 75200, "end_word": 75600, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000236": {"text": "regular expression (regex ) library, re, as shown here: >>> import re >>> def preprocessor (text): ... text = re.sub( '<[^>]*>' , '', text) ... emoticons = re.findall( '(?::|;|=)(?:-)?(?:\\)|\\(|D|P)' , ... text) ... text = (re.sub( '[\\W]+', ' ', text.lower()) + ... ' '.join(emoticons).replace( '-', '')) ... return text Via the first regex, <[^>]*> , in the preceding code section, we tried to remove all of the HTML markup from the movie reviews. Although many programmers generally advise against the use of regex to parse HTML, this regex should be sufficient to clean this particular dataset. Since we are only interested in removing HTML markup and do not plan to use the HTML markup further, using regex to do the job should be acceptable. However, if you prefer to use sophisticated tools for removing HTML markup from text, you can take a look at Python’s HTML parser module, which is described at https://docs. python.org/3/library/html.parser.html . After we removed the HTML markup, we used a slightly more complex regex to find emoticons, which we temporarily stored as emoticons. Next, we removed all non-word characters from the text via the regex [\\W]+ and converted the text into lowercase characters. Eventually, we added the temporarily stored emoticons to the end of the processed document string. Additionally, we removed the nose character (- in :-)) from the emoticons for consistency.Dealing with word capitalization In the context of this analysis, we assume that the capitalization of a word—for example, whether it appears at the beginning of a sentence—does not contain semantically relevant information. However, note that there are exceptions; for instance, we remove the notation of proper names. But again, in the context of this analysis, it is a simplifying assumption that the letter case does not contain information that is relevant for sentiment analysis. Regular expressions Although regular expressions offer an efficient and convenient approach to searching for characters in a string, they also come with a steep learning curve. Unfortunately, an in- depth discussion of regular expressions is beyond the scope of this book. However, you can find a great tutorial on the Google Developers portal at https://developers.google. com/edu/python/regular-expressions or you can check out the official documentation of Python’s re module at https://docs.python.org/3.9/library/re.html . Applying Machine Learning to Sentiment Analysis 256 Although the addition of the emoticon characters to the end of the cleaned document strings may not look like the most elegant", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 236, "start_word": 75520, "end_word": 75920, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000237": {"text": "come with a steep learning curve. Unfortunately, an in- depth discussion of regular expressions is beyond the scope of this book. However, you can find a great tutorial on the Google Developers portal at https://developers.google. com/edu/python/regular-expressions or you can check out the official documentation of Python’s re module at https://docs.python.org/3.9/library/re.html . Applying Machine Learning to Sentiment Analysis 256 Although the addition of the emoticon characters to the end of the cleaned document strings may not look like the most elegant approach, we must note that the order of the words doesn’t matter in our bag-of-words model if our vocabulary consists of only one-word tokens. But before we talk more about the splitting of documents into individual terms, words, or tokens, let’s confirm that our preprocessor function works correctly: >>> preprocessor(df.loc[ 0, 'review' ][-50:]) 'is seven title brazil not available' >>> preprocessor( \"</a>This :) is :( a test :-)!\" ) 'this is a test :) :( :)' Lastly, since we will make use of the cleaned text data over and over again during the next sections, let’s now apply our preprocessor function to all the movie reviews in our DataFrame : >>> df['review' ] = df['review' ].apply(preprocessor) Processing documents into tokens After successfully preparing the movie review dataset, we now need to think about how to split the text corpora into individual elements. One way to tokenize documents is to split them into individual words by splitting the cleaned documents at their whitespace characters: >>> def tokenizer (text): ... return text.split() >>> tokenizer( 'runners like running and thus they run' ) ['runners', 'like', 'running', 'and', 'thus', 'they', 'run'] In the context of tokenization, another useful technique is word stemming, which is the process of transforming a word into its root form. It allows us to map related words to the same stem. The origi- nal stemming algorithm was developed by Martin F. Porter in 1979 and is hence known as the Porter stemmer algorithm (An algorithm for suffix stripping by Martin F. Porter, Program: Electronic Library and Information Systems, 14(3): 130–137, 1980). The Natural Language Toolkit ( NLTK , http://www. nltk.org ) for Python implements the Porter stemming algorithm, which we will use in the following code section. To install the NLTK, you can simply execute conda install nltk or pip install nltk . The following code shows how to use the Porter stemming algorithm: >>> from nltk.stem.porter import PorterStemmer >>>", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 237, "start_word": 75840, "end_word": 76240, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000238": {"text": "Porter stemmer algorithm (An algorithm for suffix stripping by Martin F. Porter, Program: Electronic Library and Information Systems, 14(3): 130–137, 1980). The Natural Language Toolkit ( NLTK , http://www. nltk.org ) for Python implements the Porter stemming algorithm, which we will use in the following code section. To install the NLTK, you can simply execute conda install nltk or pip install nltk . The following code shows how to use the Porter stemming algorithm: >>> from nltk.stem.porter import PorterStemmer >>> porter = PorterStemmer()NLTK online book Although the NLTK is not the focus of this chapter, I highly recommend that you visit the NLTK website as well as read the official NLTK book, which is freely available at http:// www.nltk.org/book/ , if you are interested in more advanced applications in NLP. Chapter 8 257 >>> def tokenizer_porter (text): ... return [porter.stem(word) for word in text.split()] >>> tokenizer_porter( 'runners like running and thus they run' ) ['runner', 'like', 'run', 'and', 'thu', 'they', 'run'] Using the PorterStemmer from the nltk package, we modified our tokenizer function to reduce words to their root form, which was illustrated by the simple preceding example where the word 'running' was stemmed to its root form 'run' . Before we jump into the next section, where we will train a machine learning model using the bag- of-words model, let’s briefly talk about another useful topic called stop word removal. Stop words are simply those words that are extremely common in all sorts of texts and probably bear no (or only a little) useful information that can be used to distinguish between different classes of documents. Examples of stop words are is, and, has, and like. Removing stop words can be useful if we are working with raw or normalized term frequencies rather than tf-idfs, which already downweight the frequently occurring words. To remove stop words from the movie reviews, we will use the set of 127 English stop words that is available from the NLTK library, which can be obtained by calling the nltk.download function: >>> import nltk >>> nltk.download( 'stopwords' )Stemming algorithms The Porter stemming algorithm is probably the oldest and simplest stemming algorithm. Other popular stemming algorithms include the newer Snowball stemmer (Porter2 or English stemmer) and the Lancaster stemmer (Paice/Husk stemmer). While both the Snowball and Lancaster stemmers are faster than the original Porter stemmer, the Lan- caster stemmer is also notorious for being more", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 238, "start_word": 76160, "end_word": 76560, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000239": {"text": "words that is available from the NLTK library, which can be obtained by calling the nltk.download function: >>> import nltk >>> nltk.download( 'stopwords' )Stemming algorithms The Porter stemming algorithm is probably the oldest and simplest stemming algorithm. Other popular stemming algorithms include the newer Snowball stemmer (Porter2 or English stemmer) and the Lancaster stemmer (Paice/Husk stemmer). While both the Snowball and Lancaster stemmers are faster than the original Porter stemmer, the Lan- caster stemmer is also notorious for being more aggressive than the Porter stemmer, which means that it will produce shorter and more obscure words. These alternative stemming algorithms are also available through the NLTK package (http://www.nltk.org/api/ nltk.stem.html ). While stemming can create non-real words, such as 'thu' (from 'thus' ), as shown in the previous example, a technique called lemmatization aims to obtain the canonical (grammatically correct) forms of individual words—the so-called lemmas. However, lem- matization is computationally more difficult and expensive compared to stemming and, in practice, it has been observed that stemming and lemmatization have little impact on the performance of text classification (Influence of Word Normalization on Text Classification, by Michal Toman, Roman Tesar, and Karel Jezek, Proceedings of InSciT, pages 354–358, 2006). Applying Machine Learning to Sentiment Analysis 258 After we download the stop words set, we can load and apply the English stop word set as follows: >>> from nltk.corpus import stopwords >>> stop = stopwords.words( 'english' ) >>> [w for w in tokenizer_porter( 'a runner likes' ... ' running and runs a lot' ) ... if w not in stop] ['runner', 'like', 'run', 'run', 'lot'] Training a logistic regression model for document classification In this section, we will train a logistic regression model to classify the movie reviews into positive and negative reviews based on the bag-of-words model. First, we will divide the DataFrame of cleaned text documents into 25,000 documents for training and 25,000 documents for testing: >>> X_train = df.loc[: 25000, 'review' ].values >>> y_train = df.loc[: 25000, 'sentiment' ].values >>> X_test = df.loc[ 25000:, 'review' ].values >>> y_test = df.loc[ 25000:, 'sentiment' ].values Next, we will use a GridSearchCV object to find the optimal set of parameters for our logistic regression model using 5-fold stratified cross-validation: >>> from sklearn.model_selection import GridSearchCV >>> from sklearn.pipeline import Pipeline >>> from sklearn.linear_model import LogisticRegression >>> from sklearn.feature_extraction.text import TfidfVectorizer >>> tfidf = TfidfVectorizer(strip_accents= None, ... lowercase= False, ... preprocessor= None) >>> small_param_grid", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 239, "start_word": 76480, "end_word": 76880, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000240": {"text": "25000, 'review' ].values >>> y_train = df.loc[: 25000, 'sentiment' ].values >>> X_test = df.loc[ 25000:, 'review' ].values >>> y_test = df.loc[ 25000:, 'sentiment' ].values Next, we will use a GridSearchCV object to find the optimal set of parameters for our logistic regression model using 5-fold stratified cross-validation: >>> from sklearn.model_selection import GridSearchCV >>> from sklearn.pipeline import Pipeline >>> from sklearn.linear_model import LogisticRegression >>> from sklearn.feature_extraction.text import TfidfVectorizer >>> tfidf = TfidfVectorizer(strip_accents= None, ... lowercase= False, ... preprocessor= None) >>> small_param_grid = [ ... { ... 'vect__ngram_range' : [(1, 1)], ... 'vect__stop_words' : [None], ... 'vect__tokenizer' : [tokenizer, tokenizer_porter], ... 'clf__penalty' : ['l2'], ... 'clf__C' : [1.0, 10.0] ... }, ... { ... 'vect__ngram_range' : [(1, 1)], ... 'vect__stop_words' : [stop, None], ... 'vect__tokenizer' : [tokenizer], Chapter 8 259 ... 'vect__use_idf' :[False], ... 'vect__norm' :[None], ... 'clf__penalty' : ['l2'], ... 'clf__C' : [1.0, 10.0] ... }, ... ] >>> lr_tfidf = Pipeline([ ... ('vect', tfidf), ... ('clf', LogisticRegression(solver= 'liblinear' )) ... ]) >>> gs_lr_tfidf = GridSearchCV(lr_tfidf, small_param_grid, ... scoring= 'accuracy' , cv=5, ... verbose= 2, n_jobs= 1) >>> gs_lr_tfidf.fit(X_train, y_train) Note that for the logistic regression classifier, we are using the LIBLINEAR solver as it can perform better than the default choice ( 'lbfgs' ) for relatively large datasets. When we initialized the GridSearchCV object and its parameter grid using the preceding code, we restricted ourselves to a limited number of parameter combinations, since the number of feature vectors, as well as the large vocabulary, can make the grid search computationally quite expensive. Using a standard desktop computer, our grid search may take 5-10 minutes to complete. In the previous code example, we replaced CountVectorizer and TfidfTransformer from the previous subsection with TfidfVectorizer , which combines CountVectorizer with the TfidfTransformer . Our param_grid consisted of two parameter dictionaries. In the first dictionary, we used TfidfVectorizer with its default settings ( use_idf=True , smooth_idf=True , and norm='l2' ) to calculate the tf-idfs; in the second dictionary, we set those parameters to use_idf=False , smooth_idf=False , and norm=None in order to train a model based on raw term frequencies. Furthermore, for the logistic regression classifier itself, we trained models using L2 regularization via the penalty parameter and compared different regularization strengths by defining a range of values for the inverse-regularization parameter C. As an optional exercise, you are also encouraged to add L1 regularization to the parameter grid by changing 'clf__penalty': ['l2'] to", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 240, "start_word": 76800, "end_word": 77200, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000241": {"text": "in the second dictionary, we set those parameters to use_idf=False , smooth_idf=False , and norm=None in order to train a model based on raw term frequencies. Furthermore, for the logistic regression classifier itself, we trained models using L2 regularization via the penalty parameter and compared different regularization strengths by defining a range of values for the inverse-regularization parameter C. As an optional exercise, you are also encouraged to add L1 regularization to the parameter grid by changing 'clf__penalty': ['l2'] to 'clf__penalty': ['l2', 'l1'] .Multiprocessing via the n_jobs parameter Please note that we highly recommend setting n_jobs=-1 (instead of n_jobs=1 , as in the previous code example) to utilize all available cores on your machine and speed up the grid search. However, some Windows users reported issues when running the previous code with the n_jobs=-1 setting related to pickling the tokenizer and tokenizer_porter functions for multiprocessing on Windows. Another workaround would be to replace those two functions, [tokenizer, tokenizer_porter] , with [str.split] . However, note that replacement by the simple str.split would not support stemming. Applying Machine Learning to Sentiment Analysis 260 After the grid search has finished, we can print the best parameter set: >>> print(f'Best parameter set: {gs_lr_tfidf.best_params_} ') Best parameter set: {'clf__C': 10.0, 'clf__penalty': 'l2', 'vect__ngram_range': (1, 1), 'vect__stop_words': None, 'vect__tokenizer': <function tokenizer at 0x169932dc0>} As you can see in the preceding output, we obtained the best grid search results using the regular tokenizer without Porter stemming, no stop word library, and tf-idfs in combination with a logistic regression classifier that uses L2-regularization with the regularization strength C of 10.0 . Using the best model from this grid search, let’s print the average 5-fold cross-validation accuracy scores on the training dataset and the classification accuracy on the test dataset: >>> print(f'CV Accuracy: {gs_lr_tfidf.best_score_: .3f}') CV Accuracy: 0.897 >>> clf = gs_lr_tfidf.best_estimator_ >>> print(f'Test Accuracy: {clf.score(X_test, y_test): .3f}') Test Accuracy: 0.899 The results reveal that our machine learning model can predict whether a movie review is positive or negative with 90 percent accuracy. Working with bigger data – online algorithms and out- of-core learning If you executed the code examples in the previous section, you may have noticed that it could be computationally quite expensive to construct the feature vectors for the 50,000-movie review dataset during a grid search. In many real-world applications, it is not uncommon to work with even larger datasets that can exceed our computer’s memory.", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 241, "start_word": 77120, "end_word": 77520, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000242": {"text": "can predict whether a movie review is positive or negative with 90 percent accuracy. Working with bigger data – online algorithms and out- of-core learning If you executed the code examples in the previous section, you may have noticed that it could be computationally quite expensive to construct the feature vectors for the 50,000-movie review dataset during a grid search. In many real-world applications, it is not uncommon to work with even larger datasets that can exceed our computer’s memory. The naïve Bayes classifier A still very popular classifier for text classification is the naïve Bayes classifier, which gained popularity in applications of email spam filtering. Naïve Bayes classifiers are easy to implement, computationally efficient, and tend to perform particularly well on rela - tively small datasets compared to other algorithms. Although we don’t discuss naïve Bayes classifiers in this book, the interested reader can find an article about naïve Bayes text classification that is freely available on arXiv (Naive Bayes and Text Classification I – Intro - duction and Theory by S. Raschka, Computing Research Repository ( CoRR ), abs/1410.5329, 2014, http://arxiv.org/pdf/1410.5329v3.pdf). Different versions of naï ve Bayes classifiers referenced in this article are implemented in scikit-learn. You can find an overview page with links to the respective code classes here: https://scikit-learn.org/stable/ modules/naive_bayes.html . Chapter 8 261 Since not everyone has access to supercomputer facilities, we will now apply a technique called out-of- core learning, which allows us to work with such large datasets by fitting the classifier incrementally on smaller batches of a dataset. Back in Chapter 2, Training Simple Machine Learning Algorithms for Classification, the concept of sto - chastic gradient descent was introduced; it is an optimization algorithm that updates the model’s weights using one example at a time. In this section, we will make use of the partial_fit function of SGDClassifier in scikit-learn to stream the documents directly from our local drive and train a logistic regression model using small mini-batches of documents. First, we will define a tokenizer function that cleans the unprocessed text data from the movie_data. csv file that we constructed at the beginning of this chapter and separates it into word tokens while removing stop words: >>> import numpy as np >>> import re >>> from nltk.corpus import stopwords >>> stop = stopwords.words( 'english' ) >>> def tokenizer (text): ... text = re.sub( '<[^>]*>' , '', text) ... emoticons = re.findall(", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 242, "start_word": 77440, "end_word": 77840, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000243": {"text": "logistic regression model using small mini-batches of documents. First, we will define a tokenizer function that cleans the unprocessed text data from the movie_data. csv file that we constructed at the beginning of this chapter and separates it into word tokens while removing stop words: >>> import numpy as np >>> import re >>> from nltk.corpus import stopwords >>> stop = stopwords.words( 'english' ) >>> def tokenizer (text): ... text = re.sub( '<[^>]*>' , '', text) ... emoticons = re.findall( '(?::|;|=)(?:-)?(?:\\)|\\(|D|P)' , ... text.lower()) ... text = re.sub( '[\\W]+', ' ', text.lower()) \\ ... + ' '.join(emoticons).replace( '-', '') ... tokenized = [w for w in text.split() if w not in stop] ... return tokenized Next, we will define a generator function, stream_docs , that reads in and returns one document at a time: >>> def stream_docs (path): ... with open(path, 'r', encoding= 'utf-8') as csv: ... next(csv) # skip header ... for line in csv: ... text, label = line[:- 3], int(line[-2]) ... yield text, labelText classification with recurrent neural networks In Chapter 15, Modeling Sequential Data Using Recurrent Neural Networks, we will revisit this dataset and train a deep learning-based classifier (a recurrent neural network) to classify the reviews in the IMDb movie review dataset. This neural network-based classifier fol- lows the same out-of-core principle using the stochastic gradient descent optimization algorithm, but does not require the construction of a bag-of-words model. Applying Machine Learning to Sentiment Analysis 262 To verify that our stream_docs function works correctly, let’s read in the first document from the movie_data.csv file, which should return a tuple consisting of the review text as well as the corre - sponding class label: >>> next(stream_docs(path= 'movie_data.csv' )) ('\"In 1974, the teenager Martha Moxley ... ',1) We will now define a function, get_minibatch , that will take a document stream from the stream_docs function and return a particular number of documents specified by the size parameter: >>> def get_minibatch (doc_stream, size): ... docs, y = [], [] ... try: ... for _ in range (size): ... text, label = next(doc_stream) ... docs.append(text) ... y.append(label) ... except StopIteration: ... return None, None ... return docs, y Unfortunately, we can’t use CountVectorizer for out-of-core learning since it requires holding the complete vocabulary in memory. Also, TfidfVectorizer needs to keep all the feature vectors of the training dataset in memory to calculate the inverse document frequencies. However, another useful", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 243, "start_word": 77760, "end_word": 78160, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000244": {"text": ">>> def get_minibatch (doc_stream, size): ... docs, y = [], [] ... try: ... for _ in range (size): ... text, label = next(doc_stream) ... docs.append(text) ... y.append(label) ... except StopIteration: ... return None, None ... return docs, y Unfortunately, we can’t use CountVectorizer for out-of-core learning since it requires holding the complete vocabulary in memory. Also, TfidfVectorizer needs to keep all the feature vectors of the training dataset in memory to calculate the inverse document frequencies. However, another useful vectorizer for text processing implemented in scikit-learn is HashingVectorizer . HashingVectorizer is data-independent and makes use of the hashing trick via the 32-bit MurmurHash3 function by Austin Appleby (you can find more information about MurmurHash at https://en.wikipedia.org/wiki/ MurmurHash ): >>> from sklearn.feature_extraction.text import HashingVectorizer >>> from sklearn.linear_model import SGDClassifier >>> vect = HashingVectorizer(decode_error= 'ignore' , ... n_features= 2**21, ... preprocessor= None, ... tokenizer=tokenizer) >>> clf = SGDClassifier(loss= 'log', random_state= 1) >>> doc_stream = stream_docs(path= 'movie_data.csv' ) Using the preceding code, we initialized HashingVectorizer with our tokenizer function and set the number of features to 2**21 . Furthermore, we reinitialized a logistic regression classifier by setting the loss parameter of SGDClassifier to 'log' . Note that by choosing a large number of features in HashingVectorizer , we reduce the chance of causing hash collisions, but we also increase the number of coefficients in our logistic regression model. Chapter 8 263 Now comes the really interesting part—having set up all the complementary functions, we can start the out-of-core learning using the following code: >>> import pyprind >>> pbar = pyprind.ProgBar( 45) >>> classes = np.array([ 0, 1]) >>> for _ in range (45): ... X_train, y_train = get_minibatch(doc_stream, size= 1000) ... if not X_train: ... break ... X_train = vect.transform(X_train) ... clf.partial_fit(X_train, y_train, classes=classes) ... pbar.update() 0% 100% [##############################] | ETA: 00:00:00 Total time elapsed: 00:00:21 Again, we made use of the PyPrind package to estimate the progress of our learning algorithm. We initialized the progress bar object with 45 iterations and, in the following for loop, we iterated over 45 mini-batches of documents where each mini-batch consists of 1,000 documents. Having completed the incremental learning process, we will use the last 5,000 documents to evaluate the performance of our model: >>> X_test, y_test = get_minibatch(doc_stream, size= 5000) >>> X_test = vect.transform(X_test) >>> print(f'Accuracy: {clf.score(X_test, y_test): .3f}') Accuracy: 0.868 As you can see, the accuracy of the model is approximately 87 percent,", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 244, "start_word": 78080, "end_word": 78480, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000245": {"text": "We initialized the progress bar object with 45 iterations and, in the following for loop, we iterated over 45 mini-batches of documents where each mini-batch consists of 1,000 documents. Having completed the incremental learning process, we will use the last 5,000 documents to evaluate the performance of our model: >>> X_test, y_test = get_minibatch(doc_stream, size= 5000) >>> X_test = vect.transform(X_test) >>> print(f'Accuracy: {clf.score(X_test, y_test): .3f}') Accuracy: 0.868 As you can see, the accuracy of the model is approximately 87 percent, slightly below the accuracy that we achieved in the previous section using the grid search for hyperparameter tuning. However, out-of-core learning is very memory efficient, and it took less than a minute to complete. NoneType error Please note that if you encounter a NoneType error, you may have executed the X_test, y_test = get_minibatch(...) code twice. Via the previous loop, we have 45 iterations where we fetch 1,000 documents each. Hence, there are exactly 5,000 documents left for testing, which we assign via: >>> X_test, y_test = get_minibatch(doc_stream, size= 5000) If we execute this code twice, then there are not enough documents left in the generator, and X_test returns None . Hence, if you encounter the NoneType error, you have to start at the previous stream_docs(...) code again. Applying Machine Learning to Sentiment Analysis 264 Finally, we can use the last 5,000 documents to update our model: >>> clf = clf.partial_fit(X_test, y_test) Topic modeling with latent Dirichlet allocation Topic modeling describes the broad task of assigning topics to unlabeled text documents. For example, a typical application is the categorization of documents in a large text corpus of newspaper articles. In applications of topic modeling, we then aim to assign category labels to those articles, for example, sports, finance, world news, politics, and local news. Thus, in the context of the broad categories of machine learning that we discussed in Chapter 1, Giving Computers the Ability to Learn from Data, we can consider topic modeling as a clustering task, a subcategory of unsupervised learning. In this section, we will discuss a popular technique for topic modeling called latent Dirichlet allocation (LDA ). However, note that while latent Dirichlet allocation is often abbreviated as LDA, it is not to be confused with linear discriminant analysis, a supervised dimensionality reduction technique that was introduced in Chapter 5, Compressing Data via Dimensionality Reduction. Decomposing text documents with LDA Since the mathematics behind LDA is", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 245, "start_word": 78400, "end_word": 78800, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000246": {"text": "can consider topic modeling as a clustering task, a subcategory of unsupervised learning. In this section, we will discuss a popular technique for topic modeling called latent Dirichlet allocation (LDA ). However, note that while latent Dirichlet allocation is often abbreviated as LDA, it is not to be confused with linear discriminant analysis, a supervised dimensionality reduction technique that was introduced in Chapter 5, Compressing Data via Dimensionality Reduction. Decomposing text documents with LDA Since the mathematics behind LDA is quite involved and requires knowledge of Bayesian inference, we will approach this topic from a practitioner’s perspective and interpret LDA using layman’s terms. However, the interested reader can read more about LDA in the following research paper: Latent Dirichlet Allocation, by David M. Blei, Andrew Y. Ng, and Michael I. Jordan, Journal of Machine Learning Research 3, pages: 993-1022, Jan 2003, https://www.jmlr.org/papers/volume3/blei03a/blei03a.pdf . LDA is a generative probabilistic model that tries to find groups of words that appear frequently to - gether across different documents. These frequently appearing words represent our topics, assuming that each document is a mixture of different words. The input to an LDA is the bag-of-words model that we discussed earlier in this chapter. The word2vec model A more modern alternative to the bag-of-words model is word2vec, an algorithm that Google released in 2013 (Efficient Estimation of Word Representations in Vector Space by T. Mikolov, K. Chen, G. Corrado, and J. Dean, https://arxiv.org/abs/1301.3781 ). The word2vec algorithm is an unsupervised learning algorithm based on neural networks that attempts to automatically learn the relationship between words. The idea behind word2vec is to put words that have similar meanings into similar clusters, and via clever vector spacing, the model can reproduce certain words using simple vector math, for example, king – man + woman = queen. The original C-implementation with useful links to the relevant papers and alternative implementations can be found at https://code.google.com/p/word2vec/ . Chapter 8 265 Given a bag-of-words matrix as input, LDA decomposes it into two new matrices: • A document-to-topic matrix • A word-to-topic matrix LDA decomposes the bag-of-words matrix in such a way that if we multiply those two matrices to - gether, we will be able to reproduce the input, the bag-of-words matrix, with the lowest possible error. In practice, we are interested in those topics that LDA found in the bag-of-words matrix. The only downside may be that we must define", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 246, "start_word": 78720, "end_word": 79120, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000247": {"text": "Given a bag-of-words matrix as input, LDA decomposes it into two new matrices: • A document-to-topic matrix • A word-to-topic matrix LDA decomposes the bag-of-words matrix in such a way that if we multiply those two matrices to - gether, we will be able to reproduce the input, the bag-of-words matrix, with the lowest possible error. In practice, we are interested in those topics that LDA found in the bag-of-words matrix. The only downside may be that we must define the number of topics beforehand—the number of topics is a hyperparameter of LDA that has to be specified manually. LDA with scikit-learn In this subsection, we will use the LatentDirichletAllocation class implemented in scikit-learn to decompose the movie review dataset and categorize it into different topics. In the following example, we will restrict the analysis to 10 different topics, but readers are encouraged to experiment with the hyperparameters of the algorithm to further explore the topics that can be found in this dataset. First, we are going to load the dataset into a pandas DataFrame using the local movie_data.csv file of the movie reviews that we created at the beginning of this chapter: >>> import pandas as pd >>> df = pd.read_csv( 'movie_data.csv' , encoding= 'utf-8') >>> # the following is necessary on some computers: >>> df = df.rename(columns={ \"0\": \"review\" , \"1\": \"sentiment\" }) Next, we are going to use the already familiar CountVectorizer to create the bag-of-words matrix as input to the LDA. For convenience, we will use scikit-learn’s built-in English stop word library via stop_words='english' : >>> from sklearn.feature_extraction.text import CountVectorizer >>> count = CountVectorizer(stop_words= 'english' , ... max_df= .1, ... max_features= 5000) >>> X = count.fit_transform(df[ 'review' ].values) Notice that we set the maximum document frequency of words to be considered to 10 percent ( max_ df=.1 ) to exclude words that occur too frequently across documents. The rationale behind the removal of frequently occurring words is that these might be common words appearing across all documents that are, therefore, less likely to be associated with a specific topic category of a given document. Also, we limited the number of words to be considered to the most frequently occurring 5,000 words (max_features=5000 ), to limit the dimensionality of this dataset to improve the inference performed by LDA. However, both max_df=.1 and max_features=5000 are hyperparameter values chosen arbi- trarily, and readers are encouraged to tune them while", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 247, "start_word": 79040, "end_word": 79440, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000248": {"text": "is that these might be common words appearing across all documents that are, therefore, less likely to be associated with a specific topic category of a given document. Also, we limited the number of words to be considered to the most frequently occurring 5,000 words (max_features=5000 ), to limit the dimensionality of this dataset to improve the inference performed by LDA. However, both max_df=.1 and max_features=5000 are hyperparameter values chosen arbi- trarily, and readers are encouraged to tune them while comparing the results. Applying Machine Learning to Sentiment Analysis 266 The following code example demonstrates how to fit a LatentDirichletAllocation estimator to the bag-of-words matrix and infer the 10 different topics from the documents (note that the model fitting can take up to 5 minutes or more on a laptop or standard desktop computer): >>> from sklearn.decomposition import LatentDirichletAllocation >>> lda = LatentDirichletAllocation(n_components= 10, ... random_state= 123, ... learning_method= 'batch') >>> X_topics = lda.fit_transform(X) By setting learning_method='batch' , we let the lda estimator do its estimation based on all available training data (the bag-of-words matrix) in one iteration, which is slower than the alternative 'online' learning method, but can lead to more accurate results (setting learning_method='online' is anal- ogous to online or mini-batch learning, which we discussed in Chapter 2, Training Simple Machine Learning Algorithms for Classification, and previously in this chapter). After fitting the LDA, we now have access to the components_ attribute of the lda instance, which stores a matrix containing the word importance (here, 5000 ) for each of the 10 topics in increasing order: >>> lda.components_.shape (10, 5000) To analyze the results, let’s print the five most important words for each of the 10 topics. Note that the word importance values are ranked in increasing order. Thus, to print the top five words, we need to sort the topic array in reverse order: >>> n_top_words = 5 >>> feature_names = count.get_feature_names_out() >>> for topic_idx, topic in enumerate (lda.components_): ... print(f'Topic {(topic_idx + 1)}:') ... print(' '.join([feature_names[i] ... for i in topic.argsort()\\ ... [:-n_top_words - 1:-1]])) Topic 1:Expectation-maximization The scikit-learn library’s implementation of LDA uses the expectation-maximization ( EM) algorithm to update its parameter estimates iteratively. We haven’t discussed the EM algo - rithm in this chapter, but if you are curious to learn more, please see the excellent over - view on Wikipedia (https://en.wikipedia.org/wiki/Expectation–maximization_ algorithm ) and the detailed tutorial on how it is used in", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 248, "start_word": 79360, "end_word": 79760, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000249": {"text": "enumerate (lda.components_): ... print(f'Topic {(topic_idx + 1)}:') ... print(' '.join([feature_names[i] ... for i in topic.argsort()\\ ... [:-n_top_words - 1:-1]])) Topic 1:Expectation-maximization The scikit-learn library’s implementation of LDA uses the expectation-maximization ( EM) algorithm to update its parameter estimates iteratively. We haven’t discussed the EM algo - rithm in this chapter, but if you are curious to learn more, please see the excellent over - view on Wikipedia (https://en.wikipedia.org/wiki/Expectation–maximization_ algorithm ) and the detailed tutorial on how it is used in LDA in Colorado Reed’s tutorial, Latent Dirichlet Allocation: Towards a Deeper Understanding, which is freely available at http://obphio.us/pdfs/lda_tutorial.pdf . Chapter 8 267 worst minutes awful script stupid Topic 2: family mother father children girl Topic 3: american war dvd music tv Topic 4: human audience cinema art sense Topic 5: police guy car dead murder Topic 6: horror house sex girl woman Topic 7: role performance comedy actor performances Topic 8: series episode war episodes tv Topic 9: book version original read novel Topic 10: action fight guy guys cool Based on reading the five most important words for each topic, you may guess that the LDA identified the following topics: 1. Generally bad movies (not really a topic category) 2. Movies about families 3. War movies 4. Art movies 5. Crime movies 6. Horror movies 7. Comedy movie reviews 8. Movies somehow related to TV shows 9. Movies based on books 10. Action movies To confirm that the categories make sense based on the reviews, let’s plot three movies from the horror movie category (horror movies belong to category 6 at index position 5): >>> horror = X_topics[:, 5].argsort()[::- 1] >>> for iter_idx, movie_idx in enumerate (horror[: 3]): ... print(f'\\nHorror movie # {(iter_idx + 1)}:') ... print(df['review' ][movie_idx][: 300], '...') Horror movie #1: House of Dracula works from the same basic premise as House of Frankenstein from the year before; namely that Universal's three most famous monsters; Dracula, Frankenstein's Monster and The Wolf Man are appearing in the movie together. Naturally, the film is rather messy therefore, but the fact that ... Applying Machine Learning to Sentiment Analysis 268 Horror movie #2: Okay, what the hell kind of TRASH have I been watching now? \"The Witches' Mountain\" has got to be one of the most incoherent and insane Spanish exploitation flicks ever and yet, at the same time, it's also strangely compelling. There's absolutely nothing that makes sense here", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 249, "start_word": 79680, "end_word": 80080, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000250": {"text": "Monster and The Wolf Man are appearing in the movie together. Naturally, the film is rather messy therefore, but the fact that ... Applying Machine Learning to Sentiment Analysis 268 Horror movie #2: Okay, what the hell kind of TRASH have I been watching now? \"The Witches' Mountain\" has got to be one of the most incoherent and insane Spanish exploitation flicks ever and yet, at the same time, it's also strangely compelling. There's absolutely nothing that makes sense here and I even doubt there ... Horror movie #3: <br /><br />Horror movie time, Japanese style. Uzumaki/Spiral was a total freakfest from start to finish. A fun freakfest at that, but at times it was a tad too reliant on kitsch rather than the horror. The story is difficult to summarize succinctly: a carefree, normal teenage girl starts coming fac ... Using the preceding code example, we printed the first 300 characters from the top three horror mov - ies. The reviews—even though we don’t know which exact movie they belong to—sound like reviews of horror movies (however, one might argue that Horror movie #2 could also be a good fit for topic category 1: Generally bad movies). Summary In this chapter, you learned how to use machine learning algorithms to classify text documents based on their polarity, which is a basic task in sentiment analysis in the field of NLP. Not only did you learn how to encode a document as a feature vector using the bag-of-words model, but you also learned how to weight the term frequency by relevance using tf-idf. Working with text data can be computationally quite expensive due to the large feature vectors that are created during this process; in the last section, we covered how to utilize out-of-core or incremental learning to train a machine learning algorithm without loading the whole dataset into a computer’s memory. Lastly, you were introduced to the concept of topic modeling using LDA to categorize the movie reviews into different categories in an unsupervised fashion. So far, in this book, we have covered many machine learning concepts, best practices, and supervised models for classification. In the next chapter, we will look at another subcategory of supervised learn- ing, regression analysis, which lets us predict outcome variables on a continuous scale, in contrast to the categorical class labels of the classification models that we have been working with so far.", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 250, "start_word": 80000, "end_word": 80400, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000251": {"text": "topic modeling using LDA to categorize the movie reviews into different categories in an unsupervised fashion. So far, in this book, we have covered many machine learning concepts, best practices, and supervised models for classification. In the next chapter, we will look at another subcategory of supervised learn- ing, regression analysis, which lets us predict outcome variables on a continuous scale, in contrast to the categorical class labels of the classification models that we have been working with so far. Join our book’s Discord space Join the book’s Discord workspace for a monthly Ask me Anything session with the authors: https://packt.link/MLwPyTorch 9 Predicting Continuous Target Variables with Regression Analysis Throughout the previous chapters, you learned a lot about the main concepts behind supervised learning and trained many different models for classification tasks to predict group memberships or categorical variables. In this chapter, we will dive into another subcategory of supervised learning: regression analysis. Regression models are used to predict target variables on a continuous scale, which makes them attractive for addressing many questions in science. They also have applications in industry, such as understanding relationships between variables, evaluating trends, or making forecasts. One example is predicting the sales of a company in future months. In this chapter, we will discuss the main concepts of regression models and cover the following topics: • Exploring and visualizing datasets • Looking at different approaches to implementing linear regression models • Training regression models that are robust to outliers • Evaluating regression models and diagnosing common problems • Fitting regression models to nonlinear data Introducing linear regression The goal of linear regression is to model the relationship between one or multiple features and a con- tinuous target variable. In contrast to classification—a different subcategory of supervised learning— regression analysis aims to predict outputs on a continuous scale rather than categorical class labels. In the following subsections, you will be introduced to the most basic type of linear regression, sim- ple linear regression, and understand how to relate it to the more general, multivariate case (linear regression with multiple features). Predicting Continuous Target Variables with Regression Analysis 270 Simple linear regression The goal of simple (univariate) linear regression is to model the relationship between a single feature (explanatory variable, x) and a continuous-valued target (response variable, y). The equation of a linear model with one explanatory variable is defined as follows: 𝑦𝑦𝑦 𝑦𝑦𝑦𝑦 1𝑥𝑥𝑥𝑦𝑥𝑥 Here,", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 251, "start_word": 80320, "end_word": 80720, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000252": {"text": "type of linear regression, sim- ple linear regression, and understand how to relate it to the more general, multivariate case (linear regression with multiple features). Predicting Continuous Target Variables with Regression Analysis 270 Simple linear regression The goal of simple (univariate) linear regression is to model the relationship between a single feature (explanatory variable, x) and a continuous-valued target (response variable, y). The equation of a linear model with one explanatory variable is defined as follows: 𝑦𝑦𝑦 𝑦𝑦𝑦𝑦 1𝑥𝑥𝑥𝑦𝑥𝑥 Here, the parameter (bias unit), b, represents the y axis intercept and w 1 is the weight coefficient of the explanatory variable. Our goal is to learn the weights of the linear equation to describe the rela - tionship between the explanatory variable and the target variable, which can then be used to predict the responses of new explanatory variables that were not part of the training dataset. Based on the linear equation that we defined previously, linear regression can be understood as finding the best-fitting straight line through the training examples, as shown in Figure 9.1: Figure 9.1: A simple one-feature linear regression example This best-fitting line is also called the regression line, and the vertical lines from the regression line to the training examples are the so-called offsets or residuals—the errors of our prediction. Chapter 9 271 Multiple linear regression The previous section introduced simple linear regression, a special case of linear regression with one explanatory variable. Of course, we can also generalize the linear regression model to multiple explanatory variables; this process is called multiple linear regression: 𝑦𝑦𝑦 𝑦𝑦𝑦𝑦 1𝑥𝑥1+𝑦…𝑦+𝑦𝑦𝑦𝑚𝑚𝑥𝑥𝑚𝑚+𝑦𝑏𝑏𝑦 𝑦𝑦𝑏𝑦𝑦𝑖𝑖𝑥𝑥𝑖𝑖𝑚𝑚 𝑖𝑖𝑖1+𝑦𝑏𝑏𝑦 𝑦𝑦𝑦𝑦𝑇𝑇𝒙𝒙𝑦+𝑦𝑏𝑏 Figure 9.2 shows how the two-dimensional, fitted hyperplane of a multiple linear regression model with two features could look: Figure 9.2: A two-feature linear regression model As you can see, visualizations of multiple linear regression hyperplanes in a three-dimensional scatter - plot are already challenging to interpret when looking at static figures. Since we have no good means of visualizing hyperplanes with two dimensions in a scatterplot (multiple linear regression models fit to datasets with three or more features), the examples and visualizations in this chapter will mainly focus on the univariate case, using simple linear regression. However, simple and multiple linear regression are based on the same concepts and the same evaluation techniques; the code implemen- tations that we will discuss in this chapter are also compatible with both types of regression model. Predicting", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 252, "start_word": 80640, "end_word": 81040, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000253": {"text": "no good means of visualizing hyperplanes with two dimensions in a scatterplot (multiple linear regression models fit to datasets with three or more features), the examples and visualizations in this chapter will mainly focus on the univariate case, using simple linear regression. However, simple and multiple linear regression are based on the same concepts and the same evaluation techniques; the code implemen- tations that we will discuss in this chapter are also compatible with both types of regression model. Predicting Continuous Target Variables with Regression Analysis 272 Exploring the Ames Housing dataset Before we implement the first linear regression model, we will discuss a new dataset, the Ames Housing dataset, which contains information about individual residential property in Ames, Iowa, from 2006 to 2010. The dataset was collected by Dean De Cock in 2011, and additional information is available via the following links: • A report describing the dataset: http://jse.amstat.org/v19n3/decock.pdf • Detailed documentation regarding the dataset’s features: http://jse.amstat.org/v19n3/ decock/DataDocumentation.txt • The dataset in a tab-separated format: http://jse.amstat.org/v19n3/decock/AmesHousing. txt As with each new dataset, it is always helpful to explore the data through a simple visualization, to get a better feeling of what we are working with, which is what we will do in the following subsections. Loading the Ames Housing dataset into a DataFrame In this section, we will load the Ames Housing dataset using the pandas read_csv function, which is fast and versatile and a recommended tool for working with tabular data stored in a plaintext format. The Ames Housing dataset consists of 2,930 examples and 80 features. For simplicity, we will only work with a subset of the features, shown in the following list. However, if you are curious, follow the link to the full dataset description provided at the beginning of this section, and you are encouraged to explore other variables in this dataset after reading this chapter. The features we will be working with, including the target variable, are as follows: • Overall Qual : Rating for the overall material and finish of the house on a scale from 1 (very poor) to 10 (excellent) • Overall Cond : Rating for the overall condition of the house on a scale from 1 (very poor) to 10 (excellent) • Gr Liv Area : Above grade (ground) living area in square feet • Central Air : Central air conditioning (N=no, Y=yes) • Total Bsmt SF : Total square", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 253, "start_word": 80960, "end_word": 81360, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000254": {"text": "target variable, are as follows: • Overall Qual : Rating for the overall material and finish of the house on a scale from 1 (very poor) to 10 (excellent) • Overall Cond : Rating for the overall condition of the house on a scale from 1 (very poor) to 10 (excellent) • Gr Liv Area : Above grade (ground) living area in square feet • Central Air : Central air conditioning (N=no, Y=yes) • Total Bsmt SF : Total square feet of the basement area • SalePrice : Sale price in U.S. dollars ($) For the rest of this chapter, we will regard the sale price ( SalePrice ) as our target variable—the vari- able that we want to predict using one or more of the five explanatory variables. Before we explore this dataset further, let’s load it into a pandas DataFrame : import pandas as pd columns = [ 'Overall Qual' , 'Overall Cond' , 'Gr Liv Area' , 'Central Air' , 'Total Bsmt SF' , 'SalePrice' ] Chapter 9 273 df = pd.read_csv( 'http://jse.amstat.org/v19n3/decock/AmesHousing.txt' , sep= '\\t', usecols=columns) df.head() To confirm that the dataset was loaded successfully, we can display the first five lines of the dataset, as shown in Figure 9.3: Figure 9.3: The first five rows of the housing dataset After loading the dataset, let’s also check the dimensions of the DataFrame to make sure that it contains the expected number of rows: >>> df.shape (2930, 6) As we can see, the DataFrame contains 2,930 rows, as expected. Another aspect we have to take care of is the 'Central Air' variable, which is encoded as type string , as we can see in Figure 9.3. As we learned in Chapter 4, Building Good Training Datasets – Data Prepro - cessing, we can use the .map method to convert DataFrame columns. The following code will convert the string 'Y' to the integer 1, and the string 'N' to the integer 0: >>> df['Central Air' ] = df['Central Air' ].map({'N': 0, 'Y' : 1}) Lastly, let’s check whether any of the data frame columns contain missing values: >>> df.isnull(). sum() Overall Qual 0 Overall Cond 0 Total Bsmt SF 1 Central Air 0 Gr Liv Area 0 SalePrice 0 dtype: int64 Predicting Continuous Target Variables with Regression Analysis 274 As we can see, the Total Bsmt SF feature variable contains one missing value. Since we have a relatively", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 254, "start_word": 81280, "end_word": 81680, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000255": {"text": "to the integer 0: >>> df['Central Air' ] = df['Central Air' ].map({'N': 0, 'Y' : 1}) Lastly, let’s check whether any of the data frame columns contain missing values: >>> df.isnull(). sum() Overall Qual 0 Overall Cond 0 Total Bsmt SF 1 Central Air 0 Gr Liv Area 0 SalePrice 0 dtype: int64 Predicting Continuous Target Variables with Regression Analysis 274 As we can see, the Total Bsmt SF feature variable contains one missing value. Since we have a relatively large dataset, the easiest way to deal with this missing feature value is to remove the corresponding example from the dataset (for alternative methods, please see Chapter 4): >>> df = df.dropna(axis= 0) >>> df.isnull(). sum() Overall Qual 0 Overall Cond 0 Total Bsmt SF 0 Central Air 0 Gr Liv Area 0 SalePrice 0 dtype: int64 Visualizing the important characteristics of a dataset Exploratory data analysis (EDA ) is an important and recommended first step prior to the training of a machine learning model. In the rest of this section, we will use some simple yet useful techniques from the graphical EDA toolbox that may help us to visually detect the presence of outliers, the dis- tribution of the data, and the relationships between features. First, we will create a scatterplot matrix that allows us to visualize the pair-wise correlations be - tween the different features in this dataset in one place. To plot the scatterplot matrix, we will use the scatterplotmatrix function from the mlxtend library ( http://rasbt.github.io/mlxtend/ ), which is a Python library that contains various convenience functions for machine learning and data science applications in Python. You can install the mlxtend package via conda install mlxtend or pip install mlxtend . For this chapter, we used mlxtend version 0.19.0. Once the installation is complete, you can import the package and create the scatterplot matrix as follows: >>> import matplotlib.pyplot as plt >>> from mlxtend.plotting import scatterplotmatrix >>> scatterplotmatrix(df.values, figsize=( 12, 10), ... names=df.columns, alpha= 0.5) >>> plt.tight_layout() plt.show() Chapter 9 275 As you can see in Figure 9.4, the scatterplot matrix provides us with a useful graphical summary of the relationships in a dataset: Figure 9.4: A scatterplot matrix of our data Using this scatterplot matrix, we can now quickly see how the data is distributed and whether it con- tains outliers. For example, we can see (fifth column from the left of the bottom row)", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 255, "start_word": 81600, "end_word": 82000, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000256": {"text": ">>> scatterplotmatrix(df.values, figsize=( 12, 10), ... names=df.columns, alpha= 0.5) >>> plt.tight_layout() plt.show() Chapter 9 275 As you can see in Figure 9.4, the scatterplot matrix provides us with a useful graphical summary of the relationships in a dataset: Figure 9.4: A scatterplot matrix of our data Using this scatterplot matrix, we can now quickly see how the data is distributed and whether it con- tains outliers. For example, we can see (fifth column from the left of the bottom row) that there is a somewhat linear relationship between the size of the living area above ground ( Gr Liv Area ) and the sale price ( SalePrice ). Predicting Continuous Target Variables with Regression Analysis 276 Furthermore, we can see in the histogram—the lower-right subplot in the scatterplot matrix—that the SalePrice variable seems to be skewed by several outliers. Looking at relationships using a correlation matrix In the previous section, we visualized the data distributions of the Ames Housing dataset variables in the form of histograms and scatterplots. Next, we will create a correlation matrix to quantify and summarize linear relationships between variables. A correlation matrix is closely related to the covari - ance matrix that we covered in the section Unsupervised dimensionality reduction via principal component analysis in Chapter 5, Compressing Data via Dimensionality Reduction. We can interpret the correlation matrix as being a rescaled version of the covariance matrix. In fact, the correlation matrix is identical to a covariance matrix computed from standardized features. The correlation matrix is a square matrix that contains the Pearson product-moment correlation coefficient (often abbreviated as Pearson’s r), which measures the linear dependence between pairs of features. The correlation coefficients are in the range –1 to 1. Two features have a perfect positive correlation if r = 1, no correlation if r = 0, and a perfect negative correlation if r = –1. As mentioned previously, Pearson’s correlation coefficient can simply be calculated as the covariance between two features, x and y (numerator), divided by the product of their standard deviations (denominator): 𝑟𝑟𝑟∑ [(𝑥𝑥(𝑖𝑖𝑖−𝜇𝜇 𝑥𝑥𝑖(𝑦𝑦(𝑖𝑖𝑖−𝜇𝜇 𝑦𝑦)]𝑛𝑛 𝑖𝑖𝑖𝑖 √∑ (𝑥𝑥(𝑖𝑖𝑖−𝜇𝜇 𝑥𝑥𝑖2 𝑛𝑛 𝑖𝑖𝑖𝑖 √∑ (𝑦𝑦(𝑖𝑖𝑖−𝜇𝜇 𝑦𝑦)2𝑛𝑛 𝑖𝑖𝑖𝑖𝑟𝜎𝜎𝑥𝑥𝑦𝑦 𝜎𝜎𝑥𝑥𝜎𝜎𝑦𝑦 Here, 𝜇𝜇 denotes the mean of the corresponding feature, 𝜎𝜎𝑥𝑥𝑥𝑥 is the covariance between the features x and y, and 𝜎𝜎𝑥𝑥 and 𝜎𝜎𝑦𝑦 are the features’ standard deviations.The normality assumption of linear regression Note that in contrast to common belief, training a linear regression model does", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 256, "start_word": 81920, "end_word": 82320, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000257": {"text": "as the covariance between two features, x and y (numerator), divided by the product of their standard deviations (denominator): 𝑟𝑟𝑟∑ [(𝑥𝑥(𝑖𝑖𝑖−𝜇𝜇 𝑥𝑥𝑖(𝑦𝑦(𝑖𝑖𝑖−𝜇𝜇 𝑦𝑦)]𝑛𝑛 𝑖𝑖𝑖𝑖 √∑ (𝑥𝑥(𝑖𝑖𝑖−𝜇𝜇 𝑥𝑥𝑖2 𝑛𝑛 𝑖𝑖𝑖𝑖 √∑ (𝑦𝑦(𝑖𝑖𝑖−𝜇𝜇 𝑦𝑦)2𝑛𝑛 𝑖𝑖𝑖𝑖𝑟𝜎𝜎𝑥𝑥𝑦𝑦 𝜎𝜎𝑥𝑥𝜎𝜎𝑦𝑦 Here, 𝜇𝜇 denotes the mean of the corresponding feature, 𝜎𝜎𝑥𝑥𝑥𝑥 is the covariance between the features x and y, and 𝜎𝜎𝑥𝑥 and 𝜎𝜎𝑦𝑦 are the features’ standard deviations.The normality assumption of linear regression Note that in contrast to common belief, training a linear regression model does not re - quire that the explanatory or target variables are normally distributed. The normality assumption is only a requirement for certain statistics and hypothesis tests that are beyond the scope of this book (for more information on this topic, please refer to Introduction to Linear Regression Analysis by Douglas C. Montgomery, Elizabeth A. Peck, and G. Geoffrey Vining, Wiley, pages: 318-319, 2012). Chapter 9 277 In the following code example, we will use NumPy’s corrcoef function on the five feature columns that we previously visualized in the scatterplot matrix, and we will use mlxtend’s heatmap function to plot the correlation matrix array as a heat map: >>> import numpy as np >>> from mlxtend.plotting import heatmap >>> cm = np.corrcoef(df.values.T) >>> hm = heatmap(cm, row_names=df.columns, column_names=df.columns) >>> plt.tight_layout() >>> plt.show() Covariance versus correlation for standardized features We can show that the covariance between a pair of standardized features is, in fact, equal to their linear correlation coefficient. To show this, let’s first standardize the features x and y to obtain their z-scores, which we will denote as x’ and y’, respectively: 𝑥𝑥′=𝑥𝑥𝑥𝑥𝑥 𝑥𝑥 𝜎𝜎𝑥𝑥, 𝑦𝑦′=𝑦𝑦𝑥𝑥𝑥 𝑦𝑦 𝜎𝜎𝑦𝑦 Remember that we compute the (population) covariance between two features as follows: 𝜎𝜎𝑥𝑥𝑥𝑥=1 𝑛𝑛∑(𝑥𝑥(𝑖𝑖𝑖−𝜇𝜇𝑥𝑥)(𝑦𝑦(𝑖𝑖𝑖−𝜇𝜇𝑥𝑥)𝑛𝑛 𝑖𝑖 Since standardization centers a feature variable at mean zero, we can now calculate the covariance between the scaled features as follows: 𝜎𝜎𝜎𝑥𝑥𝑥𝑥=1 𝑛𝑛∑(𝑥𝑥𝜎(𝑖𝑖𝑖−0)(𝑦𝑦𝜎(𝑖𝑖𝑖−0)𝑛𝑛 𝑖𝑖 Through resubstitution, we then get the following result: 𝜎𝜎𝜎𝑥𝑥𝑥𝑥=1 𝑛𝑛∑(𝑥𝑥𝑥𝑥𝑥 𝑥𝑥 𝜎𝜎𝑥𝑥)(𝑦𝑦𝑥𝑥𝑥 𝑥𝑥 𝜎𝜎𝑥𝑥)𝑛𝑛 𝑖𝑖 𝜎𝜎𝜎𝑥𝑥𝑥𝑥=1 𝑛𝑛𝑛𝜎𝜎 𝑥𝑥𝜎𝜎𝑥𝑥∑(𝑥𝑥(𝑖𝑖𝑖𝑥𝑥𝑥 𝑥𝑥)(𝑦𝑦(𝑖𝑖𝑖𝑥𝑥𝑥 𝑥𝑥)𝑛𝑛 𝑖𝑖 Finally, we can simplify this equation as follows: 𝜎𝜎′𝑥𝑥𝑥𝑥=𝜎𝜎𝑥𝑥𝑥𝑥 𝜎𝜎𝑥𝑥𝜎𝜎𝑥𝑥 Predicting Continuous Target Variables with Regression Analysis 278 As you can see in Figure 9.5, the correlation matrix provides us with another useful summary graphic that can help us to select features based on their respective linear correlations: Figure 9.5: A correlation matrix of the selected variables To fit a linear regression model, we are interested in those features that have a", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 257, "start_word": 82240, "end_word": 82640, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000258": {"text": "𝜎𝜎𝑥𝑥)𝑛𝑛 𝑖𝑖 𝜎𝜎𝜎𝑥𝑥𝑥𝑥=1 𝑛𝑛𝑛𝜎𝜎 𝑥𝑥𝜎𝜎𝑥𝑥∑(𝑥𝑥(𝑖𝑖𝑖𝑥𝑥𝑥 𝑥𝑥)(𝑦𝑦(𝑖𝑖𝑖𝑥𝑥𝑥 𝑥𝑥)𝑛𝑛 𝑖𝑖 Finally, we can simplify this equation as follows: 𝜎𝜎′𝑥𝑥𝑥𝑥=𝜎𝜎𝑥𝑥𝑥𝑥 𝜎𝜎𝑥𝑥𝜎𝜎𝑥𝑥 Predicting Continuous Target Variables with Regression Analysis 278 As you can see in Figure 9.5, the correlation matrix provides us with another useful summary graphic that can help us to select features based on their respective linear correlations: Figure 9.5: A correlation matrix of the selected variables To fit a linear regression model, we are interested in those features that have a high correlation with our target variable, SalePrice . Looking at the previous correlation matrix, we can see that SalePrice shows the largest correlation with the Gr Liv Area variable ( 0.71 ), which seems to be a good choice for an exploratory variable to introduce the concepts of a simple linear regression model in the fol- lowing section. Implementing an ordinary least squares linear regression model At the beginning of this chapter, we mentioned that linear regression can be understood as obtaining the best-fitting straight line through the examples of our training data. However, we have neither defined the term best-fitting nor have we discussed the different techniques of fitting such a model. In the following subsections, we will fill in the missing pieces of this puzzle using the ordinary least squares (OLS ) method (sometimes also called linear least squares) to estimate the parameters of the linear regression line that minimizes the sum of the squared vertical distances (residuals or errors) to the training examples. Solving regression for regression parameters with gradient descent Consider our implementation of the Adaptive Linear Neuron ( Adaline) from Chapter 2, Training Simple Machine Learning Algorithms for Classification. You will remember that the artificial neuron uses a linear activation function. Also, we defined a loss function, L(w), which we minimized to learn the weights via optimization algorithms, such as gradient descent (GD ) and stochastic gradient descent (SGD ). Chapter 9 279 This loss function in Adaline is the mean squared error (MSE ), which is identical to the loss function that we use for OLS: 𝐿𝐿(𝒘𝒘𝒘 𝒘𝒘 )=1 2𝑛𝑛∑(𝑦𝑦(𝑖𝑖)− 𝑦𝑦𝑦(𝑖𝑖))2 𝑛𝑛 𝑖𝑖𝑖𝑖 Here, 𝑦𝑦𝑦 is the predicted value 𝑦𝑦𝑦 𝑦 𝑦𝑦𝑇𝑇𝒙𝒙𝒙𝒙𝒙𝒙𝒙 (note that the term 1 2 is just used for convenience to derive the update rule of GD). Essentially, OLS regression can be understood as Adaline without the threshold function so that we obtain continuous target values instead of the class labels", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 258, "start_word": 82560, "end_word": 82960, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000259": {"text": "function in Adaline is the mean squared error (MSE ), which is identical to the loss function that we use for OLS: 𝐿𝐿(𝒘𝒘𝒘 𝒘𝒘 )=1 2𝑛𝑛∑(𝑦𝑦(𝑖𝑖)− 𝑦𝑦𝑦(𝑖𝑖))2 𝑛𝑛 𝑖𝑖𝑖𝑖 Here, 𝑦𝑦𝑦 is the predicted value 𝑦𝑦𝑦 𝑦 𝑦𝑦𝑇𝑇𝒙𝒙𝒙𝒙𝒙𝒙𝒙 (note that the term 1 2 is just used for convenience to derive the update rule of GD). Essentially, OLS regression can be understood as Adaline without the threshold function so that we obtain continuous target values instead of the class labels 0 and 1. To demonstrate this, let’s take the GD implementation of Adaline from Chapter 2 and remove the threshold function to implement our first linear regression model: class LinearRegressionGD : def __init__ (self, eta= 0.01, n_iter= 50, random_state= 1): self.eta = eta self.n_iter = n_iter self.random_state = random_state def fit(self, X, y): rgen = np.random.RandomState(self.random_state) self.w_ = rgen.normal(loc= 0.0, scale= 0.01, size=X.shape[ 1]) self.b_ = np.array([ 0.]) self.losses_ = [] for i in range (self.n_iter): output = self.net_input(X) errors = (y - output) self.w_ += self.eta * 2.0 * X.T.dot(errors) / X.shape[ 0] self.b_ += self.eta * 2.0 * errors.mean() loss = (errors** 2).mean() self.losses_.append(loss) return self def net_input (self, X): return np.dot(X, self.w_) + self.b_ def predict (self, X): return self.net_input(X) Predicting Continuous Target Variables with Regression Analysis 280 To see our LinearRegressionGD regressor in action, let’s use the Gr Living Area (size of the living area above ground in square feet) feature from the Ames Housing dataset as the explanatory variable and train a model that can predict SalePrice . Furthermore, we will standardize the variables for better convergence of the GD algorithm. The code is as follows: >>> X = df[[ 'Gr Liv Area' ]].values >>> y = df[ 'SalePrice' ].values >>> from sklearn.preprocessing import StandardScaler >>> sc_x = StandardScaler() >>> sc_y = StandardScaler() >>> X_std = sc_x.fit_transform(X) >>> y_std = sc_y.fit_transform(y[:, np.newaxis]).flatten() >>> lr = LinearRegressionGD(eta= 0.1) >>> lr.fit(X_std, y_std) Notice the workaround regarding y_std , using np.newaxis and flatten . Most data preprocessing classes in scikit-learn expect data to be stored in two-dimensional arrays. In the previous code ex - ample, the use of np.newaxis in y[:, np.newaxis] added a new dimension to the array. Then, after StandardScaler returned the scaled variable, we converted it back to the original one-dimensional array representation using the flatten() method for our convenience. We discussed in Chapter 2 that it is always a good idea to plot the", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 259, "start_word": 82880, "end_word": 83280, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000260": {"text": ", using np.newaxis and flatten . Most data preprocessing classes in scikit-learn expect data to be stored in two-dimensional arrays. In the previous code ex - ample, the use of np.newaxis in y[:, np.newaxis] added a new dimension to the array. Then, after StandardScaler returned the scaled variable, we converted it back to the original one-dimensional array representation using the flatten() method for our convenience. We discussed in Chapter 2 that it is always a good idea to plot the loss as a function of the number of epochs (complete iterations) over the training dataset when we are using optimization algorithms, such as GD, to check that the algorithm converged to a loss minimum (here, a global loss minimum): >>> plt.plot( range(1, lr.n_iter+ 1), lr.losses_) >>> plt.ylabel( 'MSE') >>> plt.xlabel( 'Epoch') >>> plt.show()Weight updates with gradient descent If you need a refresher about how the weights are updated—taking a step in the opposite direction of the gradient—please revisit the Adaptive linear neurons and the convergence of learning section in Chapter 2. Chapter 9 281 As you can see in Figure 9.6, the GD algorithm converged approximately after the tenth epoch: Figure 9.6: The loss function versus the number of epochs Next, let’s visualize how well the linear regression line fits the training data. To do so, we will define a simple helper function that will plot a scatterplot of the training examples and add the regression line: >>> def lin_regplot (X, y, model): ... plt.scatter(X, y, c= 'steelblue' , edgecolor= 'white', s=70) ... plt.plot(X, model.predict(X), color= 'black', lw=2) Now, we will use this lin_regplot function to plot the living area against the sale price: >>> lin_regplot(X_std, y_std, lr) >>> plt.xlabel( ' Living area above ground (standardized)' ) >>> plt.ylabel( 'Sale price (standardized)' ) >>> plt.show() Predicting Continuous Target Variables with Regression Analysis 282 As you can see in Figure 9.7, the linear regression line reflects the general trend that house prices tend to increase with the size of the living area: Figure 9.7: A linear regression plot of sale prices versus living area size Although this observation makes sense, the data also tells us that the living area size does not explain house prices very well in many cases. Later in this chapter, we will discuss how to quantify the per - formance of a regression model. Interestingly, we can also observe several outliers, for example, the three data points", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 260, "start_word": 83200, "end_word": 83600, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000261": {"text": "prices tend to increase with the size of the living area: Figure 9.7: A linear regression plot of sale prices versus living area size Although this observation makes sense, the data also tells us that the living area size does not explain house prices very well in many cases. Later in this chapter, we will discuss how to quantify the per - formance of a regression model. Interestingly, we can also observe several outliers, for example, the three data points corresponding to a standardized living area greater than 6. We will discuss how we can deal with outliers later in this chapter. In certain applications, it may also be important to report the predicted outcome variables on their original scale. To scale the predicted price back onto the original price in U.S. dollars scale, we can simply apply the inverse_transform method of StandardScaler : >>> feature_std = sc_x.transform(np.array([[ 2500]])) >>> target_std = lr.predict(feature_std) >>> target_reverted = sc_y.inverse_transform(target_std.reshape(- 1, 1)) >>> print(f'Sales price: $ {target_reverted.flatten()[ 0]:.2f}') Sales price: $ 292507.07 Chapter 9 283 In this code example, we used the previously trained linear regression model to predict the price of a house with an aboveground living area of 2,500 square feet. According to our model, such a house will be worth $292,507.07. As a side note, it is also worth mentioning that we technically don’t have to update the intercept pa - rameter (for instance, the bias unit, b) if we are working with standardized variables, since the y axis intercept is always 0 in those cases. We can quickly confirm this by printing the model parameters: >>> print(f'Slope: {lr.w_[0]:.3f}') Slope: 0.707 >>> print(f'Intercept: {lr.b_[0]:.3f}') Intercept: -0.000 Estimating the coefficient of a regression model via scikit-learn In the previous section, we implemented a working model for regression analysis; however, in a real-world application, we may be interested in more efficient implementations. For example, many of scikit-learn’s estimators for regression make use of the least squares implementation in SciPy (scipy.linalg.lstsq ), which, in turn, uses highly optimized code optimizations based on the Linear Algebra Package (LAPACK). The linear regression implementation in scikit-learn also works (better) with unstandardized variables, since it does not use (S)GD-based optimization, so we can skip the standardization step: >>> from sklearn.linear_model import LinearRegression >>> slr = LinearRegression() >>> slr.fit(X, y) >>> y_pred = slr.predict(X) >>> print(f'Slope: {slr.coef_[ 0]:.3f}') Slope: 111.666 >>> print(f'Intercept: {slr.intercept_: .3f}') Intercept: 13342.979 As you", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 261, "start_word": 83520, "end_word": 83920, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000262": {"text": "of the least squares implementation in SciPy (scipy.linalg.lstsq ), which, in turn, uses highly optimized code optimizations based on the Linear Algebra Package (LAPACK). The linear regression implementation in scikit-learn also works (better) with unstandardized variables, since it does not use (S)GD-based optimization, so we can skip the standardization step: >>> from sklearn.linear_model import LinearRegression >>> slr = LinearRegression() >>> slr.fit(X, y) >>> y_pred = slr.predict(X) >>> print(f'Slope: {slr.coef_[ 0]:.3f}') Slope: 111.666 >>> print(f'Intercept: {slr.intercept_: .3f}') Intercept: 13342.979 As you can see from executing this code, scikit-learn’s LinearRegression model, fitted with the un- standardized Gr Liv Area and SalePrice variables, yielded different model coefficients, since the features have not been standardized. However, when we compare it to our GD implementation by plotting SalePrice against Gr Liv Area , we can qualitatively see that it fits the data similarly well: >>> lin_regplot(X, y, slr) >>> plt.xlabel( 'Living area above ground in square feet' ) >>> plt.ylabel( 'Sale price in U.S. dollars' ) >>> plt.tight_layout() >>> plt.show() Predicting Continuous Target Variables with Regression Analysis 284 For instance, we can see that the overall result looks identical to our GD implementation: Figure 9.8: A linear regression plot using scikit-learn Analytical solutions of linear regression As an alternative to using machine learning libraries, there is also a closed-form solution for solving OLS involving a system of linear equations that can be found in most intro - ductory statistics textbooks: 𝑤𝑤 𝑤 𝑤𝑤𝑤𝑇𝑇𝑤𝑤𝑋−1𝑤𝑤𝑇𝑇𝑦𝑦 We can implement it in Python as follows: # adding a column vector of \"ones\" >>> Xb = np.hstack((np.ones((X.shape[ 0], 1)), X)) >>> w = np.zeros(X.shape[ 1]) >>> z = np.linalg.inv(np.dot(Xb.T, Xb)) >>> w = np.dot(z, np.dot(Xb.T, y)) >>> print(f'Slope: {w[1]:.3f}') Slope: 111.666 >>> print(f'Intercept: {w[0]:.3f}') Intercept: 13342.979 Chapter 9 285 Fitting a robust regression model using RANSAC Linear regression models can be heavily impacted by the presence of outliers. In certain situations, a very small subset of our data can have a big effect on the estimated model coefficients. Many statistical tests can be used to detect outliers, but these are beyond the scope of the book. However, removing outliers always requires our own judgment as data scientists as well as our domain knowledge. As an alternative to throwing out outliers, we will look at a robust method of regression using the RANdom SAmple Consensus (RANSAC ) algorithm, which fits a regression model to a subset of the data, the so-called", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 262, "start_word": 83840, "end_word": 84240, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000263": {"text": "a big effect on the estimated model coefficients. Many statistical tests can be used to detect outliers, but these are beyond the scope of the book. However, removing outliers always requires our own judgment as data scientists as well as our domain knowledge. As an alternative to throwing out outliers, we will look at a robust method of regression using the RANdom SAmple Consensus (RANSAC ) algorithm, which fits a regression model to a subset of the data, the so-called inliers. We can summarize the iterative RANSAC algorithm as follows: 1. Select a random number of examples to be inliers and fit the model. 2. Test all other data points against the fitted model and add those points that fall within a us- er-given tolerance to the inliers. 3. Refit the model using all inliers. 4. Estimate the error of the fitted model versus the inliers. 5. Terminate the algorithm if the performance meets a certain user-defined threshold or if a fixed number of iterations was reached; go back to step 1 otherwise.The advantage of this method is that it is guaranteed to find the optimal solution analyti- cally. However, if we are working with very large datasets, it can be computationally too expensive to invert the matrix in this formula (sometimes also called the normal equation), or the matrix containing the training examples may be singular (non-invertible), which is why we may prefer iterative methods in certain cases. If you are interested in more information on how to obtain normal equations, take a look at Dr. Stephen Pollock’s chapter The Classical Linear Regression Model, from his lectures at the University of Leicester, which is available for free at http://www.le.ac.uk/users/ dsgp1/COURSES/MESOMET/ECMETXT/06mesmet.pdf . Also, if you want to compare linear regression solutions obtained via GD, SGD, the closed-form solution, QR factorization, and singular vector decomposition, you can use the LinearRegression class implemented in mlxtend (http://rasbt.github.io/ mlxtend/user_guide/regressor/LinearRegression/), which lets users toggle between these options. Another great library to recommend for regression modeling in Python is statsmodels, which implements more advanced linear regression models, as illustrated at https://www.statsmodels.org/stable/examples/index.html#regression . Predicting Continuous Target Variables with Regression Analysis 286 Let’s now use a linear model in combination with the RANSAC algorithm as implemented in scikit- learn’s RANSACRegressor class: >>> from sklearn.linear_model import RANSACRegressor >>> ransac = RANSACRegressor( ... LinearRegression(), ... max_trials= 100, # default value ... min_samples= 0.95, ... residual_threshold= None, # default value ...", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 263, "start_word": 84160, "end_word": 84560, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000264": {"text": "these options. Another great library to recommend for regression modeling in Python is statsmodels, which implements more advanced linear regression models, as illustrated at https://www.statsmodels.org/stable/examples/index.html#regression . Predicting Continuous Target Variables with Regression Analysis 286 Let’s now use a linear model in combination with the RANSAC algorithm as implemented in scikit- learn’s RANSACRegressor class: >>> from sklearn.linear_model import RANSACRegressor >>> ransac = RANSACRegressor( ... LinearRegression(), ... max_trials= 100, # default value ... min_samples= 0.95, ... residual_threshold= None, # default value ... random_state= 123) >>> ransac.fit(X, y) We set the maximum number of iterations of the RANSACRegressor to 100, and using min_samples=0.95 , we set the minimum number of the randomly chosen training examples to be at least 95 percent of the dataset. By default (via residual_threshold=None ), scikit-learn uses the MAD estimate to select the inlier threshold, where MAD stands for the median absolute deviation of the target values, y. However, the choice of an appropriate value for the inlier threshold is problem-specific, which is one disadvantage of RANSAC. Many different approaches have been developed in recent years to select a good inlier threshold au- tomatically. You can find a detailed discussion in Automatic Estimation of the Inlier Threshold in Robust Multiple Structures Fitting by R. Toldo and A. Fusiello, Springer, 2009 (in Image Analysis and Processing– ICIAP 2009, pages: 123-131). Once we have fitted the RANSAC model, let’s obtain the inliers and outliers from the fitted RANSAC linear regression model and plot them together with the linear fit: >>> inlier_mask = ransac.inlier_mask_ >>> outlier_mask = np.logical_not(inlier_mask) >>> line_X = np.arange( 3, 10, 1) >>> line_y_ransac = ransac.predict(line_X[:, np.newaxis]) >>> plt.scatter(X[inlier_mask], y[inlier_mask], ... c= 'steelblue' , edgecolor= 'white', ... marker= 'o', label= 'Inliers' ) >>> plt.scatter(X[outlier_mask], y[outlier_mask], ... c= 'limegreen' , edgecolor= 'white', ... marker= 's', label= 'Outliers' ) >>> plt.plot(line_X, line_y_ransac, color= 'black', lw=2) >>> plt.xlabel( 'Living area above ground in square feet' ) >>> plt.ylabel( 'Sale price in U.S. dollars' ) >>> plt.legend(loc= 'upper left' ) >>> plt.tight_layout() >>> plt.show() Chapter 9 287 As you can see in Figure 9.9, the linear regression model was fitted on the detected set of inliers, which are shown as circles: Figure 9.9: Inliers and outliers identified via a RANSAC linear regression model When we print the slope and intercept of the model by executing the following code, the linear re - gression line will be slightly different from the fit that we", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 264, "start_word": 84480, "end_word": 84880, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000265": {"text": "dollars' ) >>> plt.legend(loc= 'upper left' ) >>> plt.tight_layout() >>> plt.show() Chapter 9 287 As you can see in Figure 9.9, the linear regression model was fitted on the detected set of inliers, which are shown as circles: Figure 9.9: Inliers and outliers identified via a RANSAC linear regression model When we print the slope and intercept of the model by executing the following code, the linear re - gression line will be slightly different from the fit that we obtained in the previous section without using RANSAC: >>> print(f'Slope: {ransac.estimator_.coef_[ 0]:.3f}') Slope: 106.348 >>> print(f'Intercept: {ransac.estimator_.intercept_: .3f}') Intercept: 20190.093 Remember that we set the residual_threshold parameter to None , so RANSAC was using the MAD to compute the threshold for flagging inliers and outliers. The MAD, for this dataset, can be computed as follows: >>> def mean_absolute_deviation (data): ... return np.mean(np. abs(data - np.mean(data))) >>> mean_absolute_deviation(y) 58269.561754979375 Predicting Continuous Target Variables with Regression Analysis 288 So, if we want to identify fewer data points as outliers, we can choose a residual_threshold value greater than the preceding MAD. For example, Figure 9.10 shows the inliers and outliers of a RANSAC linear regression model with a residual threshold of 65,000: Figure 9.10: Inliers and outliers determined by a RANSAC linear regression model with a larger re - sidual threshold Using RANSAC, we reduced the potential effect of the outliers in this dataset, but we don’t know whether this approach will have a positive effect on the predictive performance for unseen data or not. Thus, in the next section, we will look at different approaches for evaluating a regression model, which is a crucial part of building systems for predictive modeling. Evaluating the performance of linear regression models In the previous section, you learned how to fit a regression model on training data. However, you discovered in previous chapters that it is crucial to test the model on data that it hasn’t seen during training to obtain a more unbiased estimate of its generalization performance. As you may remember from Chapter 6, Learning Best Practices for Model Evaluation and Hyperparam- eter Tuning, we want to split our dataset into separate training and test datasets, where we will use the former to fit the model and the latter to evaluate its performance on unseen data to estimate the generalization performance. Instead of proceeding with the simple regression model, we will now use all", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 265, "start_word": 84800, "end_word": 85200, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000266": {"text": "seen during training to obtain a more unbiased estimate of its generalization performance. As you may remember from Chapter 6, Learning Best Practices for Model Evaluation and Hyperparam- eter Tuning, we want to split our dataset into separate training and test datasets, where we will use the former to fit the model and the latter to evaluate its performance on unseen data to estimate the generalization performance. Instead of proceeding with the simple regression model, we will now use all five features in the dataset and train a multiple regression model: >>> from sklearn.model_selection import train_test_split >>> target = 'SalePrice' >>> features = df.columns[df.columns != target] >>> X = df[features].values >>> y = df[target].values Chapter 9 289 >>> X_train, X_test, y_train, y_test = train_test_split( ... X, y, test_size= 0.3, random_state= 123) >>> slr = LinearRegression() >>> slr.fit(X_train, y_train) >>> y_train_pred = slr.predict(X_train) >>> y_test_pred = slr.predict(X_test) Since our model uses multiple explanatory variables, we can’t visualize the linear regression line (or hyperplane, to be precise) in a two-dimensional plot, but we can plot the residuals (the differences or vertical distances between the actual and predicted values) versus the predicted values to diagnose our regression model. Residual plots are a commonly used graphical tool for diagnosing regression models. They can help to detect nonlinearity and outliers and check whether the errors are randomly distributed. Using the following code, we will now plot a residual plot where we simply subtract the true target variables from our predicted responses: >>> x_max = np. max( ... [np. max(y_train_pred), np. max(y_test_pred)]) >>> x_min = np. min( ... [np. min(y_train_pred), np. min(y_test_pred)]) >>> fig, (ax1, ax2) = plt.subplots( ... 1, 2, figsize=( 7, 3), sharey= True) >>> ax1.scatter( ... y_test_pred, y_test_pred - y_test, ... c='limegreen' , marker= 's', ... edgecolor= 'white', ... label= 'Test data' ) >>> ax2.scatter( ... y_train_pred, y_train_pred - y_train, ... c='steelblue' , marker= 'o', edgecolor= 'white', ... label= 'Training data' ) >>> ax1.set_ylabel( 'Residuals' ) >>> for ax in (ax1, ax2): ... ax.set_xlabel( 'Predicted values' ) ... ax.legend(loc= 'upper left' ) ... ax.hlines(y= 0, xmin=x_min- 100, xmax=x_max+ 100,\\ ... color= 'black', lw=2) >>> plt.tight_layout() >>> plt.show() Predicting Continuous Target Variables with Regression Analysis 290 After executing the code, we should see residual plots for the test and training datasets with a line passing through the x axis origin, as shown in Figure 9.11: Figure 9.11: Residual plots of our data In the", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 266, "start_word": 85120, "end_word": 85520, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000267": {"text": "ax1.set_ylabel( 'Residuals' ) >>> for ax in (ax1, ax2): ... ax.set_xlabel( 'Predicted values' ) ... ax.legend(loc= 'upper left' ) ... ax.hlines(y= 0, xmin=x_min- 100, xmax=x_max+ 100,\\ ... color= 'black', lw=2) >>> plt.tight_layout() >>> plt.show() Predicting Continuous Target Variables with Regression Analysis 290 After executing the code, we should see residual plots for the test and training datasets with a line passing through the x axis origin, as shown in Figure 9.11: Figure 9.11: Residual plots of our data In the case of a perfect prediction, the residuals would be exactly zero, which we will probably never encounter in realistic and practical applications. However, for a good regression model, we would expect the errors to be randomly distributed and the residuals to be randomly scattered around the centerline. If we see patterns in a residual plot, it means that our model is unable to capture some ex - planatory information, which has leaked into the residuals, as you can see to a degree in our previous residual plot. Furthermore, we can also use residual plots to detect outliers, which are represented by the points with a large deviation from the centerline. Another useful quantitative measure of a model’s performance is the mean squared error (MSE ) that we discussed earlier as our loss function that we minimized to fit the linear regression model. The following is a version of the MSE without the 1 2 scaling factor that is often used to simplify the loss derivative in gradient descent: 𝑀𝑀𝑀𝑀𝑀𝑀 𝑀1 𝑛𝑛∑(𝑦𝑦(𝑖𝑖𝑖− 𝑦𝑦𝑦(𝑖𝑖𝑖𝑖2𝑛𝑛 𝑖𝑖𝑖𝑖 Similar to prediction accuracy in classification contexts, we can use the MSE for cross-validation and model selection as discussed in Chapter 6. Like classification accuracy, MSE also normalizes according to the sample size, n. This makes it pos- sible to compare across different sample sizes (for example, in the context of learning curves) as well. Let’s now compute the MSE of our training and test predictions: >>> from sklearn.metrics import mean_squared_error >>> mse_train = mean_squared_error(y_train, y_train_pred) >>> mse_test = mean_squared_error(y_test, y_test_pred) Chapter 9 291 >>> print(f'MSE train: {mse_train:.2f} ') MSE train: 1497216245.85 >>> print(f'MSE test: {mse_test:.2f} ') MSE test: 1516565821.00 We can see that the MSE on the training dataset is larger than on the test set, which is an indicator that our model is slightly overfitting the training data in this case. Note that it can be more intuitive to show the error on the original", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 267, "start_word": 85440, "end_word": 85840, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000268": {"text": "from sklearn.metrics import mean_squared_error >>> mse_train = mean_squared_error(y_train, y_train_pred) >>> mse_test = mean_squared_error(y_test, y_test_pred) Chapter 9 291 >>> print(f'MSE train: {mse_train:.2f} ') MSE train: 1497216245.85 >>> print(f'MSE test: {mse_test:.2f} ') MSE test: 1516565821.00 We can see that the MSE on the training dataset is larger than on the test set, which is an indicator that our model is slightly overfitting the training data in this case. Note that it can be more intuitive to show the error on the original unit scale (here, dollar instead of dollar-squared), which is why we may choose to compute the square root of the MSE, called root mean squared error, or the mean absolute error (MAE ), which emphasizes incorrect prediction slightly less: 𝑀𝑀𝑀𝑀𝑀𝑀𝑀 𝑀𝑀1 𝑛𝑛∑|𝑦𝑦(𝑖𝑖𝑖− 𝑦𝑦𝑦(𝑖𝑖𝑖|𝑛𝑛 𝑖𝑖𝑖𝑖 We can compute the MAE similar to the MSE: >>> from sklearn.metrics import mean_absolute_error >>> mae_train = mean_absolute_error(y_train, y_train_pred) >>> mae_test = mean_absolute_error(y_test, y_test_pred) >>> print(f'MAE train: {mae_train: .2f}') MAE train: 25983.03 >>> print(f'MAE test: {mae_test: .2f}') MAE test: 24921.29 Based on the test set MAE, we can say that the model makes an error of approximately $25,000 on average. When we use the MAE or MSE for comparing models, we need to be aware that these are unbounded in contrast to the classification accuracy, for example. In other words, the interpretations of the MAE and MSE depend on the dataset and feature scaling. For example, if the sale prices were presented as multiples of 1,000 (with the K suffix), the same model would yield a lower MAE compared to a model that worked with unscaled features. To further illustrate this point, |$500K − 550K| < |$500, 000 − 550, 000 | Thus, it may sometimes be more useful to report the coefficient of determination (R2), which can be understood as a standardized version of the MSE, for better interpretability of the model’s perfor - mance. Or, in other words, R2 is the fraction of response variance that is captured by the model. The R2 value is defined as: 𝑅𝑅2=1−𝑆𝑆𝑆𝑆𝑆𝑆 𝑆𝑆𝑆𝑆𝑆𝑆 Predicting Continuous Target Variables with Regression Analysis 292 Here, SSE is the sum of squared errors, which is similar to the MSE but does not include the normal- ization by sample size n: 𝑆𝑆𝑆𝑆𝑆𝑆 = ∑(𝑦𝑦(𝑖𝑖)− 𝑦𝑦𝑦(𝑖𝑖))2 𝑛𝑛 𝑖𝑖𝑖𝑖 And SST is the total sum of squares: 𝑆𝑆𝑆𝑆𝑆𝑆 = ∑(𝑦𝑦(𝑖𝑖)− 𝜇𝜇 𝑦𝑦)2 𝑛𝑛 𝑖𝑖𝑖𝑖 In other words, SST is simply the variance of the response.", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 268, "start_word": 85760, "end_word": 86160, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000269": {"text": "variance that is captured by the model. The R2 value is defined as: 𝑅𝑅2=1−𝑆𝑆𝑆𝑆𝑆𝑆 𝑆𝑆𝑆𝑆𝑆𝑆 Predicting Continuous Target Variables with Regression Analysis 292 Here, SSE is the sum of squared errors, which is similar to the MSE but does not include the normal- ization by sample size n: 𝑆𝑆𝑆𝑆𝑆𝑆 = ∑(𝑦𝑦(𝑖𝑖)− 𝑦𝑦𝑦(𝑖𝑖))2 𝑛𝑛 𝑖𝑖𝑖𝑖 And SST is the total sum of squares: 𝑆𝑆𝑆𝑆𝑆𝑆 = ∑(𝑦𝑦(𝑖𝑖)− 𝜇𝜇 𝑦𝑦)2 𝑛𝑛 𝑖𝑖𝑖𝑖 In other words, SST is simply the variance of the response. Now, let’s briefly show that R2 is indeed just a rescaled version of the MSE: 𝑅𝑅2= 1−𝑆𝑆𝑆𝑆𝑆𝑆 𝑆𝑆𝑆𝑆𝑆𝑆 =1 𝑛𝑛∑ (𝑦𝑦(𝑖𝑖)− 𝑦𝑦𝑦(𝑖𝑖))2 𝑛𝑛 𝑖𝑖𝑖𝑖 1 𝑛𝑛∑ (𝑦𝑦(𝑖𝑖)− 𝜇𝜇 𝑦𝑦)2 𝑛𝑛 𝑖𝑖𝑖𝑖 = 1−𝑀𝑀𝑆𝑆𝑆𝑆 𝑉𝑉𝑉𝑉𝑉𝑉 (𝑦𝑦) For the training dataset, R2 is bounded between 0 and 1, but it can become negative for the test dataset. A negative R2 means that the regression model fits the data worse than a horizontal line representing the sample mean. (In practice, this often happens in the case of extreme overfitting, or if we forget to scale the test set in the same manner we scaled the training set.) If R2 = 1, the model fits the data perfectly with a corresponding MSE = 0. Evaluated on the training data, the R2 of our model is 0.77, which isn’t great but also not too bad giv - en that we only work with a small set of features. However, the R2 on the test dataset is only slightly smaller, at 0.75, which indicates that the model is only overfitting slightly: >>> from sklearn.metrics import r2_score >>> train_r2 = r2_score(y_train, y_train_pred) >>> test_r2 = r2_score(y_test, y_test_pred) >>> print(f'R^2 train: {train_r2: .3f}, {test_r2: .3f}') R^2 train: 0.77, test: 0.75 Using regularized methods for regression As we discussed in Chapter 3, A Tour of Machine Learning Classifiers Using Scikit-Learn, regularization is one approach to tackling the problem of overfitting by adding additional information and thereby shrinking the parameter values of the model to induce a penalty against complexity. The most popular approaches to regularized linear regression are the so-called ridge regression, least absolute shrinkage and selection operator (LASSO), and elastic net. Chapter 9 293 Ridge regression is an L2 penalized model where we simply add the squared sum of the weights to the MSE loss function: 𝐿𝐿(𝒘𝒘)𝑅𝑅𝑅𝑅𝑅𝑅𝑅𝑅𝑅𝑅 = ∑(𝑦𝑦(𝑅𝑅) − 𝑦𝑦𝑦(𝑅𝑅))2+ 𝜆𝜆𝜆𝜆𝒘𝒘 𝜆𝜆22𝑛𝑛 𝑅𝑅𝑖𝑖 Here, the L2 term is defined as follows: 𝜆𝜆𝜆𝜆𝜆𝜆𝜆𝜆22= 𝜆𝜆 𝜆 𝜆𝜆𝑗𝑗2𝑚𝑚 𝑗𝑗𝑗𝑗 By", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 269, "start_word": 86080, "end_word": 86480, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000270": {"text": "values of the model to induce a penalty against complexity. The most popular approaches to regularized linear regression are the so-called ridge regression, least absolute shrinkage and selection operator (LASSO), and elastic net. Chapter 9 293 Ridge regression is an L2 penalized model where we simply add the squared sum of the weights to the MSE loss function: 𝐿𝐿(𝒘𝒘)𝑅𝑅𝑅𝑅𝑅𝑅𝑅𝑅𝑅𝑅 = ∑(𝑦𝑦(𝑅𝑅) − 𝑦𝑦𝑦(𝑅𝑅))2+ 𝜆𝜆𝜆𝜆𝒘𝒘 𝜆𝜆22𝑛𝑛 𝑅𝑅𝑖𝑖 Here, the L2 term is defined as follows: 𝜆𝜆𝜆𝜆𝜆𝜆𝜆𝜆22= 𝜆𝜆 𝜆 𝜆𝜆𝑗𝑗2𝑚𝑚 𝑗𝑗𝑗𝑗 By increasing the value of hyperparameter 𝜆𝜆 , we increase the regularization strength and thereby shrink the weights of our model. Please note that, as mentioned in Chapter 3, the bias unit b is not regularized. An alternative approach that can lead to sparse models is LASSO. Depending on the regularization strength, certain weights can become zero, which also makes LASSO useful as a supervised feature selection technique: 𝐿𝐿(𝒘𝒘)𝐿𝐿𝐿𝐿𝐿𝐿𝐿𝐿𝐿𝐿 = ∑(𝑦𝑦(𝑖𝑖) − 𝑦𝑦𝑦(𝑖𝑖))2+ 𝜆𝜆𝜆𝜆𝒘𝒘 𝜆𝜆1𝑛𝑛 𝑖𝑖𝑖1 Here, the L1 penalty for LASSO is defined as the sum of the absolute magnitudes of the model weights, as follows: 𝜆𝜆𝜆𝜆𝜆𝜆𝜆𝜆 1= 𝜆𝜆 𝜆𝜆𝜆𝜆 𝑗𝑗𝜆𝑚𝑚 𝑗𝑗𝑗1 However, a limitation of LASSO is that it selects at most n features if m > n, where n is the number of training examples. This may be undesirable in certain applications of feature selection. In practice, however, this property of LASSO is often an advantage because it avoids saturated models. The satura - tion of a model occurs if the number of training examples is equal to the number of features, which is a form of overparameterization. As a consequence, a saturated model can always fit the training data perfectly but is merely a form of interpolation and thus is not expected to generalize well. A compromise between ridge regression and LASSO is elastic net, which has an L1 penalty to generate sparsity and an L2 penalty such that it can be used for selecting more than n features if m > n: 𝐿𝐿(𝒘𝒘)𝐸𝐸𝐸𝐸𝐸𝐸𝐸𝐸𝐸𝐸𝐸𝐸𝐸𝐸𝐸𝐸𝐸𝐸𝐸𝐸𝐸 =𝐸∑(𝑦𝑦(𝐸𝐸)𝐸−𝐸𝑦𝑦 𝑦(𝐸𝐸))2+𝐸𝜆𝜆2||𝒘𝒘||22𝐸+𝐸𝜆𝜆1||𝒘𝒘||1𝑛𝑛 𝐸𝐸𝑖1 Those regularized regression models are all available via scikit-learn, and their usage is similar to the regular regression model except that we have to specify the regularization strength via the parameter 𝜆𝜆 , for example, optimized via k-fold cross-validation. Predicting Continuous Target Variables with Regression Analysis 294 A ridge regression model can be initialized via: >>> from sklearn.linear_model import Ridge >>> ridge = Ridge(alpha= 1.0) Note that the regularization strength", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 270, "start_word": 86400, "end_word": 86800, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000271": {"text": "n features if m > n: 𝐿𝐿(𝒘𝒘)𝐸𝐸𝐸𝐸𝐸𝐸𝐸𝐸𝐸𝐸𝐸𝐸𝐸𝐸𝐸𝐸𝐸𝐸𝐸𝐸𝐸 =𝐸∑(𝑦𝑦(𝐸𝐸)𝐸−𝐸𝑦𝑦 𝑦(𝐸𝐸))2+𝐸𝜆𝜆2||𝒘𝒘||22𝐸+𝐸𝜆𝜆1||𝒘𝒘||1𝑛𝑛 𝐸𝐸𝑖1 Those regularized regression models are all available via scikit-learn, and their usage is similar to the regular regression model except that we have to specify the regularization strength via the parameter 𝜆𝜆 , for example, optimized via k-fold cross-validation. Predicting Continuous Target Variables with Regression Analysis 294 A ridge regression model can be initialized via: >>> from sklearn.linear_model import Ridge >>> ridge = Ridge(alpha= 1.0) Note that the regularization strength is regulated by the parameter alpha , which is similar to the parameter 𝜆𝜆 . Likewise, we can initialize a LASSO regressor from the linear_model submodule: >>> from sklearn.linear_model import Lasso >>> lasso = Lasso(alpha= 1.0) Lastly, the ElasticNet implementation allows us to vary the L1 to L2 ratio: >>> from sklearn.linear_model import ElasticNet >>> elanet = ElasticNet(alpha= 1.0, l1_ratio= 0.5) For example, if we set l1_ratio to 1.0, the ElasticNet regressor would be equal to LASSO regression. For more detailed information about the different implementations of linear regression, please refer to the documentation at http://scikit-learn.org/stable/modules/linear_model.html . Turning a linear regression model into a curve – polynomial regression In the previous sections, we assumed a linear relationship between explanatory and response vari - ables. One way to account for the violation of linearity assumption is to use a polynomial regression model by adding polynomial terms: 𝑦𝑦𝑦𝑦𝑦𝑦𝑦 1𝑥𝑥𝑦𝑥𝑦𝑦𝑦2𝑥𝑥2𝑥𝑦…𝑦𝑥𝑦𝑦𝑦𝑑𝑑𝑥𝑥𝑑𝑑𝑥𝑦𝑏𝑏 Here, d denotes the degree of the polynomial. Although we can use polynomial regression to model a nonlinear relationship, it is still considered a multiple linear regression model because of the linear regression coefficients, w. In the following subsections, we will see how we can add such polynomial terms to an existing dataset conveniently and fit a polynomial regression model. Adding polynomial terms using scikit-learn We will now learn how to use the PolynomialFeatures transformer class from scikit-learn to add a quadratic term (d = 2) to a simple regression problem with one explanatory variable. Then, we will compare the polynomial to the linear fit by following these steps: Chapter 9 295 1. Add a second-degree polynomial term: >>> from sklearn.preprocessing import PolynomialFeatures >>> X = np.array([ 258.0, 270.0, 294.0, 320.0, 342.0, ... 368.0, 396.0, 446.0, 480.0, 586.0])\\ ... [:, np.newaxis] >>> y = np.array([ 236.4, 234.4, 252.8, 298.6, 314.2, ... 342.2, 360.8, 368.0, 391.2, 390.8]) >>> lr = LinearRegression() >>> pr = LinearRegression() >>> quadratic = PolynomialFeatures(degree= 2) >>> X_quad = quadratic.fit_transform(X)", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 271, "start_word": 86720, "end_word": 87120, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000272": {"text": "explanatory variable. Then, we will compare the polynomial to the linear fit by following these steps: Chapter 9 295 1. Add a second-degree polynomial term: >>> from sklearn.preprocessing import PolynomialFeatures >>> X = np.array([ 258.0, 270.0, 294.0, 320.0, 342.0, ... 368.0, 396.0, 446.0, 480.0, 586.0])\\ ... [:, np.newaxis] >>> y = np.array([ 236.4, 234.4, 252.8, 298.6, 314.2, ... 342.2, 360.8, 368.0, 391.2, 390.8]) >>> lr = LinearRegression() >>> pr = LinearRegression() >>> quadratic = PolynomialFeatures(degree= 2) >>> X_quad = quadratic.fit_transform(X) 2. Fit a simple linear regression model for comparison: >>> lr.fit(X, y) >>> X_fit = np.arange( 250, 600, 10)[:, np.newaxis] >>> y_lin_fit = lr.predict(X_fit) 3. Fit a multiple regression model on the transformed features for polynomial regression: >>> pr.fit(X_quad, y) >>> y_quad_fit = pr.predict(quadratic.fit_transform(X_fit)) 4. Plot the results: >>> plt.scatter(X, y, label= 'Training points' ) >>> plt.plot(X_fit, y_lin_fit, ... label= 'Linear fit' , linestyle= '--') >>> plt.plot(X_fit, y_quad_fit, ... label= 'Quadratic fit' ) >>> plt.xlabel( 'Explanatory variable' ) >>> plt.ylabel( 'Predicted or known target values' ) >>> plt.legend(loc= 'upper left' ) >>> plt.tight_layout() >>> plt.show() Predicting Continuous Target Variables with Regression Analysis 296 In the resulting plot, you can see that the polynomial fit captures the relationship between the response and explanatory variables much better than the linear fit: Figure 9.12: A comparison of a linear and quadratic model Next, we will compute the MSE and R2 evaluation metrics: >>> y_lin_pred = lr.predict(X) >>> y_quad_pred = pr.predict(X_quad) >>> mse_lin = mean_squared_error(y, y_lin_pred) >>> mse_quad = mean_squared_error(y, y_quad_pred) >>> print(f'Training MSE linear: {mse_lin: .3f}' f', quadratic: {mse_quad:.3f}') Training MSE linear: 569.780, quadratic: 61.330 >>> r2_lin = r2_score(y, y_lin_pred) >>> r2_quad = r2_score(y, y_quad_pred) >>> print(f'Training R^2 linear: {r2_lin: .3f}' f', quadratic: {r2_quad:.3f}') Training R^2 linear: 0.832, quadratic: 0.982 As you can see after executing the code, the MSE decreased from 570 (linear fit) to 61 (quadratic fit); also, the coefficient of determination reflects a closer fit of the quadratic model (R2 = 0.982) as opposed to the linear fit (R2 = 0.832) in this particular toy problem. Chapter 9 297 Modeling nonlinear relationships in the Ames Housing dataset In the preceding subsection, you learned how to construct polynomial features to fit nonlinear relation - ships in a toy problem; let’s now take a look at a more concrete example and apply those concepts to the data in the Ames Housing dataset. By executing the following code, we will model the relationship", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 272, "start_word": 87040, "end_word": 87440, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000273": {"text": "= 0.982) as opposed to the linear fit (R2 = 0.832) in this particular toy problem. Chapter 9 297 Modeling nonlinear relationships in the Ames Housing dataset In the preceding subsection, you learned how to construct polynomial features to fit nonlinear relation - ships in a toy problem; let’s now take a look at a more concrete example and apply those concepts to the data in the Ames Housing dataset. By executing the following code, we will model the relationship between sale prices and the living area above ground using second-degree (quadratic) and third-degree (cubic) polynomials and compare that to a linear fit. We start by removing the three outliers with a living area greater than 4,000 square feet, which we can see in previous figures, such as in Figure 9.8, so that these outliers don’t skew our regression fits: >>> X = df[[ 'Gr Liv Area' ]].values >>> y = df[ 'SalePrice' ].values >>> X = X[(df[ 'Gr Liv Area' ] < 4000)] >>> y = y[(df[ 'Gr Liv Area' ] < 4000)] Next, we fit the regression models: >>> regr = LinearRegression() >>> # create quadratic and cubic features >>> quadratic = PolynomialFeatures(degree= 2) >>> cubic = PolynomialFeatures(degree= 3) >>> X_quad = quadratic.fit_transform(X) >>> X_cubic = cubic.fit_transform(X) >>> # fit to features >>> X_fit = np.arange(X. min()-1, X.max()+2, 1)[:, np.newaxis] >>> regr = regr.fit(X, y) >>> y_lin_fit = regr.predict(X_fit) >>> linear_r2 = r2_score(y, regr.predict(X)) >>> regr = regr.fit(X_quad, y) >>> y_quad_fit = regr.predict(quadratic.fit_transform(X_fit)) >>> quadratic_r2 = r2_score(y, regr.predict(X_quad)) >>> regr = regr.fit(X_cubic, y) >>> y_cubic_fit = regr.predict(cubic.fit_transform(X_fit)) >>> cubic_r2 = r2_score(y, regr.predict(X_cubic)) >>> # plot results >>> plt.scatter(X, y, label= 'Training points' , color= 'lightgray' ) >>> plt.plot(X_fit, y_lin_fit, ... label= f'Linear (d=1), $R^2$= {linear_r2: .2f}', Predicting Continuous Target Variables with Regression Analysis 298 ... color= 'blue', ... lw= 2, ... linestyle= ':') >>> plt.plot(X_fit, y_quad_fit, ... label= f'Quadratic (d=2), $R^2$= {quadratic_r2: .2f}', ... color= 'red', ... lw= 2, ... linestyle= '-') >>> plt.plot(X_fit, y_cubic_fit, ... label= f'Cubic (d=3), $R^2$= {cubic_r2: .2f}', ... color= 'green', ... lw=2, ... linestyle= '--') >>> plt.xlabel( 'Living area above ground in square feet' ) >>> plt.ylabel( 'Sale price in U.S. dollars' ) >>> plt.legend(loc= 'upper left' ) >>> plt.show() The resulting plot is shown in Figure 9.13: Figure 9.13: A comparison of different curves fitted to the sale price and living area data Chapter 9 299 As we can see, using quadratic", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 273, "start_word": 87360, "end_word": 87760, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000274": {"text": "2, ... linestyle= '-') >>> plt.plot(X_fit, y_cubic_fit, ... label= f'Cubic (d=3), $R^2$= {cubic_r2: .2f}', ... color= 'green', ... lw=2, ... linestyle= '--') >>> plt.xlabel( 'Living area above ground in square feet' ) >>> plt.ylabel( 'Sale price in U.S. dollars' ) >>> plt.legend(loc= 'upper left' ) >>> plt.show() The resulting plot is shown in Figure 9.13: Figure 9.13: A comparison of different curves fitted to the sale price and living area data Chapter 9 299 As we can see, using quadratic or cubic features does not really have an effect. That’s because the relationship between the two variables appears to be linear. So, let’s take a look at another feature, namely, Overall Qual . The Overall Qual variable rates the overall quality of the material and finish of the houses and is given on a scale from 1 to 10, where 10 is best: >>> X = df[[ 'Overall Qual' ]].values >>> y = df[ 'SalePrice' ].values After specifying the X and y variables, we can reuse the previous code and obtain the plot in Figure 9.14: Figure 9.14: A linear, quadratic, and cubic fit on the sale price and house quality data As you can see, the quadratic and cubic fits capture the relationship between sale prices and the overall quality of the house better than the linear fit. However, you should be aware that adding more and more polynomial features increases the complexity of a model and therefore increases the chance of overfitting. Thus, in practice, it is always recommended to evaluate the performance of the model on a separate test dataset to estimate the generalization performance. Dealing with nonlinear relationships using random forests In this section, we are going to look at random forest regression, which is conceptually different from the previous regression models in this chapter. A random forest, which is an ensemble of multiple decision trees, can be understood as the sum of piecewise linear functions, in contrast to the global linear and polynomial regression models that we discussed previously. In other words, via the deci- sion tree algorithm, we subdivide the input space into smaller regions that become more manageable. Predicting Continuous Target Variables with Regression Analysis 300 Decision tree regression An advantage of the decision tree algorithm is that it works with arbitrary features and does not re - quire any transformation of the features if we are dealing with nonlinear data because decision", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 274, "start_word": 87680, "end_word": 88080, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000275": {"text": "in contrast to the global linear and polynomial regression models that we discussed previously. In other words, via the deci- sion tree algorithm, we subdivide the input space into smaller regions that become more manageable. Predicting Continuous Target Variables with Regression Analysis 300 Decision tree regression An advantage of the decision tree algorithm is that it works with arbitrary features and does not re - quire any transformation of the features if we are dealing with nonlinear data because decision trees analyze one feature at a time, rather than taking weighted combinations into account. (Likewise, normalizing or standardizing features is not required for decision trees.) As mentioned in Chapter 3, A Tour of Machine Learning Classifiers Using Scikit-Learn, we grow a decision tree by iteratively splitting its nodes until the leaves are pure or a stopping criterion is satisfied. When we used decision trees for classification, we defined entropy as a measure of impurity to determine which feature split maximizes the information gain (IG ), which can be defined as follows for a binary split: 𝐼𝐼𝐼𝐼(𝐷𝐷𝑝𝑝,𝑥𝑥𝑖𝑖) = 𝐼𝐼(𝐷𝐷𝑝𝑝)−𝑁𝑁𝑙𝑙𝑙𝑙𝑙𝑙𝑙𝑙 𝑁𝑁𝑝𝑝𝐼𝐼(𝐷𝐷𝑙𝑙𝑙𝑙𝑙𝑙𝑙𝑙)−𝑁𝑁𝑟𝑟𝑖𝑖𝑟𝑟𝑟𝑙𝑙 𝑁𝑁𝑝𝑝𝐼𝐼(𝐷𝐷𝑟𝑟𝑖𝑖𝑟𝑟𝑟𝑙𝑙) Here, xi is the feature to perform the split, N p is the number of training examples in the parent node, I is the impurity function, D p is the subset of training examples at the parent node, and D left and D right are the subsets of training examples at the left and right child nodes after the split. Remember that our goal is to find the feature split that maximizes the information gain; in other words, we want to find the feature split that reduces the impurities in the child nodes most. In Chapter 3, we discussed Gini impurity and entropy as measures of impurity, which are both useful criteria for classification. To use a decision tree for regression, however, we need an impurity metric that is suitable for continuous variables, so we define the impurity measure of a node, t, as the MSE instead: 𝐼𝐼(𝑡𝑡)= 𝑀𝑀𝑀𝑀𝑀𝑀(𝑡𝑡)=1 𝑁𝑁𝑡𝑡∑(𝑦𝑦(𝑖𝑖)− 𝑦𝑦𝑦𝑡𝑡)2 𝑖𝑖𝑖𝑖𝑖𝑡𝑡 Here, Nt is the number of training examples at node t, Dt is the training subset at node t, 𝑦𝑦(𝑖𝑖𝑖 is the true target value, and 𝑦𝑦𝑡𝑡̂ is the predicted target value (sample mean): 𝑦𝑦𝑦𝑡𝑡=1 𝑁𝑁𝑡𝑡∑𝑦𝑦(𝑖𝑖𝑖 𝑖𝑖𝑖𝑖𝑖𝑡𝑡 In the context of decision tree regression, the MSE is often referred to as within-node variance, which is why the splitting criterion is also better known as variance reduction. To see", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 275, "start_word": 88000, "end_word": 88400, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000276": {"text": "a node, t, as the MSE instead: 𝐼𝐼(𝑡𝑡)= 𝑀𝑀𝑀𝑀𝑀𝑀(𝑡𝑡)=1 𝑁𝑁𝑡𝑡∑(𝑦𝑦(𝑖𝑖)− 𝑦𝑦𝑦𝑡𝑡)2 𝑖𝑖𝑖𝑖𝑖𝑡𝑡 Here, Nt is the number of training examples at node t, Dt is the training subset at node t, 𝑦𝑦(𝑖𝑖𝑖 is the true target value, and 𝑦𝑦𝑡𝑡̂ is the predicted target value (sample mean): 𝑦𝑦𝑦𝑡𝑡=1 𝑁𝑁𝑡𝑡∑𝑦𝑦(𝑖𝑖𝑖 𝑖𝑖𝑖𝑖𝑖𝑡𝑡 In the context of decision tree regression, the MSE is often referred to as within-node variance, which is why the splitting criterion is also better known as variance reduction. To see what the line fit of a decision tree looks like, let’s use the DecisionTreeRegressor implemented in scikit-learn to model the relationship between the SalePrice and Gr Living Area variables. Note that SalePrice and Gr Living Area do not necessarily represent a nonlinear relationship, but this feature combination still demonstrates the general aspects of a regression tree quite nicely: >>> from sklearn.tree import DecisionTreeRegressor >>> X = df[[ 'Gr Liv Area' ]].values >>> y = df[ 'SalePrice' ].values >>> tree = DecisionTreeRegressor(max_depth= 3) >>> tree.fit(X, y) Chapter 9 301 >>> sort_idx = X.flatten().argsort() >>> lin_regplot(X[sort_idx], y[sort_idx], tree) >>> plt.xlabel( 'Living area above ground in square feet' ) >>> plt.ylabel( 'Sale price in U.S. dollars' )>>> plt.show() As you can see in the resulting plot, the decision tree captures the general trend in the data. And we can imagine that a regression tree could also capture trends in nonlinear data relatively well. However, a limitation of this model is that it does not capture the continuity and differentiability of the desired prediction. In addition, we need to be careful about choosing an appropriate value for the depth of the tree so as to not overfit or underfit the data; here, a depth of three seemed to be a good choice. Figure 9.15: A decision tree regression plot You are encouraged to experiment with deeper decision trees. Note that the relationship between Gr Living Area and SalePrice is rather linear, so you are also encouraged to apply the decision tree to the Overall Qual variable instead. In the next section, we will look at a more robust way of fitting regression trees: random forests. Random forest regression As you learned in Chapter 3, the random forest algorithm is an ensemble technique that combines multiple decision trees. A random forest usually has a better generalization performance than an individual decision tree due to randomness, which helps to decrease the model’s variance. Other ad- vantages", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 276, "start_word": 88320, "end_word": 88720, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000277": {"text": "also encouraged to apply the decision tree to the Overall Qual variable instead. In the next section, we will look at a more robust way of fitting regression trees: random forests. Random forest regression As you learned in Chapter 3, the random forest algorithm is an ensemble technique that combines multiple decision trees. A random forest usually has a better generalization performance than an individual decision tree due to randomness, which helps to decrease the model’s variance. Other ad- vantages of random forests are that they are less sensitive to outliers in the dataset and don’t require much parameter tuning. The only parameter in random forests that we typically need to experiment with is the number of trees in the ensemble. The basic random forest algorithm for regression is almost identical to the random forest algorithm for classification that we discussed in Chapter 3. The only difference is that we use the MSE criterion to grow the individual decision trees, and the predicted target variable is calculated as the average prediction across all decision trees. Predicting Continuous Target Variables with Regression Analysis 302 Now, let’s use all the features in the Ames Housing dataset to fit a random forest regression model on 70 percent of the examples and evaluate its performance on the remaining 30 percent, as we have done previously in the Evaluating the performance of linear regression models section. The code is as follows: >>> target = 'SalePrice' >>> features = df.columns[df.columns != target] >>> X = df[features].values >>> y = df[target].values >>> X_train, X_test, y_train, y_test = train_test_split( ... X, y, test_size= 0.3, random_state= 123) >>> from sklearn.ensemble import RandomForestRegressor >>> forest = RandomForestRegressor( ... n_estimators= 1000, ... criterion= 'squared_error' , ... random_state= 1, ... n_jobs=- 1) >>> forest.fit(X_train, y_train) >>> y_train_pred = forest.predict(X_train) >>> y_test_pred = forest.predict(X_test) >>> mae_train = mean_absolute_error(y_train, y_train_pred) >>> mae_test = mean_absolute_error(y_test, y_test_pred) >>> print(f'MAE train: {mae_train: .2f}') MAE train: 8305.18 >>> print(f'MAE test: {mae_test: .2f}') MAE test: 20821.77 >>> r2_train = r2_score(y_train, y_train_pred) >>> r2_test =r2_score(y_test, y_test_pred) >>> print(f'R^2 train: {r2_train: .2f}') R^2 train: 0.98 >>> print(f'R^2 test: {r2_test: .2f}') R^2 test: 0.85 Unfortunately, you can see that the random forest tends to overfit the training data. However, it’s still able to explain the relationship between the target and explanatory variables relatively well ( 𝑅𝑅2= 0.85 on the test dataset). For comparison, the linear model from the previous section, Evaluating the", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 277, "start_word": 88640, "end_word": 89040, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000278": {"text": "print(f'MAE test: {mae_test: .2f}') MAE test: 20821.77 >>> r2_train = r2_score(y_train, y_train_pred) >>> r2_test =r2_score(y_test, y_test_pred) >>> print(f'R^2 train: {r2_train: .2f}') R^2 train: 0.98 >>> print(f'R^2 test: {r2_test: .2f}') R^2 test: 0.85 Unfortunately, you can see that the random forest tends to overfit the training data. However, it’s still able to explain the relationship between the target and explanatory variables relatively well ( 𝑅𝑅2= 0.85 on the test dataset). For comparison, the linear model from the previous section, Evaluating the perfor- mance of linear regression models, which was fit to the same dataset, was overfitting less but performed worse on the test set ( 𝑅𝑅2= 0.75 ). Lastly, let’s also take a look at the residuals of the prediction: >>> x_max = np. max([np.max(y_train_pred), np. max(y_test_pred)]) >>> x_min = np. min([np.min(y_train_pred), np. min(y_test_pred)]) >>> fig, (ax1, ax2) = plt.subplots( 1, 2, figsize=( 7, 3), sharey= True) Chapter 9 303 >>> ax1.scatter(y_test_pred, y_test_pred - y_test, ... c= 'limegreen' , marker= 's', edgecolor= 'white', ... label= 'Test data' ) >>> ax2.scatter(y_train_pred, y_train_pred - y_train, ... c= 'steelblue' , marker= 'o', edgecolor= 'white', ... label= 'Training data' ) >>> ax1.set_ylabel( 'Residuals' ) >>> for ax in (ax1, ax2): ... ax.set_xlabel( 'Predicted values' ) ... ax.legend(loc= 'upper left' ) ... ax.hlines(y= 0, xmin=x_min- 100, xmax=x_max+ 100, ... color= 'black', lw=2) >>> plt.tight_layout() >>> plt.show() As it was already summarized by the R2 coefficient, you can see that the model fits the training data better than the test data, as indicated by the outliers in the y axis direction. Also, the distribution of the residuals does not seem to be completely random around the zero center point, indicating that the model is not able to capture all the exploratory information. However, the residual plot indicates a large improvement over the residual plot of the linear model that we plotted earlier in this chapter. Figure 9.16: The residuals of the random forest regression Predicting Continuous Target Variables with Regression Analysis 304 Ideally, our model error should be random or unpredictable. In other words, the error of the predic- tions should not be related to any of the information contained in the explanatory variables; rather, it should reflect the randomness of the real-world distributions or patterns. If we find patterns in the prediction errors, for example, by inspecting the residual plot, it means that the residual plots contain predictive information. A common reason for this could be", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 278, "start_word": 88960, "end_word": 89360, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000279": {"text": "Variables with Regression Analysis 304 Ideally, our model error should be random or unpredictable. In other words, the error of the predic- tions should not be related to any of the information contained in the explanatory variables; rather, it should reflect the randomness of the real-world distributions or patterns. If we find patterns in the prediction errors, for example, by inspecting the residual plot, it means that the residual plots contain predictive information. A common reason for this could be that explanatory information is leaking into those residuals. Unfortunately, there is not a universal approach for dealing with non-randomness in residual plots, and it requires experimentation. Depending on the data that is available to us, we may be able to improve the model by transforming variables, tuning the hyperparameters of the learning algorithm, choosing simpler or more complex models, removing outliers, or including additional variables. Summary At the beginning of this chapter, you learned about simple linear regression analysis to model the relationship between a single explanatory variable and a continuous response variable. We then dis- cussed a useful explanatory data analysis technique to look at patterns and anomalies in data, which is an important first step in predictive modeling tasks. We built our first model by implementing linear regression using a gradient-based optimization ap - proach. You then saw how to utilize scikit-learn’s linear models for regression and also implement a robust regression technique (RANSAC) as an approach for dealing with outliers. To assess the predictive performance of regression models, we computed the mean sum of squared errors and the related R2 metric. Furthermore, we also discussed a useful graphical approach for diagnosing the problems of regression models: the residual plot. After we explored how regularization can be applied to regression models to reduce the model com- plexity and avoid overfitting, we also covered several approaches for modeling nonlinear relationships, including polynomial feature transformation and random forest regressors. We discussed supervised learning, classification, and regression analysis in detail in the previous chapters. In the next chapter, we are going to learn about another interesting subfield of machine learning, unsupervised learning, and also how to use cluster analysis to find hidden structures in data in the absence of target variables. Join our book’s Discord space Join the book’s Discord workspace for a monthly Ask me Anything session with the authors: https://packt.link/MLwPyTorch 10 Working with Unlabeled Data – Clustering Analysis In", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 279, "start_word": 89280, "end_word": 89680, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000280": {"text": "discussed supervised learning, classification, and regression analysis in detail in the previous chapters. In the next chapter, we are going to learn about another interesting subfield of machine learning, unsupervised learning, and also how to use cluster analysis to find hidden structures in data in the absence of target variables. Join our book’s Discord space Join the book’s Discord workspace for a monthly Ask me Anything session with the authors: https://packt.link/MLwPyTorch 10 Working with Unlabeled Data – Clustering Analysis In the previous chapters, we used supervised learning techniques to build machine learning models, using data where the answer was already known—the class labels were already available in our training data. In this chapter, we will switch gears and explore cluster analysis, a category of unsupervised learning techniques that allows us to discover hidden structures in data where we do not know the right answer upfront. The goal of clustering is to find a natural grouping in data so that items in the same cluster are more similar to each other than to those from different clusters. Given its exploratory nature, clustering is an exciting topic, and in this chapter, you will learn about the following concepts, which can help us to organize data into meaningful structures: • Finding centers of similarity using the popular k-means algorithm • Taking a bottom-up approach to building hierarchical clustering trees • Identifying arbitrary shapes of objects using a density-based clustering approach Grouping objects by similarity using k-means In this section, we will learn about one of the most popular clustering algorithms, k-means, which is widely used in academia as well as in industry. Clustering (or cluster analysis) is a technique that allows us to find groups of similar objects that are more related to each other than to objects in other groups. Examples of business-oriented applications of clustering include the grouping of documents, music, and movies by different topics, or finding customers that share similar interests based on common purchase behaviors as a basis for recommendation engines. k-means clustering using scikit-learn As you will see in a moment, the k-means algorithm is extremely easy to implement, but it is also com - putationally very efficient compared to other clustering algorithms, which might explain its popularity. The k-means algorithm belongs to the category of prototype-based clustering. Working with Unlabeled Data – Clustering Analysis 306 We will discuss two other categories of clustering, hierarchical and density-based", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 280, "start_word": 89600, "end_word": 90000, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000281": {"text": "similar interests based on common purchase behaviors as a basis for recommendation engines. k-means clustering using scikit-learn As you will see in a moment, the k-means algorithm is extremely easy to implement, but it is also com - putationally very efficient compared to other clustering algorithms, which might explain its popularity. The k-means algorithm belongs to the category of prototype-based clustering. Working with Unlabeled Data – Clustering Analysis 306 We will discuss two other categories of clustering, hierarchical and density-based clustering, later in this chapter. Prototype-based clustering means that each cluster is represented by a prototype, which is usually either the centroid (average) of similar points with continuous features, or the medoid (the most representative or the point that minimizes the distance to all other points that belong to a particular cluster) in the case of categorical features. While k-means is very good at identifying clusters with a spherical shape, one of the drawbacks of this clustering algorithm is that we have to specify the number of clusters, k, a priori. An inappropriate choice for k can result in poor clustering performance. Later in this chapter, we will discuss the elbow method and silhouette plots, which are useful techniques to evaluate the quality of a clustering to help us determine the optimal number of clusters, k. Although k-means clustering can be applied to data in higher dimensions, we will walk through the following examples using a simple two-dimensional dataset for the purpose of visualization: >>> from sklearn.datasets import make_blobs >>> X, y = make_blobs(n_samples= 150, ... n_features= 2, ... centers= 3, ... cluster_std= 0.5, ... shuffle= True, ... random_state= 0) >>> import matplotlib.pyplot as plt >>> plt.scatter(X[:, 0], ... X[:, 1], ... c= 'white', ... marker= 'o', ... edgecolor= 'black', ... s= 50) >>> plt.xlabel( 'Feature 1' ) >>> plt.ylabel( 'Feature 2' ) >>> plt.grid() >>> plt.tight_layout() >>> plt.show() Chapter 10 307 The dataset that we just created consists of 150 randomly generated points that are roughly grouped into three regions with higher density, which is visualized via a two-dimensional scatterplot: Figure 10.1: A scatterplot of our unlabeled dataset In real-world applications of clustering, we do not have any ground-truth category information (in- formation provided as empirical evidence as opposed to inference) about those examples; if we were given class labels, this task would fall into the category of supervised learning. Thus, our goal is to group the examples based", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 281, "start_word": 89920, "end_word": 90320, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000282": {"text": "150 randomly generated points that are roughly grouped into three regions with higher density, which is visualized via a two-dimensional scatterplot: Figure 10.1: A scatterplot of our unlabeled dataset In real-world applications of clustering, we do not have any ground-truth category information (in- formation provided as empirical evidence as opposed to inference) about those examples; if we were given class labels, this task would fall into the category of supervised learning. Thus, our goal is to group the examples based on their feature similarities, which can be achieved using the k-means algorithm, as summarized by the following four steps: 1. Randomly pick k centroids from the examples as initial cluster centers 2. Assign each example to the nearest centroid, 𝜇𝜇(𝑗𝑗),𝑗𝑗𝑗{1,…,𝑘𝑘} 3. Move the centroids to the center of the examples that were assigned to it 4. Repeat steps 2 and 3 until the cluster assignments do not change or a user-defined tolerance or maximum number of iterations is reached Now, the next question is, how do we measure similarity between objects? We can define similarity as the opposite of distance, and a commonly used distance for clustering examples with continuous features is the squared Euclidean distance between two points, x and y, in m-dimensional space: 𝑑𝑑(𝒙𝒙𝒙𝒙𝒙)2= ∑(𝑥𝑥 𝑗𝑗−𝑦𝑦𝑗𝑗)2𝑚𝑚 𝑗𝑗𝑗𝑗=‖𝒙𝒙−𝒙𝒙‖22 Working with Unlabeled Data – Clustering Analysis 308 Note that, in the preceding equation, the index j refers to the jth dimension (feature column) of the example inputs, x and y. In the rest of this section, we will use the superscripts i and j to refer to the index of the example (data record) and cluster index, respectively. Based on this Euclidean distance metric, we can describe the k-means algorithm as a simple optimi- zation problem, an iterative approach for minimizing the within-cluster sum of squared errors (SSE ), which is sometimes also called cluster inertia: 𝑆𝑆𝑆𝑆𝑆𝑆=∑∑𝑤𝑤(𝑖𝑖𝑖𝑖𝑖)‖𝒙𝒙(𝑖𝑖)−𝝁𝝁(𝑖𝑖)‖22𝑘𝑘 𝑖𝑖𝑗𝑗𝑛𝑛 𝑖𝑖𝑗𝑗 Here, 𝝁𝝁(𝑗𝑗) is the representative point (centroid) for cluster j. w(i, j) = 1 if the example, x(i), is in cluster j, or 0 otherwise. 𝑤𝑤(𝑖𝑖𝑖𝑖𝑖)={1𝑖 if 𝒙𝒙(𝑖𝑖)∈𝑗𝑗 0𝑖otherwise Now that you have learned how the simple k-means algorithm works, let’s apply it to our example dataset using the KMeans class from scikit-learn’s cluster module: >>> from sklearn.cluster import KMeans >>> km = KMeans(n_clusters= 3, ... init= 'random' , ... n_init= 10, ... max_iter= 300, ... tol= 1e-04, ... random_state= 0) >>> y_km = km.fit_predict(X) Using the preceding code, we set", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 282, "start_word": 90240, "end_word": 90640, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000283": {"text": "j) = 1 if the example, x(i), is in cluster j, or 0 otherwise. 𝑤𝑤(𝑖𝑖𝑖𝑖𝑖)={1𝑖 if 𝒙𝒙(𝑖𝑖)∈𝑗𝑗 0𝑖otherwise Now that you have learned how the simple k-means algorithm works, let’s apply it to our example dataset using the KMeans class from scikit-learn’s cluster module: >>> from sklearn.cluster import KMeans >>> km = KMeans(n_clusters= 3, ... init= 'random' , ... n_init= 10, ... max_iter= 300, ... tol= 1e-04, ... random_state= 0) >>> y_km = km.fit_predict(X) Using the preceding code, we set the number of desired clusters to 3; having to specify the number of clusters a priori is one of the limitations of k-means. We set n_init=10 to run the k-means clustering algorithms 10 times independently, with different random centroids to choose the final model as the one with the lowest SSE. Via the max_iter parameter, we specify the maximum number of iterations for each single run (here, 300). Note that the k-means implementation in scikit-learn stops early if it converges before the maximum number of iterations is reached. However, it is possible that k-means does not reach convergence for a particular run, which can be problematic (computationally expen- sive) if we choose relatively large values for max_iter . One way to deal with convergence problems is to choose larger values for tol, which is a parameter that controls the tolerance with regard to the changes in the within-cluster SSE to declare convergence. In the preceding code, we chose a tolerance of 1e-04 (=0.0001). A problem with k-means is that one or more clusters can be empty. Note that this problem does not exist for k-medoids or fuzzy C-means, an algorithm that we will discuss later in this section. However, this problem is accounted for in the current k-means implementation in scikit-learn. If a cluster is empty, the algorithm will search for the example that is farthest away from the centroid of the empty cluster. Then, it will reassign the centroid to be this farthest point. Chapter 10 309 Having predicted the cluster labels, y_km , and discussed some of the challenges of the k-means algo - rithm, let’s now visualize the clusters that k-means identified in the dataset together with the cluster centroids. These are stored under the cluster_centers_ attribute of the fitted KMeans object: >>> plt.scatter(X[y_km == 0, 0], ... X[y_km == 0, 1], ... s= 50, c='lightgreen' , ... marker= 's', edgecolor= 'black', ... label= 'Cluster 1' )", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 283, "start_word": 90560, "end_word": 90960, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000284": {"text": "to be this farthest point. Chapter 10 309 Having predicted the cluster labels, y_km , and discussed some of the challenges of the k-means algo - rithm, let’s now visualize the clusters that k-means identified in the dataset together with the cluster centroids. These are stored under the cluster_centers_ attribute of the fitted KMeans object: >>> plt.scatter(X[y_km == 0, 0], ... X[y_km == 0, 1], ... s= 50, c='lightgreen' , ... marker= 's', edgecolor= 'black', ... label= 'Cluster 1' ) >>> plt.scatter(X[y_km == 1, 0], ... X[y_km == 1, 1], ... s= 50, c='orange' , ... marker= 'o', edgecolor= 'black', ... label= 'Cluster 2' ) >>> plt.scatter(X[y_km == 2, 0], ... X[y_km == 2, 1], ... s= 50, c='lightblue' , ... marker= 'v', edgecolor= 'black', ... label= 'Cluster 3' ) >>> plt.scatter(km.cluster_centers_[:, 0], ... km.cluster_centers_[:, 1], ... s= 250, marker= '*', ... c= 'red', edgecolor= 'black', ... label= 'Centroids' ) >>> plt.xlabel( 'Feature 1' ) >>> plt.ylabel( 'Feature 2' ) >>> plt.legend(scatterpoints= 1) >>> plt.grid() >>> plt.tight_layout() >>> plt.show()Feature scaling When we are applying k-means to real-world data using a Euclidean distance metric, we want to make sure that the features are measured on the same scale and apply z-score standardization or min-max scaling if necessary. Working with Unlabeled Data – Clustering Analysis 310 In Figure 10.2 , you can see that k-means placed the three centroids at the center of each sphere, which looks like a reasonable grouping given this dataset: Figure 10.2: The k-means clusters and their centroids Although k-means worked well on this toy dataset, we still have the drawback of having to specify the number of clusters, k, a priori. The number of clusters to choose may not always be so obvious in real-world applications, especially if we are working with a higher-dimensional dataset that cannot be visualized. The other properties of k-means are that clusters do not overlap and are not hierar - chical, and we also assume that there is at least one item in each cluster. Later in this chapter, we will encounter different types of clustering algorithms, hierarchical and density-based clustering. Neither type of algorithm requires us to specify the number of clusters upfront or assume spherical structures in our dataset. In the next subsection, we will cover a popular variant of the classic k-means algorithm called k-means++. While it doesn’t address those assumptions and drawbacks of k-means that were discussed in", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 284, "start_word": 90880, "end_word": 91280, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000285": {"text": "we also assume that there is at least one item in each cluster. Later in this chapter, we will encounter different types of clustering algorithms, hierarchical and density-based clustering. Neither type of algorithm requires us to specify the number of clusters upfront or assume spherical structures in our dataset. In the next subsection, we will cover a popular variant of the classic k-means algorithm called k-means++. While it doesn’t address those assumptions and drawbacks of k-means that were discussed in the previous paragraph, it can greatly improve the clustering results through more clever seeding of the initial cluster centers. A smarter way of placing the initial cluster centroids using k-means++ So far, we have discussed the classic k-means algorithm, which uses a random seed to place the initial centroids, which can sometimes result in bad clusterings or slow convergence if the initial centroids are chosen poorly. One way to address this issue is to run the k-means algorithm multiple times on a dataset and choose the best-performing model in terms of the SSE. Chapter 10 311 Another strategy is to place the initial centroids far away from each other via the k-means++ algorithm, which leads to better and more consistent results than the classic k-means (k-means++: The Advantag- es of Careful Seeding by D. Arthur and S. Vassilvitskii in Proceedings of the eighteenth annual ACM-SIAM symposium on Discrete algorithms , pages 1027-1035. Society for Industrial and Applied Mathematics , 2007). The initialization in k-means++ can be summarized as follows: 1. Initialize an empty set, M, to store the k centroids being selected. 2. Randomly choose the first centroid, 𝝁𝝁(𝑗𝑗) , from the input examples and assign it to M. 3. For each example, x(i), that is not in M, find the minimum squared distance, d(x(i), M)2, to any of the centroids in M. 4. To randomly select the next centroid, 𝝁𝝁(𝑝𝑝) , use a weighted probability distribution equal to 𝑑𝑑𝑑𝑑𝑑(𝑝𝑝),𝐌𝐌𝐌2 ∑𝑑𝑑𝑑𝑑𝑑(𝑖𝑖),𝐌𝐌𝐌2 𝑖𝑖 . For instance, we collect all points in an array and choose a weighted random sam- pling, such that the larger the squared distance, the more likely a point gets chosen as the centroid. 5. Repeat steps 3 and 4 until k centroids are chosen. 6. Proceed with the classic k-means algorithm. To use k-means++ with scikit-learn’s KMeans object, we just need to set the init parameter to 'k-means++' . In fact, 'k-means++' is the default argument to", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 285, "start_word": 91200, "end_word": 91600, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000286": {"text": "∑𝑑𝑑𝑑𝑑𝑑(𝑖𝑖),𝐌𝐌𝐌2 𝑖𝑖 . For instance, we collect all points in an array and choose a weighted random sam- pling, such that the larger the squared distance, the more likely a point gets chosen as the centroid. 5. Repeat steps 3 and 4 until k centroids are chosen. 6. Proceed with the classic k-means algorithm. To use k-means++ with scikit-learn’s KMeans object, we just need to set the init parameter to 'k-means++' . In fact, 'k-means++' is the default argument to the init parameter, which is strongly recommended in practice. The only reason we didn’t use it in the previous example was to not introduce too many concepts all at once. The rest of this section on k-means will use k-means++, but you are encouraged to experiment more with the two different approaches (classic k-means via init='random' versus k-means++ via init='k-means++' ) for placing the initial cluster centroids. Hard versus soft clustering Hard clustering describes a family of algorithms where each example in a dataset is assigned to exactly one cluster, as in the k-means and k-means++ algorithms that we discussed earlier in this chapter. In contrast, algorithms for soft clustering (sometimes also called fuzzy clustering) assign an example to one or more clusters. A popular example of soft clustering is the fuzzy C-means (FCM ) algorithm (also called soft k-means or fuzzy k-means). The original idea goes back to the 1970s, when Joseph C. Dunn first proposed an early version of fuzzy clustering to improve k-means (A Fuzzy Relative of the ISODATA Process and Its Use in Detecting Compact Well-Separated Clusters, 1973). Almost a decade later, James C. Bedzek published his work on the improvement of the fuzzy clustering algorithm, which is now known as the FCM algorithm ( Pattern Recognition with Fuzzy Objective Function Algorithms , Springer Science+Business Media, 2013). The FCM procedure is very similar to k-means. However, we replace the hard cluster assignment with probabilities for each point belonging to each cluster. In k-means, we could express the cluster membership of an example, x, with a sparse vector of binary values: [𝑥𝑥𝑥𝑥𝑥(1)→𝑤𝑤(𝑖𝑖𝑖𝑖𝑖)=0 𝑥𝑥𝑥𝑥𝑥(2)→𝑤𝑤(𝑖𝑖𝑖𝑖𝑖)=1 𝑥𝑥𝑥𝑥𝑥(3)→𝑤𝑤(𝑖𝑖𝑖𝑖𝑖)=0] Working with Unlabeled Data – Clustering Analysis 312 Here, the index position with value 1 indicates the cluster centroid, 𝝁𝝁(𝑗𝑗) , that the example is assigned to (assuming k = 3, 𝑗𝑗𝑗{1,2,3} ). In contrast, a membership vector in FCM could be represented as follows: [𝑥𝑥𝑥𝑥𝑥(1)→𝑤𝑤(𝑖𝑖𝑖𝑖𝑖)= 0.1 𝑥𝑥𝑥𝑥𝑥(2)→𝑤𝑤(𝑖𝑖𝑖𝑖𝑖)= 0.85 𝑥𝑥𝑥𝑥𝑥(3)→𝑤𝑤(𝑖𝑖𝑖𝑖𝑖)= 0.05] Here, each", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 286, "start_word": 91520, "end_word": 91920, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000287": {"text": "point belonging to each cluster. In k-means, we could express the cluster membership of an example, x, with a sparse vector of binary values: [𝑥𝑥𝑥𝑥𝑥(1)→𝑤𝑤(𝑖𝑖𝑖𝑖𝑖)=0 𝑥𝑥𝑥𝑥𝑥(2)→𝑤𝑤(𝑖𝑖𝑖𝑖𝑖)=1 𝑥𝑥𝑥𝑥𝑥(3)→𝑤𝑤(𝑖𝑖𝑖𝑖𝑖)=0] Working with Unlabeled Data – Clustering Analysis 312 Here, the index position with value 1 indicates the cluster centroid, 𝝁𝝁(𝑗𝑗) , that the example is assigned to (assuming k = 3, 𝑗𝑗𝑗{1,2,3} ). In contrast, a membership vector in FCM could be represented as follows: [𝑥𝑥𝑥𝑥𝑥(1)→𝑤𝑤(𝑖𝑖𝑖𝑖𝑖)= 0.1 𝑥𝑥𝑥𝑥𝑥(2)→𝑤𝑤(𝑖𝑖𝑖𝑖𝑖)= 0.85 𝑥𝑥𝑥𝑥𝑥(3)→𝑤𝑤(𝑖𝑖𝑖𝑖𝑖)= 0.05] Here, each value falls in the range [0, 1] and represents a probability of membership of the respective cluster centroid. The sum of the memberships for a given example is equal to 1. As with the k-means algorithm, we can summarize the FCM algorithm in four key steps: 1. Specify the number of k centroids and randomly assign the cluster memberships for each point 2. Compute the cluster centroids, 𝝁𝝁(𝑗𝑗),𝑗𝑗𝑗{1,…,𝑘𝑘} 3. Update the cluster memberships for each point 4. Repeat steps 2 and 3 until the membership coefficients do not change or a user-defined tolerance or maximum number of iterations is reached The objective function of FCM—we abbreviate it as J m—looks very similar to the within-cluster SSE that we minimize in k-means: 𝐽𝐽𝑚𝑚=∑∑𝑤𝑤(𝑖𝑖𝑖𝑖𝑖)𝑚𝑚‖𝒙𝒙(𝑖𝑖)−𝝁𝝁(𝑖𝑖)‖22𝑘𝑘 𝑖𝑖𝑗𝑗𝑛𝑛 𝑖𝑖𝑗𝑗 However, note that the membership indicator, w(i, j), is not a binary value as in k-means ( 𝑤𝑤(𝑖𝑖𝑖𝑖𝑖)∈{0𝑖1} ), but a real value that denotes the cluster membership probability ( 𝑤𝑤(𝑖𝑖𝑖𝑖𝑖)∈[0𝑖1] ). You also may have noticed that we added an additional exponent to w(i, j); the exponent m, any number greater than or equal to one (typically m = 2), is the so-called fuzziness coefficient (or simply fuzzifier), which controls the degree of fuzziness. The larger the value of m, the smaller the cluster membership, w(i, j), becomes, which leads to fuzzier clusters. The cluster membership probability itself is calculated as follows: 𝑤𝑤(𝑖𝑖𝑖𝑖𝑖)=[∑(‖𝒙𝒙(𝑖𝑖)−𝝁𝝁(𝑖𝑖)‖2 ‖𝒙𝒙(𝑖𝑖)−𝝁𝝁(𝑐𝑐)‖2)2 𝑚𝑚𝑚𝑚𝑘𝑘 𝑐𝑐𝑐𝑚]𝑚𝑚 For example, if we chose three cluster centers, as in the previous k-means example, we could calculate the membership of 𝒙𝒙(𝑖𝑖) belonging to the 𝝁𝝁(𝑗𝑗) cluster as follows: 𝑤𝑤(𝑖𝑖𝑖𝑖𝑖)=[(‖𝒙𝒙(𝑖𝑖)−𝝁𝝁(𝑖𝑖)‖2 ‖𝒙𝒙(𝑖𝑖)−𝝁𝝁(1)‖2)2 𝑚𝑚𝑚1 +(‖𝒙𝒙(𝑖𝑖)−𝝁𝝁(𝑖𝑖)‖2 ‖𝒙𝒙(𝑖𝑖)−𝝁𝝁(2)‖2)2 𝑚𝑚𝑚1 +(‖𝒙𝒙(𝑖𝑖)−𝝁𝝁(𝑖𝑖)‖2 ‖𝒙𝒙(𝑖𝑖)−𝝁𝝁(3)‖2)2 𝑚𝑚𝑚1 ]𝑚1 Chapter 10 313 The center, 𝝁𝝁(𝑗𝑗) , of a cluster itself is calculated as the mean of all examples weighted by the degree to which each example belongs to that cluster ( 𝑤𝑤(𝑖𝑖𝑖𝑖𝑖)𝑚𝑚 ): 𝝁𝝁(𝑗𝑗)=∑𝑤𝑤(𝑖𝑖𝑖𝑗𝑗)𝑚𝑚𝒙𝒙(𝑖𝑖) 𝑛𝑛 𝑖𝑖𝑖𝑖 ∑𝑤𝑤(𝑖𝑖𝑖𝑗𝑗)𝑚𝑚 𝑛𝑛 𝑖𝑖𝑖𝑖 Just by looking at the equation to calculate the cluster memberships,", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 287, "start_word": 91840, "end_word": 92240, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000288": {"text": "in the previous k-means example, we could calculate the membership of 𝒙𝒙(𝑖𝑖) belonging to the 𝝁𝝁(𝑗𝑗) cluster as follows: 𝑤𝑤(𝑖𝑖𝑖𝑖𝑖)=[(‖𝒙𝒙(𝑖𝑖)−𝝁𝝁(𝑖𝑖)‖2 ‖𝒙𝒙(𝑖𝑖)−𝝁𝝁(1)‖2)2 𝑚𝑚𝑚1 +(‖𝒙𝒙(𝑖𝑖)−𝝁𝝁(𝑖𝑖)‖2 ‖𝒙𝒙(𝑖𝑖)−𝝁𝝁(2)‖2)2 𝑚𝑚𝑚1 +(‖𝒙𝒙(𝑖𝑖)−𝝁𝝁(𝑖𝑖)‖2 ‖𝒙𝒙(𝑖𝑖)−𝝁𝝁(3)‖2)2 𝑚𝑚𝑚1 ]𝑚1 Chapter 10 313 The center, 𝝁𝝁(𝑗𝑗) , of a cluster itself is calculated as the mean of all examples weighted by the degree to which each example belongs to that cluster ( 𝑤𝑤(𝑖𝑖𝑖𝑖𝑖)𝑚𝑚 ): 𝝁𝝁(𝑗𝑗)=∑𝑤𝑤(𝑖𝑖𝑖𝑗𝑗)𝑚𝑚𝒙𝒙(𝑖𝑖) 𝑛𝑛 𝑖𝑖𝑖𝑖 ∑𝑤𝑤(𝑖𝑖𝑖𝑗𝑗)𝑚𝑚 𝑛𝑛 𝑖𝑖𝑖𝑖 Just by looking at the equation to calculate the cluster memberships, we can say that each iteration in FCM is more expensive than an iteration in k-means. On the other hand, FCM typically requires fewer iterations overall to reach convergence. However, it has been found, in practice, that both k-means and FCM produce very similar clustering outputs, as described in a study (Comparative Analysis of k-means and Fuzzy C-Means Algorithms by S. Ghosh and S. K. Dubey, IJACSA, 4: 35–38, 2013). Unfortu- nately, the FCM algorithm is not implemented in scikit-learn currently, but interested readers can try out the FCM implementation from the scikit-fuzzy package, which is available at https://github. com/scikit-fuzzy/scikit-fuzzy . Using the elbow method to find the optimal number of clusters One of the main challenges in unsupervised learning is that we do not know the definitive answer. We don’t have the ground-truth class labels in our dataset that allow us to apply the techniques that we used in Chapter 6, Learning Best Practices for Model Evaluation and Hyperparameter Tuning, to evaluate the performance of a supervised model. Thus, to quantify the quality of clustering, we need to use intrinsic metrics—such as the within-cluster SSE (distortion)—to compare the performance of different k-means clustering models. Conveniently, we don’t need to compute the within-cluster SSE explicitly when we are using scikit-learn, as it is already accessible via the inertia_ attribute after fitting a KMeans model: >>> print(f'Distortion: {km.inertia_: .2f}') Distortion: 72.48 Based on the within-cluster SSE, we can use a graphical tool, the so-called elbow method, to estimate the optimal number of clusters, k, for a given task. We can say that if k increases, the distortion will decrease. This is because the examples will be closer to the centroids they are assigned to. The idea behind the elbow method is to identify the value of k where the distortion begins to increase most rapidly, which will become clearer if we plot the distortion for different values of k: >>> distortions", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 288, "start_word": 92160, "end_word": 92560, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000289": {"text": "tool, the so-called elbow method, to estimate the optimal number of clusters, k, for a given task. We can say that if k increases, the distortion will decrease. This is because the examples will be closer to the centroids they are assigned to. The idea behind the elbow method is to identify the value of k where the distortion begins to increase most rapidly, which will become clearer if we plot the distortion for different values of k: >>> distortions = [] >>> for i in range (1, 11): ... km = KMeans(n_clusters=i, ... init= 'k-means++' , ... n_init= 10, ... max_iter= 300, ... random_state= 0) ... km.fit(X) ... distortions.append(km.inertia_) Working with Unlabeled Data – Clustering Analysis 314 >>> plt.plot( range(1,11), distortions, marker= 'o') >>> plt.xlabel( 'Number of clusters' ) >>> plt.ylabel( 'Distortion' ) >>> plt.tight_layout() >>> plt.show() As you can see in Figure 10.3, the elbow is located at k = 3, so this is supporting evidence that k = 3 is indeed a good choice for this dataset: Figure 10.3: Finding the optimal number of clusters using the elbow method Quantifying the quality of clustering via silhouette plots Another intrinsic metric to evaluate the quality of a clustering is silhouette analysis, which can also be applied to clustering algorithms other than k-means that we will discuss later in this chapter. Sil- houette analysis can be used as a graphical tool to plot a measure of how tightly grouped the examples in the clusters are. To calculate the silhouette coefficient of a single example in our dataset, we can apply the following three steps: 1. Calculate the cluster cohesion, a(i), as the average distance between an example, x(i), and all other points in the same cluster. 2. Calculate the cluster separation, b(i), from the next closest cluster as the average distance between the example, x(i), and all examples in the nearest cluster. 3. Calculate the silhouette, s(i), as the difference between cluster cohesion and separation divided by the greater of the two, as shown here: 𝑠𝑠(𝑖𝑖)=𝑏𝑏(𝑖𝑖)−𝑎𝑎(𝑖𝑖) 𝑚𝑚𝑎𝑎𝑚𝑚{𝑏𝑏(𝑖𝑖),𝑎𝑎(𝑖𝑖)} Chapter 10 315 The silhouette coefficient is bounded in the range –1 to 1. Based on the preceding equation, we can see that the silhouette coefficient is 0 if the cluster separation and cohesion are equal (b(i) = a(i)). Furthermore, we get close to an ideal silhouette coefficient of 1 if b(i) >> a(i), since b(i) quantifies how dissimilar an example is", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 289, "start_word": 92480, "end_word": 92880, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000290": {"text": "difference between cluster cohesion and separation divided by the greater of the two, as shown here: 𝑠𝑠(𝑖𝑖)=𝑏𝑏(𝑖𝑖)−𝑎𝑎(𝑖𝑖) 𝑚𝑚𝑎𝑎𝑚𝑚{𝑏𝑏(𝑖𝑖),𝑎𝑎(𝑖𝑖)} Chapter 10 315 The silhouette coefficient is bounded in the range –1 to 1. Based on the preceding equation, we can see that the silhouette coefficient is 0 if the cluster separation and cohesion are equal (b(i) = a(i)). Furthermore, we get close to an ideal silhouette coefficient of 1 if b(i) >> a(i), since b(i) quantifies how dissimilar an example is from other clusters, and a(i) tells us how similar it is to the other examples in its own cluster. The silhouette coefficient is available as silhouette_samples from scikit-learn’s metric module, and optionally, the silhouette_scores function can be imported for convenience. The silhouette_scores function calculates the average silhouette coefficient across all examples, which is equivalent to numpy. mean(silhouette_samples(...)) . By executing the following code, we will now create a plot of the silhouette coefficients for a k-means clustering with k = 3: >>> km = KMeans(n_clusters= 3, ... init= 'k-means++' , ... n_init= 10, ... max_iter= 300, ... tol= 1e-04, ... random_state= 0) >>> y_km = km.fit_predict(X) >>> import numpy as np >>> from matplotlib import cm >>> from sklearn.metrics import silhouette_samples >>> cluster_labels = np.unique(y_km) >>> n_clusters = cluster_labels.shape[ 0] >>> silhouette_vals = silhouette_samples( ... X, y_km, metric= 'euclidean' ... ) >>> y_ax_lower, y_ax_upper = 0, 0 >>> yticks = [] >>> for i, c in enumerate (cluster_labels): ... c_silhouette_vals = silhouette_vals[y_km == c] ... c_silhouette_vals.sort() ... y_ax_upper += len(c_silhouette_vals) ... color = cm.jet( float(i) / n_clusters) ... plt.barh( range(y_ax_lower, y_ax_upper), ... c_silhouette_vals, ... height= 1.0, ... edgecolor= 'none', ... color=color) ... yticks.append((y_ax_lower + y_ax_upper) / 2.) ... y_ax_lower += len(c_silhouette_vals) Working with Unlabeled Data – Clustering Analysis 316 >>> silhouette_avg = np.mean(silhouette_vals) >>> plt.axvline(silhouette_avg, ... color= \"red\", ... linestyle= \"--\") >>> plt.yticks(yticks, cluster_labels + 1) >>> plt.ylabel( 'Cluster' ) >>> plt.xlabel( 'Silhouette coefficient' ) >>> plt.tight_layout() >>> plt.show() Through a visual inspection of the silhouette plot, we can quickly scrutinize the sizes of the different clusters and identify clusters that contain outliers: Figure 10.4: A silhouette plot for a good example of clustering However, as you can see in the preceding silhouette plot, the silhouette coefficients are not close to 0 and are approximately equally far away from the average silhouette score, which is, in this case, an indicator of good clustering. Furthermore, to summarize the goodness of our", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 290, "start_word": 92800, "end_word": 93200, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000291": {"text": "a visual inspection of the silhouette plot, we can quickly scrutinize the sizes of the different clusters and identify clusters that contain outliers: Figure 10.4: A silhouette plot for a good example of clustering However, as you can see in the preceding silhouette plot, the silhouette coefficients are not close to 0 and are approximately equally far away from the average silhouette score, which is, in this case, an indicator of good clustering. Furthermore, to summarize the goodness of our clustering, we added the average silhouette coefficient to the plot (dotted line). Chapter 10 317 To see what a silhouette plot looks like for a relatively bad clustering, let’s seed the k-means algorithm with only two centroids: >>> km = KMeans(n_clusters= 2, ... init= 'k-means++' , ... n_init= 10, ... max_iter= 300, ... tol= 1e-04, ... random_state= 0) >>> y_km = km.fit_predict(X) >>> plt.scatter(X[y_km == 0, 0], ... X[y_km == 0, 1], ... s= 50, c='lightgreen' , ... edgecolor= 'black', ... marker= 's', ... label= 'Cluster 1' ) >>> plt.scatter(X[y_km == 1, 0], ... X[y_km == 1, 1], ... s= 50, ... c= 'orange' , ... edgecolor= 'black', ... marker= 'o', ... label= 'Cluster 2' ) >>> plt.scatter(km.cluster_centers_[:, 0], ... km.cluster_centers_[:, 1], ... s= 250, ... marker= '*', ... c= 'red', ... label= 'Centroids' ) >>> plt.xlabel( 'Feature 1' ) >>> plt.ylabel( 'Feature 2' ) >>> plt.legend() >>> plt.grid() >>> plt.tight_layout() >>> plt.show() As you can see in Figure 10.5, one of the centroids falls between two of the three spherical groupings of the input data. Working with Unlabeled Data – Clustering Analysis 318 Although the clustering does not look completely terrible, it is suboptimal: Figure 10.5: A suboptimal example of clustering Please keep in mind that we typically do not have the luxury of visualizing datasets in two-dimensional scatterplots in real-world problems, since we typically work with data in higher dimensions. So, next, we will create the silhouette plot to evaluate the results: >>> cluster_labels = np.unique(y_km) >>> n_clusters = cluster_labels.shape[ 0] >>> silhouette_vals = silhouette_samples( ... X, y_km, metric= 'euclidean' ... ) >>> y_ax_lower, y_ax_upper = 0, 0 >>> yticks = [] >>> for i, c in enumerate (cluster_labels): ... c_silhouette_vals = silhouette_vals[y_km == c] ... c_silhouette_vals.sort() ... y_ax_upper += len(c_silhouette_vals) ... color = cm.jet( float(i) / n_clusters) ... plt.barh( range(y_ax_lower, y_ax_upper), ... c_silhouette_vals, ... height= 1.0, ... edgecolor= 'none', ... color=color) Chapter 10 319 ... yticks.append((y_ax_lower +", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 291, "start_word": 93120, "end_word": 93520, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000292": {"text": "to evaluate the results: >>> cluster_labels = np.unique(y_km) >>> n_clusters = cluster_labels.shape[ 0] >>> silhouette_vals = silhouette_samples( ... X, y_km, metric= 'euclidean' ... ) >>> y_ax_lower, y_ax_upper = 0, 0 >>> yticks = [] >>> for i, c in enumerate (cluster_labels): ... c_silhouette_vals = silhouette_vals[y_km == c] ... c_silhouette_vals.sort() ... y_ax_upper += len(c_silhouette_vals) ... color = cm.jet( float(i) / n_clusters) ... plt.barh( range(y_ax_lower, y_ax_upper), ... c_silhouette_vals, ... height= 1.0, ... edgecolor= 'none', ... color=color) Chapter 10 319 ... yticks.append((y_ax_lower + y_ax_upper) / 2.) ... y_ax_lower += len(c_silhouette_vals) >>> silhouette_avg = np.mean(silhouette_vals) >>> plt.axvline(silhouette_avg, color= \"red\", linestyle= \"--\") >>> plt.yticks(yticks, cluster_labels + 1) >>> plt.ylabel( 'Cluster' ) >>> plt.xlabel( 'Silhouette coefficient' ) >>> plt.tight_layout() >>> plt.show() As you can see in Figure 10.6, the silhouettes now have visibly different lengths and widths, which is evidence of a relatively bad or at least suboptimal clustering: Figure 10.6: A silhouette plot for a suboptimal example of clustering Now, after we have gained a good understanding of how clustering works, the next section will intro - duce hierarchical clustering as an alternative approach to k-means. Organizing clusters as a hierarchical tree In this section, we will look at an alternative approach to prototype-based clustering: hierarchical clustering. One advantage of the hierarchical clustering algorithm is that it allows us to plot dendro - grams (visualizations of a binary hierarchical clustering), which can help with the interpretation of the results by creating meaningful taxonomies. Another advantage of this hierarchical approach is that we do not need to specify the number of clusters upfront. Working with Unlabeled Data – Clustering Analysis 320 The two main approaches to hierarchical clustering are agglomerative and divisive hierarchical clus- tering. In divisive hierarchical clustering, we start with one cluster that encompasses the complete dataset, and we iteratively split the cluster into smaller clusters until each cluster only contains one example. In this section, we will focus on agglomerative clustering, which takes the opposite approach. We start with each example as an individual cluster and merge the closest pairs of clusters until only one cluster remains. Grouping clusters in a bottom-up fashion The two standard algorithms for agglomerative hierarchical clustering are single linkage and complete linkage. Using single linkage, we compute the distances between the most similar members for each pair of clusters and merge the two clusters for which the distance between the most similar members is the smallest. The complete", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 292, "start_word": 93440, "end_word": 93840, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000293": {"text": "the opposite approach. We start with each example as an individual cluster and merge the closest pairs of clusters until only one cluster remains. Grouping clusters in a bottom-up fashion The two standard algorithms for agglomerative hierarchical clustering are single linkage and complete linkage. Using single linkage, we compute the distances between the most similar members for each pair of clusters and merge the two clusters for which the distance between the most similar members is the smallest. The complete linkage approach is similar to single linkage but, instead of comparing the most similar members in each pair of clusters, we compare the most dissimilar members to per - form the merge. This is shown in Figure 10.7: Figure 10.7: The complete linkage approach In this section, we will focus on agglomerative clustering using the complete linkage approach. Hier - archical complete linkage clustering is an iterative procedure that can be summarized by the following steps: 1. Compute a pair-wise distance matrix of all examples. 2. Represent each data point as a singleton cluster.Alternative types of linkages Other commonly used algorithms for agglomerative hierarchical clustering include average linkage and Ward’s linkage. In average linkage, we merge the cluster pairs based on the minimum average distances between all group members in the two clusters. In Ward’s linkage, the two clusters that lead to the minimum increase of the total within-cluster SSE are merged. Chapter 10 321 3. Merge the two closest clusters based on the distance between the most dissimilar (distant) members. 4. Update the cluster linkage matrix. 5. Repeat steps 2-4 until one single cluster remains. Next, we will discuss how to compute the distance matrix (step 1). But first, let’s generate a random data sample to work with. The rows represent different observations (IDs 0-4), and the columns are the different features ( X, Y, Z) of those examples: >>> import pandas as pd >>> import numpy as np >>> np.random.seed( 123) >>> variables = [ 'X', 'Y', 'Z'] >>> labels = [ 'ID_0', 'ID_1' , 'ID_2' , 'ID_3' , 'ID_4' ] >>> X = np.random.random_sample([ 5, 3])*10 >>> df = pd.DataFrame(X, columns=variables, index=labels) >>> df After executing the preceding code, we should now see the following DataFrame containing the ran- domly generated examples: Figure 10.8: A randomly generated data sample Performing hierarchical clustering on a distance matrix To calculate the distance matrix as input for the hierarchical clustering", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 293, "start_word": 93760, "end_word": 94160, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000294": {"text": ">>> np.random.seed( 123) >>> variables = [ 'X', 'Y', 'Z'] >>> labels = [ 'ID_0', 'ID_1' , 'ID_2' , 'ID_3' , 'ID_4' ] >>> X = np.random.random_sample([ 5, 3])*10 >>> df = pd.DataFrame(X, columns=variables, index=labels) >>> df After executing the preceding code, we should now see the following DataFrame containing the ran- domly generated examples: Figure 10.8: A randomly generated data sample Performing hierarchical clustering on a distance matrix To calculate the distance matrix as input for the hierarchical clustering algorithm, we will use the pdist function from SciPy’s spatial.distance submodule: >>> from scipy.spatial.distance import pdist, squareform >>> row_dist = pd.DataFrame(squareform( ... pdist(df, metric= 'euclidean' )), ... columns=labels, index=labels) >>> row_dist Working with Unlabeled Data – Clustering Analysis 322 Using the preceding code, we calculated the Euclidean distance between each pair of input examples in our dataset based on the features X, Y, and Z. We provided the condensed distance matrix—returned by pdist —as input to the squareform function to create a symmetrical matrix of the pair-wise distances, as shown here: Figure 10.9: The calculated pair-wise distances of our data Next, we will apply the complete linkage agglomeration to our clusters using the linkage function from SciPy’s cluster.hierarchy submodule, which returns a so-called linkage matrix. However, before we call the linkage function, let’s take a careful look at the function documentation: >>> from scipy.cluster.hierarchy import linkage >>> help(linkage) [...] Parameters: y : ndarray A condensed or redundant distance matrix. A condensed distance matrix is a flat array containing the upper triangular of the distance matrix. This is the form that pdist returns. Alternatively, a collection of m observation vectors in n dimensions may be passed as an m by n array. method : str, optional The linkage algorithm to use. See the Linkage Methods section below for full descriptions. metric : str, optional The distance metric to use. See the distance.pdist function for a list of valid distance metrics. Returns: Z : ndarray Chapter 10 323 The hierarchical clustering encoded as a linkage matrix. [...] Based on the function description, we understand that we can use a condensed distance matrix (up - per triangular) from the pdist function as an input attribute. Alternatively, we could also provide the initial data array and use the 'euclidean' metric as a function argument in linkage . However, we should not use the squareform distance matrix that we defined earlier, since it would yield", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 294, "start_word": 94080, "end_word": 94480, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000295": {"text": "Z : ndarray Chapter 10 323 The hierarchical clustering encoded as a linkage matrix. [...] Based on the function description, we understand that we can use a condensed distance matrix (up - per triangular) from the pdist function as an input attribute. Alternatively, we could also provide the initial data array and use the 'euclidean' metric as a function argument in linkage . However, we should not use the squareform distance matrix that we defined earlier, since it would yield different distance values than expected. To sum it up, the three possible scenarios are listed here: • Incorrect approach: Using the squareform distance matrix as shown in the following code snippet leads to incorrect results: >>> row_clusters = linkage(row_dist, ... method= 'complete' , ... metric= 'euclidean' ) • Correct approach: Using the condensed distance matrix as shown in the following code ex - ample yields the correct linkage matrix: >>> row_clusters = linkage(pdist(df, metric= 'euclidean' ), ... method= 'complete' ) • Correct approach: Using the complete input example matrix (the so-called design matrix) as shown in the following code snippet also leads to a correct linkage matrix similar to the preceding approach: >>> row_clusters = linkage(df.values, ... method= 'complete' , ... metric= 'euclidean' ) To take a closer look at the clustering results, we can turn those results into a pandas DataFrame (best viewed in a Jupyter notebook) as follows: >>> pd.DataFrame(row_clusters, ... columns=[ 'row label 1' , ... 'row label 2' , ... 'distance' , ... 'no. of items in clust.' ], ... index=[ f'cluster {(i + 1)}' for i in ... range(row_clusters.shape[ 0])]) As shown in Figure 10.10, the linkage matrix consists of several rows where each row represents one merge. The first and second columns denote the most dissimilar members in each cluster, and the third column reports the distance between those members. Working with Unlabeled Data – Clustering Analysis 324 The last column returns the count of the members in each cluster: Figure 10.10: The linkage matrix Now that we have computed the linkage matrix, we can visualize the results in the form of a dendro - gram: >>> from scipy.cluster.hierarchy import dendrogram >>> # make dendrogram black (part 1/2) >>> # from scipy.cluster.hierarchy import set_link_color_palette >>> # set_link_color_palette(['black']) >>> row_dendr = dendrogram( ... row_clusters, ... labels=labels, ... # make dendrogram black (part 2/2) ... # color_threshold=np.inf ... ) >>> plt.tight_layout() >>> plt.ylabel( 'Euclidean distance' )", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 295, "start_word": 94400, "end_word": 94800, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000296": {"text": "of the members in each cluster: Figure 10.10: The linkage matrix Now that we have computed the linkage matrix, we can visualize the results in the form of a dendro - gram: >>> from scipy.cluster.hierarchy import dendrogram >>> # make dendrogram black (part 1/2) >>> # from scipy.cluster.hierarchy import set_link_color_palette >>> # set_link_color_palette(['black']) >>> row_dendr = dendrogram( ... row_clusters, ... labels=labels, ... # make dendrogram black (part 2/2) ... # color_threshold=np.inf ... ) >>> plt.tight_layout() >>> plt.ylabel( 'Euclidean distance' ) >>> plt.show() If you are executing the preceding code or reading an e-book version of this book, you will notice that the branches in the resulting dendrogram are shown in different colors. The color scheme is derived from a list of Matplotlib colors that are cycled for the distance thresholds in the dendrogram. For example, to display the dendrograms in black, you can uncomment the respective sections that were inserted in the preceding code: Chapter 10 325 Figure 10.11: A dendrogram of our data Such a dendrogram summarizes the different clusters that were formed during the agglomerative hierarchical clustering; for example, you can see that the examples ID_0 and ID_4 , followed by ID_1 and ID_2 , are the most similar ones based on the Euclidean distance metric. Attaching dendrograms to a heat map In practical applications, hierarchical clustering dendrograms are often used in combination with a heat map, which allows us to represent the individual values in the data array or matrix containing our training examples with a color code. In this section, we will discuss how to attach a dendrogram to a heat map plot and order the rows in the heat map correspondingly. Working with Unlabeled Data – Clustering Analysis 326 However, attaching a dendrogram to a heat map can be a little bit tricky, so let’s go through this pro - cedure step by step: 1. We create a new figure object and define the x axis position, y axis position, width, and height of the dendrogram via the add_axes attribute. Furthermore, we rotate the dendrogram 90 degrees counterclockwise. The code is as follows: >>> fig = plt.figure(figsize=( 8, 8), facecolor= 'white') >>> axd = fig.add_axes([ 0.09, 0.1, 0.2, 0.6]) >>> row_dendr = dendrogram(row_clusters, ... orientation= 'left') >>> # note: for matplotlib < v1.5.1, please use >>> # orientation='right' 2. Next, we reorder the data in our initial DataFrame according to the clustering labels that can", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 296, "start_word": 94720, "end_word": 95120, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000297": {"text": "axis position, y axis position, width, and height of the dendrogram via the add_axes attribute. Furthermore, we rotate the dendrogram 90 degrees counterclockwise. The code is as follows: >>> fig = plt.figure(figsize=( 8, 8), facecolor= 'white') >>> axd = fig.add_axes([ 0.09, 0.1, 0.2, 0.6]) >>> row_dendr = dendrogram(row_clusters, ... orientation= 'left') >>> # note: for matplotlib < v1.5.1, please use >>> # orientation='right' 2. Next, we reorder the data in our initial DataFrame according to the clustering labels that can be accessed from the dendrogram object, which is essentially a Python dictionary, via the leaves key. The code is as follows: >>> df_rowclust = df.iloc[row_dendr[ 'leaves' ][::-1]] 3. Now, we construct the heat map from the reordered DataFrame and position it next to the dendrogram: >>> axm = fig.add_axes([ 0.23, 0.1, 0.6, 0.6]) >>> cax = axm.matshow(df_rowclust, ... interpolation= 'nearest' , ... cmap= 'hot_r') 4. Finally, we modify the aesthetics of the dendrogram by removing the axis ticks and hiding the axis spines. Also, we add a color bar and assign the feature and data record names to the x and y axis tick labels, respectively: >>> axd.set_xticks([]) >>> axd.set_yticks([]) >>> for i in axd.spines.values(): ... i.set_visible( False) >>> fig.colorbar(cax) >>> axm.set_xticklabels([ ''] + list(df_rowclust.columns)) >>> axm.set_yticklabels([ ''] + list(df_rowclust.index)) >>> plt.show() Chapter 10 327 After following the previous steps, the heat map should be displayed with the dendrogram attached: Figure 10.12: A heat map and dendrogram of our data As you can see, the order of rows in the heat map reflects the clustering of the examples in the den- drogram. In addition to a simple dendrogram, the color-coded values of each example and feature in the heat map provide us with a nice summary of the dataset. Applying agglomerative clustering via scikit-learn In the previous subsection, you saw how to perform agglomerative hierarchical clustering using SciPy. However, there is also an AgglomerativeClustering implementation in scikit-learn, which allows us to choose the number of clusters that we want to return. This is useful if we want to prune the hierarchical cluster tree. Working with Unlabeled Data – Clustering Analysis 328 By setting the n_cluster parameter to 3, we will now cluster the input examples into three groups using the same complete linkage approach based on the Euclidean distance metric as before: >>> from sklearn.cluster import AgglomerativeClustering >>> ac = AgglomerativeClustering(n_clusters= 3, ... affinity= 'euclidean' , ... linkage= 'complete' )", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 297, "start_word": 95040, "end_word": 95440, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000298": {"text": "to choose the number of clusters that we want to return. This is useful if we want to prune the hierarchical cluster tree. Working with Unlabeled Data – Clustering Analysis 328 By setting the n_cluster parameter to 3, we will now cluster the input examples into three groups using the same complete linkage approach based on the Euclidean distance metric as before: >>> from sklearn.cluster import AgglomerativeClustering >>> ac = AgglomerativeClustering(n_clusters= 3, ... affinity= 'euclidean' , ... linkage= 'complete' ) >>> labels = ac.fit_predict(X) >>> print(f'Cluster labels: {labels} ') Cluster labels: [1 0 0 2 1] Looking at the predicted cluster labels, we can see that the first and the fifth examples ( ID_0 and ID_4 ) were assigned to one cluster (label 1), and the examples ID_1 and ID_2 were assigned to a sec- ond cluster (label 0). The example ID_3 was put into its own cluster (label 2). Overall, the results are consistent with the results that we observed in the dendrogram. We should note, though, that ID_3 is more similar to ID_4 and ID_0 than to ID_1 and ID_2 , as shown in the preceding dendrogram figure; this is not clear from scikit-learn’s clustering results. Let’s now rerun the AgglomerativeClustering using n_cluster=2 in the following code snippet: >>> ac = AgglomerativeClustering(n_clusters= 2, ... affinity= 'euclidean' , ... linkage= 'complete' ) >>> labels = ac.fit_predict(X) >>> print(f'Cluster labels: {labels} ') Cluster labels: [0 1 1 0 0] As you can see, in this pruned clustering hierarchy, label ID_3 was assigned to the same cluster as ID_0 and ID_4 , as expected. Locating regions of high density via DBSCAN Although we can’t cover the vast number of different clustering algorithms in this chapter, let’s at least include one more approach to clustering: density-based spatial clustering of applications with noise (DBSCAN), which does not make assumptions about spherical clusters like k-means, nor does it partition the dataset into hierarchies that require a manual cut-off point. As its name implies, den- sity-based clustering assigns cluster labels based on dense regions of points. In DBSCAN, the notion of density is defined as the number of points within a specified radius, 𝜀𝜀 . According to the DBSCAN algorithm, a special label is assigned to each example (data point) using the following criteria: • A point is considered a core point if at least a specified number (MinPts) of neighboring points fall within the", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 298, "start_word": 95360, "end_word": 95760, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000299": {"text": "require a manual cut-off point. As its name implies, den- sity-based clustering assigns cluster labels based on dense regions of points. In DBSCAN, the notion of density is defined as the number of points within a specified radius, 𝜀𝜀 . According to the DBSCAN algorithm, a special label is assigned to each example (data point) using the following criteria: • A point is considered a core point if at least a specified number (MinPts) of neighboring points fall within the specified radius, 𝜀𝜀 • A border point is a point that has fewer neighbors than MinPts within 𝜀𝜀 , but lies within the 𝜀𝜀 radius of a core point • All other points that are neither core nor border points are considered noise points Chapter 10 329 After labeling the points as core, border, or noise, the DBSCAN algorithm can be summarized in two simple steps: 1. Form a separate cluster for each core point or connected group of core points. (Core points are connected if they are no farther away than 𝜀𝜀 .) 2. Assign each border point to the cluster of its corresponding core point. To get a better understanding of what the result of DBSCAN can look like, before jumping to the im- plementation, let’s summarize what we have just learned about core points, border points, and noise points in Figure 10.13: Figure 10.13: Core, noise, and border points for DBSCAN One of the main advantages of using DBSCAN is that it does not assume that the clusters have a spher - ical shape as in k-means. Furthermore, DBSCAN is different from k-means and hierarchical clustering in that it doesn’t necessarily assign each point to a cluster but is capable of removing noise points. For a more illustrative example, let’s create a new dataset of half-moon-shaped structures to compare k-means clustering, hierarchical clustering, and DBSCAN: >>> from sklearn.datasets import make_moons >>> X, y = make_moons(n_samples= 200, ... noise= 0.05, ... random_state= 0) >>> plt.scatter(X[:, 0], X[:, 1]) >>> plt.xlabel( 'Feature 1' ) >>> plt.ylabel( 'Feature 2' ) >>> plt.tight_layout() >>> plt.show() Working with Unlabeled Data – Clustering Analysis 330 As you can see in the resulting plot, there are two visible, half-moon-shaped groups consisting of 100 examples (data points) each: Figure 10.14: A two-feature half-moon-shaped dataset We will start by using the k-means algorithm and complete linkage clustering to see if one of those previously discussed clustering", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 299, "start_word": 95680, "end_word": 96080, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000300": {"text": "noise= 0.05, ... random_state= 0) >>> plt.scatter(X[:, 0], X[:, 1]) >>> plt.xlabel( 'Feature 1' ) >>> plt.ylabel( 'Feature 2' ) >>> plt.tight_layout() >>> plt.show() Working with Unlabeled Data – Clustering Analysis 330 As you can see in the resulting plot, there are two visible, half-moon-shaped groups consisting of 100 examples (data points) each: Figure 10.14: A two-feature half-moon-shaped dataset We will start by using the k-means algorithm and complete linkage clustering to see if one of those previously discussed clustering algorithms can successfully identify the half-moon shapes as separate clusters. The code is as follows: >>> f, (ax1, ax2) = plt.subplots( 1, 2, figsize=( 8, 3)) >>> km = KMeans(n_clusters= 2, ... random_state= 0) >>> y_km = km.fit_predict(X) >>> ax1.scatter(X[y_km == 0, 0], ... X[y_km == 0, 1], ... c= 'lightblue' , ... edgecolor= 'black', ... marker= 'o', ... s= 40, ... label= 'cluster 1' ) Chapter 10 331 >>> ax1.scatter(X[y_km == 1, 0], ... X[y_km == 1, 1], ... c= 'red', ... edgecolor= 'black', ... marker= 's', ... s= 40, ... label= 'cluster 2' ) >>> ax1.set_title( 'K-means clustering' ) >>> ax1.set_xlabel( 'Feature 1' ) >>> ax1.set_ylabel( 'Feature 2' ) >>> ac = AgglomerativeClustering(n_clusters= 2, ... affinity= 'euclidean' , ... linkage= 'complete' ) >>> y_ac = ac.fit_predict(X) >>> ax2.scatter(X[y_ac == 0, 0], ... X[y_ac == 0, 1], ... c= 'lightblue' , ... edgecolor= 'black', ... marker= 'o', ... s= 40, ... label= 'Cluster 1' ) >>> ax2.scatter(X[y_ac == 1, 0], ... X[y_ac == 1, 1], ... c= 'red', ... edgecolor= 'black', ... marker= 's', ... s= 40, ... label= 'Cluster 2' ) >>> ax2.set_title( 'Agglomerative clustering' ) >>> ax2.set_xlabel( 'Feature 1' ) >>> ax2.set_ylabel( 'Feature 2' ) >>> plt.legend() >>> plt.tight_layout() >>> plt.show() Working with Unlabeled Data – Clustering Analysis 332 Based on the visualized clustering results, we can see that the k-means algorithm was unable to separate the two clusters, and also, the hierarchical clustering algorithm was challenged by those complex shapes: Figure 10.15: k-means and agglomerative clustering on the half-moon-shaped dataset Finally, let’s try the DBSCAN algorithm on this dataset to see if it can find the two half-moon-shaped clusters using a density-based approach: >>> from sklearn.cluster import DBSCAN >>> db = DBSCAN(eps= 0.2, ... min_samples= 5, ... metric= 'euclidean' ) >>> y_db = db.fit_predict(X) >>> plt.scatter(X[y_db == 0, 0], ... X[y_db == 0, 1], ... c= 'lightblue' , ... edgecolor= 'black', ... marker= 'o', ... s=", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 300, "start_word": 96000, "end_word": 96400, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000301": {"text": "by those complex shapes: Figure 10.15: k-means and agglomerative clustering on the half-moon-shaped dataset Finally, let’s try the DBSCAN algorithm on this dataset to see if it can find the two half-moon-shaped clusters using a density-based approach: >>> from sklearn.cluster import DBSCAN >>> db = DBSCAN(eps= 0.2, ... min_samples= 5, ... metric= 'euclidean' ) >>> y_db = db.fit_predict(X) >>> plt.scatter(X[y_db == 0, 0], ... X[y_db == 0, 1], ... c= 'lightblue' , ... edgecolor= 'black', ... marker= 'o', ... s= 40, ... label= 'Cluster 1' ) >>> plt.scatter(X[y_db == 1, 0], ... X[y_db == 1, 1], ... c= 'red', ... edgecolor= 'black', ... marker= 's', ... s= 40, ... label= 'Cluster 2' ) >>> plt.xlabel( 'Feature 1' ) >>> plt.ylabel( 'Feature 2' ) >>> plt.legend() >>> plt.tight_layout() >>> plt.show() Chapter 10 333 The DBSCAN algorithm can successfully detect the half-moon shapes, which highlights one of the strengths of DBSCAN—clustering data of arbitrary shapes: Figure 10.16: DBSCAN clustering on the half-moon-shaped dataset However, we should also note some of the disadvantages of DBSCAN. With an increasing number of features in our dataset—assuming a fixed number of training examples—the negative effect of the curse of dimensionality increases. This is especially a problem if we are using the Euclidean distance metric. However, the problem of the curse of dimensionality is not unique to DBSCAN: it also affects other clustering algorithms that use the Euclidean distance metric, for example, k-means and hier - archical clustering algorithms. In addition, we have two hyperparameters in DBSCAN (MinPts and 𝜀𝜀 ) that need to be optimized to yield good clustering results. Finding a good combination of MinPts and 𝜀𝜀 can be problematic if the density differences in the dataset are relatively large. Graph-based clustering So far, we have seen three of the most fundamental categories of clustering algorithms: prototype-based clustering with k-means, agglomerative hierarchical clustering, and den - sity-based clustering via DBSCAN. However, there is also a fourth class of more advanced clustering algorithms that we have not covered in this chapter: graph-based clustering. Probably the most prominent members of the graph-based clustering family are the spec - tral clustering algorithms. Although there are many different implementations of spectral clustering, what they all have in common is that they use the eigenvectors of a similarity or distance matrix to derive the cluster relationships. Since spectral clustering is beyond the scope of this book, you can read the", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 301, "start_word": 96320, "end_word": 96720, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000302": {"text": "fourth class of more advanced clustering algorithms that we have not covered in this chapter: graph-based clustering. Probably the most prominent members of the graph-based clustering family are the spec - tral clustering algorithms. Although there are many different implementations of spectral clustering, what they all have in common is that they use the eigenvectors of a similarity or distance matrix to derive the cluster relationships. Since spectral clustering is beyond the scope of this book, you can read the excellent tutorial by Ulrike von Luxburg to learn more about this topic (A tutorial on spectral clustering, Statistics and Computing, 17(4): 395-416, 2007). It is freely available from arXiv at http://arxiv.org/pdf/0711.0189v1.pdf . Working with Unlabeled Data – Clustering Analysis 334 Note that, in practice, it is not always obvious which clustering algorithm will perform best on a given dataset, especially if the data comes in multiple dimensions that make it hard or impossible to visu- alize. Furthermore, it is important to emphasize that a successful clustering does not only depend on the algorithm and its hyperparameters; rather, the choice of an appropriate distance metric and the use of domain knowledge that can help to guide the experimental setup can be even more important. In the context of the curse of dimensionality, it is thus common practice to apply dimensionality reduction techniques prior to performing clustering. Such dimensionality reduction techniques for unsupervised datasets include principal component analysis and t-SNE, which we covered in Chapter 5, Compressing Data via Dimensionality Reduction. Also, it is particularly common to compress datasets down to two-dimensional subspaces, which allows us to visualize the clusters and assigned labels using two-dimensional scatterplots, which are particularly helpful for evaluating the results. Summary In this chapter, you learned about three different clustering algorithms that can help us with the discovery of hidden structures or information in data. We started with a prototype-based approach, k-means, which clusters examples into spherical shapes based on a specified number of cluster cen- troids. Since clustering is an unsupervised method, we do not enjoy the luxury of ground-truth labels to evaluate the performance of a model. Thus, we used intrinsic performance metrics, such as the elbow method or silhouette analysis, as an attempt to quantify the quality of clustering. We then looked at a different approach to clustering: agglomerative hierarchical clustering. Hierar - chical clustering does not require specifying the number of clusters upfront, and", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 302, "start_word": 96640, "end_word": 97040, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000303": {"text": "based on a specified number of cluster cen- troids. Since clustering is an unsupervised method, we do not enjoy the luxury of ground-truth labels to evaluate the performance of a model. Thus, we used intrinsic performance metrics, such as the elbow method or silhouette analysis, as an attempt to quantify the quality of clustering. We then looked at a different approach to clustering: agglomerative hierarchical clustering. Hierar - chical clustering does not require specifying the number of clusters upfront, and the result can be visualized in a dendrogram representation, which can help with the interpretation of the results. The last clustering algorithm that we covered in this chapter was DBSCAN, an algorithm that groups points based on local densities and is capable of handling outliers and identifying non-globular shapes. After this excursion into the field of unsupervised learning, it is now time to introduce some of the most exciting machine learning algorithms for supervised learning: multilayer artificial neural networks. After their recent resurgence, neural networks are once again the hottest topic in machine learning research. Thanks to recently developed deep learning algorithms, neural networks are considered state of the art for many complex tasks such as image classification, natural language processing, and speech recognition. In Chapter 11, Implementing a Multilayer Artificial Neural Network from Scratch, we will construct our own multilayer neural network. In Chapter 12, Parallelizing Neural Network Training with PyTorch, we will work with the PyTorch library, which specializes in training neural network models with multiple layers very efficiently by utilizing graphics processing units . Join our book’s Discord space Join the book’s Discord workspace for a monthly Ask me Anything session with the authors: https://packt.link/MLwPyTorch 11 Implementing a Multilayer Artificial Neural Network from Scratch As you may know, deep learning is getting a lot of attention from the press and is, without doubt, the hottest topic in the machine learning field. Deep learning can be understood as a subfield of machine learning that is concerned with training artificial neural networks (NNs ) with many layers efficiently. In this chapter, you will learn the basic concepts of artificial NNs so that you are well equipped for the following chapters, which will introduce advanced Python-based deep learning libraries and deep neural network (DNN ) architectures that are particularly well suited for image and text analyses. The topics that we will cover in this chapter are as follows: • Gaining", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 303, "start_word": 96960, "end_word": 97360, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000304": {"text": "a subfield of machine learning that is concerned with training artificial neural networks (NNs ) with many layers efficiently. In this chapter, you will learn the basic concepts of artificial NNs so that you are well equipped for the following chapters, which will introduce advanced Python-based deep learning libraries and deep neural network (DNN ) architectures that are particularly well suited for image and text analyses. The topics that we will cover in this chapter are as follows: • Gaining a conceptual understanding of multilayer NNs • Implementing the fundamental backpropagation algorithm for NN training from scratch • Training a basic multilayer NN for image classification Modeling complex functions with artificial neural networks At the beginning of this book, we started our journey through machine learning algorithms with ar - tificial neurons in Chapter 2, Training Simple Machine Learning Algorithms for Classification. Artificial neurons represent the building blocks of the multilayer artificial NNs that we will discuss in this chapter. Implementing a Multilayer Artificial Neural Network from Scratch 336 The basic concept behind artificial NNs was built upon hypotheses and models of how the human brain works to solve complex problem tasks. Although artificial NNs have gained a lot of popularity in recent years, early studies of NNs go back to the 1940s, when Warren McCulloch and Walter Pitts first described how neurons could work. (A logical calculus of the ideas immanent in nervous activity, by W. S. McCulloch and W. Pitts, The Bulletin of Mathematical Biophysics, 5(4):115–133, 1943.) However, in the decades that followed the first implementation of the McCulloch-Pitts neuron model—Rosenblatt’s perceptron in the 1950s—many researchers and machine learning practitioners slowly began to lose interest in NNs since no one had a good solution for training an NN with multiple layers. Eventually, interest in NNs was rekindled in 1986 when D.E. Rumelhart, G.E. Hinton, and R.J. Williams were involved in the (re)discovery and popularization of the backpropagation algorithm to train NNs more efficiently, which we will discuss in more detail later in this chapter (Learning rep - resentations by backpropagating errors, by D.E. Rumelhart, G.E. Hinton, and R.J. Williams, Nature, 323 (6088): 533–536, 1986). Readers who are interested in the history of artificial intelligence ( AI), machine learning, and NNs are also encouraged to read the Wikipedia article on the so-called AI winters, which are the periods of time where a large portion of the research community lost", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 304, "start_word": 97280, "end_word": 97680, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000305": {"text": "to train NNs more efficiently, which we will discuss in more detail later in this chapter (Learning rep - resentations by backpropagating errors, by D.E. Rumelhart, G.E. Hinton, and R.J. Williams, Nature, 323 (6088): 533–536, 1986). Readers who are interested in the history of artificial intelligence ( AI), machine learning, and NNs are also encouraged to read the Wikipedia article on the so-called AI winters, which are the periods of time where a large portion of the research community lost interest in the study of NNs (https://en.wikipedia.org/wiki/AI_winter ). However, NNs are more popular today than ever thanks to the many breakthroughs that have been made in the previous decade, which resulted in what we now call deep learning algorithms and archi- tectures—NNs that are composed of many layers. NNs are a hot topic not only in academic research but also in big technology companies, such as Facebook, Microsoft, Amazon, Uber, Google, and many more that invest heavily in artificial NNs and deep learning research. As of today, complex NNs powered by deep learning algorithms are considered state-of-the-art solutions for complex problem solving such as image and voice recognition. Some of the recent applications include: • Predicting COVID-19 resource needs from a series of X-rays ( https://arxiv.org/ abs/2101.04909 ) • Modeling virus mutations ( https://science.sciencemag.org/content/371/6526/284 ) • Leveraging data from social media platforms to manage extreme weather events ( https:// onlinelibrary.wiley.com/doi/abs/10.1111/1468-5973.12311 ) • Improving photo descriptions for people who are blind or visually impaired ( https://tech. fb.com/how-facebook-is-using-ai-to-improve-photo-descriptions-for-people-who-are- blind-or-visually-impaired/ ) Chapter 11 337 Single-layer neural network recap This chapter is all about multilayer NNs, how they work, and how to train them to solve complex problems. However, before we dig deeper into a particular multilayer NN architecture, let’s briefly reiterate some of the concepts of single-layer NNs that we introduced in Chapter 2, namely, the ADAp - tive LInear NEuron (Adaline) algorithm, which is shown in Figure 11.1: Figure 11.1: The Adaline algorithm In Chapter 2, we implemented the Adaline algorithm to perform binary classification, and we used the gradient descent optimization algorithm to learn the weight coefficients of the model. In every epoch (pass over the training dataset), we updated the weight vector w and bias unit b using the following update rule: 𝒘𝒘 𝒘 𝒘𝒘𝒘𝒘𝒘𝒘𝒘𝒘𝒘𝒘𝒘𝒘𝒘 𝒘 𝒘𝒘 𝒘𝒘𝒘𝒘 where ∆𝑤𝑤𝑗𝑗= −𝜂𝜂𝜕𝜕𝜕𝜕 𝜕𝜕𝜕𝜕𝑗𝑗 and ∆𝑏𝑏 𝑏 𝑏𝑏𝑏𝜕𝜕𝜕𝜕 𝜕𝜕𝜕𝜕 for the bias unit and each weight w j in the weight vector", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 305, "start_word": 97600, "end_word": 98000, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000306": {"text": "algorithm In Chapter 2, we implemented the Adaline algorithm to perform binary classification, and we used the gradient descent optimization algorithm to learn the weight coefficients of the model. In every epoch (pass over the training dataset), we updated the weight vector w and bias unit b using the following update rule: 𝒘𝒘 𝒘 𝒘𝒘𝒘𝒘𝒘𝒘𝒘𝒘𝒘𝒘𝒘𝒘𝒘 𝒘 𝒘𝒘 𝒘𝒘𝒘𝒘 where ∆𝑤𝑤𝑗𝑗= −𝜂𝜂𝜕𝜕𝜕𝜕 𝜕𝜕𝜕𝜕𝑗𝑗 and ∆𝑏𝑏 𝑏 𝑏𝑏𝑏𝜕𝜕𝜕𝜕 𝜕𝜕𝜕𝜕 for the bias unit and each weight w j in the weight vector w. In other words, we computed the gradient based on the whole training dataset and updated the weights of the model by taking a step in the opposite direction of the loss gradient ∇𝐿𝐿(𝒘𝒘) . (For simplicity, we will focus on the weights and omit the bias unit in the following paragraphs; however, as you remem- ber from Chapter 2, the same concepts apply.) In order to find the optimal weights of the model, we optimized an objective function that we defined as the mean of squared errors (MSE ) loss function L(w). Furthermore, we multiplied the gradient by a factor, the learning rate 𝜂𝜂 , which we had to choose carefully to balance the speed of learning against the risk of overshooting the global minimum of the loss function. Implementing a Multilayer Artificial Neural Network from Scratch 338 In gradient descent optimization, we updated all weights simultaneously after each epoch, and we defined the partial derivative for each weight w j in the weight vector, w, as follows: 𝜕𝜕𝜕𝜕 𝜕𝜕𝜕𝜕𝑗𝑗=𝜕𝜕 𝜕𝜕𝜕𝜕𝑗𝑗1 𝑛𝑛∑(𝑦𝑦(𝑖𝑖)−𝑎𝑎(𝑖𝑖))2 𝑖𝑖=−2 𝑛𝑛∑(𝑦𝑦(𝑖𝑖)−𝑎𝑎(𝑖𝑖))𝑥𝑥𝑗𝑗(𝑖𝑖) 𝑖𝑖 Here, y(i) is the target class label of a particular sample x(i), and a(i) is the activation of the neuron, which is a linear function in the special case of Adaline. Furthermore, we defined the activation function 𝜎𝜎(⋅) as follows: 𝜎𝜎(⋅)=𝑧𝑧=𝑧𝑧 Here, the net input, z, is a linear combination of the weights that are connecting the input layer to the output layer: 𝑧𝑧𝑧𝑧𝑧𝑧 𝑗𝑗𝑥𝑥𝑗𝑗+𝑏𝑏 𝑗𝑗𝑧𝒘𝒘𝑇𝑇𝒙𝒙+𝑏𝑏 While we used the activation 𝜎𝜎(⋅) to compute the gradient update, we implemented a threshold func- tion to squash the continuous-valued output into binary class labels for prediction: 𝑦𝑦𝑦 𝑦 𝑦1if 𝑧𝑧 𝑧 𝑧𝑧 𝑧otherwise Also, we learned about a certain trick to accelerate the model learning, the so-called stochastic gra - dient descent (SGD ) optimization. SGD approximates the loss from a single training sample (online learning) or a small subset of training examples (mini-batch learning). We", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 306, "start_word": 97920, "end_word": 98320, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000307": {"text": "𝑗𝑗𝑥𝑥𝑗𝑗+𝑏𝑏 𝑗𝑗𝑧𝒘𝒘𝑇𝑇𝒙𝒙+𝑏𝑏 While we used the activation 𝜎𝜎(⋅) to compute the gradient update, we implemented a threshold func- tion to squash the continuous-valued output into binary class labels for prediction: 𝑦𝑦𝑦 𝑦 𝑦1if 𝑧𝑧 𝑧 𝑧𝑧 𝑧otherwise Also, we learned about a certain trick to accelerate the model learning, the so-called stochastic gra - dient descent (SGD ) optimization. SGD approximates the loss from a single training sample (online learning) or a small subset of training examples (mini-batch learning). We will make use of this concept later in this chapter when we implement and train a multilayer perceptron (MLP ). Apart from faster learning—due to the more frequent weight updates compared to gradient descent—its noisy nature is also regarded as beneficial when training multilayer NNs with nonlinear activation functions, which do not have a convex loss function. Here, the added noise can help to escape local loss minima, but we will discuss this topic in more detail later in this chapter. Introducing the multilayer neural network architecture In this section, you will learn how to connect multiple single neurons to a multilayer feedforward NN; this special type of fully connected network is also called MLP .Single-layer naming convention Note that although Adaline consists of two layers, one input layer and one output layer, it is called a single-layer network because of its single link between the input and output layers. Chapter 11 339 Figure 11.2 illustrates the concept of an MLP consisting of two layers: Figure 11.2: A two-layer MLP Next to the data input, the MLP depicted in Figure 11.2 has one hidden layer and one output layer. The units in the hidden layer are fully connected to the input features, and the output layer is fully connected to the hidden layer. If such a network has more than one hidden layer, we also call it a deep NN. (Note that in some contexts, the inputs are also regarded as a layer. However, in this case, it would make the Adaline model, which is a single-layer neural network, a two-layer neural network, which may be counterintuitive.) Adding additional hidden layers We can add any number of hidden layers to the MLP to create deeper network architectures. Practically, we can think of the number of layers and units in an NN as additional hyper - parameters that we want to optimize for a given problem task using the cross-validation technique,", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 307, "start_word": 98240, "end_word": 98640, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000308": {"text": "as a layer. However, in this case, it would make the Adaline model, which is a single-layer neural network, a two-layer neural network, which may be counterintuitive.) Adding additional hidden layers We can add any number of hidden layers to the MLP to create deeper network architectures. Practically, we can think of the number of layers and units in an NN as additional hyper - parameters that we want to optimize for a given problem task using the cross-validation technique, which we discussed in Chapter 6, Learning Best Practices for Model Evaluation and Hyperparameter Tuning. However, the loss gradients for updating the network’s parameters, which we will calcu- late later via backpropagation, will become increasingly small as more layers are added to a network. This vanishing gradient problem makes model learning more challenging. Therefore, special algorithms have been developed to help train such DNN structures; this is known as deep learning, which we will discuss in more detail in the following chapters. Implementing a Multilayer Artificial Neural Network from Scratch 340 As shown in Figure 11.2, we denote the ith activation unit in the lth layer as 𝑎𝑎𝑖𝑖(𝑙𝑙) . To make the math and code implementations a bit more intuitive, we will not use numerical indices to refer to layers, but we will use the in superscript for the input features, the h superscript for the hidden layer, and the out superscript for the output layer. For instance, 𝑥𝑥𝑖𝑖(𝑖𝑖𝑖𝑖) refers to the ith input feature value, 𝑎𝑎𝑖𝑖(ℎ) refers to the ith unit in the hidden layer, and 𝑎𝑎𝑖𝑖(𝑜𝑜𝑜𝑜𝑜𝑜) refers to the ith unit in the output layer. Note that the b’s in Figure 11.2 denote the bias units. In fact, b(h) and b(out) are vectors with the number of elements being equal to the number of nodes in the layer they correspond to. For example, b(h) stores d bias units, where d is the number of nodes in the hidden layer. If this sounds confusing, don’t worry. Looking at the code implementation later, where we initialize weight matrices and bias unit vectors, will help clarify these concepts. Each node in layer l is connected to all nodes in layer l + 1 via a weight coefficient. For example, the connection between the kth unit in layer l to the jth unit in layer l + 1 will be written as 𝑤𝑤𝑗𝑗𝑗𝑗𝑗(𝑙𝑙) . Referring back to Figure 11.2, we denote the", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 308, "start_word": 98560, "end_word": 98960, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000309": {"text": "layer. If this sounds confusing, don’t worry. Looking at the code implementation later, where we initialize weight matrices and bias unit vectors, will help clarify these concepts. Each node in layer l is connected to all nodes in layer l + 1 via a weight coefficient. For example, the connection between the kth unit in layer l to the jth unit in layer l + 1 will be written as 𝑤𝑤𝑗𝑗𝑗𝑗𝑗(𝑙𝑙) . Referring back to Figure 11.2, we denote the weight matrix that connects the input to the hidden layer as W(h), and we write the matrix that connects the hidden layer to the output layer as W(out). While one unit in the output layer would suffice for a binary classification task, we saw a more gen- eral form of an NN in the preceding figure, which allows us to perform multiclass classification via a generalization of the one-versus-all ( OvA ) technique. To better understand how this works, remember the one-hot representation of categorical variables that we introduced in Chapter 4, Building Good Training Datasets – Data Preprocessing. For example, we can encode the three class labels in the familiar Iris dataset (0= Setosa, 1= Versicol - or, 2=Virginica) as follows: 0=[1 0 0],1=[0 1 0],2=[0 0 1] This one-hot vector representation allows us to tackle classification tasks with an arbitrary number of unique class labels present in the training dataset. If you are new to NN representations, the indexing notation (subscripts and superscripts) may look a little bit confusing at first. What may seem overly complicated at first will make much more sense in later sections when we vectorize the NN representation. As introduced earlier, we summarize the weights that connect the input and hidden layers by a d×m dimensional matrix W(h), where d is the number of hidden units and m is the number of input units. Activating a neural network via forward propagation In this section, we will describe the process of forward propagation to calculate the output of an MLP model. To understand how it fits into the context of learning an MLP model, let’s summarize the MLP learning procedure in three simple steps: 1. Starting at the input layer, we forward propagate the patterns of the training data through the network to generate an output. 2. Based on the network’s output, we calculate the loss that we want to minimize using a loss function", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 309, "start_word": 98880, "end_word": 99280, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000310": {"text": "we will describe the process of forward propagation to calculate the output of an MLP model. To understand how it fits into the context of learning an MLP model, let’s summarize the MLP learning procedure in three simple steps: 1. Starting at the input layer, we forward propagate the patterns of the training data through the network to generate an output. 2. Based on the network’s output, we calculate the loss that we want to minimize using a loss function that we will describe later. Chapter 11 341 3. We backpropagate the loss, find its derivative with respect to each weight and bias unit in the network, and update the model. Finally, after we repeat these three steps for multiple epochs and learn the weight and bias parame - ters of the MLP, we use forward propagation to calculate the network output and apply a threshold function to obtain the predicted class labels in the one-hot representation, which we described in the previous section. Now, let’s walk through the individual steps of forward propagation to generate an output from the patterns in the training data. Since each unit in the hidden layer is connected to all units in the input layers, we first calculate the activation unit of the hidden layer 𝑎𝑎1(ℎ) as follows: 𝑧𝑧1(ℎ)=𝑥𝑥1(𝑖𝑖𝑖𝑖)𝑤𝑤1,1(ℎ)+𝑥𝑥2(𝑖𝑖𝑖𝑖)𝑤𝑤1,2(ℎ)+⋯+𝑥𝑥𝑚𝑚(𝑖𝑖𝑖𝑖)𝑤𝑤1,𝑚𝑚(ℎ) 𝑎𝑎1(ℎ)= 𝜎𝜎𝜎𝑧𝑧1(ℎ)) Here, 𝑧𝑧1(ℎ) is the net input and 𝜎𝜎(⋅) is the activation function, which has to be differentiable to learn the weights that connect the neurons using a gradient-based approach. To be able to solve complex problems such as image classification, we need nonlinear activation functions in our MLP model, for example, the sigmoid (logistic) activation function that we remember from the section about logistic regression in Chapter 3, A Tour of Machine Learning Classifiers Using Scikit-Learn: 𝜎𝜎(𝑧𝑧)=1 1+𝑒𝑒−𝑧𝑧 As you may recall, the sigmoid function is an S-shaped curve that maps the net input z onto a logistic distribution in the range 0 to 1, which cuts the y axis at z = 0, as shown in Figure 11.3: Figure 11.3: The sigmoid activation function Implementing a Multilayer Artificial Neural Network from Scratch 342 MLP is a typical example of a feedforward artificial NN. The term feedforward refers to the fact that each layer serves as the input to the next layer without loops, in contrast to recurrent NNs—an archi- tecture that we will discuss later in this chapter and discuss in more", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 310, "start_word": 99200, "end_word": 99600, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000311": {"text": "to 1, which cuts the y axis at z = 0, as shown in Figure 11.3: Figure 11.3: The sigmoid activation function Implementing a Multilayer Artificial Neural Network from Scratch 342 MLP is a typical example of a feedforward artificial NN. The term feedforward refers to the fact that each layer serves as the input to the next layer without loops, in contrast to recurrent NNs—an archi- tecture that we will discuss later in this chapter and discuss in more detail in Chapter 15, Modeling Sequential Data Using Recurrent Neural Networks. The term multilayer perceptron may sound a little bit confusing since the artificial neurons in this network architecture are typically sigmoid units, not perceptrons. We can think of the neurons in the MLP as logistic regression units that return values in the continuous range between 0 and 1. For purposes of code efficiency and readability, we will now write the activation in a more compact form using the concepts of basic linear algebra, which will allow us to vectorize our code implementa - tion via NumPy rather than writing multiple nested and computationally expensive Python for loops: 𝑧𝑧(ℎ)=𝒙𝒙(𝑖𝑖𝑖𝑖)𝑾𝑾(ℎ)𝑇𝑇+𝒃𝒃(ℎ) 𝑎𝑎(ℎ)= 𝜎𝜎𝜎𝜎𝜎(ℎ)) Here, z(h) is our 1×m dimensional feature vector. W(h) is a d×m dimensional weight matrix where d is the number of units in the hidden layer; consequently, the transposed matrix W(h)T is m ×d dimensional. The bias vector b(h) consists of d bias units (one bias unit per hidden node). After matrix-vector multiplication, we obtain the 1×d dimensional net input vector z(h) to calculate the activation a(h) (where 𝒂𝒂(ℎ)∈ℝ1×𝑑𝑑 ). Furthermore, we can generalize this computation to all n examples in the training dataset: Z(h) = X(in)W(h)T + b(h) Here, X(in) is now an n×m matrix, and the matrix multiplication will result in an n×d dimensional net input matrix, Z(h). Finally, we apply the activation function 𝜎𝜎(⋅) to each value in the net input matrix to get the n×d activation matrix in the next layer (here, the output layer): 𝑨𝑨(ℎ)= 𝜎𝜎𝜎𝜎𝜎(ℎ)) Similarly, we can write the activation of the output layer in vectorized form for multiple examples: Z(out) = A(h)W(out)T + b(out) Here, we multiply the transpose of the t×d matrix W(out) (t is the number of output units) by the n×d dimensional matrix, A(h), and add the t dimensional bias vector b(out) to obtain the n×t dimensional matrix, Z(out). (The columns in this matrix represent the outputs for", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 311, "start_word": 99520, "end_word": 99920, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000312": {"text": "activation matrix in the next layer (here, the output layer): 𝑨𝑨(ℎ)= 𝜎𝜎𝜎𝜎𝜎(ℎ)) Similarly, we can write the activation of the output layer in vectorized form for multiple examples: Z(out) = A(h)W(out)T + b(out) Here, we multiply the transpose of the t×d matrix W(out) (t is the number of output units) by the n×d dimensional matrix, A(h), and add the t dimensional bias vector b(out) to obtain the n×t dimensional matrix, Z(out). (The columns in this matrix represent the outputs for each sample.) Lastly, we apply the sigmoid activation function to obtain the continuous-valued output of our network: 𝑨𝑨(𝑜𝑜𝑜𝑜𝑜𝑜)= 𝜎𝜎𝜎𝜎𝜎(𝑜𝑜𝑜𝑜𝑜𝑜)) Similar to Z(out), A(out) is an n×t dimensional matrix. Chapter 11 343 Classifying handwritten digits In the previous section, we covered a lot of the theory around NNs, which can be a little bit over - whelming if you are new to this topic. Before we continue with the discussion of the algorithm for learning the weights of the MLP model, backpropagation, let’s take a short break from the theory and see an NN in action. In this section, we will implement and train our first multilayer NN to classify handwritten digits from the popular Mixed National Institute of Standards and Technology (MNIST) dataset that has been constructed by Yann LeCun and others and serves as a popular benchmark dataset for machine learning algorithms (Gradient-Based Learning Applied to Document Recognition by Y. LeCun, L. Bottou, Y. Bengio, and P. Haffner, Proceedings of the IEEE, 86(11): 2278-2324, 1998). Obtaining and preparing the MNIST dataset The MNIST dataset is publicly available at http://yann.lecun.com/exdb/mnist/ and consists of the following four parts: 1. Training dataset images: train-images-idx3-ubyte.gz (9.9 MB, 47 MB unzipped, and 60,000 examples) 2. Training dataset labels: train-labels-idx1-ubyte.gz (29 KB, 60 KB unzipped, and 60,000 labels) 3. Test dataset images: t10k-images-idx3-ubyte.gz (1.6 MB, 7.8 MB unzipped, and 10,000 ex - amples) 4. Test dataset labels: t10k-labels-idx1-ubyte.gz (5 KB, 10 KB unzipped, and 10,000 labels)Additional resources on backpropagation The NN theory can be quite complex; thus, we want to provide readers with additional resources that cover some of the topics we discuss in this chapter in more detail or from a different perspective: • Chapter 6, Deep Feedforward Networks, Deep Learning, by I. Goodfellow, Y. Bengio, and A. Courville, MIT Press, 2016 (manuscripts freely accessible at http://www. deeplearningbook.org ). • Pattern Recognition and Machine Learning, by C. M. Bishop, Springer New York, 2006. •", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 312, "start_word": 99840, "end_word": 100240, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000313": {"text": "labels)Additional resources on backpropagation The NN theory can be quite complex; thus, we want to provide readers with additional resources that cover some of the topics we discuss in this chapter in more detail or from a different perspective: • Chapter 6, Deep Feedforward Networks, Deep Learning, by I. Goodfellow, Y. Bengio, and A. Courville, MIT Press, 2016 (manuscripts freely accessible at http://www. deeplearningbook.org ). • Pattern Recognition and Machine Learning, by C. M. Bishop, Springer New York, 2006. • Lecture video slides from Sebastian Raschka’s deep learning course: https://sebastianraschka.com/blog/2021/dl-course.html#l08- multinomial-logistic-regression--softmax-regression https://sebastianraschka.com/blog/2021/dl-course.html#l09- multilayer-perceptrons-and-backpropration Implementing a Multilayer Artificial Neural Network from Scratch 344 The MNIST dataset was constructed from two datasets of the US National Institute of Standards and Technology (NIST ). The training dataset consists of handwritten digits from 250 different people, 50 percent high school students, and 50 percent employees from the Census Bureau. Note that the test dataset contains handwritten digits from different people following the same split. Instead of downloading the abovementioned dataset files and preprocessing them into NumPy arrays ourselves, we will use scikit-learn’s new fetch_openml function, which allows us to load the MNIST dataset more conveniently: >>> from sklearn.datasets import fetch_openml >>> X, y = fetch_openml( 'mnist_784' , version= 1, ... return_X_y= True) >>> X = X.values >>> y = y.astype( int).values In scikit-learn, the fetch_openml function downloads the MNIST dataset from OpenML ( https://www. openml.org/d/554 ) as pandas DataFrame and Series objects, which is why we use the .values attribute to obtain the underlying NumPy arrays. (If you are using a scikit-learn version older than 1.0, fetch_openml downloads NumPy arrays directly so you can omit using the .values attribute.) The n×m dimensional X array consists of 70,000 images with 784 pixels each, and the y array stores the corresponding 70,000 class labels, which we can confirm by checking the dimensions of the arrays as follows: >>> print(X.shape) (70000, 784) >>> print(y.shape) (70000,) The images in the MNIST dataset consist of 28×28 pixels, and each pixel is represented by a grayscale intensity value. Here, fetch_openml already unrolled the 28×28 pixels into one-dimensional row vectors, which represent the rows in our X array (784 per row or image) above. The second array ( y) returned by the fetch_openml function contains the corresponding target variable, the class labels (integers 0-9) of the handwritten digits. Next, let’s normalize the pixels values in MNIST to the range –1 to", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 313, "start_word": 100160, "end_word": 100560, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000314": {"text": "in the MNIST dataset consist of 28×28 pixels, and each pixel is represented by a grayscale intensity value. Here, fetch_openml already unrolled the 28×28 pixels into one-dimensional row vectors, which represent the rows in our X array (784 per row or image) above. The second array ( y) returned by the fetch_openml function contains the corresponding target variable, the class labels (integers 0-9) of the handwritten digits. Next, let’s normalize the pixels values in MNIST to the range –1 to 1 (originally 0 to 255) via the fol- lowing code line: >>> X = ((X / 255.) - .5) * 2 The reason behind this is that gradient-based optimization is much more stable under these conditions, as discussed in Chapter 2. Note that we scaled the images on a pixel-by-pixel basis, which is different from the feature-scaling approach that we took in previous chapters. Previously, we derived scaling parameters from the training dataset and used these to scale each column in the training dataset and test dataset. However, when working with image pixels, centering them at zero and rescaling them to a [–1, 1] range is also common and usually works well in practice. Chapter 11 345 To get an idea of how those images in MNIST look, let’s visualize examples of the digits 0-9 after re - shaping the 784-pixel vectors from our feature matrix into the original 28×28 image that we can plot via Matplotlib’s imshow function: >>> import matplotlib.pyplot as plt >>> fig, ax = plt.subplots(nrows= 2, ncols= 5, ... sharex= True, sharey= True) >>> ax = ax.flatten() >>> for i in range (10): ... img = X[y == i][ 0].reshape( 28, 28) ... ax[i].imshow(img, cmap= 'Greys') >>> ax[0].set_xticks([]) >>> ax[0].set_yticks([]) >>> plt.tight_layout() >>> plt.show() We should now see a plot of the 2×5 subfigures showing a representative image of each unique digit: Figure 11.4: A plot showing one randomly chosen handwritten digit from each class In addition, let’s also plot multiple examples of the same digit to see how different the handwriting for each really is: >>> fig, ax = plt.subplots(nrows= 5, ... ncols= 5, ... sharex= True, ... sharey= True) >>> ax = ax.flatten() Implementing a Multilayer Artificial Neural Network from Scratch 346 >>> for i in range (25): ... img = X[y == 7][i].reshape( 28, 28) ... ax[i].imshow(img, cmap= 'Greys') >>> ax[0].set_xticks([]) >>> ax[0].set_yticks([]) >>> plt.tight_layout() >>> plt.show() After executing the code, we should", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 314, "start_word": 100480, "end_word": 100880, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000315": {"text": "addition, let’s also plot multiple examples of the same digit to see how different the handwriting for each really is: >>> fig, ax = plt.subplots(nrows= 5, ... ncols= 5, ... sharex= True, ... sharey= True) >>> ax = ax.flatten() Implementing a Multilayer Artificial Neural Network from Scratch 346 >>> for i in range (25): ... img = X[y == 7][i].reshape( 28, 28) ... ax[i].imshow(img, cmap= 'Greys') >>> ax[0].set_xticks([]) >>> ax[0].set_yticks([]) >>> plt.tight_layout() >>> plt.show() After executing the code, we should now see the first 25 variants of the digit 7: Figure 11.5: Different variants of the handwritten digit 7 Finally, let’s divide the dataset into training, validation, and test subsets. The following code will split the dataset such that 55,000 images are used for training, 5,000 images for validation, and 10,000 images for testing: >>> from sklearn.model_selection import train_test_split >>> X_temp, X_test, y_temp, y_test = train_test_split( ... X, y, test_size= 10000, random_state= 123, stratify=y ... ) >>> X_train, X_valid, y_train, y_valid = train_test_split( ... X_temp, y_temp, test_size= 5000, ... random_state= 123, stratify=y_temp ... ) Chapter 11 347 Implementing a multilayer perceptron In this subsection, we will now implement an MLP from scratch to classify the images in the MNIST dataset. To keep things simple, we will implement an MLP with only one hidden layer. Since the ap - proach may seem a little bit complicated at first, you are encouraged to download the sample code for this chapter from the Packt Publishing website or from GitHub ( https://github.com/rasbt/ machine-learning-book ) so that you can view this MLP implementation annotated with comments and syntax highlighting for better readability. If you are not running the code from the accompanying Jupyter Notebook file or don’t have access to the internet, copy the NeuralNetMLP code from this chapter into a Python script file in your current working directory (for example, neuralnet.py) , which you can then import into your current Python session via the following command: from neuralnet import NeuralNetMLP The code will contain parts that we have not talked about yet, such as the backpropagation algo - rithm. Do not worry if not all the code makes immediate sense to you; we will follow up on certain parts later in this chapter. However, going over the code at this stage can make it easier to follow the theory later. So, let’s look at the following implementation of an MLP, starting with the two", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 315, "start_word": 100800, "end_word": 101200, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000316": {"text": "following command: from neuralnet import NeuralNetMLP The code will contain parts that we have not talked about yet, such as the backpropagation algo - rithm. Do not worry if not all the code makes immediate sense to you; we will follow up on certain parts later in this chapter. However, going over the code at this stage can make it easier to follow the theory later. So, let’s look at the following implementation of an MLP, starting with the two helper functions to compute the logistic sigmoid activation and to convert integer class label arrays to one-hot encoded labels: import numpy as np def sigmoid (z): return 1. / (1. + np.exp(-z)) def int_to_onehot (y, num_labels): ary = np.zeros((y.shape[ 0], num_labels)) for i, val in enumerate (y): ary[i, val] = 1 return ary Implementing a Multilayer Artificial Neural Network from Scratch 348 Below, we implement the main class for our MLP, which we call NeuralNetMLP . There are three class methods, .__init__() , .forward() , and .backward() , that we will discuss one by one, starting with the __init__ constructor: class NeuralNetMLP : def __init__(self, num_features, num_hidden, num_classes, random_seed= 123): super().__init__() self.num_classes = num_classes # hidden rng = np.random.RandomState(random_seed) self.weight_h = rng.normal( loc= 0.0, scale= 0.1, size=(num_hidden, num_features)) self.bias_h = np.zeros(num_hidden) # output self.weight_out = rng.normal( loc= 0.0, scale= 0.1, size=(num_classes, num_hidden)) self.bias_out = np.zeros(num_classes) The __init__ constructor instantiates the weight matrices and bias vectors for the hidden and the output layer. Next, let’s see how these are used in the forward method to make predictions: def forward (self, x): # Hidden layer # input dim: [n_hidden, n_features] # dot [n_features, n_examples] .T # output dim: [n_examples, n_hidden] z_h = np.dot(x, self.weight_h.T) + self.bias_h a_h = sigmoid(z_h) # Output layer # input dim: [n_classes, n_hidden] # dot [n_hidden, n_examples] .T # output dim: [n_examples, n_classes] z_out = np.dot(a_h, self.weight_out.T) + self.bias_out a_out = sigmoid(z_out) return a_h, a_out Chapter 11 349 The forward method takes in one or more training examples and returns the predictions. In fact, it returns both the activation values from the hidden layer and the output layer, a_h and a_out . While a_out represents the class-membership probabilities that we can convert to class labels, which we care about, we also need the activation values from the hidden layer, a_h, to optimize the model pa - rameters; that is, the weight and bias units of the hidden and", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 316, "start_word": 101120, "end_word": 101520, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000317": {"text": "The forward method takes in one or more training examples and returns the predictions. In fact, it returns both the activation values from the hidden layer and the output layer, a_h and a_out . While a_out represents the class-membership probabilities that we can convert to class labels, which we care about, we also need the activation values from the hidden layer, a_h, to optimize the model pa - rameters; that is, the weight and bias units of the hidden and output layers. Finally, let’s talk about the backward method, which updates the weight and bias parameters of the neural network: def backward (self, x, a_h, a_out, y): ######################### ### Output layer weights ######################### # one-hot encoding y_onehot = int_to_onehot(y, self.num_classes) # Part 1: dLoss/dOutWeights ## = dLoss/dOutAct * dOutAct/dOutNet * dOutNet/dOutWeight ## where DeltaOut = dLoss/dOutAct * dOutAct/dOutNet ## for convenient re-use # input/output dim: [n_examples, n_classes] d_loss__d_a_out = 2.*(a_out - y_onehot) / y.shape[ 0] # input/output dim: [n_examples, n_classes] d_a_out__d_z_out = a_out * ( 1. - a_out) # sigmoid derivative # output dim: [n_examples, n_classes] delta_out = d_loss__d_a_out * d_a_out__d_z_out # gradient for output weights # [n_examples, n_hidden] d_z_out__dw_out = a_h # input dim: [n_classes, n_examples] # dot [n_examples, n_hidden] # output dim: [n_classes, n_hidden] d_loss__dw_out = np.dot(delta_out.T, d_z_out__dw_out) d_loss__db_out = np. sum(delta_out, axis= 0) Implementing a Multilayer Artificial Neural Network from Scratch 350 ################################# # Part 2: dLoss/dHiddenWeights ## = DeltaOut * dOutNet/dHiddenAct * dHiddenAct/dHiddenNet # * dHiddenNet/dWeight # [n_classes, n_hidden] d_z_out__a_h = self.weight_out # output dim: [n_examples, n_hidden] d_loss__a_h = np.dot(delta_out, d_z_out__a_h) # [n_examples, n_hidden] d_a_h__d_z_h = a_h * ( 1. - a_h) # sigmoid derivative # [n_examples, n_features] d_z_h__d_w_h = x # output dim: [n_hidden, n_features] d_loss__d_w_h = np.dot((d_loss__a_h * d_a_h__d_z_h).T, d_z_h__d_w_h) d_loss__d_b_h = np. sum((d_loss__a_h * d_a_h__d_z_h), axis= 0) return (d_loss__dw_out, d_loss__db_out, d_loss__d_w_h, d_loss__d_b_h) The backward method implements the so-called backpropagation algorithm, which calculates the gra - dients of the loss with respect to the weight and bias parameters. Similar to Adaline, these gradients are then used to update these parameters via gradient descent. Note that multilayer NNs are more complex than their single-layer siblings, and we will go over the mathematical concepts of how to compute the gradients in a later section after discussing the code. For now, just consider the backward method as a way for computing gradients that are used for the gradient descent updates. For simplic- ity, the loss function this", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 317, "start_word": 101440, "end_word": 101840, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000318": {"text": "weight and bias parameters. Similar to Adaline, these gradients are then used to update these parameters via gradient descent. Note that multilayer NNs are more complex than their single-layer siblings, and we will go over the mathematical concepts of how to compute the gradients in a later section after discussing the code. For now, just consider the backward method as a way for computing gradients that are used for the gradient descent updates. For simplic- ity, the loss function this derivation is based on is the same MSE loss that we used in Adaline. In later chapters, we will look at alternative loss functions, such as multi-category cross-entropy loss, which is a generalization of the binary logistic regression loss to multiple classes. Looking at this code implementation of the NeuralNetMLP class, you may have noticed that this object-oriented implementation differs from the familiar scikit-learn API that is centered around the .fit() and .predict() methods. Instead, the main methods of the NeuralNetMLP class are the .forward() and .backward() methods. One of the reasons behind this is that it makes a complex neu- ral network a bit easier to understand in terms of how the information flows through the networks. Chapter 11 351 Another reason is that this implementation is relatively similar to how more advanced deep learning libraries such as PyTorch operate, which we will introduce and use in the upcoming chapters to im- plement more complex neural networks. After we have implemented the NeuralNetMLP class, we use the following code to instantiate a new NeuralNetMLP object: >>> model = NeuralNetMLP(num_features= 28*28, ... num_hidden= 50, ... num_classes= 10) The model accepts MNIST images reshaped into 784-dimensional vectors (in the format of X_train , X_valid , or X_test , which we defined previously) for the 10 integer classes (digits 0-9). The hidden layer consists of 50 nodes. Also, as you may be able to tell from looking at the previously defined .forward() method, we use a sigmoid activation function after the first hidden layer and output layer to keep things simple. In later chapters, we will learn about alternative activation functions for both the hidden and output layers. Figure 11.6 summarizes the neural network architecture that we instantiated above: Figure 11.6: The NN architecture for labeling handwritten digits In the next subsection, we are going to implement the training function that we can use to train the network on mini-batches of the", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 318, "start_word": 101760, "end_word": 102160, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000319": {"text": "method, we use a sigmoid activation function after the first hidden layer and output layer to keep things simple. In later chapters, we will learn about alternative activation functions for both the hidden and output layers. Figure 11.6 summarizes the neural network architecture that we instantiated above: Figure 11.6: The NN architecture for labeling handwritten digits In the next subsection, we are going to implement the training function that we can use to train the network on mini-batches of the data via backpropagation. Implementing a Multilayer Artificial Neural Network from Scratch 352 Coding the neural network training loop Now that we have implemented the NeuralNetMLP class in the previous subsection and initiated a model, the next step is to train the model. We will tackle this in multiple steps. First, we will define some helper functions for data loading. Second, we will embed these functions into the training loop that iterates over the dataset in multiple epochs. The first function we are going to define is a mini-batch generator, which takes in our dataset and divides it into mini-batches of a desired size for stochastic gradient descent training. The code is as follows: >>> import numpy as np >>> num_epochs = 50 >>> minibatch_size = 100 >>> def minibatch_generator (X, y, minibatch_size): ... indices = np.arange(X.shape[ 0]) ... np.random.shuffle(indices) ... for start_idx in range (0, indices.shape[ 0] - minibatch_size ... + 1, minibatch_size): ... batch_idx = indices[start_idx:start_idx + minibatch_size] ... yield X[batch_idx], y[batch_idx] Before we move on to the next functions, let’s confirm that the mini-batch generator works as intended and produces mini-batches of the desired size. The following code will attempt to iterate through the dataset, and then we will print the dimension of the mini-batches. Note that in the following code examples, we will remove the break statements. The code is as follows: >>> # iterate over training epochs >>> for i in range (num_epochs): ... # iterate over minibatches ... minibatch_gen = minibatch_generator( ... X_train, y_train, minibatch_size) ... for X_train_mini, y_train_mini in minibatch_gen: ... break ... break >>> print(X_train_mini.shape) (100, 784) >>> print(y_train_mini.shape) (100,) As we can see, the network returns mini-batches of size 100 as intended. Chapter 11 353 Next, we have to define our loss function and performance metric that we can use to monitor the training process and evaluate the model. The MSE loss and accuracy function can be implemented as follows: >>> def", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 319, "start_word": 102080, "end_word": 102480, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000320": {"text": "over minibatches ... minibatch_gen = minibatch_generator( ... X_train, y_train, minibatch_size) ... for X_train_mini, y_train_mini in minibatch_gen: ... break ... break >>> print(X_train_mini.shape) (100, 784) >>> print(y_train_mini.shape) (100,) As we can see, the network returns mini-batches of size 100 as intended. Chapter 11 353 Next, we have to define our loss function and performance metric that we can use to monitor the training process and evaluate the model. The MSE loss and accuracy function can be implemented as follows: >>> def mse_loss (targets, probas, num_labels= 10): ... onehot_targets = int_to_onehot( ... targets, num_labels=num_labels ... ) ... return np.mean((onehot_targets - probas)** 2) >>> def accuracy (targets, predicted_labels): ... return np.mean(predicted_labels == targets) Let’s test the preceding function and compute the initial validation set MSE and accuracy of the model we instantiated in the previous section: >>> _, probas = model.forward(X_valid) >>> mse = mse_loss(y_valid, probas) >>> print(f'Initial validation MSE: {mse:.1f}') Initial validation MSE: 0.3 >>> predicted_labels = np.argmax(probas, axis= 1) >>> acc = accuracy(y_valid, predicted_labels) >>> print(f'Initial validation accuracy: {acc*100:.1f}%') Initial validation accuracy: 9.4% In this code example, note that model.forward() returns the hidden and output layer activations. Remember that we have 10 output nodes (one corresponding to each unique class label). Hence, when computing the MSE, we first converted the class labels into one-hot encoded class labels in the mse_loss() function. In practice, it does not make a difference whether we average over the row or the columns of the squared-difference matrix first, so we simply call np.mean() without any axis specification so that it returns a scalar. The output layer activations, since we used the logistic sigmoid function, are values in the range [0, 1]. For each input, the output layer produces 10 values in the range [0, 1], so we used the np.argmax() function to select the index position of the largest value, which yields the predicted class label. We then compared the true labels with the predicted class labels to compute the accuracy via the accuracy() function we defined. As we can see from the preceding output, the accuracy is not very high. Howev - er, given that we have a balanced dataset with 10 classes, a prediction accuracy of approximately 10 percent is what we would expect for an untrained model producing random predictions. Implementing a Multilayer Artificial Neural Network from Scratch 354 Using the previous code, we can compute the performance on, for example, the whole", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 320, "start_word": 102400, "end_word": 102800, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000321": {"text": "labels to compute the accuracy via the accuracy() function we defined. As we can see from the preceding output, the accuracy is not very high. Howev - er, given that we have a balanced dataset with 10 classes, a prediction accuracy of approximately 10 percent is what we would expect for an untrained model producing random predictions. Implementing a Multilayer Artificial Neural Network from Scratch 354 Using the previous code, we can compute the performance on, for example, the whole training set if we provide y_train as input to targets and the predicted labels from feeding the model with X_train . However, in practice, our computer memory is usually a limiting factor for how much data the model can ingest in one forward pass (due to the large matrix multiplications). Hence, we are defining our MSE and accuracy computation based on our previous mini-batch generator. The following function will compute the MSE and accuracy incrementally by iterating over the dataset one mini-batch at a time to be more memory-efficient: >>> def compute_mse_and_acc (nnet, X, y, num_labels= 10, ... minibatch_size= 100): ... mse, correct_pred, num_examples = 0., 0, 0 ... minibatch_gen = minibatch_generator(X, y, minibatch_size) ... for i, (features, targets) in enumerate(minibatch_gen): ... _, probas = nnet.forward(features) ... predicted_labels = np.argmax(probas, axis= 1) ... onehot_targets = int_to_onehot( ... targets, num_labels=num_labels ... ) ... loss = np.mean((onehot_targets - probas)** 2) ... correct_pred += (predicted_labels == targets). sum() ... num_examples += targets.shape[ 0] ... mse += loss ... mse = mse/i ... acc = correct_pred/num_examples ... return mse, acc Before we implement the training loop, let’s test the function and compute the initial training set MSE and accuracy of the model we instantiated in the previous section and make sure it works as intended: >>> mse, acc = compute_mse_and_acc(model, X_valid, y_valid) >>> print(f'Initial valid MSE: {mse:.1f}') Initial valid MSE: 0.3 >>> print(f'Initial valid accuracy: {acc*100:.1f}%') Initial valid accuracy: 9.4% As we can see from the results, our generator approach produces the same results as the previously defined MSE and accuracy functions, except for a small rounding error in the MSE (0.27 versus 0.28), which is negligible for our purposes. Let’s now get to the main part and implement the code to train our model: >>> def train(model, X_train, y_train, X_valid, y_valid, num_epochs, ... learning_rate= 0.1): ... epoch_loss = [] Chapter 11 355 ... epoch_train_acc = [] ... epoch_valid_acc = [] ... ... for", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 321, "start_word": 102720, "end_word": 103120, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000322": {"text": "from the results, our generator approach produces the same results as the previously defined MSE and accuracy functions, except for a small rounding error in the MSE (0.27 versus 0.28), which is negligible for our purposes. Let’s now get to the main part and implement the code to train our model: >>> def train(model, X_train, y_train, X_valid, y_valid, num_epochs, ... learning_rate= 0.1): ... epoch_loss = [] Chapter 11 355 ... epoch_train_acc = [] ... epoch_valid_acc = [] ... ... for e in range (num_epochs): ... # iterate over minibatches ... minibatch_gen = minibatch_generator( ... X_train, y_train, minibatch_size) ... for X_train_mini, y_train_mini in minibatch_gen: ... #### Compute outputs #### ... a_h, a_out = model.forward(X_train_mini) ... #### Compute gradients #### ... d_loss__d_w_out, d_loss__d_b_out, \\ ... d_loss__d_w_h, d_loss__d_b_h = \\ ... model.backward(X_train_mini, a_h, a_out, ... y_train_mini) ... ... #### Update weights #### ... model.weight_h -= learning_rate * d_loss__d_w_h ... model.bias_h -= learning_rate * d_loss__d_b_h ... model.weight_out -= learning_rate * d_loss__d_w_out ... model.bias_out -= learning_rate * d_loss__d_b_out ... ... #### Epoch Logging #### ... train_mse, train_acc = compute_mse_and_acc( ... model, X_train, y_train ... ) ... valid_mse, valid_acc = compute_mse_and_acc( ... model, X_valid, y_valid ... ) ... train_acc, valid_acc = train_acc* 100, valid_acc* 100 ... epoch_train_acc.append(train_acc) ... epoch_valid_acc.append(valid_acc) ... epoch_loss.append(train_mse) ... print(f'Epoch: {e+1:03d}/{num_epochs:03d} ' ... f'| Train MSE: {train_mse: .2f} ' ... f'| Train Acc: {train_acc: .2f}% ' ... f'| Valid Acc: {valid_acc: .2f}%') ... ... return epoch_loss, epoch_train_acc, epoch_valid_acc Implementing a Multilayer Artificial Neural Network from Scratch 356 On a high level, the train() function iterates over multiple epochs, and in each epoch, it used the pre - viously defined minibatch_generator() function to iterate over the whole training set in mini-batches for stochastic gradient descent training. Inside the mini-batch generator for loop, we obtain the out- puts from the model, a_h and a_out , via its .forward() method. Then, we compute the loss gradients via the model’s .backward() method—the theory will be explained in a later section. Using the loss gradients, we update the weights by adding the negative gradient multiplied by the learning rate. This is the same concept that we discussed earlier for Adaline. For example, to update the model weights of the hidden layer, we defined the following line: model.weight_h -= learning_rate * d_loss__d_w_h For a single weight, w j, this corresponds to the following partial derivative-based update: 𝑤𝑤𝑗𝑗≔𝑤𝑤𝑗𝑗−𝜂𝜂𝜕𝜕𝜕𝜕 𝜕𝜕𝑤𝑤𝑗𝑗 Finally, the last portion of the previous code computes the losses", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 322, "start_word": 103040, "end_word": 103440, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000323": {"text": "a later section. Using the loss gradients, we update the weights by adding the negative gradient multiplied by the learning rate. This is the same concept that we discussed earlier for Adaline. For example, to update the model weights of the hidden layer, we defined the following line: model.weight_h -= learning_rate * d_loss__d_w_h For a single weight, w j, this corresponds to the following partial derivative-based update: 𝑤𝑤𝑗𝑗≔𝑤𝑤𝑗𝑗−𝜂𝜂𝜕𝜕𝜕𝜕 𝜕𝜕𝑤𝑤𝑗𝑗 Finally, the last portion of the previous code computes the losses and prediction accuracies on the training and test sets to track the training progress. Let’s now execute this function to train our model for 50 epochs, which may take a few minutes to finish: >>> np.random.seed( 123) # for the training set shuffling >>> epoch_loss, epoch_train_acc, epoch_valid_acc = train( ... model, X_train, y_train, X_valid, y_valid, ... num_epochs= 50, learning_rate= 0.1) During training, we should see the following output: Epoch: 001/050 | Train MSE: 0.05 | Train Acc: 76.17% | Valid Acc: 76.02% Epoch: 002/050 | Train MSE: 0.03 | Train Acc: 85.46% | Valid Acc: 84.94% Epoch: 003/050 | Train MSE: 0.02 | Train Acc: 87.89% | Valid Acc: 87.64% Epoch: 004/050 | Train MSE: 0.02 | Train Acc: 89.36% | Valid Acc: 89.38% Epoch: 005/050 | Train MSE: 0.02 | Train Acc: 90.21% | Valid Acc: 90.16% ... Epoch: 048/050 | Train MSE: 0.01 | Train Acc: 95.57% | Valid Acc: 94.58% Epoch: 049/050 | Train MSE: 0.01 | Train Acc: 95.55% | Valid Acc: 94.54% Epoch: 050/050 | Train MSE: 0.01 | Train Acc: 95.59% | Valid Acc: 94.74% The reason why we print all this output is that, in NN training, it is really useful to compare training and validation accuracy. This helps us judge whether the network model performs well, given the architecture and hyperparameters. For example, if we observe a low training and validation accuracy, there is likely an issue with the training dataset, or the hyperparameters’ settings are not ideal. In general, training (deep) NNs is relatively expensive compared with the other models we’ve discussed so far. Thus, we want to stop it early in certain circumstances and start over with different hyperpa - rameter settings. On the other hand, if we find that it increasingly tends to overfit the training data (noticeable by an increasing gap between training and validation dataset performance), we may want to stop the training early, as well. Chapter", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 323, "start_word": 103360, "end_word": 103760, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000324": {"text": "the hyperparameters’ settings are not ideal. In general, training (deep) NNs is relatively expensive compared with the other models we’ve discussed so far. Thus, we want to stop it early in certain circumstances and start over with different hyperpa - rameter settings. On the other hand, if we find that it increasingly tends to overfit the training data (noticeable by an increasing gap between training and validation dataset performance), we may want to stop the training early, as well. Chapter 11 357 In the next subsection, we will discuss the performance of our NN model in more detail. Evaluating the neural network performance Before we discuss backpropagation, the training procedure of NNs, in more detail in the next section, let’s look at the performance of the model that we trained in the previous subsection. In train() , we collected the training loss and the training and validation accuracy for each epoch so that we can visualize the results using Matplotlib. Let’s look at the training MSE loss first: >>> plt.plot( range(len(epoch_loss)), epoch_loss) >>> plt.ylabel( 'Mean squared error' ) >>> plt.xlabel( 'Epoch') >>> plt.show() The preceding code plots the loss over the 50 epochs, as shown in Figure 11.7: Figure 11.7: A plot of the MSE by the number of training epochs As we can see, the loss decreased substantially during the first 10 epochs and seems to slowly converge in the last 10 epochs. However, the small slope between epoch 40 and epoch 50 indicates that the loss would further decrease with training over additional epochs. Next, let’s take a look at the training and validation accuracy: >>> plt.plot( range(len(epoch_train_acc)), epoch_train_acc, ... label= 'Training' ) >>> plt.plot( range(len(epoch_valid_acc)), epoch_valid_acc, ... label= 'Validation' ) >>> plt.ylabel( 'Accuracy' ) >>> plt.xlabel( 'Epochs' ) >>> plt.legend(loc= 'lower right' ) >>> plt.show() Implementing a Multilayer Artificial Neural Network from Scratch 358 The preceding code examples plot those accuracy values over the 50 training epochs, as shown in Figure 11.8: Figure 11.8: Classification accuracy by the number of training epochs The plot reveals that the gap between training and validation accuracy increases as we train for more epochs. At approximately the 25th epoch, the training and validation accuracy values are almost equal, and then, the network starts to slightly overfit the training data. Finally, let’s evaluate the generalization performance of the model by calculating the prediction ac- curacy on the test dataset: >>> test_mse, test_acc", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 324, "start_word": 103680, "end_word": 104080, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000325": {"text": "as shown in Figure 11.8: Figure 11.8: Classification accuracy by the number of training epochs The plot reveals that the gap between training and validation accuracy increases as we train for more epochs. At approximately the 25th epoch, the training and validation accuracy values are almost equal, and then, the network starts to slightly overfit the training data. Finally, let’s evaluate the generalization performance of the model by calculating the prediction ac- curacy on the test dataset: >>> test_mse, test_acc = compute_mse_and_acc(model, X_test, y_test) >>> print(f'Test accuracy: {test_acc* 100:.2f}%') Test accuracy: 94.51% We can see that the test accuracy is very close to the validation set accuracy corresponding to the last epoch (94.74%), which we reported during the training in the last subsection. Moreover, the respec- tive training accuracy is only minimally higher at 95.59%, reaffirming that our model only slightly overfits the training data. To further fine-tune the model, we could change the number of hidden units, the learning rate, or use various other tricks that have been developed over the years but are beyond the scope of this book. In Chapter 14, Classifying Images with Deep Convolutional Neural Networks, you will learn about a different NN architecture that is known for its good performance on image datasets.Reducing overfitting One way to decrease the effect of overfitting is to increase the regularization strength via L2 regularization, which we introduced in Chapter 3, A Tour of Machine Learning Classifiers Using Scikit-Learn. Another useful technique for tackling overfitting in NNs is dropout, which will be covered in Chapter 14, Classifying Images with Deep Convolutional Neural Networks. Chapter 11 359 Also, the chapter will introduce additional performance-enhancing tricks such as adaptive learning rates, more sophisticated SGD-based optimization algorithms, batch normalization, and dropout. Other common tricks that are beyond the scope of the following chapters include: • Adding skip-connections, which are the main contribution of residual NNs (Deep residual learn - ing for image recognition by K. He, X. Zhang, S. Ren, and J. Sun, Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition, pp. 770-778, 2016) • Using learning rate schedulers that change the learning rate during training (Cyclical learning rates for training neural networks by L.N. Smith, 2017 IEEE Winter Conference on Applications of Computer Vision (WACV), pp. 464-472, 2017) • Attaching loss functions to earlier layers in the networks as it’s being done in the popular In- ception", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 325, "start_word": 104000, "end_word": 104400, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000326": {"text": "image recognition by K. He, X. Zhang, S. Ren, and J. Sun, Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition, pp. 770-778, 2016) • Using learning rate schedulers that change the learning rate during training (Cyclical learning rates for training neural networks by L.N. Smith, 2017 IEEE Winter Conference on Applications of Computer Vision (WACV), pp. 464-472, 2017) • Attaching loss functions to earlier layers in the networks as it’s being done in the popular In- ception v3 architecture (Rethinking the Inception architecture for computer vision by C. Szegedy, V. Vanhoucke, S. Ioffe, J. Shlens, and Z. Wojna, Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition, pp. 2818-2826, 2016) Lastly, let’s take a look at some of the images that our MLP struggles with by extracting and plotting the first 25 misclassified samples from the test set: >>> X_test_subset = X_test[: 1000, :] >>> y_test_subset = y_test[: 1000] >>> _, probas = model.forward(X_test_subset) >>> test_pred = np.argmax(probas, axis= 1) >>> misclassified_images = \\ ... X_test_subset[y_test_subset != test_pred][: 25] >>> misclassified_labels = test_pred[y_test_subset != test_pred][: 25] >>> correct_labels = y_test_subset[y_test_subset != test_pred][: 25] >>> fig, ax = plt.subplots(nrows= 5, ncols= 5, ... sharex= True, sharey= True, ... figsize=( 8, 8)) >>> ax = ax.flatten() >>> for i in range (25): ... img = misclassified_images[i].reshape( 28, 28) ... ax[i].imshow(img, cmap= 'Greys', interpolation= 'nearest' ) ... ax[i].set_title( f'{i+1}) ' ... f'True: {correct_labels[i]} \\n' ... f' Predicted: {misclassified_labels[i]} ') >>> ax[0].set_xticks([]) >>> ax[0].set_yticks([]) >>> plt.tight_layout() >>> plt.show() Implementing a Multilayer Artificial Neural Network from Scratch 360 We should now see a 5×5 subplot matrix where the first number in the subtitles indicates the plot index, the second number represents the true class label ( True ), and the third number stands for the predicted class label ( Predicted ): Figure 11.9: Handwritten digits that the model fails to classify correctly As we can see in Figure 11.9, among others, the network finds 7s challenging when they include a horizontal line as in examples 19 and 20. Looking back at an earlier figure in this chapter where we plotted different training examples of the number 7, we can hypothesize that the handwritten digit 7 with a horizontal line is underrepresented in our dataset and is often misclassified. Training an artificial neural network Now that we have seen an NN in action and have gained a basic understanding of how", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 326, "start_word": 104320, "end_word": 104720, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000327": {"text": "others, the network finds 7s challenging when they include a horizontal line as in examples 19 and 20. Looking back at an earlier figure in this chapter where we plotted different training examples of the number 7, we can hypothesize that the handwritten digit 7 with a horizontal line is underrepresented in our dataset and is often misclassified. Training an artificial neural network Now that we have seen an NN in action and have gained a basic understanding of how it works by look - ing over the code, let’s dig a little bit deeper into some of the concepts, such as the loss computation and the backpropagation algorithm that we implemented to learn the model parameters. Computing the loss function As mentioned previously, we used an MSE loss (as in Adaline) to train the multilayer NN as it makes the derivation of the gradients a bit easier to follow. In later chapters, we will discuss other loss functions, such as the multi-category cross-entropy loss (a generalization of the binary logistic regression loss), which is a more common choice for training NN classifiers. Chapter 11 361 In the previous section, we implemented an MLP for multiclass classification that returns an output vector of t elements that we need to compare to the t ×1 dimensional target vector in the one-hot encoding representation. If we predict the class label of an input image with class label 2, using this MLP, the activation of the third layer and the target may look like this: 𝑎𝑎(𝑜𝑜𝑜𝑜𝑜𝑜 )=[0.1 0.9 ⋮ 0.3], 𝑦𝑦 =[0 1 ⋮ 0] Thus, our MSE loss either has to sum or average over the t activation units in our network in addition to averaging over the n examples in the dataset or mini-batch: 𝐿𝐿(𝑾𝑾𝑾𝑾𝑾)=1 𝑛𝑛∑1 𝑡𝑡∑(𝑦𝑦𝑗𝑗[𝑖𝑖]−𝑎𝑎𝑗𝑗(𝑜𝑜𝑜𝑜𝑜𝑜)[𝑖𝑖])2𝑜𝑜 𝑗𝑗𝑗𝑗𝑛𝑛 𝑗 Here, again, the superscript [i] is the index of a particular example in our training dataset. Remember that our goal is to minimize the loss function L(W); thus, we need to calculate the partial derivative of the parameters W with respect to each weight for every layer in the network: 𝜕𝜕 𝜕𝜕𝜕𝜕𝑗𝑗𝑗𝑗𝑗(𝑗𝑗)=𝐿𝐿(𝑾𝑾𝑗𝑾𝑾) In the next section, we will talk about the backpropagation algorithm, which allows us to calculate those partial derivatives to minimize the loss function. Note that W consists of multiple matrices. In an MLP with one hidden layer, we have the weight matrix, W(h), which connects the input to the", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 327, "start_word": 104640, "end_word": 105040, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000328": {"text": "minimize the loss function L(W); thus, we need to calculate the partial derivative of the parameters W with respect to each weight for every layer in the network: 𝜕𝜕 𝜕𝜕𝜕𝜕𝑗𝑗𝑗𝑗𝑗(𝑗𝑗)=𝐿𝐿(𝑾𝑾𝑗𝑾𝑾) In the next section, we will talk about the backpropagation algorithm, which allows us to calculate those partial derivatives to minimize the loss function. Note that W consists of multiple matrices. In an MLP with one hidden layer, we have the weight matrix, W(h), which connects the input to the hidden layer, and W(out), which connects the hidden layer to the output layer. A visualization of the three-dimensional tensor W is provided in Figure 11.10: Figure 11.10: A visualization of a three-dimensional tensor Implementing a Multilayer Artificial Neural Network from Scratch 362 In this simplified figure, it may seem that both W(h) and W(out) have the same number of rows and col- umns, which is typically not the case unless we initialize an MLP with the same number of hidden units, output units, and input features. If this sounds confusing, stay tuned for the next section, where we will discuss the dimensionality of W(h) and W(out) in more detail in the context of the backpropagation algorithm. Also, you are encouraged to read through the code of NeuralNetMLP again, which is annotated with helpful comments about the dimensionality of the different matrices and vector transformations. Developing your understanding of backpropagation Although backpropagation was introduced to the neural network community more than 30 years ago (Learning representations by backpropagating errors, by D.E. Rumelhart, G.E. Hinton, and R.J. Williams, Nature, 323: 6088, pages 533–536, 1986), it remains one of the most widely used algorithms for training artificial NNs very efficiently. If you are interested in additional references regarding the history of backpropagation, Juergen Schmidhuber wrote a nice survey article, Who Invented Backpropagation?, which you can find online at http://people.idsia.ch/~juergen/who-invented-backpropagation. html . This section will provide both a short, clear summary and the bigger picture of how this fascinat - ing algorithm works before we dive into more mathematical details. In essence, we can think of backpropagation as a very computationally efficient approach to compute the partial derivatives of a complex, non-convex loss function in multilayer NNs. Here, our goal is to use those derivatives to learn the weight coefficients for parameterizing such a multilayer artificial NN. The challenge in the parameterization of NNs is that we are typically dealing with a very large", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 328, "start_word": 104960, "end_word": 105360, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000329": {"text": "picture of how this fascinat - ing algorithm works before we dive into more mathematical details. In essence, we can think of backpropagation as a very computationally efficient approach to compute the partial derivatives of a complex, non-convex loss function in multilayer NNs. Here, our goal is to use those derivatives to learn the weight coefficients for parameterizing such a multilayer artificial NN. The challenge in the parameterization of NNs is that we are typically dealing with a very large number of model param- eters in a high-dimensional feature space. In contrast to loss functions of single-layer NNs such as Adaline or logistic regression, which we have seen in previous chapters, the error surface of an NN loss function is not convex or smooth with respect to the parameters. There are many bumps in this high-dimensional loss surface (local minima) that we have to overcome in order to find the global minimum of the loss function. You may recall the concept of the chain rule from your introductory calculus classes. The chain rule is an approach to compute the derivative of a complex, nested function, such as f(g(x)), as follows: 𝑑𝑑 𝑑𝑑𝑑𝑑[𝑓𝑓(𝑔𝑔(𝑑𝑑))]=𝑑𝑑𝑓𝑓 𝑑𝑑𝑔𝑔⋅𝑑𝑑𝑔𝑔 𝑑𝑑𝑑𝑑 Similarly, we can use the chain rule for an arbitrarily long function composition. For example, let’s assume that we have five different functions, f(x), g(x), h(x), u(x), and v(x), and let F be the function composition: F(x) = f (g(h(u(v(x))))). Applying the chain rule, we can compute the derivative of this function as follows: 𝑑𝑑𝑑𝑑 𝑑𝑑𝑑𝑑=𝑑𝑑 𝑑𝑑𝑑𝑑𝑑𝑑(𝑑𝑑)=𝑑𝑑 𝑑𝑑𝑑𝑑𝑓𝑓(𝑔𝑔(ℎ(𝑢𝑢(𝑣𝑣(𝑑𝑑)))))=𝑑𝑑𝑓𝑓 𝑑𝑑𝑔𝑔⋅𝑑𝑑𝑔𝑔 𝑑𝑑ℎ⋅𝑑𝑑ℎ 𝑑𝑑𝑢𝑢⋅𝑑𝑑𝑢𝑢 𝑑𝑑𝑣𝑣⋅𝑑𝑑𝑣𝑣 𝑑𝑑𝑑𝑑 Chapter 11 363 In the context of computer algebra, a set of techniques, known as automatic differentiation , has been developed to solve such problems very efficiently. If you are interested in learning more about automatic differentiation in machine learning applications, read A.G. Baydin and B.A. Pearlmutter’s article, Automatic Differentiation of Algorithms for Machine Learning, arXiv preprint arXiv:1404.7456, 2014, which is freely available on arXiv at http://arxiv.org/pdf/1404.7456.pdf . Automatic differentiation comes with two modes, the forward and reverse modes; backpropagation is simply a special case of reverse-mode automatic differentiation. The key point is that applying the chain rule in forward mode could be quite expensive since we would have to multiply large matrices for each layer (Jacobians) that we would eventually multiply by a vector to obtain the output. The trick of reverse mode is that we traverse the chain rule from right", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 329, "start_word": 105280, "end_word": 105680, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000330": {"text": "on arXiv at http://arxiv.org/pdf/1404.7456.pdf . Automatic differentiation comes with two modes, the forward and reverse modes; backpropagation is simply a special case of reverse-mode automatic differentiation. The key point is that applying the chain rule in forward mode could be quite expensive since we would have to multiply large matrices for each layer (Jacobians) that we would eventually multiply by a vector to obtain the output. The trick of reverse mode is that we traverse the chain rule from right to left. We multiply a matrix by a vector, which yields another vector that is multiplied by the next matrix, and so on. Matrix-vector multiplication is computationally much cheaper than matrix-matrix multiplication, which is why backpropagation is one of the most popular algorithms used in NN training. Training neural networks via backpropagation In this section, we will go through the math of backpropagation to understand how you can learn the weights in an NN very efficiently. Depending on how comfortable you are with mathematical repre - sentations, the following equations may seem relatively complicated at first. In a previous section, we saw how to calculate the loss as the difference between the activation of the last layer and the target class label. Now, we will see how the backpropagation algorithm works to update the weights in our MLP model from a mathematical perspective, which we implemented in the .backward() method of the NeuralNetMLP() class. As we recall from the beginning of this chapter, we first need to apply forward propagation to obtain the activation of the output layer, which we formulated as follows: 𝒁𝒁(ℎ)=𝑿𝑿(𝑖𝑖𝑖𝑖)𝑾𝑾(ℎ)𝑇𝑇+𝒃𝒃(ℎ)(net input of the hidden layer ) 𝑨𝑨(ℎ)= 𝜎𝜎𝜎𝒁𝒁(ℎ)) (activation of the hidden layer ) 𝒁𝒁(𝑜𝑜𝑜𝑜𝑜𝑜 )=𝑨𝑨(ℎ)𝑾𝑾(𝑜𝑜𝑜𝑜𝑜𝑜 )𝑇𝑇+𝒃𝒃(𝑜𝑜𝑜𝑜𝑜𝑜 )(net input of the output layer ) 𝑨𝑨(𝑜𝑜𝑜𝑜𝑜𝑜 )= 𝜎𝜎𝜎𝒁𝒁(𝑜𝑜𝑜𝑜𝑜𝑜 )) (activation of the output layer ) A basic calculus refresher To fully understand backpropagation, we need to borrow certain concepts from differential calculus, which is outside the scope of this book. However, you can refer to a review chapter of the most fundamental concepts, which you might find useful in this context. It discusses function derivatives, partial derivatives, gradients, and the Jacobian. This text is freely accessible at https://sebastianraschka.com/pdf/books/dlb/appendix_d_calculus. pdf. If you are unfamiliar with calculus or need a brief refresher, consider reading this text as an additional supporting resource before reading the next section. Implementing a Multilayer Artificial Neural Network from Scratch 364 Concisely, we just forward-propagate", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 330, "start_word": 105600, "end_word": 106000, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000331": {"text": "of this book. However, you can refer to a review chapter of the most fundamental concepts, which you might find useful in this context. It discusses function derivatives, partial derivatives, gradients, and the Jacobian. This text is freely accessible at https://sebastianraschka.com/pdf/books/dlb/appendix_d_calculus. pdf. If you are unfamiliar with calculus or need a brief refresher, consider reading this text as an additional supporting resource before reading the next section. Implementing a Multilayer Artificial Neural Network from Scratch 364 Concisely, we just forward-propagate the input features through the connections in the network, as shown by the arrows in Figure 11.11 for a network with two input features, three hidden nodes, and two output nodes: Figure 11.11: Forward-propagating the input features of an NN In backpropagation, we propagate the error from right to left. We can think of this as an application of the chain rule to the computation of the forward pass to compute the gradient of the loss with respect to the model weights (and bias units). For simplicity, we will illustrate this process for the partial derivative used to update the first weight in the weight matrix of the output layer. The paths of the computation we backpropagate are highlighted via the bold arrows below: Figure 11.12: Backpropagating the error of an NN If we include the net inputs z explicitly, the partial derivative computation shown in the previous figure expands as follows: 𝜕𝜕𝜕𝜕 𝜕𝜕𝜕𝜕1,1(𝑜𝑜𝑜𝑜𝑜𝑜)=𝜕𝜕𝜕𝜕 𝜕𝜕𝜕𝜕1(𝑜𝑜𝑜𝑜𝑜𝑜)⋅𝜕𝜕𝜕𝜕1(𝑜𝑜𝑜𝑜𝑜𝑜) 𝜕𝜕𝜕𝜕1(𝑜𝑜𝑜𝑜𝑜𝑜)⋅𝜕𝜕𝜕𝜕1(𝑜𝑜𝑜𝑜𝑜𝑜) 𝜕𝜕𝜕𝜕1,1(𝑜𝑜𝑜𝑜𝑜𝑜) To compute this partial derivative, which is used to update 𝑤𝑤1,1(𝑜𝑜𝑜𝑜𝑜𝑜) , we can compute the three individual partial derivative terms and multiply the results. For simplicity, we will omit averaging over the indi- vidual examples in the mini-batch, so we drop the 1 𝑛𝑛∑𝑛𝑛 𝑖𝑖𝑖1 averaging term from the following equations. Chapter 11 365 Let’s start with 𝜕𝜕𝜕𝜕 𝜕𝜕𝜕𝜕1(𝑜𝑜𝑜𝑜𝑜𝑜) , which is the partial derivative of the MSE loss (which simplifies to the squared error if we omit the mini-batch dimension) with respect to the predicted output score of the first output node: 𝜕𝜕𝜕𝜕 𝜕𝜕𝜕𝜕1(𝑜𝑜𝑜𝑜𝑜𝑜)=𝜕𝜕 𝜕𝜕𝜕𝜕1(𝑜𝑜𝑜𝑜𝑜𝑜)(𝑦𝑦1−𝜕𝜕1(𝑜𝑜𝑜𝑜𝑜𝑜))2= 2(𝜕𝜕1(𝑜𝑜𝑜𝑜𝑜𝑜)−𝑦𝑦) The next term is the derivative of the logistic sigmoid activation function that we used in the output layer: 𝜕𝜕𝜕𝜕1(𝑜𝑜𝑜𝑜𝑜𝑜 ) 𝜕𝜕𝜕𝜕1(𝑜𝑜𝑜𝑜𝑜𝑜 )=𝜕𝜕 𝜕𝜕𝜕𝜕1(𝑜𝑜𝑜𝑜𝑜𝑜 )1 1+𝑒𝑒𝑧𝑧1(𝑜𝑜𝑜𝑜𝑜𝑜 )= … =(1 1+𝑒𝑒𝑧𝑧1(𝑜𝑜𝑜𝑜𝑜𝑜 )) (1 −1 1+𝑒𝑒𝑧𝑧1(𝑜𝑜𝑜𝑜𝑜𝑜 )) =𝜕𝜕1(𝑜𝑜𝑜𝑜𝑜𝑜 )(1 − 𝜕𝜕1(𝑜𝑜𝑜𝑜𝑜𝑜 )) Lastly, we compute the derivative of the net input with respect to the weight: 𝜕𝜕𝜕𝜕1(𝑜𝑜𝑜𝑜𝑜𝑜) 𝜕𝜕𝜕𝜕1,1(𝑜𝑜𝑜𝑜𝑜𝑜)=𝜕𝜕 𝜕𝜕𝜕𝜕1,1(𝑜𝑜𝑜𝑜𝑜𝑜)𝑎𝑎1(ℎ)𝜕𝜕1,1(𝑜𝑜𝑜𝑜𝑜𝑜)+𝑏𝑏1(𝑜𝑜𝑜𝑜𝑜𝑜)=𝑎𝑎1(ℎ) Putting all of it together, we get the", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 331, "start_word": 105920, "end_word": 106320, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000332": {"text": "respect to the predicted output score of the first output node: 𝜕𝜕𝜕𝜕 𝜕𝜕𝜕𝜕1(𝑜𝑜𝑜𝑜𝑜𝑜)=𝜕𝜕 𝜕𝜕𝜕𝜕1(𝑜𝑜𝑜𝑜𝑜𝑜)(𝑦𝑦1−𝜕𝜕1(𝑜𝑜𝑜𝑜𝑜𝑜))2= 2(𝜕𝜕1(𝑜𝑜𝑜𝑜𝑜𝑜)−𝑦𝑦) The next term is the derivative of the logistic sigmoid activation function that we used in the output layer: 𝜕𝜕𝜕𝜕1(𝑜𝑜𝑜𝑜𝑜𝑜 ) 𝜕𝜕𝜕𝜕1(𝑜𝑜𝑜𝑜𝑜𝑜 )=𝜕𝜕 𝜕𝜕𝜕𝜕1(𝑜𝑜𝑜𝑜𝑜𝑜 )1 1+𝑒𝑒𝑧𝑧1(𝑜𝑜𝑜𝑜𝑜𝑜 )= … =(1 1+𝑒𝑒𝑧𝑧1(𝑜𝑜𝑜𝑜𝑜𝑜 )) (1 −1 1+𝑒𝑒𝑧𝑧1(𝑜𝑜𝑜𝑜𝑜𝑜 )) =𝜕𝜕1(𝑜𝑜𝑜𝑜𝑜𝑜 )(1 − 𝜕𝜕1(𝑜𝑜𝑜𝑜𝑜𝑜 )) Lastly, we compute the derivative of the net input with respect to the weight: 𝜕𝜕𝜕𝜕1(𝑜𝑜𝑜𝑜𝑜𝑜) 𝜕𝜕𝜕𝜕1,1(𝑜𝑜𝑜𝑜𝑜𝑜)=𝜕𝜕 𝜕𝜕𝜕𝜕1,1(𝑜𝑜𝑜𝑜𝑜𝑜)𝑎𝑎1(ℎ)𝜕𝜕1,1(𝑜𝑜𝑜𝑜𝑜𝑜)+𝑏𝑏1(𝑜𝑜𝑜𝑜𝑜𝑜)=𝑎𝑎1(ℎ) Putting all of it together, we get the following: 𝜕𝜕𝜕𝜕 𝜕𝜕𝜕𝜕1,1(𝑜𝑜𝑜𝑜𝑜𝑜)=𝜕𝜕𝜕𝜕 𝜕𝜕𝜕𝜕1(𝑜𝑜𝑜𝑜𝑜𝑜)⋅𝜕𝜕𝜕𝜕1(𝑜𝑜𝑜𝑜𝑜𝑜) 𝜕𝜕𝜕𝜕1(𝑜𝑜𝑜𝑜𝑜𝑜)⋅𝜕𝜕𝜕𝜕1(𝑜𝑜𝑜𝑜𝑜𝑜) 𝜕𝜕𝜕𝜕1,1(𝑜𝑜𝑜𝑜𝑜𝑜)= 2(𝜕𝜕1(𝑜𝑜𝑜𝑜𝑜𝑜)−𝑦𝑦𝑦⋅𝜕𝜕1(𝑜𝑜𝑜𝑜𝑜𝑜)(1−𝜕𝜕1(𝑜𝑜𝑜𝑜𝑜𝑜)𝑦⋅𝜕𝜕1(ℎ) We then use this value to update the weight via the familiar stochastic gradient descent update with a learning rate of 𝜂𝜂 : 𝑤𝑤1,1(𝑜𝑜𝑜𝑜𝑜𝑜)≔𝑤𝑤1,1(𝑜𝑜𝑜𝑜𝑜𝑜)−𝜂𝜂𝜕𝜕𝜕𝜕 𝜕𝜕𝑤𝑤1,1(𝑜𝑜𝑜𝑜𝑜𝑜) In our code implementation of NeuralNetMLP() , we implemented the computation 𝜕𝜕𝜕𝜕 𝜕𝜕𝜕𝜕1,1(𝑜𝑜𝑜𝑜𝑜𝑜) in vectorized form in the .backward() method as follows: # Part 1: dLoss/dOutWeights ## = dLoss/dOutAct * dOutAct/dOutNet * dOutNet/dOutWeight ## where DeltaOut = dLoss/dOutAct * dOutAct/dOutNet for convenient re-use # input/output dim: [n_examples, n_classes] d_loss__d_a_out = 2.*(a_out - y_onehot) / y.shape[0 ] # input/output dim: [n_examples, n_classes] d_a_out__d_z_out = a_out * (1. - a_out) # sigmoid derivative # output dim: [n_examples, n_classes] delta_out = d_loss__d_a_out * d_a_out__d_z_out # \"delta (rule) # placeholder\" # gradient for output weights # [n_examples, n_hidden] Implementing a Multilayer Artificial Neural Network from Scratch 366 d_z_out__dw_out = a_h # input dim: [n_classes, n_examples] dot [n_examples, n_hidden] # output dim: [n_classes, n_hidden] d_loss__dw_out = np.dot(delta_out.T, d_z_out__dw_out) d_loss__db_out = np.sum(delta_out, axis=0 ) As annotated in the code snippet above, we created the following “delta” placeholder variable: 𝛿𝛿1(𝑜𝑜𝑜𝑜𝑜𝑜)=𝜕𝜕𝜕𝜕 𝜕𝜕𝜕𝜕1(𝑜𝑜𝑜𝑜𝑜𝑜)⋅𝜕𝜕𝜕𝜕1(𝑜𝑜𝑜𝑜𝑜𝑜) 𝜕𝜕𝜕𝜕1(𝑜𝑜𝑜𝑜𝑜𝑜) This is because 𝛿𝛿(𝑜𝑜𝑜𝑜𝑜𝑜) terms are involved in computing the partial derivatives (or gradients) of the hidden layer weights as well; hence, we can reuse 𝛿𝛿(𝑜𝑜𝑜𝑜𝑜𝑜) . Speaking of hidden layer weights, Figure 11.13 illustrates how to compute the partial derivative of the loss with respect to the first weight of the hidden layer: Figure 11.13: Computing the partial derivatives of the loss with respect to the first hidden layer weight It is important to highlight that since the weight 𝑤𝑤1,1(ℎ) is connected to both output nodes, we have to use the multi-variable chain rule to sum the two paths highlighted with bold arrows. As before, we can expand it to include the net inputs z and then solve the individual terms: 𝜕𝜕𝜕𝜕 𝜕𝜕𝜕𝜕1,1(𝑜𝑜𝑜𝑜𝑜𝑜 )=𝜕𝜕𝜕𝜕 𝜕𝜕𝜕𝜕1(𝑜𝑜𝑜𝑜𝑜𝑜 )⋅𝜕𝜕𝜕𝜕1(𝑜𝑜𝑜𝑜𝑜𝑜 ) 𝜕𝜕𝜕𝜕1(𝑜𝑜𝑜𝑜𝑜𝑜 )⋅𝜕𝜕𝜕𝜕1(𝑜𝑜𝑜𝑜𝑜𝑜 ) 𝜕𝜕𝜕𝜕1(ℎ)⋅𝜕𝜕𝜕𝜕1(ℎ) 𝜕𝜕𝜕𝜕1(ℎ)⋅𝜕𝜕𝜕𝜕1(ℎ) 𝜕𝜕𝜕𝜕1,1(ℎ) +𝜕𝜕𝜕𝜕 𝜕𝜕𝜕𝜕2(𝑜𝑜𝑜𝑜𝑜𝑜 )⋅𝜕𝜕𝜕𝜕2(𝑜𝑜𝑜𝑜𝑜𝑜 ) 𝜕𝜕𝜕𝜕2(𝑜𝑜𝑜𝑜𝑜𝑜 )⋅𝜕𝜕𝜕𝜕2(𝑜𝑜𝑜𝑜𝑜𝑜 ) 𝜕𝜕𝜕𝜕1(ℎ)⋅𝜕𝜕𝜕𝜕1(ℎ) 𝜕𝜕𝜕𝜕1(ℎ)⋅𝜕𝜕𝜕𝜕1(ℎ)", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 332, "start_word": 106240, "end_word": 106640, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000333": {"text": "with respect to the first hidden layer weight It is important to highlight that since the weight 𝑤𝑤1,1(ℎ) is connected to both output nodes, we have to use the multi-variable chain rule to sum the two paths highlighted with bold arrows. As before, we can expand it to include the net inputs z and then solve the individual terms: 𝜕𝜕𝜕𝜕 𝜕𝜕𝜕𝜕1,1(𝑜𝑜𝑜𝑜𝑜𝑜 )=𝜕𝜕𝜕𝜕 𝜕𝜕𝜕𝜕1(𝑜𝑜𝑜𝑜𝑜𝑜 )⋅𝜕𝜕𝜕𝜕1(𝑜𝑜𝑜𝑜𝑜𝑜 ) 𝜕𝜕𝜕𝜕1(𝑜𝑜𝑜𝑜𝑜𝑜 )⋅𝜕𝜕𝜕𝜕1(𝑜𝑜𝑜𝑜𝑜𝑜 ) 𝜕𝜕𝜕𝜕1(ℎ)⋅𝜕𝜕𝜕𝜕1(ℎ) 𝜕𝜕𝜕𝜕1(ℎ)⋅𝜕𝜕𝜕𝜕1(ℎ) 𝜕𝜕𝜕𝜕1,1(ℎ) +𝜕𝜕𝜕𝜕 𝜕𝜕𝜕𝜕2(𝑜𝑜𝑜𝑜𝑜𝑜 )⋅𝜕𝜕𝜕𝜕2(𝑜𝑜𝑜𝑜𝑜𝑜 ) 𝜕𝜕𝜕𝜕2(𝑜𝑜𝑜𝑜𝑜𝑜 )⋅𝜕𝜕𝜕𝜕2(𝑜𝑜𝑜𝑜𝑜𝑜 ) 𝜕𝜕𝜕𝜕1(ℎ)⋅𝜕𝜕𝜕𝜕1(ℎ) 𝜕𝜕𝜕𝜕1(ℎ)⋅𝜕𝜕𝜕𝜕1(ℎ) 𝜕𝜕𝜕𝜕1,1(ℎ) Notice that if we reuse 𝛿𝛿(𝑜𝑜𝑜𝑜𝑜𝑜) computed previously, this equation can be simplified as follows: 𝜕𝜕𝜕𝜕 𝜕𝜕𝜕𝜕1,1(𝑜𝑜𝑜𝑜𝑜𝑜 )=𝛿𝛿1(𝑜𝑜𝑜𝑜𝑜𝑜 )⋅𝜕𝜕𝜕𝜕1(𝑜𝑜𝑜𝑜𝑜𝑜 ) 𝜕𝜕𝜕𝜕1(ℎ)⋅𝜕𝜕𝜕𝜕1(ℎ) 𝜕𝜕𝜕𝜕1(ℎ)⋅𝜕𝜕𝜕𝜕1(ℎ) 𝜕𝜕𝜕𝜕1,1(ℎ) +𝛿𝛿2(𝑜𝑜𝑜𝑜𝑜𝑜 )⋅𝜕𝜕𝜕𝜕2(𝑜𝑜𝑜𝑜𝑜𝑜 ) 𝜕𝜕𝜕𝜕1(ℎ)⋅𝜕𝜕𝜕𝜕1(ℎ) 𝜕𝜕𝜕𝜕1(ℎ)⋅𝜕𝜕𝜕𝜕1(ℎ) 𝜕𝜕𝜕𝜕1,1(ℎ) Chapter 11 367 The preceding terms can be individually solved relatively easily, as we have done previously, because there are no new derivatives involved. For example, 𝜕𝜕𝜕𝜕1(ℎ) 𝜕𝜕𝜕𝜕1(ℎ) is the derivative of the sigmoid activation, that is, 𝑎𝑎1(ℎ)(1−𝑎𝑎1(ℎ)) , and so forth. We’ll leave solving the individual parts as an optional exercise for you. About convergence in neural networks You might be wondering why we did not use regular gradient descent but instead used mini-batch learning to train our NN for the handwritten digit classification earlier. You may recall our discussion on SGD that we used to implement online learning. In online learning, we compute the gradient based on a single training example (k = 1) at a time to perform the weight update. Although this is a stochastic approach, it often leads to very accurate solutions with a much faster convergence than regular gra - dient descent. Mini-batch learning is a special form of SGD where we compute the gradient based on a subset k of the n training examples with 1 < k < n. Mini-batch learning has an advantage over online learning in that we can make use of our vectorized implementations to improve computational effi- ciency. However, we can update the weights much faster than in regular gradient descent. Intuitively, you can think of mini-batch learning as predicting the voter turnout of a presidential election from a poll by asking only a representative subset of the population rather than asking the entire population (which would be equal to running the actual election). Multilayer NNs are much harder to train than simpler algorithms such as Adaline, logistic regres - sion, or support vector machines. In multilayer NNs, we typically have hundreds, thousands, or even billions of weights", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 333, "start_word": 106560, "end_word": 106960, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000334": {"text": "regular gradient descent. Intuitively, you can think of mini-batch learning as predicting the voter turnout of a presidential election from a poll by asking only a representative subset of the population rather than asking the entire population (which would be equal to running the actual election). Multilayer NNs are much harder to train than simpler algorithms such as Adaline, logistic regres - sion, or support vector machines. In multilayer NNs, we typically have hundreds, thousands, or even billions of weights that we need to optimize. Unfortunately, the output function has a rough surface, and the optimization algorithm can easily become trapped in local minima, as shown in Figure 11.14: Figure 11.14: Optimization algorithms can become trapped in local minima Note that this representation is extremely simplified since our NN has many dimensions; it makes it impossible to visualize the actual loss surface for the human eye. Here, we only show the loss surface for a single weight on the x axis. However, the main message is that we do not want our algorithm to get trapped in local minima. By increasing the learning rate, we can more readily escape such local minima. On the other hand, we also increase the chance of overshooting the global optimum if the learning rate is too large. Since we initialize the weights randomly, we start with a solution to the optimization problem that is typically hopelessly wrong. Implementing a Multilayer Artificial Neural Network from Scratch 368 A few last words about the neural network implementation You may be wondering why we went through all of this theory just to implement a simple multilayer artificial network that can classify handwritten digits instead of using an open source Python machine learning library. In fact, we will introduce more complex NN models in the next chapters, which we will train using the open source PyTorch library ( https://pytorch.org ). Although the from-scratch implementation in this chapter seems a bit tedious at first, it was a good exercise for understanding the basics behind backpropagation and NN training. A basic understand- ing of algorithms is crucial for applying machine learning techniques appropriately and successfully. Now that you have learned how feedforward NNs work, we are ready to explore more sophisticated DNNs using PyTorch, which allows us to construct NNs more efficiently, as we will see in Chapter 12, Parallelizing Neural Network Training with PyTorch. PyTorch, which was originally released", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 334, "start_word": 106880, "end_word": 107280, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000335": {"text": "a bit tedious at first, it was a good exercise for understanding the basics behind backpropagation and NN training. A basic understand- ing of algorithms is crucial for applying machine learning techniques appropriately and successfully. Now that you have learned how feedforward NNs work, we are ready to explore more sophisticated DNNs using PyTorch, which allows us to construct NNs more efficiently, as we will see in Chapter 12, Parallelizing Neural Network Training with PyTorch. PyTorch, which was originally released in September 2016, has gained a lot of popularity among ma - chine learning researchers, who use it to construct DNNs because of its ability to optimize mathematical expressions for computations on multidimensional arrays utilizing graphics processing units (GPUs ). Lastly, we should note that scikit-learn also includes a basic MLP implementation, MLPClassifier , which you can find at https://scikit-learn.org/stable/modules/generated/sklearn.neural_ network.MLPClassifier.html . While this implementation is great and very convenient for training basic MLPs, we strongly recommend specialized deep learning libraries, such as PyTorch, for imple - menting and training multilayer NNs. Summary In this chapter, you have learned the basic concepts behind multilayer artificial NNs, which are cur - rently the hottest topic in machine learning research. In Chapter 2, Training Simple Machine Learning Algorithms for Classification, we started our journey with simple single-layer NN structures and now we have connected multiple neurons to a powerful NN architecture to solve complex problems such as handwritten digit recognition. We demystified the popular backpropagation algorithm, which is one of the building blocks of many NN models that are used in deep learning. After learning about the backpropagation algorithm in this chapter, we are well equipped for exploring more complex DNN architectures. In the remaining chapters, we will cover more advanced deep learning concepts and PyTorch, an open source library that allows us to implement and train multilayer NNs more efficiently. Join our book’s Discord space Join the book’s Discord workspace for a monthly Ask me Anything session with the authors: https://packt.link/MLwPyTorch 12 Parallelizing Neural Network Training with PyTorch In this chapter, we will move on from the mathematical foundations of machine learning and deep learning to focus on PyTorch. PyTorch is one of the most popular deep learning libraries currently available, and it lets us implement neural networks ( NNs ) much more efficiently than any of our previous NumPy implementations. In this chapter, we will start using PyTorch and see", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 335, "start_word": 107200, "end_word": 107600, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000336": {"text": "a monthly Ask me Anything session with the authors: https://packt.link/MLwPyTorch 12 Parallelizing Neural Network Training with PyTorch In this chapter, we will move on from the mathematical foundations of machine learning and deep learning to focus on PyTorch. PyTorch is one of the most popular deep learning libraries currently available, and it lets us implement neural networks ( NNs ) much more efficiently than any of our previous NumPy implementations. In this chapter, we will start using PyTorch and see how it brings significant benefits to training performance. This chapter will begin the next stage of our journey into machine learning and deep learning, and we will explore the following topics: • How PyTorch improves training performance • Working with PyTorch’s Dataset and DataLoader to build input pipelines and enable efficient model training • Working with PyTorch to write optimized machine learning code • Using the torch.nn module to implement common deep learning architectures conveniently • Choosing activation functions for artificial NNs PyTorch and training performance PyTorch can speed up our machine learning tasks significantly. To understand how it can do this, let’s begin by discussing some of the performance challenges we typically run into when we execute expensive calculations on our hardware. Then, we will take a high-level look at what PyTorch is and what our learning approach will be in this chapter. Performance challenges The performance of computer processors has, of course, been continuously improving in recent years. That allows us to train more powerful and complex learning systems, which means that we can improve the predictive performance of our machine learning models. Even the cheapest desktop computer hardware that’s available right now comes with processing units that have multiple cores. Parallelizing Neural Network Training with PyTorch 370 In the previous chapters, we saw that many functions in scikit-learn allow us to spread those com- putations over multiple processing units. However, by default, Python is limited to execution on one core due to the global interpreter lock (GIL ). So, although we indeed take advantage of Python’s mul- tiprocessing library to distribute our computations over multiple cores, we still have to consider that the most advanced desktop hardware rarely comes with more than 8 or 16 such cores. You will recall from Chapter 11, Implementing a Multilayer Artificial Neural Network from Scratch, that we implemented a very simple multilayer perceptron (MLP ) with only one hidden layer consisting", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 336, "start_word": 107520, "end_word": 107920, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000337": {"text": "on one core due to the global interpreter lock (GIL ). So, although we indeed take advantage of Python’s mul- tiprocessing library to distribute our computations over multiple cores, we still have to consider that the most advanced desktop hardware rarely comes with more than 8 or 16 such cores. You will recall from Chapter 11, Implementing a Multilayer Artificial Neural Network from Scratch, that we implemented a very simple multilayer perceptron (MLP ) with only one hidden layer consisting of 100 units. We had to optimize approximately 80,000 weight parameters ([784*100 + 100] + [100 * 10] + 10 = 79,510) for a very simple image classification task. The images in MNIST are rather small (28×28), and we can only imagine the explosion in the number of parameters if we wanted to add additional hidden layers or work with images that have higher pixel densities. Such a task would quickly become unfeasible for a single processing unit. The question then becomes, how can we tackle such problems more effectively? The obvious solution to this problem is to use graphics processing units (GPUs ), which are real work - horses. You can think of a graphics card as a small computer cluster inside your machine. Another advantage is that modern GPUs are great value compared to the state-of-the-art central processing units (CPUs ), as you can see in the following overview: Figure 12.1: Comparison of a state-of-the-art CPU and GPU The sources for the information in Figure 12.1 are the following websites (date accessed: July 2021): • https://ark.intel.com/content/www/us/en/ark/products/215570/intel-core-i9- 11900kb-processor-24m-cache-up-to-4-90-ghz.html • https://www.nvidia.com/en-us/geforce/graphics-cards/30-series/rtx-3080-3080ti/ At 2.2 times the price of a modern CPU, we can get a GPU that has 640 times more cores and is capa - ble of around 46 times more floating-point calculations per second. So, what is holding us back from utilizing GPUs for our machine learning tasks? The challenge is that writing code to target GPUs is not as simple as executing Python code in our interpreter. There are special packages, such as CUDA and OpenCL, that allow us to target the GPU. However, writing code in CUDA or OpenCL is probably not the most convenient way to implement and run machine learning algorithms. The good news is that this is what PyTorch was developed for! Chapter 12 371 What is PyTorch? PyTorch is a scalable and multiplatform programming interface for implementing and running ma - chine learning", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 337, "start_word": 107840, "end_word": 108240, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000338": {"text": "as simple as executing Python code in our interpreter. There are special packages, such as CUDA and OpenCL, that allow us to target the GPU. However, writing code in CUDA or OpenCL is probably not the most convenient way to implement and run machine learning algorithms. The good news is that this is what PyTorch was developed for! Chapter 12 371 What is PyTorch? PyTorch is a scalable and multiplatform programming interface for implementing and running ma - chine learning algorithms, including convenience wrappers for deep learning. PyTorch was primarily developed by the researchers and engineers from the Facebook AI Research ( FAIR ) lab. Its development also involves many contributions from the community. PyTorch was initially released in September 2016 and is free and open source under the modified BSD license. Many machine learning research- ers and practitioners from academia and industry have adapted PyTorch to develop deep learning solutions, such as Tesla Autopilot, Uber’s Pyro, and Hugging Face’s Transformers ( https://pytorch. org/ecosystem/ ). To improve the performance of training machine learning models, PyTorch allows execution on CPUs, GPUs, and XLA devices such as TPUs. However, its greatest performance capabilities can be discov - ered when using GPUs and XLA devices. PyTorch supports CUDA-enabled and ROCm GPUs officially. PyTorch’s development is based on the Torch library ( www.torch.ch ). As its name implies, the Python interface is the primary development focus of PyTorch. PyTorch is built around a computation graph composed of a set of nodes. Each node represents an operation that may have zero or more inputs or outputs. PyTorch provides an imperative program- ming environment that evaluates operations, executes computation, and returns concrete values immediately. Hence, the computation graph in PyTorch is defined implicitly, rather than constructed in advance and executed after. Mathematically, tensors can be understood as a generalization of scalars, vectors, matrices, and so on. More concretely, a scalar can be defined as a rank-0 tensor, a vector can be defined as a rank-1 tensor, a matrix can be defined as a rank-2 tensor, and matrices stacked in a third dimension can be defined as rank-3 tensors. Tensors in PyTorch are similar to NumPy’s arrays, except that tensors are optimized for automatic differentiation and can run on GPUs. To make the concept of a tensor clearer, consider Figure 12.2, which represents tensors of ranks 0 and 1 in the first row, and tensors of ranks", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 338, "start_word": 108160, "end_word": 108560, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000339": {"text": "tensor, a vector can be defined as a rank-1 tensor, a matrix can be defined as a rank-2 tensor, and matrices stacked in a third dimension can be defined as rank-3 tensors. Tensors in PyTorch are similar to NumPy’s arrays, except that tensors are optimized for automatic differentiation and can run on GPUs. To make the concept of a tensor clearer, consider Figure 12.2, which represents tensors of ranks 0 and 1 in the first row, and tensors of ranks 2 and 3 in the second row: Figure 12.2: Different types of tensor in PyTorch Now that we know what PyTorch is, let’s see how to use it. Parallelizing Neural Network Training with PyTorch 372 How we will learn PyTorch First, we are going to cover PyTorch’s programming model, in particular, creating and manipulating tensors. Then, we will see how to load data and utilize the torch.utils.data module, which will allow us to iterate through a dataset efficiently. In addition, we will discuss the existing, ready-to-use datasets in the torch.utils.data.Dataset submodule and learn how to use them. After learning about these basics, the PyTorch neural network torch.nn module will be introduced. Then, we will move forward to building machine learning models, learn how to compose and train the models, and learn how to save the trained models on disk for future evaluation. First steps with PyTorch In this section, we will take our first steps in using the low-level PyTorch API. After installing PyTorch, we will cover how to create tensors in PyTorch and different ways of manipulating them, such as changing their shape, data type, and so on. Installing PyTorch To install PyTorch, we recommend consulting the latest instructions on the official https://pytorch.org website. Below, we will outline the basic steps that will work on most systems. Depending on how your system is set up, you can typically just use Python’s pip installer and install PyTorch from PyPI by executing the following from your terminal: pip install torch torchvision This will install the latest stable version, which is 1.9.0 at the time of writing. To install the 1.9.0 ver - sion, which is guaranteed to be compatible with the following code examples, you can modify the preceding command as follows: pip install torch==1.9.0 torchvision==0.10.0 If you want to use GPUs (recommended), you need a compatible NVIDIA graphics card that supports CUDA and cuDNN. If your machine satisfies these requirements,", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 339, "start_word": 108480, "end_word": 108880, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000340": {"text": "executing the following from your terminal: pip install torch torchvision This will install the latest stable version, which is 1.9.0 at the time of writing. To install the 1.9.0 ver - sion, which is guaranteed to be compatible with the following code examples, you can modify the preceding command as follows: pip install torch==1.9.0 torchvision==0.10.0 If you want to use GPUs (recommended), you need a compatible NVIDIA graphics card that supports CUDA and cuDNN. If your machine satisfies these requirements, you can install PyTorch with GPU support, as follows: pip install torch==1.9.0+cu111 torchvision==0.10.0+cu111 -f https://download. pytorch.org/whl/torch_stable.html for CUDA 11.1 or: pip install torch==1.9.0 torchvision==0.10.0\\ -f https://download.pytorch.org/ whl/torch_stable.html for CUDA 10.2 as of the time of writing. As macOS binaries don’t support CUDA, you can install from source: https://pytorch.org/get- started/locally/#mac-from-source . For more information about the installation and setup process, please see the official recommenda - tions at https://pytorch.org/get-started/locally/ . Chapter 12 373 Note that PyTorch is under active development; therefore, every couple of months, new versions are released with significant changes. You can verify your PyTorch version from your terminal, as follows: python -c 'import torch; print(torch.__version__)' Creating tensors in PyTorch Now, let’s consider a few different ways of creating tensors, and then see some of their properties and how to manipulate them. Firstly, we can simply create a tensor from a list or a NumPy array using the torch.tensor or the torch.from_numpy function as follows: >>> import torch >>> import numpy as np >>> np.set_printoptions(precision= 3) >>> a = [1, 2, 3] >>> b = np.array([ 4, 5, 6], dtype=np.int32) >>> t_a = torch.tensor(a) >>> t_b = torch.from_numpy(b) >>> print(t_a) >>> print(t_b) tensor([ 1, 2, 3]) tensor([ 4, 5, 6], dtype=torch.int32) This resulted in tensors t_a and t_b, with their properties, shape=(3,) and dtype=int32 , adopted from their source. Similar to NumPy arrays, we can also see these properties: >>> t_ones = torch.ones( 2, 3) >>> t_ones.shape torch.Size([2, 3]) >>> print(t_ones)Troubleshooting your installation of PyTorch If you experience problems with the installation procedure, read more about system- and platform-specific recommendations that are provided at https://pytorch.org/ get-started/locally/ . Note that all the code in this chapter can be run on your CPU; using a GPU is entirely optional but recommended if you want to fully enjoy the benefits of PyTorch. For example, while training some NN models on a CPU could take a week, the same models could be trained", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 340, "start_word": 108800, "end_word": 109200, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000341": {"text": ">>> print(t_ones)Troubleshooting your installation of PyTorch If you experience problems with the installation procedure, read more about system- and platform-specific recommendations that are provided at https://pytorch.org/ get-started/locally/ . Note that all the code in this chapter can be run on your CPU; using a GPU is entirely optional but recommended if you want to fully enjoy the benefits of PyTorch. For example, while training some NN models on a CPU could take a week, the same models could be trained in just a few hours on a modern GPU. If you have a graphics card, refer to the installation page to set it up appropriately. In addition, you may find this setup guide helpful, which explains how to install the NVIDIA graphics card drivers, CUDA, and cuDNN on Ubuntu (not required but recommended requirements for running PyTorch on a GPU): https://sebastianraschka.com/pdf/books/dlb/ appendix_h_cloud-computing.pdf . Furthermore, as you will see in Chapter 17, Gener- ative Adversarial Networks for Synthesizing New Data, you can also train your models using a GPU for free via Google Colab. Parallelizing Neural Network Training with PyTorch 374 tensor([[1., 1., 1.], [1., 1., 1.]]) Finally, creating a tensor of random values can be done as follows: >>> rand_tensor = torch.rand( 2,3) >>> print(rand_tensor) tensor([[0.1409, 0.2848, 0.8914], [0.9223, 0.2924, 0.7889]]) Manipulating the data type and shape of a tensor Learning ways to manipulate tensors is necessary to make them compatible for input to a model or an operation. In this section, you will learn how to manipulate tensor data types and shapes via several PyTorch functions that cast, reshape, transpose, and squeeze (remove dimensions). The torch.to() function can be used to change the data type of a tensor to a desired type: >>> t_a_new = t_a.to(torch.int64) >>> print(t_a_new.dtype) torch.int64 See https://pytorch.org/docs/stable/tensor_attributes.html for all other data types. As you will see in upcoming chapters, certain operations require that the input tensors have a certain number of dimensions (that is, rank) associated with a certain number of elements (shape). Thus, we might need to change the shape of a tensor, add a new dimension, or squeeze an unnecessary dimen- sion. PyTorch provides useful functions (or operations) to achieve this, such as torch.transpose() , torch.reshape() , and torch.squeeze() . Let’s take a look at some examples: • Transposing a tensor: >>> t = torch.rand( 3, 5) >>> t_tr = torch.transpose(t, 0, 1) >>> print(t.shape, ' --> ', t_tr.shape) torch.Size([3, 5]) --> torch.Size([5,", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 341, "start_word": 109120, "end_word": 109520, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000342": {"text": "associated with a certain number of elements (shape). Thus, we might need to change the shape of a tensor, add a new dimension, or squeeze an unnecessary dimen- sion. PyTorch provides useful functions (or operations) to achieve this, such as torch.transpose() , torch.reshape() , and torch.squeeze() . Let’s take a look at some examples: • Transposing a tensor: >>> t = torch.rand( 3, 5) >>> t_tr = torch.transpose(t, 0, 1) >>> print(t.shape, ' --> ', t_tr.shape) torch.Size([3, 5]) --> torch.Size([5, 3]) • Reshaping a tensor (for example, from a 1D vector to a 2D array): >>> t = torch.zeros( 30) >>> t_reshape = t.reshape( 5, 6) >>> print(t_reshape.shape) torch.Size([5, 6]) • Removing the unnecessary dimensions (dimensions that have size 1, which are not needed): >>> t = torch.zeros( 1, 2, 1, 4, 1) >>> t_sqz = torch.squeeze(t, 2) >>> print(t.shape, ' --> ', t_sqz.shape) torch.Size([1, 2, 1, 4, 1]) --> torch.Size([1, 2, 4, 1]) Chapter 12 375 Applying mathematical operations to tensors Applying mathematical operations, in particular linear algebra operations, is necessary for building most machine learning models. In this subsection, we will cover some widely used linear algebra operations, such as element-wise product, matrix multiplication, and computing the norm of a tensor. First, let’s instantiate two random tensors, one with uniform distribution in the range [–1, 1) and the other with a standard normal distribution: >>> torch.manual_seed( 1) >>> t1 = 2 * torch.rand( 5, 2) - 1 >>> t2 = torch.normal(mean= 0, std=1, size=( 5, 2)) Note that torch.rand returns a tensor filled with random numbers from a uniform distribution in the range of [0, 1). Notice that t1 and t2 have the same shape. Now, to compute the element-wise product of t1 and t2, we can use the following: >>> t3 = torch.multiply(t1, t2) >>> print(t3) tensor([[ 0.4426, -0.3114], [ 0.0660, -0.5970], [ 1.1249, 0.0150], [ 0.1569, 0.7107], [-0.0451, -0.0352]]) To compute the mean, sum, and standard deviation along a certain axis (or axes), we can use torch. mean() , torch.sum() , and torch.std() . For example, the mean of each column in t1 can be com- puted as follows: >>> t4 = torch.mean(t1, axis= 0) >>> print(t4) tensor([-0.1373, 0.2028]) The matrix-matrix product between t1 and t2 (that is, 𝑡𝑡1×𝑡𝑡2T , where the superscript T is for transpose) can be computed by using the torch.matmul() function as follows: >>> t5 = torch.matmul(t1, torch.transpose(t2, 0, 1)) >>> print(t5)", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 342, "start_word": 109440, "end_word": 109840, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000343": {"text": "deviation along a certain axis (or axes), we can use torch. mean() , torch.sum() , and torch.std() . For example, the mean of each column in t1 can be com- puted as follows: >>> t4 = torch.mean(t1, axis= 0) >>> print(t4) tensor([-0.1373, 0.2028]) The matrix-matrix product between t1 and t2 (that is, 𝑡𝑡1×𝑡𝑡2T , where the superscript T is for transpose) can be computed by using the torch.matmul() function as follows: >>> t5 = torch.matmul(t1, torch.transpose(t2, 0, 1)) >>> print(t5) tensor([[ 0.1312, 0.3860, -0.6267, -1.0096, -0.2943], [ 0.1647, -0.5310, 0.2434, 0.8035, 0.1980], [-0.3855, -0.4422, 1.1399, 1.5558, 0.4781], [ 0.1822, -0.5771, 0.2585, 0.8676, 0.2132], [ 0.0330, 0.1084, -0.1692, -0.2771, -0.0804]]) Parallelizing Neural Network Training with PyTorch 376 On the other hand, computing 𝑡𝑡1𝑇𝑇×𝑡𝑡2 is performed by transposing t1, resulting in an array of size 2×2: >>> t6 = torch.matmul(torch.transpose(t1, 0, 1), t2) >>> print(t6) tensor([[ 1.7453, 0.3392], [-1.6038, -0.2180]]) Finally, the torch.linalg.norm() function is useful for computing the Lp norm of a tensor. For ex - ample, we can calculate the L2 norm of t1 as follows: >>> norm_t1 = torch.linalg.norm(t1, ord=2, dim= 1) >>> print(norm_t1) tensor([0.6785, 0.5078, 1.1162, 0.5488, 0.1853]) To verify that this code snippet computes the L2 norm of t1 correctly, you can compare the results with the following NumPy function: np.sqrt(np.sum(np.square(t1.numpy()), axis=1)) . Split, stack, and concatenate tensors In this subsection, we will cover PyTorch operations for splitting a tensor into multiple tensors, or the reverse: stacking and concatenating multiple tensors into a single one. Assume that we have a single tensor, and we want to split it into two or more tensors. For this, PyTorch provides a convenient torch.chunk() function, which divides an input tensor into a list of equally sized tensors. We can determine the desired number of splits as an integer using the chunks argument to split a tensor along the desired dimension specified by the dim argument. In this case, the total size of the input tensor along the specified dimension must be divisible by the desired number of splits. Alternatively, we can provide the desired sizes in a list using the torch.split() function. Let’s have a look at an example of both these options: • Providing the number of splits: >>> torch.manual_seed( 1) >>> t = torch.rand( 6) >>> print(t) tensor([0.7576, 0.2793, 0.4031, 0.7347, 0.0293, 0.7999]) >>> t_splits = torch.chunk(t, 3) >>> [item.numpy() for item in t_splits] [array([0.758, 0.279], dtype=float32), array([0.403, 0.735],", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 343, "start_word": 109760, "end_word": 110160, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000344": {"text": "of the input tensor along the specified dimension must be divisible by the desired number of splits. Alternatively, we can provide the desired sizes in a list using the torch.split() function. Let’s have a look at an example of both these options: • Providing the number of splits: >>> torch.manual_seed( 1) >>> t = torch.rand( 6) >>> print(t) tensor([0.7576, 0.2793, 0.4031, 0.7347, 0.0293, 0.7999]) >>> t_splits = torch.chunk(t, 3) >>> [item.numpy() for item in t_splits] [array([0.758, 0.279], dtype=float32), array([0.403, 0.735], dtype=float32), array([0.029, 0.8 ], dtype=float32)] In this example, a tensor of size 6 was divided into a list of three tensors each with size 2. If the tensor size is not divisible by the chunks value, the last chunk will be smaller. Chapter 12 377 • Providing the sizes of different splits: Alternatively, instead of defining the number of splits, we can also specify the sizes of the output tensors directly. Here, we are splitting a tensor of size 5 into tensors of sizes 3 and 2: >>> torch.manual_seed( 1) >>> t = torch.rand( 5) >>> print(t) tensor([0.7576, 0.2793, 0.4031, 0.7347, 0.0293]) >>> t_splits = torch.split(t, split_size_or_sections=[ 3, 2]) >>> [item.numpy() for item in t_splits] [array([0.758, 0.279, 0.403], dtype=float32), array([0.735, 0.029], dtype=float32)] Sometimes, we are working with multiple tensors and need to concatenate or stack them to create a single tensor. In this case, PyTorch functions such as torch.stack() and torch.cat() come in handy. For example, let’s create a 1D tensor, A, containing 1s with size 3, and a 1D tensor, B, containing 0s with size 2, and concatenate them into a 1D tensor, C, of size 5: >>> A = torch.ones( 3) >>> B = torch.zeros( 2) >>> C = torch.cat([A, B], axis= 0) >>> print(C) tensor([1., 1., 1., 0., 0.]) If we create 1D tensors A and B, both with size 3, then we can stack them together to form a 2D tensor, S: >>> A = torch.ones( 3) >>> B = torch.zeros( 3) >>> S = torch.stack([A, B], axis= 1) >>> print(S) tensor([[1., 0.], [1., 0.], [1., 0.]]) The PyTorch API has many operations that you can use for building a model, processing your data, and more. However, covering every function is outside the scope of this book, where we will focus on the most essential ones. For the full list of operations and functions, you can refer to the documentation page of PyTorch at https://pytorch.org/docs/stable/index.html .", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 344, "start_word": 110080, "end_word": 110480, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000345": {"text": "3) >>> B = torch.zeros( 3) >>> S = torch.stack([A, B], axis= 1) >>> print(S) tensor([[1., 0.], [1., 0.], [1., 0.]]) The PyTorch API has many operations that you can use for building a model, processing your data, and more. However, covering every function is outside the scope of this book, where we will focus on the most essential ones. For the full list of operations and functions, you can refer to the documentation page of PyTorch at https://pytorch.org/docs/stable/index.html . Parallelizing Neural Network Training with PyTorch 378 Building input pipelines in PyTorch When we are training a deep NN model, we usually train the model incrementally using an iterative optimization algorithm such as stochastic gradient descent, as we have seen in previous chapters. As mentioned at the beginning of this chapter, torch.nn is a module for building NN models. In cas- es where the training dataset is rather small and can be loaded as a tensor into the memory, we can directly use this tensor for training. In typical use cases, however, when the dataset is too large to fit into the computer memory, we will need to load the data from the main storage device (for example, the hard drive or solid-state drive) in chunks, that is, batch by batch. (Note the use of the term “batch” instead of “mini-batch” in this chapter to stay close to the PyTorch terminology.) In addition, we may need to construct a data-processing pipeline to apply certain transformations and preprocessing steps to our data, such as mean centering, scaling, or adding noise to augment the training procedure and to prevent overfitting. Applying preprocessing functions manually every time can be quite cumbersome. Luckily, PyTorch provides a special class for constructing efficient and convenient preprocessing pipelines. In this sec- tion, we will see an overview of different methods for constructing a PyTorch Dataset and DataLoader , and implementing data loading, shuffling, and batching. Creating a PyTorch DataLoader from existing tensors If the data already exists in the form of a tensor object, a Python list, or a NumPy array, we can easily create a dataset loader using the torch.utils.data.DataLoader() class. It returns an object of the DataLoader class, which we can use to iterate through the individual elements in the input dataset. As a simple example, consider the following code, which creates a dataset from a list of values from 0 to 5: >>> from", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 345, "start_word": 110400, "end_word": 110800, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000346": {"text": "PyTorch DataLoader from existing tensors If the data already exists in the form of a tensor object, a Python list, or a NumPy array, we can easily create a dataset loader using the torch.utils.data.DataLoader() class. It returns an object of the DataLoader class, which we can use to iterate through the individual elements in the input dataset. As a simple example, consider the following code, which creates a dataset from a list of values from 0 to 5: >>> from torch.utils.data import DataLoader >>> t = torch.arange( 6, dtype=torch.float32) >>> data_loader = DataLoader(t) We can easily iterate through a dataset entry by entry as follows: >>> for item in data_loader: ... print(item) tensor([0.]) tensor([1.]) tensor([2.]) tensor([3.]) tensor([4.]) tensor([5.]) Chapter 12 379 If we want to create batches from this dataset, with a desired batch size of 3, we can do this with the batch_size argument as follows: >>> data_loader = DataLoader(t, batch_size= 3, drop_last= False) >>> for i, batch in enumerate (data_loader, 1): ... print(f'batch {i}:', batch) batch 1: tensor([0., 1., 2.]) batch 2: tensor([3., 4., 5.]) This will create two batches from this dataset, where the first three elements go into batch #1, and the remaining elements go into batch #2. The optional drop_last argument is useful for cases when the number of elements in the tensor is not divisible by the desired batch size. We can drop the last non-full batch by setting drop_last to True . The default value for drop_last is False . We can always iterate through a dataset directly, but as you just saw, DataLoader provides an automatic and customizable batching to a dataset. Combining two tensors into a joint dataset Often, we may have the data in two (or possibly more) tensors. For example, we could have a tensor for features and a tensor for labels. In such cases, we need to build a dataset that combines these tensors, which will allow us to retrieve the elements of these tensors in tuples. Assume that we have two tensors, t_x and t_y. Tensor t_x holds our feature values, each of size 3, and t_y stores the class labels. For this example, we first create these two tensors as follows: >>> torch.manual_seed( 1) >>> t_x = torch.rand([ 4, 3], dtype=torch.float32) >>> t_y = torch.arange( 4) Now, we want to create a joint dataset from these two tensors. We first need to create a Dataset class", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 346, "start_word": 110720, "end_word": 111120, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000347": {"text": "to retrieve the elements of these tensors in tuples. Assume that we have two tensors, t_x and t_y. Tensor t_x holds our feature values, each of size 3, and t_y stores the class labels. For this example, we first create these two tensors as follows: >>> torch.manual_seed( 1) >>> t_x = torch.rand([ 4, 3], dtype=torch.float32) >>> t_y = torch.arange( 4) Now, we want to create a joint dataset from these two tensors. We first need to create a Dataset class as follows: >>> from torch.utils.data import Dataset >>> class JointDataset (Dataset ): ... def __init__(self, x, y): ... self.x = x ... self.y = y ... ... def __len__(self): ... return len(self.x) ... Parallelizing Neural Network Training with PyTorch 380 ... def __getitem__(self, idx): ... return self.x[idx], self.y[idx] A custom Dataset class must contain the following methods to be used by the data loader later on: • __init__() : This is where the initial logic happens, such as reading existing arrays, loading a file, filtering data, and so forth. • __getitem__() : This returns the corresponding sample to the given index. Then we create a joint dataset of t_x and t_y with the custom Dataset class as follows: >>> joint_dataset = JointDataset(t_x, t_y) Finally, we can print each example of the joint dataset as follows: >>> for example in joint_dataset: ... print(' x: ' , example[ 0], ' y: ', example[ 1]) x: tensor([0.7576, 0.2793, 0.4031]) y: tensor(0) x: tensor([0.7347, 0.0293, 0.7999]) y: tensor(1) x: tensor([0.3971, 0.7544, 0.5695]) y: tensor(2) x: tensor([0.4388, 0.6387, 0.5247]) y: tensor(3) We can also simply utilize the torch.utils.data.TensorDataset class, if the second dataset is a labeled dataset in the form of tensors. So, instead of using our self-defined Dataset class, JointDataset , we can create a joint dataset as follows: >>> joint_dataset = JointDataset(t_x, t_y) Note that a common source of error could be that the element-wise correspondence between the orig - inal features (x) and labels (y) might be lost (for example, if the two datasets are shuffled separately). However, once they are merged into one dataset, it is safe to apply these operations. If we have a dataset created from the list of image filenames on disk, we can define a function to load the images from these filenames. You will see an example of applying multiple transformations to a dataset later in this chapter. Shuffle, batch, and repeat As was mentioned in", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 347, "start_word": 111040, "end_word": 111440, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000348": {"text": "and labels (y) might be lost (for example, if the two datasets are shuffled separately). However, once they are merged into one dataset, it is safe to apply these operations. If we have a dataset created from the list of image filenames on disk, we can define a function to load the images from these filenames. You will see an example of applying multiple transformations to a dataset later in this chapter. Shuffle, batch, and repeat As was mentioned in Chapter 2, Training Simple Machine Learning Algorithms for Classification, when training an NN model using stochastic gradient descent optimization, it is important to feed training data as randomly shuffled batches. You have already seen how to specify the batch size using the batch_size argument of a data loader object. Now, in addition to creating batches, you will see how to shuffle and reiterate over the datasets. We will continue working with the previous joint dataset. Chapter 12 381 First, let’s create a shuffled version data loader from the joint_dataset dataset: >>> torch.manual_seed( 1) >>> data_loader = DataLoader(dataset=joint_dataset, batch_size= 2, shuffle= True) Here, each batch contains two data records (x ) and the corresponding labels (y ). Now we iterate through the data loader entry by entry as follows: >>> for i, batch in enumerate (data_loader, 1): ... print(f'batch {i}:', 'x:' , batch[ 0], '\\n y:', batch[1]) batch 1: x: tensor([[0.4388, 0.6387, 0.5247], [0.3971, 0.7544, 0.5695]]) y: tensor([3, 2]) batch 2: x: tensor([[0.7576, 0.2793, 0.4031], [0.7347, 0.0293, 0.7999]]) y: tensor([0, 1]) The rows are shuffled without losing the one-to-one correspondence between the entries in x and y. In addition, when training a model for multiple epochs, we need to shuffle and iterate over the dataset by the desired number of epochs. So, let’s iterate over the batched dataset twice: >>> for epoch in range (2): >>> print(f'epoch {epoch+1}') >>> for i, batch in enumerate (data_loader, 1): ... print(f'batch {i}:', 'x:' , batch[ 0], '\\n y:', batch[1]) epoch 1 batch 1: x: tensor([[0.7347, 0.0293, 0.7999], [0.3971, 0.7544, 0.5695]]) y: tensor([1, 2]) batch 2: x: tensor([[0.4388, 0.6387, 0.5247], [0.7576, 0.2793, 0.4031]]) y: tensor([3, 0]) epoch 2 batch 1: x: tensor([[0.3971, 0.7544, 0.5695], [0.7576, 0.2793, 0.4031]]) y: tensor([2, 0]) batch 2: x: tensor([[0.7347, 0.0293, 0.7999], [0.4388, 0.6387, 0.5247]]) y: tensor([1, 3]) Parallelizing Neural Network Training with PyTorch 382 This results in two different sets of batches. In the first epoch, the first batch contains", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 348, "start_word": 111360, "end_word": 111760, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000349": {"text": "batch[ 0], '\\n y:', batch[1]) epoch 1 batch 1: x: tensor([[0.7347, 0.0293, 0.7999], [0.3971, 0.7544, 0.5695]]) y: tensor([1, 2]) batch 2: x: tensor([[0.4388, 0.6387, 0.5247], [0.7576, 0.2793, 0.4031]]) y: tensor([3, 0]) epoch 2 batch 1: x: tensor([[0.3971, 0.7544, 0.5695], [0.7576, 0.2793, 0.4031]]) y: tensor([2, 0]) batch 2: x: tensor([[0.7347, 0.0293, 0.7999], [0.4388, 0.6387, 0.5247]]) y: tensor([1, 3]) Parallelizing Neural Network Training with PyTorch 382 This results in two different sets of batches. In the first epoch, the first batch contains a pair of values [y=1, y=2] , and the second batch contains a pair of values [y=3, y=0] . In the second epoch, two batches contain a pair of values, [y=2, y=0] and [y=1, y=3] respectively. For each iteration, the elements within a batch are also shuffled. Creating a dataset from files on your local storage disk In this section, we will build a dataset from image files stored on disk. There is an image folder asso - ciated with the online content of this chapter. After downloading the folder, you should be able to see six images of cats and dogs in JPEG format. This small dataset will show how building a dataset from stored files generally works. To accomplish this, we are going to use two additional modules: Image in PIL to read the image file contents and transforms in torchvision to decode the raw contents and resize the images. Before we start, let’s take a look at the content of these files. We will use the pathlib library to gen- erate a list of image files: >>> import pathlib >>> imgdir_path = pathlib.Path( 'cat_dog_images' ) >>> file_list = sorted([str(path) for path in ... imgdir_path.glob( '*.jpg')]) >>> print(file_list) ['cat_dog_images/dog-03.jpg', 'cat_dog_images/cat-01.jpg', 'cat_dog_images/cat- 02.jpg', 'cat_dog_images/cat-03.jpg', 'cat_dog_images/dog-01.jpg', 'cat_dog_ images/dog-02.jpg'] Next, we will visualize these image examples using Matplotlib: >>> import matplotlib.pyplot as plt >>> import os >>> from PIL import Image >>> fig = plt.figure(figsize=( 10, 5)) >>> for i, file in enumerate (file_list): ... img = Image. open(file) ... print('Image shape:' , np.array(img).shape) ... ax = fig.add_subplot( 2, 3, i+ 1) ... ax.set_xticks([]); ax.set_yticks([])The PIL.Image and torchvision.transforms modules provide a lot of additional and useful functions, which are beyond the scope of the book. You are encouraged to browse through the official documentation to learn more about these functions: https://pillow.readthedocs.io/en/stable/reference/Image.html for PIL.Image https://pytorch.org/vision/stable/transforms.html for torchvision. transforms Chapter 12 383 ... ax.imshow(img) ... ax.set_title(os.path.basename(file), size= 15) >>> plt.tight_layout() >>> plt.show() Image", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 349, "start_word": 111680, "end_word": 112080, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000350": {"text": "in enumerate (file_list): ... img = Image. open(file) ... print('Image shape:' , np.array(img).shape) ... ax = fig.add_subplot( 2, 3, i+ 1) ... ax.set_xticks([]); ax.set_yticks([])The PIL.Image and torchvision.transforms modules provide a lot of additional and useful functions, which are beyond the scope of the book. You are encouraged to browse through the official documentation to learn more about these functions: https://pillow.readthedocs.io/en/stable/reference/Image.html for PIL.Image https://pytorch.org/vision/stable/transforms.html for torchvision. transforms Chapter 12 383 ... ax.imshow(img) ... ax.set_title(os.path.basename(file), size= 15) >>> plt.tight_layout() >>> plt.show() Image shape: (900, 1200, 3) Image shape: (900, 1200, 3) Image shape: (900, 1200, 3) Image shape: (900, 742, 3) Image shape: (800, 1200, 3) Image shape: (800, 1200, 3) Figure 12.3 shows the example images: Figure 12.3: Images of cats and dogs Just from this visualization and the printed image shapes, we can already see that the images have different aspect ratios. If you print the aspect ratios (or data array shapes) of these images, you will see that some images are 900 pixels high and 1200 pixels wide (900×1200), some are 800×1200, and one is 900×742. Later, we will preprocess these images to a consistent size. Another point to consider is that the labels for these images are provided within their filenames. So, we extract these labels from the list of filenames, assigning label 1 to dogs and label 0 to cats: >>> labels = [ 1 if 'dog' in ... os.path.basename(file) else 0 ... for file in file_list] >>> print(labels) [0, 0, 0, 1, 1, 1] Now, we have two lists: a list of filenames (or paths of each image) and a list of their labels. In the pre - vious section, you learned how to create a joint dataset from two arrays. Here, we will do the following: >>> class ImageDataset (Dataset ): ... def __init__(self, file_list, labels): ... self.file_list = file_list Parallelizing Neural Network Training with PyTorch 384 ... self.labels = labels ... ... def __getitem__(self, index): ... file = self.file_list[index] ... label = self.labels[index] ... return file, label ... ... def __len__(self): ... return len(self.labels) >>> image_dataset = ImageDataset(file_list, labels) >>> for file, label in image_dataset: ... print(file, label) cat_dog_images/cat-01.jpg 0 cat_dog_images/cat-02.jpg 0 cat_dog_images/cat-03.jpg 0 cat_dog_images/dog-01.jpg 1 cat_dog_images/dog-02.jpg 1 cat_dog_images/dog-03.jpg 1 The joint dataset has filenames and labels. Next, we need to apply transformations to this dataset: load the image content from its file path, de - code the raw content, and resize it to", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 350, "start_word": 112000, "end_word": 112400, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000351": {"text": "index): ... file = self.file_list[index] ... label = self.labels[index] ... return file, label ... ... def __len__(self): ... return len(self.labels) >>> image_dataset = ImageDataset(file_list, labels) >>> for file, label in image_dataset: ... print(file, label) cat_dog_images/cat-01.jpg 0 cat_dog_images/cat-02.jpg 0 cat_dog_images/cat-03.jpg 0 cat_dog_images/dog-01.jpg 1 cat_dog_images/dog-02.jpg 1 cat_dog_images/dog-03.jpg 1 The joint dataset has filenames and labels. Next, we need to apply transformations to this dataset: load the image content from its file path, de - code the raw content, and resize it to a desired size, for example, 80×120. As mentioned before, we use the torchvision.transforms module to resize the images and convert the loaded pixels into tensors as follows: >>> import torchvision.transforms as transforms >>> img_height, img_width = 80, 120 >>> transform = transforms.Compose([ ... transforms.ToTensor(), ... transforms.Resize((img_height, img_width)), ... ]) Now we update the ImageDataset class with the transform we just defined: >>> class ImageDataset (Dataset ): ... def __init__(self, file_list, labels, transform= None): ... self.file_list = file_list ... self.labels = labels ... self.transform = transform ... Chapter 12 385 ... def __getitem__(self, index): ... img = Image. open(self.file_list[index]) ... if self.transform is not None: ... img = self.transform(img) ... label = self.labels[index] ... return img, label ... ... def __len__(self): ... return len(self.labels) >>> >>> image_dataset = ImageDataset(file_list, labels, transform) Finally, we visualize these transformed image examples using Matplotlib: >>> fig = plt.figure(figsize=( 10, 6)) >>> for i, example in enumerate (image_dataset): ... ax = fig.add_subplot( 2, 3, i+ 1) ... ax.set_xticks([]); ax.set_yticks([]) ... ax.imshow(example[ 0].numpy().transpose(( 1, 2, 0))) ... ax.set_title( f'{example[ 1]}', size= 15) ... >>> plt.tight_layout() >>> plt.show() This results in the following visualization of the retrieved example images, along with their labels: Figure 12.4: Images are labeled Parallelizing Neural Network Training with PyTorch 386 The __getitem__ method in the ImageDataset class wraps all four steps into a single function, including the loading of the raw content (images and labels), decoding the images into tensors, and resizing the images. The function then returns a dataset that we can iterate over and apply other operations that we learned about in the previous sections via a data loader, such as shuffling and batching. Fetching available datasets from the torchvision.datasets library The torchvision.datasets library provides a nice collection of freely available image datasets for training or evaluating deep learning models. Similarly, the torchtext.datasets library provides datasets for natural language. Here, we use torchvision.datasets as an example. The torchvision datasets ( https://pytorch.org/vision/stable/datasets.html", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 351, "start_word": 112320, "end_word": 112720, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000352": {"text": "images. The function then returns a dataset that we can iterate over and apply other operations that we learned about in the previous sections via a data loader, such as shuffling and batching. Fetching available datasets from the torchvision.datasets library The torchvision.datasets library provides a nice collection of freely available image datasets for training or evaluating deep learning models. Similarly, the torchtext.datasets library provides datasets for natural language. Here, we use torchvision.datasets as an example. The torchvision datasets ( https://pytorch.org/vision/stable/datasets.html ) are nicely format - ted and come with informative descriptions, including the format of features and labels and their type and dimensionality, as well as the link to the original source of the dataset. Another advantage is that these datasets are all subclasses of torch.utils.data.Dataset , so all the functions we covered in the previous sections can be used directly. So, let’s see how to use these datasets in action. First, if you haven’t already installed torchvision together with PyTorch earlier, you need to install the torchvision library via pip from the command line: pip install torchvision You can take a look at the list of available datasets at https://pytorch.org/vision/stable/datasets. html . In the following paragraphs, we will cover fetching two different datasets: CelebA ( celeb_a ) and the MNIST digit dataset. Let’s first work with the CelebA dataset ( http://mmlab.ie.cuhk.edu.hk/projects/CelebA.html ) with torchvision.datasets.CelebA (https://pytorch.org/vision/stable/datasets.html#celeba ). The description of torchvision.datasets.CelebA provides some useful information to help us understand the structure of this dataset: • The database has three subsets, 'train' , 'valid' , and 'test' . We can select a specific subset or load all of them with the split parameter. • The images are stored in PIL.Image format. And we can obtain a transformed version using a custom transform function, such as transforms.ToTensor and transforms.Resize . • There are different types of targets we can use, including 'attributes' , 'identity' , and 'landmarks' . 'attributes' is 40 facial attributes for the person in the image, such as facial expression, makeup, hair properties, and so on; 'identity' is the person ID for an image; and 'landmarks' refers to the dictionary of extracted facial points, such as the position of the eyes, nose, and so on. Chapter 12 387 Next, we will call the torchvision.datasets.CelebA class to download the data, store it on disk in a designated folder, and load it into a torch.utils.data.Dataset object: >>> import torchvision >>> image_path", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 352, "start_word": 112640, "end_word": 113040, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000353": {"text": "attributes for the person in the image, such as facial expression, makeup, hair properties, and so on; 'identity' is the person ID for an image; and 'landmarks' refers to the dictionary of extracted facial points, such as the position of the eyes, nose, and so on. Chapter 12 387 Next, we will call the torchvision.datasets.CelebA class to download the data, store it on disk in a designated folder, and load it into a torch.utils.data.Dataset object: >>> import torchvision >>> image_path = './' >>> celeba_dataset = torchvision.datasets.CelebA( ... image_path, split= 'train', target_type= 'attr', download= True ... ) 1443490838/? [01:28<00:00, 6730259.81it/s] 26721026/? [00:03<00:00, 8225581.57it/s] 3424458/? [00:00<00:00, 14141274.46it/s] 6082035/? [00:00<00:00, 21695906.49it/s] 12156055/? [00:00<00:00, 12002767.35it/s] 2836386/? [00:00<00:00, 3858079.93it/s] You may run into a BadZipFile: File is not a zip file error, or RuntimeError: The daily quota of the file img_align_celeba.zip is exceeded and it can't be downloaded. This is a limitation of Google Drive and can only be overcome by trying again later ; it just means that Google Drive has a daily maximum quota that is exceeded by the CelebA files. To work around it, you can manually download the files from the source: http://mmlab.ie.cuhk.edu.hk/projects/ CelebA.html . In the downloaded folder, celeba/ , you can unzip the img_align_celeba.zip file. The image_path is the root of the downloaded folder, celeba/ . If you have already downloaded the files once, you can simply set download=False . For additional information and guidance, we highly recom - mend to see accompanying code notebook at https://github.com/rasbt/machine-learning-book/ blob/main/ch12/ch12_part1.ipynb . Now that we have instantiated the datasets, let’s check if the object is of the torch.utils.data.Dataset class: >>> assert isinstance (celeba_dataset, torch.utils.data.Dataset) As mentioned, the dataset is already split into train, test, and validation datasets, and we only load the train set. And we only use the 'attributes' target. In order to see what the data examples look like, we can execute the following code: >>> example = next(iter(celeba_dataset)) >>> print(example) (<PIL.JpegImagePlugin.JpegImageFile image mode=RGB size=178x218 at 0x120C6C668>, tensor([0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1])) Note that the sample in this dataset comes in a tuple of (PIL.Image, attributes) . If we want to pass this dataset to a supervised deep learning model during training, we have to", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 353, "start_word": 112960, "end_word": 113360, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000354": {"text": "print(example) (<PIL.JpegImagePlugin.JpegImageFile image mode=RGB size=178x218 at 0x120C6C668>, tensor([0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1])) Note that the sample in this dataset comes in a tuple of (PIL.Image, attributes) . If we want to pass this dataset to a supervised deep learning model during training, we have to reformat it as a tuple of (features tensor, label) . For the label, we will use the 'Smiling' category from the attributes as an example, which is the 31st element. Parallelizing Neural Network Training with PyTorch 388 Finally, let’s take the first 18 examples from it to visualize them with their 'Smiling' labels: >>> from itertools import islice >>> fig = plt.figure(figsize=( 12, 8)) >>> for i, (image, attributes) in islice( enumerate (celeba_dataset), 18): ... ax = fig.add_subplot( 3, 6, i+ 1) ... ax.set_xticks([]); ax.set_yticks([]) ... ax.imshow(image) ... ax.set_title( f'{attributes[ 31]}', size= 15) >>> plt.show() The examples and their labels that are retrieved from celeba_dataset are shown in Figure 12.5: Figure 12.5: Model predicts smiling celebrities This was all we needed to do to fetch and use the CelebA image dataset. Next, we will proceed with the second dataset from torchvision.datasets.MNIST (https://pytorch. org/vision/stable/datasets.html#mnist ). Let’s see how it can be used to fetch the MNIST digit dataset: • The database has two partitions, 'train' and 'test' . We need to select a specific subset to load. • The images are stored in PIL.Image format. And we can obtain a transformed version using a custom transform function, such as transforms.ToTensor and transforms.Resize . • There are 10 classes for the target, from 0 to 9. Chapter 12 389 Now, we can download the 'train' partition, convert the elements to tuples, and visualize 10 examples: >>> mnist_dataset = torchvision.datasets.MNIST(image_path, 'train', download= True) >>> assert isinstance (mnist_dataset, torch.utils.data.Dataset) >>> example = next(iter(mnist_dataset)) >>> print(example) (<PIL.Image.Image image mode=L size=28x28 at 0x126895B00>, 5) >>> fig = plt.figure(figsize=( 15, 6)) >>> for i, (image, label) in islice( enumerate (mnist_dataset), 10): ... ax = fig.add_subplot( 2, 5, i+ 1) ... ax.set_xticks([]); ax.set_yticks([]) ... ax.imshow(image, cmap= 'gray_r' ) ... ax.set_title( f'{label} ', size= 15) >>> plt.show() The retrieved example handwritten digits from this dataset are shown as follows: Figure 12.6: Correctly identifying handwritten digits This concludes our coverage", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 354, "start_word": 113280, "end_word": 113680, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000355": {"text": ">>> assert isinstance (mnist_dataset, torch.utils.data.Dataset) >>> example = next(iter(mnist_dataset)) >>> print(example) (<PIL.Image.Image image mode=L size=28x28 at 0x126895B00>, 5) >>> fig = plt.figure(figsize=( 15, 6)) >>> for i, (image, label) in islice( enumerate (mnist_dataset), 10): ... ax = fig.add_subplot( 2, 5, i+ 1) ... ax.set_xticks([]); ax.set_yticks([]) ... ax.imshow(image, cmap= 'gray_r' ) ... ax.set_title( f'{label} ', size= 15) >>> plt.show() The retrieved example handwritten digits from this dataset are shown as follows: Figure 12.6: Correctly identifying handwritten digits This concludes our coverage of building and manipulating datasets and fetching datasets from the torchvision.datasets library. Next, we will see how to build NN models in PyTorch. Building an NN model in PyTorch So far in this chapter, you have learned about the basic utility components of PyTorch for manipulat- ing tensors and organizing data into formats that we can iterate over during training. In this section, we will finally implement our first predictive model in PyTorch. As PyTorch is a bit more flexible but also more complex than machine learning libraries such as scikit-learn, we will start with a simple linear regression model. Parallelizing Neural Network Training with PyTorch 390 The PyTorch neural network module (torch.nn) torch.nn is an elegantly designed module developed to help create and train NNs. It allows easy pro - totyping and the building of complex models in just a few lines of code. To fully utilize the power of the module and customize it for your problem, you need to understand what it’s doing. To develop this understanding, we will first train a basic linear regression model on a toy dataset without using any features from the torch.nn module; we will use nothing but the basic PyTorch tensor operations. Then, we will incrementally add features from torch.nn and torch.optim . As you will see in the following subsections, these modules make building an NN model extremely easy. We will also take advantage of the dataset pipeline functionalities supported in PyTorch, such as Dataset and DataLoader , which you learned about in the previous section. In this book, we will use the torch.nn module to build NN models. The most commonly used approach for building an NN in PyTorch is through nn.Module , which allows layers to be stacked to form a network. This gives us more control over the forward pass. We will see examples of building an NN model using the nn.Module class. Finally, as you will", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 355, "start_word": 113600, "end_word": 114000, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000356": {"text": "in PyTorch, such as Dataset and DataLoader , which you learned about in the previous section. In this book, we will use the torch.nn module to build NN models. The most commonly used approach for building an NN in PyTorch is through nn.Module , which allows layers to be stacked to form a network. This gives us more control over the forward pass. We will see examples of building an NN model using the nn.Module class. Finally, as you will see in the following subsections, a trained model can be saved and reloaded for future use. Building a linear regression model In this subsection, we will build a simple model to solve a linear regression problem. First, let’s create a toy dataset in NumPy and visualize it: >>> X_train = np.arange( 10, dtype= 'float32' ).reshape(( 10, 1)) >>> y_train = np.array([ 1.0, 1.3, 3.1, 2.0, 5.0, ... 6.3, 6.6,7.4, 8.0, ... 9.0], dtype= 'float32' ) >>> plt.plot(X_train, y_train, 'o', markersize= 10) >>> plt.xlabel( 'x') >>> plt.ylabel( 'y') >>> plt.show() Chapter 12 391 As a result, the training examples will be shown in a scatterplot as follows: Figure 12.7: A scatterplot of the training examples Next, we will standardize the features (mean centering and dividing by the standard deviation) and create a PyTorch Dataset for the training set and a corresponding DataLoader : >>> from torch.utils.data import TensorDataset >>> X_train_norm = (X_train - np.mean(X_train)) / np.std(X_train) >>> X_train_norm = torch.from_numpy(X_train_norm) >>> y_train = torch.from_numpy(y_train) >>> train_ds = TensorDataset(X_train_norm, y_train) >>> batch_size = 1 >>> train_dl = DataLoader(train_ds, batch_size, shuffle= True) Here, we set a batch size of 1 for the DataLoader . Now, we can define our model for linear regression as z = wx + b . Here, we are going to use the torch.nn module. It provides predefined layers for building complex NN models, but to start, you will learn how to define a model from scratch. Later in this chapter, you will see how to use those predefined layers. Parallelizing Neural Network Training with PyTorch 392 For this regression problem, we will define a linear regression model from scratch. We will define the parameters of our model, weight and bias , which correspond to the weight and the bias parameters, respectively. Finally, we will define the model() function to determine how this model uses the input data to generate its output: >>> torch.manual_seed( 1) >>> weight = torch.randn(", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 356, "start_word": 113920, "end_word": 114320, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000357": {"text": "this chapter, you will see how to use those predefined layers. Parallelizing Neural Network Training with PyTorch 392 For this regression problem, we will define a linear regression model from scratch. We will define the parameters of our model, weight and bias , which correspond to the weight and the bias parameters, respectively. Finally, we will define the model() function to determine how this model uses the input data to generate its output: >>> torch.manual_seed( 1) >>> weight = torch.randn( 1) >>> weight.requires_grad_() >>> bias = torch.zeros( 1, requires_grad= True) >>> def model(xb): ... return xb @ weight + bias After defining the model, we can define the loss function that we want to minimize to find the optimal model weights. Here, we will choose the mean squared error (MSE ) as our loss function: >>> def loss_fn (input, target): ... return (input-target). pow(2).mean() Furthermore, to learn the weight parameters of the model, we will use stochastic gradient descent. In this subsection, we will implement this training via the stochastic gradient descent procedure by ourselves, but in the next subsection, we will use the SGD method from the optimization package, torch.optim , to do the same thing. To implement the stochastic gradient descent algorithm, we need to compute the gradients. Rather than manually computing the gradients, we will use PyTorch’s torch.autograd.backward function. We will cover torch.autograd and its different classes and functions for implementing automatic differentiation in Chapter 13, Going Deeper – The Mechanics of PyTorch. Now, we can set the learning rate and train the model for 200 epochs. The code for training the model against the batched version of the dataset is as follows: >>> learning_rate = 0.001 >>> num_epochs = 200 >>> log_epochs = 10 >>> for epoch in range (num_epochs): ... for x_batch, y_batch in train_dl: ... pred = model(x_batch) ... loss = loss_fn(pred, y_batch) ... loss.backward() ... with torch.no_grad(): ... weight -= weight.grad * learning_rate ... bias -= bias.grad * learning_rate ... weight.grad.zero_() ... bias.grad.zero_() ... if epoch % log_epochs== 0: Chapter 12 393 ... print(f'Epoch {epoch} Loss {loss.item(): .4f}') Epoch 0 Loss 5.1701 Epoch 10 Loss 30.3370 Epoch 20 Loss 26.9436 Epoch 30 Loss 0.9315 Epoch 40 Loss 3.5942 Epoch 50 Loss 5.8960 Epoch 60 Loss 3.7567 Epoch 70 Loss 1.5877 Epoch 80 Loss 0.6213 Epoch 90 Loss 1.5596 Epoch 100 Loss 0.2583 Epoch 110 Loss 0.6957 Epoch 120 Loss 0.2659 Epoch 130 Loss", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 357, "start_word": 114240, "end_word": 114640, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000358": {"text": "... bias -= bias.grad * learning_rate ... weight.grad.zero_() ... bias.grad.zero_() ... if epoch % log_epochs== 0: Chapter 12 393 ... print(f'Epoch {epoch} Loss {loss.item(): .4f}') Epoch 0 Loss 5.1701 Epoch 10 Loss 30.3370 Epoch 20 Loss 26.9436 Epoch 30 Loss 0.9315 Epoch 40 Loss 3.5942 Epoch 50 Loss 5.8960 Epoch 60 Loss 3.7567 Epoch 70 Loss 1.5877 Epoch 80 Loss 0.6213 Epoch 90 Loss 1.5596 Epoch 100 Loss 0.2583 Epoch 110 Loss 0.6957 Epoch 120 Loss 0.2659 Epoch 130 Loss 0.1615 Epoch 140 Loss 0.6025 Epoch 150 Loss 0.0639 Epoch 160 Loss 0.1177 Epoch 170 Loss 0.3501 Epoch 180 Loss 0.3281 Epoch 190 Loss 0.0970 Let’s look at the trained model and plot it. For the test data, we will create a NumPy array of values evenly spaced between 0 and 9. Since we trained our model with standardized features, we will also apply the same standardization to the test data: >>> print('Final Parameters:' , weight.item(), bias.item()) Final Parameters: 2.669806480407715 4.879569053649902 >>> X_test = np.linspace( 0, 9, num= 100, dtype= 'float32' ).reshape(- 1, 1) >>> X_test_norm = (X_test - np.mean(X_train)) / np.std(X_train) >>> X_test_norm = torch.from_numpy(X_test_norm) >>> y_pred = model(X_test_norm).detach().numpy() >>> fig = plt.figure(figsize=( 13, 5)) >>> ax = fig.add_subplot( 1, 2, 1) >>> plt.plot(X_train_norm, y_train, 'o', markersize= 10) >>> plt.plot(X_test_norm, y_pred, '--', lw=3) >>> plt.legend([ 'Training examples' , 'Linear reg.' ], fontsize= 15) >>> ax.set_xlabel( 'x', size=15) >>> ax.set_ylabel( 'y', size=15) >>> ax.tick_params(axis= 'both', which= 'major', labelsize= 15) >>> plt.show() Parallelizing Neural Network Training with PyTorch 394 Figure 12.8 shows a scatterplot of the training examples and the trained linear regression model: Figure 12.8: The linear regression model fits the data well Model training via the torch.nn and torch.optim modules In the previous example, we saw how to train a model by writing a custom loss function loss_fn() and applied stochastic gradient descent optimization. However, writing the loss function and gradient updates can be a repeatable task across different projects. The torch.nn module provides a set of loss functions, and torch.optim supports most commonly used optimization algorithms that can be called to update the parameters based on the computed gradients. To see how they work, let’s create a new MSE loss function and a stochastic gradient descent optimizer: >>> import torch.nn as nn >>> loss_fn = nn.MSELoss(reduction= 'mean') >>> input_size = 1 >>> output_size = 1 >>> model = nn.Linear(input_size, output_size) >>> optimizer = torch.optim.SGD(model.parameters(), lr=learning_rate) Note that here", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 358, "start_word": 114560, "end_word": 114960, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000359": {"text": "projects. The torch.nn module provides a set of loss functions, and torch.optim supports most commonly used optimization algorithms that can be called to update the parameters based on the computed gradients. To see how they work, let’s create a new MSE loss function and a stochastic gradient descent optimizer: >>> import torch.nn as nn >>> loss_fn = nn.MSELoss(reduction= 'mean') >>> input_size = 1 >>> output_size = 1 >>> model = nn.Linear(input_size, output_size) >>> optimizer = torch.optim.SGD(model.parameters(), lr=learning_rate) Note that here we use the torch.nn.Linear class for the linear layer instead of manually de fining it. Chapter 12 395 Now, we can simply call the step() method of the optimizer to train the model. We can pass a batched dataset (such as train_dl , which was created in the previous example): >>> for epoch in range (num_epochs): ... for x_batch, y_batch in train_dl: ... # 1. Generate predictions ... pred = model(x_batch)[:, 0] ... # 2. Calculate loss ... loss = loss_fn(pred, y_batch) ... # 3. Compute gradients ... loss.backward() ... # 4. Update parameters using gradients ... optimizer.step() ... # 5. Reset the gradients to zero ... optimizer.zero_grad() ... if epoch % log_epochs== 0: ... print(f'Epoch {epoch} Loss {loss.item(): .4f}') After the model is trained, visualize the results and make sure that they are similar to the results of the previous method. To obtain the weight and bias parameters, we can do the following: >>> print('Final Parameters:' , model.weight.item(), model.bias.item()) Final Parameters: 2.646660089492798 4.883835315704346 Building a multilayer perceptron for classifying flowers in the Iris dataset In the previous example, you saw how to build a model from scratch. We trained this model using stochastic gradient descent optimization. While we started our journey based on the simplest possible example, you can see that defining the model from scratch, even for such a simple case, is neither appealing nor good practice. PyTorch instead provides already defined layers through torch.nn that can be readily used as the building blocks of an NN model. In this section, you will learn how to use these layers to solve a classification task using the Iris flower dataset (identifying between three spe - cies of irises) and build a two-layer perceptron using the torch.nn module. First, let’s get the data from sklearn.datasets : >>> from sklearn.datasets import load_iris >>> from sklearn.model_selection import train_test_split >>> iris = load_iris() Parallelizing Neural Network Training with PyTorch 396 >>> X =", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 359, "start_word": 114880, "end_word": 115280, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000360": {"text": "readily used as the building blocks of an NN model. In this section, you will learn how to use these layers to solve a classification task using the Iris flower dataset (identifying between three spe - cies of irises) and build a two-layer perceptron using the torch.nn module. First, let’s get the data from sklearn.datasets : >>> from sklearn.datasets import load_iris >>> from sklearn.model_selection import train_test_split >>> iris = load_iris() Parallelizing Neural Network Training with PyTorch 396 >>> X = iris[ 'data'] >>> y = iris[ 'target' ] >>> X_train, X_test, y_train, y_test = train_test_split( ... X, y, test_size=1./3, random_state=1) Here, we randomly select 100 samples (2/3) for training and 50 samples (1/3) for testing. Next, we standardize the features (mean centering and dividing by the standard deviation) and create a PyTorch Dataset for the training set and a corresponding DataLoader : >>> X_train_norm = (X_train - np.mean(X_train)) / np.std(X_train) >>> X_train_norm = torch.from_numpy(X_train_norm). float() >>> y_train = torch.from_numpy(y_train) >>> train_ds = TensorDataset(X_train_norm, y_train) >>> torch.manual_seed( 1) >>> batch_size = 2 >>> train_dl = DataLoader(train_ds, batch_size, shuffle= True) Here, we set the batch size to 2 for the DataLoader . Now, we are ready to use the torch.nn module to build a model efficiently. In particular, using the nn.Module class, we can stack a few layers and build an NN. You can see the list of all the layers that are already available at https://pytorch.org/docs/stable/nn.html . For this problem, we are going to use the Linear layer, which is also known as a fully connected layer or dense layer, and can be best represented by f(w × x + b), where x represents a tensor containing the input features, w and b are the weight matrix and the bias vector, and f is the activation function. Each layer in an NN receives its inputs from the preceding layer; therefore, its dimensionality (rank and shape) is fixed. Typically, we need to concern ourselves with the dimensionality of output only when we design an NN architecture. Here, we want to define a model with two hidden layers. The first one receives an input of four features and projects them to 16 neurons. The second layer receives the output of the previous layer (which has a size of 16) and projects them to three output neurons, since we have three class labels. This can be done as follows: >>> class Model(nn.Module): ... def", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 360, "start_word": 115200, "end_word": 115600, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000361": {"text": "concern ourselves with the dimensionality of output only when we design an NN architecture. Here, we want to define a model with two hidden layers. The first one receives an input of four features and projects them to 16 neurons. The second layer receives the output of the previous layer (which has a size of 16) and projects them to three output neurons, since we have three class labels. This can be done as follows: >>> class Model(nn.Module): ... def __init__(self, input_size, hidden_size, output_size): ... super().__init__() ... self.layer1 = nn.Linear(input_size, hidden_size) ... self.layer2 = nn.Linear(hidden_size, output_size) ... def forward (self, x): ... x = self.layer1(x) ... x = nn.Sigmoid()(x) ... x = self.layer2(x) ... x = nn.Softmax(dim= 1)(x) ... return x Chapter 12 397 >>> input_size = X_train_norm.shape[ 1] >>> hidden_size = 16 >>> output_size = 3 >>> model = Model(input_size, hidden_size, output_size) Here, we used the sigmoid activation function for the first layer and softmax activation for the last (output) layer. Softmax activation in the last layer is used to support multiclass classification since we have three class labels here (which is why we have three neurons in the output layer). We will discuss the different activation functions and their applications later in this chapter. Next, we specify the loss function as cross-entropy loss and the optimizer as Adam: >>> learning_rate = 0.001 >>> loss_fn = nn.CrossEntropyLoss() >>> optimizer = torch.optim.Adam(model.parameters(), lr=learning_rate) Now, we can train the model. We will specify the number of epochs to be 100. The code of training the flower classification model is as follows: >>> num_epochs = 100 >>> loss_hist = [ 0] * num_epochs >>> accuracy_hist = [ 0] * num_epochs >>> for epoch in range (num_epochs): ... for x_batch, y_batch in train_dl: ... pred = model(x_batch) ... loss = loss_fn(pred, y_batch) ... loss.backward() ... optimizer.step() ... optimizer.zero_grad() ... loss_hist[epoch] += loss.item()*y_batch.size( 0) ... is_correct = (torch.argmax(pred, dim= 1) == y_batch). float() ... accuracy_hist[epoch] += is_correct.mean() ... loss_hist[epoch] /= len(train_dl.dataset) ... accuracy_hist[epoch] /= len(train_dl.dataset) The loss_hist and accuracy_hist lists keep the training loss and the training accuracy after each epoch. We can use this to visualize the learning curves as follows: >>> fig = plt.figure(figsize=( 12, 5)) >>> ax = fig.add_subplot( 1, 2, 1)The Adam optimizer is a robust, gradient-based optimization method, which we will talk about in detail in Chapter 14, Classifying Images with Deep Convolutional Neural Networks. Parallelizing Neural Network Training", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 361, "start_word": 115520, "end_word": 115920, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000362": {"text": "accuracy_hist[epoch] += is_correct.mean() ... loss_hist[epoch] /= len(train_dl.dataset) ... accuracy_hist[epoch] /= len(train_dl.dataset) The loss_hist and accuracy_hist lists keep the training loss and the training accuracy after each epoch. We can use this to visualize the learning curves as follows: >>> fig = plt.figure(figsize=( 12, 5)) >>> ax = fig.add_subplot( 1, 2, 1)The Adam optimizer is a robust, gradient-based optimization method, which we will talk about in detail in Chapter 14, Classifying Images with Deep Convolutional Neural Networks. Parallelizing Neural Network Training with PyTorch 398 >>> ax.plot(loss_hist, lw= 3) >>> ax.set_title( 'Training loss' , size=15) >>> ax.set_xlabel( 'Epoch', size=15) >>> ax.tick_params(axis= 'both', which= 'major', labelsize= 15) >>> ax = fig.add_subplot( 1, 2, 2) >>> ax.plot(accuracy_hist, lw= 3) >>> ax.set_title( 'Training accuracy' , size=15) >>> ax.set_xlabel( 'Epoch', size=15) >>> ax.tick_params(axis= 'both', which= 'major', labelsize= 15) >>> plt.show() The learning curves (training loss and training accuracy) are as follows: Figure 12.9: Training loss and accuracy curves Evaluating the trained model on the test dataset We can now evaluate the classification accuracy of the trained model on the test dataset: >>> X_test_norm = (X_test - np.mean(X_train)) / np.std(X_train) >>> X_test_norm = torch.from_numpy(X_test_norm). float() >>> y_test = torch.from_numpy(y_test) >>> pred_test = model(X_test_norm) >>> correct = (torch.argmax(pred_test, dim= 1) == y_test). float() >>> accuracy = correct.mean() >>> print(f'Test Acc.: {accuracy: .4f}') Test Acc.: 0.9800 Since we trained our model with standardized features, we also applied the same standardization to the test data. The classification accuracy is 0.98 (that is, 98 percent). Chapter 12 399 Saving and reloading the trained model Trained models can be saved on disk for future use. This can be done as follows: >>> path = 'iris_classifier.pt' >>> torch.save(model, path) Calling save(model) will save both the model architecture and all the learned parameters. As a com- mon convention, we can save models using a 'pt' or 'pth' file extension. Now, let’s reload the saved model. Since we have saved both the model architecture and the weights, we can easily rebuild and reload the parameters in just one line: >>> model_new = torch.load(path) Try to verify the model architecture by calling model_new.eval() : >>> model_new. eval() Model( (layer1): Linear(in_features=4, out_features=16, bias=True) (layer2): Linear(in_features=16, out_features=3, bias=True) ) Finally, let’s evaluate this new model that is reloaded on the test dataset to verify that the results are the same as before: >>> pred_test = model_new(X_test_norm) >>> correct = (torch.argmax(pred_test, dim= 1) == y_test). float() >>> accuracy =", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 362, "start_word": 115840, "end_word": 116240, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000363": {"text": "the weights, we can easily rebuild and reload the parameters in just one line: >>> model_new = torch.load(path) Try to verify the model architecture by calling model_new.eval() : >>> model_new. eval() Model( (layer1): Linear(in_features=4, out_features=16, bias=True) (layer2): Linear(in_features=16, out_features=3, bias=True) ) Finally, let’s evaluate this new model that is reloaded on the test dataset to verify that the results are the same as before: >>> pred_test = model_new(X_test_norm) >>> correct = (torch.argmax(pred_test, dim= 1) == y_test). float() >>> accuracy = correct.mean() >>> print(f'Test Acc.: {accuracy: .4f}') Test Acc.: 0.9800 If you want to save only the learned parameters, you can use save(model.state_dict()) as follows: >>> path = 'iris_classifier_state.pt' >>> torch.save(model.state_dict(), path) To reload the saved parameters, we first need to construct the model as we did before, then feed the loaded parameters to the model: >>> model_new = Model(input_size, hidden_size, output_size) >>> model_new.load_state_dict(torch.load(path)) Parallelizing Neural Network Training with PyTorch 400 Choosing activation functions for multilayer neural networks For simplicity, we have only discussed the sigmoid activation function in the context of multilayer feedforward NNs so far; we have used it in the hidden layer as well as the output layer in the MLP implementation in Chapter 11. Note that in this book, the sigmoidal logistic function, 𝜎𝜎(𝑧𝑧)=1 1+𝑒𝑒−𝑧𝑧 , is referred to as the sigmoid function for brevity, which is common in machine learning literature. In the following subsections, you will learn more about alternative nonlinear functions that are useful for implementing multilayer NNs. Technically, we can use any function as an activation function in multilayer NNs as long as it is differ - entiable. We can even use linear activation functions, such as in Adaline (Chapter 2, Training Simple Machine Learning Algorithms for Classification). However, in practice, it would not be very useful to use linear activation functions for both hidden and output layers, since we want to introduce nonlinearity in a typical artificial NN to be able to tackle complex problems. The sum of linear functions yields a linear function after all. The logistic (sigmoid) activation function that we used in Chapter 11 probably mimics the concept of a neuron in a brain most closely—we can think of it as the probability of whether a neuron fires. However, the logistic (sigmoid) activation function can be problematic if we have highly negative input, since the output of the sigmoid function will be close to zero in this case. If", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 363, "start_word": 116160, "end_word": 116560, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000364": {"text": "tackle complex problems. The sum of linear functions yields a linear function after all. The logistic (sigmoid) activation function that we used in Chapter 11 probably mimics the concept of a neuron in a brain most closely—we can think of it as the probability of whether a neuron fires. However, the logistic (sigmoid) activation function can be problematic if we have highly negative input, since the output of the sigmoid function will be close to zero in this case. If the sigmoid function returns output that is close to zero, the NN will learn very slowly, and it will be more likely to get trapped in the local minima of the loss landscape during training. This is why people often prefer a hyperbolic tangent as an activation function in hidden layers. Before we discuss what a hyperbolic tangent looks like, let’s briefly recapitulate some of the basics of the logistic function and look at a generalization that makes it more useful for multilabel classification problems. Logistic function recap As was mentioned in the introduction to this section, the logistic function is, in fact, a special case of a sigmoid function. You will recall from the section on logistic regression in Chapter 3, A Tour of Machine Learning Classifiers Using Scikit-Learn, that we can use a logistic function to model the probability that sample x belongs to the positive class (class 1) in a binary classification task. The given net input, z, is shown in the following equation: 𝑧𝑧𝑧𝑧𝑧0𝑥𝑥0+𝑧𝑧1𝑥𝑥1+⋯+𝑧𝑧𝑚𝑚𝑥𝑥𝑚𝑚𝑧∑𝑧𝑧𝑖𝑖𝑥𝑥𝑖𝑖𝑚𝑚 𝑖𝑖𝑖0𝑧𝑧𝑧T𝑥𝑥 The logistic (sigmoid) function will compute the following: 𝜎𝜎logistic(𝑧𝑧)=1 1+𝑒𝑒−𝑧𝑧 Chapter 12 401 Note that w 0 is the bias unit (y-axis intercept, which means x 0 = 1). To provide a more concrete ex - ample, let’s take a model for a two-dimensional data point, x, and a model with the following weight coefficients assigned to the w vector: >>> import numpy as np >>> X = np.array([ 1, 1.4, 2.5]) ## first value must be 1 >>> w = np.array([ 0.4, 0.3, 0.5]) >>> def net_input (X, w): ... return np.dot(X, w) >>> def logistic (z): ... return 1.0 / (1.0 + np.exp(-z)) >>> def logistic_activation (X, w): ... z = net_input(X, w) ... return logistic(z) >>> print(f'P(y=1|x) = {logistic_activation(X, w):.3f}' ) P(y=1|x) = 0.888 If we calculate the net input (z) and use it to activate a logistic neuron with those particular feature values and weight coefficients, we", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 364, "start_word": 116480, "end_word": 116880, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000365": {"text": "2.5]) ## first value must be 1 >>> w = np.array([ 0.4, 0.3, 0.5]) >>> def net_input (X, w): ... return np.dot(X, w) >>> def logistic (z): ... return 1.0 / (1.0 + np.exp(-z)) >>> def logistic_activation (X, w): ... z = net_input(X, w) ... return logistic(z) >>> print(f'P(y=1|x) = {logistic_activation(X, w):.3f}' ) P(y=1|x) = 0.888 If we calculate the net input (z) and use it to activate a logistic neuron with those particular feature values and weight coefficients, we get a value of 0.888 , which we can interpret as an 88.8 percent probability that this particular sample, x, belongs to the positive class. In Chapter 11 , we used the one-hot encoding technique to represent multiclass ground truth labels and designed the output layer consisting of multiple logistic activation units. However, as will be demon- strated by the following code example, an output layer consisting of multiple logistic activation units does not produce meaningful, interpretable probability values: >>> # W : array with shape = (n_output_units, n_hidden_units+1) >>> # note that the first column are the bias units >>> W = np.array([[ 1.1, 1.2, 0.8, 0.4], ... [ 0.2, 0.4, 1.0, 0.2], ... [ 0.6, 1.5, 1.2, 0.7]]) >>> # A : data array with shape = (n_hidden_units + 1, n_samples) >>> # note that the first column of this array must be 1 >>> A = np.array([[ 1, 0.1, 0.4, 0.6]]) >>> Z = np.dot(W, A[ 0]) >>> y_probas = logistic(Z) >>> print('Net Input: \\n' , Z) Net Input: [1.78 0.76 1.65] >>> print('Output Units:\\n' , y_probas) Output Units: [ 0.85569687 0.68135373 0.83889105] Parallelizing Neural Network Training with PyTorch 402 As you can see in the output, the resulting values cannot be interpreted as probabilities for a three-class problem. The reason for this is that they do not sum to 1. However, this is, in fact, not a big concern if we use our model to predict only the class labels and not the class membership probabilities. One way to predict the class label from the output units obtained earlier is to use the maximum value: >>> y_class = np.argmax(Z, axis= 0) >>> print('Predicted class label:' , y_class) Predicted class label: 0 In certain contexts, it can be useful to compute meaningful class probabilities for multiclass predic- tions. In the next section, we will take a look at a generalization of the logistic function, the softmax function,", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 365, "start_word": 116800, "end_word": 117200, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000366": {"text": "only the class labels and not the class membership probabilities. One way to predict the class label from the output units obtained earlier is to use the maximum value: >>> y_class = np.argmax(Z, axis= 0) >>> print('Predicted class label:' , y_class) Predicted class label: 0 In certain contexts, it can be useful to compute meaningful class probabilities for multiclass predic- tions. In the next section, we will take a look at a generalization of the logistic function, the softmax function, which can help us with this task. Estimating class probabilities in multiclass classification via the softmax function In the previous section, you saw how we can obtain a class label using the argmax function. Previously, in the Building a multilayer perceptron for classifying flowers in the Iris dataset section, we determined activation='softmax' in the last layer of the MLP model. The softmax function is a soft form of the argmax function; instead of giving a single class index, it provides the probability of each class. Therefore, it allows us to compute meaningful class probabilities in multiclass settings (multinomial logistic regression). In softmax , the probability of a particular sample with net input z belonging to the ith class can be computed with a normalization term in the denominator, that is, the sum of the exponentially weighted linear functions: 𝑝𝑝(𝑧𝑧)=𝜎𝜎(𝑧𝑧)=𝑒𝑒𝑧𝑧𝑖𝑖 ∑𝑒𝑒𝑧𝑧𝑗𝑗𝑀𝑀 𝑗𝑗𝑗𝑗 To see softmax in action, let’s code it up in Python: >>> def softmax (z): ... return np.exp(z) / np. sum(np.exp(z)) >>> y_probas = softmax(Z) >>> print('Probabilities:\\n' , y_probas) Probabilities: [ 0.44668973 0.16107406 0.39223621] >>> np.sum(y_probas) 1.0 As you can see, the predicted class probabilities now sum to 1, as we would expect. It is also notable that the predicted class label is the same as when we applied the argmax function to the logistic output. Chapter 12 403 It may help to think of the result of the softmax function as a normalized output that is useful for ob - taining meaningful class-membership predictions in multiclass settings. Therefore, when we build a multiclass classification model in PyTorch, we can use the torch.softmax() function to estimate the probabilities of each class membership for an input batch of examples. To see how we can use the torch.softmax() activation function in PyTorch, we will convert Z to a tensor in the following code, with an additional dimension reserved for the batch size: >>> torch.softmax(torch.from_numpy(Z), dim= 0) tensor([0.4467, 0.1611, 0.3922], dtype=torch.float64) Broadening", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 366, "start_word": 117120, "end_word": 117520, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000367": {"text": "ob - taining meaningful class-membership predictions in multiclass settings. Therefore, when we build a multiclass classification model in PyTorch, we can use the torch.softmax() function to estimate the probabilities of each class membership for an input batch of examples. To see how we can use the torch.softmax() activation function in PyTorch, we will convert Z to a tensor in the following code, with an additional dimension reserved for the batch size: >>> torch.softmax(torch.from_numpy(Z), dim= 0) tensor([0.4467, 0.1611, 0.3922], dtype=torch.float64) Broadening the output spectrum using a hyperbolic tangent Another sigmoidal function that is often used in the hidden layers of artificial NNs is the hyperbolic tangent (commonly known as tanh), which can be interpreted as a rescaled version of the logistic function: 𝜎𝜎logistic(𝑧𝑧)=1 1+𝑒𝑒−𝑧𝑧 𝜎𝜎tanh(𝑧𝑧)= 2×𝜎𝜎 logistic(2𝑧𝑧)−1=𝑒𝑒𝑧𝑧−𝑒𝑒−𝑧𝑧 𝑒𝑒𝑧𝑧+𝑒𝑒−𝑧𝑧 The advantage of the hyperbolic tangent over the logistic function is that it has a broader output spectrum ranging in the open interval (–1, 1), which can improve the convergence of the backpropa - gation algorithm (Neural Networks for Pattern Recognition, C. M. Bishop, Oxford University Press, pages: 500-501, 1995). In contrast, the logistic function returns an output signal ranging in the open interval (0, 1). For a simple comparison of the logistic function and the hyperbolic tangent, let’s plot the two sigmoidal functions: >>> import matplotlib.pyplot as plt >>> def tanh(z): ... e_p = np.exp(z) ... e_m = np.exp(-z) ... return (e_p - e_m) / (e_p + e_m) >>> z = np.arange(- 5, 5, 0.005 ) >>> log_act = logistic(z) >>> tanh_act = tanh(z) >>> plt.ylim([- 1.5, 1.5]) >>> plt.xlabel( 'net input $z$' ) >>> plt.ylabel( 'activation $\\phi(z)$' ) >>> plt.axhline( 1, color= 'black', linestyle= ':') >>> plt.axhline( 0.5, color= 'black', linestyle= ':') >>> plt.axhline( 0, color= 'black', linestyle= ':') Parallelizing Neural Network Training with PyTorch 404 >>> plt.axhline(- 0.5, color= 'black', linestyle= ':') >>> plt.axhline(- 1, color= 'black', linestyle= ':') >>> plt.plot(z, tanh_act, ... linewidth= 3, linestyle= '--', ... label= 'tanh') >>> plt.plot(z, log_act, ... linewidth= 3, ... label= 'logistic' ) >>> plt.legend(loc= 'lower right' ) >>> plt.tight_layout() >>> plt.show() As you can see, the shapes of the two sigmoidal curves look very similar; however, the tanh function has double the output space of the logistic function: Figure 12.10: A comparison of the tanh and logistic functions Note that we previously implemented the logistic and tanh functions verbosely for the purpose of illustration. In practice, we can use NumPy’s tanh function.", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 367, "start_word": 117440, "end_word": 117840, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000368": {"text": ">>> plt.plot(z, log_act, ... linewidth= 3, ... label= 'logistic' ) >>> plt.legend(loc= 'lower right' ) >>> plt.tight_layout() >>> plt.show() As you can see, the shapes of the two sigmoidal curves look very similar; however, the tanh function has double the output space of the logistic function: Figure 12.10: A comparison of the tanh and logistic functions Note that we previously implemented the logistic and tanh functions verbosely for the purpose of illustration. In practice, we can use NumPy’s tanh function. Alternatively, when building an NN model, we can use torch.tanh(x) in PyTorch to achieve the same results: >>> np.tanh(z) array([-0.9999092 , -0.99990829, -0.99990737, ..., 0.99990644, 0.99990737, 0.99990829]) >>> torch.tanh(torch.from_numpy(z)) tensor([-0.9999, -0.9999, -0.9999, ..., 0.9999, 0.9999, 0.9999], dtype=torch.float64) Chapter 12 405 In addition, the logistic function is available in SciPy’s special module: >>> from scipy.special import expit >>> expit(z) array([0.00669285, 0.00672617, 0.00675966, ..., 0.99320669, 0.99324034, 0.99327383]) Similarly, we can use the torch.sigmoid() function in PyTorch to do the same computation, as follows: >>> torch.sigmoid(torch.from_numpy(z)) tensor([0.0067, 0.0067, 0.0068, ..., 0.9932, 0.9932, 0.9933], dtype=torch.float64) Rectified linear unit activation The rectified linear unit (ReLU ) is another activation function that is often used in deep NNs. Before we delve into ReLU, we should step back and understand the vanishing gradient problem of tanh and logistic activations. To understand this problem, let’s assume that we initially have the net input z 1 = 20, which changes to z2 = 25. Computing the tanh activation, we get 𝜎𝜎(𝑧𝑧1)= 1.0 and 𝜎𝜎(𝑧𝑧2)= 1.0 , which shows no change in the output (due to the asymptotic behavior of the tanh function and numerical errors). This means that the derivative of activations with respect to the net input diminishes as z becomes large. As a result, learning the weights during the training phase becomes very slow because the gra - dient terms may be very close to zero. ReLU activation addresses this issue. Mathematically, ReLU is defined as follows: 𝜎𝜎(𝑧𝑧)= max(0,𝑧𝑧) ReLU is still a nonlinear function that is good for learning complex functions with NNs. Besides this, the derivative of ReLU, with respect to its input, is always 1 for positive input values. Therefore, it solves the problem of vanishing gradients, making it suitable for deep NNs. In PyTorch, we can apply the ReLU activation torch.relu() as follows: >>> torch.relu(torch.from_numpy(z)) tensor([0.0000, 0.0000, 0.0000, ..., 4.9850, 4.9900, 4.9950], dtype=torch.float64) We will use the ReLU activation function in the next", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 368, "start_word": 117760, "end_word": 118160, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000369": {"text": "𝜎𝜎(𝑧𝑧)= max(0,𝑧𝑧) ReLU is still a nonlinear function that is good for learning complex functions with NNs. Besides this, the derivative of ReLU, with respect to its input, is always 1 for positive input values. Therefore, it solves the problem of vanishing gradients, making it suitable for deep NNs. In PyTorch, we can apply the ReLU activation torch.relu() as follows: >>> torch.relu(torch.from_numpy(z)) tensor([0.0000, 0.0000, 0.0000, ..., 4.9850, 4.9900, 4.9950], dtype=torch.float64) We will use the ReLU activation function in the next chapter as an activation function for multilayer convolutional NNs.Note that using torch.sigmoid(x) produces results that are equivalent to torch. nn.Sigmoid()(x) , which we used earlier. torch.nn.Sigmoid is a class to which you can pass in parameters to construct an object in order to control the behavior. In contrast, torch.sigmoid is a function. Parallelizing Neural Network Training with PyTorch 406 Now that we know more about the different activation functions that are commonly used in artificial NNs, let’s conclude this section with an overview of the different activation functions that we have encountered so far in this book: Figure 12.11: The activation functions covered in this book You can find the list of all activation functions available in the torch.nn module at https://pytorch. org/docs/stable/nn.functional.html#non-linear-activation-functions . Summary In this chapter, you learned how to use PyTorch, an open source library for numerical computations, with a special focus on deep learning. While PyTorch is more inconvenient to use than NumPy, due to its additional complexity to support GPUs, it allows us to define and train large, multilayer NNs very efficiently. Chapter 12 407 Also, you learned about using the torch.nn module to build complex machine learning and NN models and run them efficiently. We explored model building in PyTorch by defining a model from scratch via the basic PyTorch tensor functionality. Implementing models can be tedious when we have to program at the level of matrix-vector multiplications and define every detail of each operation. How - ever, the advantage is that this allows us, as developers, to combine such basic operations and build more complex models. We then explored torch.nn , which makes building NN models a lot easier than implementing them from scratch. Finally, you learned about different activation functions and understood their behaviors and applica - tions. Specifically, in this chapter, we covered tanh, softmax, and ReLU. In the next chapter, we’ll continue our journey and dive deeper into PyTorch, where", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 369, "start_word": 118080, "end_word": 118480, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000370": {"text": "operation. How - ever, the advantage is that this allows us, as developers, to combine such basic operations and build more complex models. We then explored torch.nn , which makes building NN models a lot easier than implementing them from scratch. Finally, you learned about different activation functions and understood their behaviors and applica - tions. Specifically, in this chapter, we covered tanh, softmax, and ReLU. In the next chapter, we’ll continue our journey and dive deeper into PyTorch, where we’ll find ourselves working with PyTorch computation graphs and the automatic differentiation package. Along the way, you’ll learn many new concepts, such as gradient computations. Join our book’s Discord space Join the book’s Discord workspace for a monthly Ask me Anything session with the authors: https://packt.link/MLwPyTorch 13 Going Deeper – The Mechanics of PyTorch In Chapter 12, Parallelizing Neural Network Training with PyTorch, we covered how to define and ma - nipulate tensors and worked with the torch.utils.data module to build input pipelines. We further built and trained a multilayer perceptron to classify the Iris dataset using the PyTorch neural network module ( torch.nn ). Now that we have some hands-on experience with PyTorch neural network training and machine learning, it’s time to take a deeper dive into the PyTorch library and explore its rich set of features, which will allow us to implement more advanced deep learning models in upcoming chapters. In this chapter, we will use different aspects of PyTorch’s API to implement NNs. In particular, we will again use the torch.nn module, which provides multiple layers of abstraction to make the im- plementation of standard architectures very convenient. It also allows us to implement custom NN layers, which is very useful in research-oriented projects that require more customization. Later in this chapter, we will implement such a custom layer. To illustrate the different ways of model building using the torch.nn module, we will also consider the classic exclusive or ( XOR ) problem. Firstly, we will build multilayer perceptrons using the Sequential class. Then, we will consider other methods, such as subclassing nn.Module for defining custom lay - ers. Finally, we will work on two real-world projects that cover the machine learning steps from raw input to prediction. The topics that we will cover are as follows: • Understanding and working with PyTorch computation graphs • Working with PyTorch tensor objects • Solving the classic XOR problem", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 370, "start_word": 118400, "end_word": 118800, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000371": {"text": "exclusive or ( XOR ) problem. Firstly, we will build multilayer perceptrons using the Sequential class. Then, we will consider other methods, such as subclassing nn.Module for defining custom lay - ers. Finally, we will work on two real-world projects that cover the machine learning steps from raw input to prediction. The topics that we will cover are as follows: • Understanding and working with PyTorch computation graphs • Working with PyTorch tensor objects • Solving the classic XOR problem and understanding model capacity • Building complex NN models using PyTorch’s Sequential class and the nn.Module class • Computing gradients using automatic differentiation and torch.autograd Going Deeper – The Mechanics of PyTorch 410 The key features of PyTorch In the previous chapter, we saw that PyTorch provides us with a scalable, multiplatform programming interface for implementing and running machine learning algorithms. After its initial release in 2016 and its 1.0 release in 2018, PyTorch has evolved into one of the two most popular frameworks for deep learning. It uses dynamic computational graphs, which have the advantage of being more flexible compared to its static counterparts. Dynamic computational graphs are debugging friendly: PyTorch allows for interleaving the graph declaration and graph evaluation steps. You can execute the code line by line while having full access to all variables. This is a very important feature that makes the development and training of NNs very convenient. While PyTorch is an open-source library and can be used for free by everyone, its development is funded and supported by Facebook. This involves a large team of software engineers who expand and improve the library continuously. Since PyTorch is an open-source library, it also has strong support from other developers outside of Facebook, who avidly contribute and provide user feedback. This has made the PyTorch library more useful to both academic researchers and developers. A further conse - quence of these factors is that PyTorch has extensive documentation and tutorials to help new users. Another key feature of PyTorch, which was also noted in the previous chapter, is its ability to work with single or multiple graphical processing units (GPUs ). This allows users to train deep learning models very efficiently on large datasets and large-scale systems. Last but not least, PyTorch supports mobile deployment, which also makes it a very suitable tool for production. In the next section, we will look at how a tensor", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 371, "start_word": 118720, "end_word": 119120, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000372": {"text": "extensive documentation and tutorials to help new users. Another key feature of PyTorch, which was also noted in the previous chapter, is its ability to work with single or multiple graphical processing units (GPUs ). This allows users to train deep learning models very efficiently on large datasets and large-scale systems. Last but not least, PyTorch supports mobile deployment, which also makes it a very suitable tool for production. In the next section, we will look at how a tensor and function in PyTorch are interconnected via a computation graph. PyTorch’s computation graphs PyTorch performs its computations based on a directed acyclic graph (DAG ). In this section, we will see how these graphs can be defined for a simple arithmetic computation. Then, we will see the dy - namic graph paradigm, as well as how the graph is created on the fly in PyTorch. Understanding computation graphs PyTorch relies on building a computation graph at its core, and it uses this computation graph to derive relationships between tensors from the input all the way to the output. Let’s say that we have rank 0 (scalar) tensors a, b, and c and we want to evaluate z = 2 × (a – b) + c. Chapter 13 411 This evaluation can be represented as a computation graph, as shown in Figure 13.1: Figure 13.1: How a computation graph works As you can see, the computation graph is simply a network of nodes. Each node resembles an oper - ation, which applies a function to its input tensor or tensors and returns zero or more tensors as the output. PyTorch builds this computation graph and uses it to compute the gradients accordingly. In the next subsection, we will see some examples of creating a graph for this computation using PyTorch. Creating a graph in PyTorch Let’s look at a simple example that illustrates how to create a graph in PyTorch for evaluating z = 2 × (a – b) + c, as shown in the previous figure. The variables a, b, and c are scalars (single numbers), and we define these as PyTorch tensors. To create the graph, we can simply define a regular Python function with a, b, and c as its input arguments, for example: >>> import torch >>> def compute_z (a, b, c): ... r1 = torch.sub(a, b) ... r2 = torch.mul(r1, 2) ... z = torch.add(r2, c)", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 372, "start_word": 119040, "end_word": 119440, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000373": {"text": "evaluating z = 2 × (a – b) + c, as shown in the previous figure. The variables a, b, and c are scalars (single numbers), and we define these as PyTorch tensors. To create the graph, we can simply define a regular Python function with a, b, and c as its input arguments, for example: >>> import torch >>> def compute_z (a, b, c): ... r1 = torch.sub(a, b) ... r2 = torch.mul(r1, 2) ... z = torch.add(r2, c) ... return z Going Deeper – The Mechanics of PyTorch 412 Now, to carry out the computation, we can simply call this function with tensor objects as function arguments. Note that PyTorch functions such as add, sub (or subtract ), and mul (or multiply ) also allow us to provide inputs of higher ranks in the form of a PyTorch tensor object. In the following code example, we provide scalar inputs (rank 0), as well as rank 1 and rank 2 inputs, as lists: >>> print('Scalar Inputs:' , compute_z(torch.tensor( 1), ... torch.tensor( 2), torch.tensor( 3))) Scalar Inputs: tensor(1) >>> print('Rank 1 Inputs:' , compute_z(torch.tensor([ 1]), ... torch.tensor([ 2]), torch.tensor([ 3]))) Rank 1 Inputs: tensor([1]) >>> print('Rank 2 Inputs:' , compute_z(torch.tensor([[ 1]]), ... torch.tensor([[ 2]]), torch.tensor([[ 3]]))) Rank 2 Inputs: tensor([[1]]) In this section, you saw how simple it is to create a computation graph in PyTorch. Next, we will look at PyTorch tensors that can be used for storing and updating model parameters. PyTorch tensor objects for storing and updating model parameters We covered tensor objects in Chapter 12, Parallelizing Neural Network Training with PyTorch. In PyTorch, a special tensor object for which gradients need to be computed allows us to store and update the pa - rameters of our models during training. Such a tensor can be created by just assigning requires_grad to True on user-specified initial values. Note that as of now (mid-2021), only tensors of floating point and complex dtype can require gradients. In the following code, we will generate tensor objects of type float32 : >>> a = torch.tensor( 3.14, requires_grad= True) >>> print(a) tensor(3.1400, requires_grad=True) >>> b = torch.tensor([ 1.0, 2.0, 3.0], requires_grad= True) >>> print(b) tensor([1., 2., 3.], requires_grad=True) Chapter 13 413 Notice that requires_grad is set to False by default. This value can be efficiently set to True by run- ning requires_grad_() . Let’s take a look at the following example: >>> w", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 373, "start_word": 119360, "end_word": 119760, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000374": {"text": "and complex dtype can require gradients. In the following code, we will generate tensor objects of type float32 : >>> a = torch.tensor( 3.14, requires_grad= True) >>> print(a) tensor(3.1400, requires_grad=True) >>> b = torch.tensor([ 1.0, 2.0, 3.0], requires_grad= True) >>> print(b) tensor([1., 2., 3.], requires_grad=True) Chapter 13 413 Notice that requires_grad is set to False by default. This value can be efficiently set to True by run- ning requires_grad_() . Let’s take a look at the following example: >>> w = torch.tensor([ 1.0, 2.0, 3.0]) >>> print(w.requires_grad) False >>> w.requires_grad_() >>> print(w.requires_grad) True You will recall that for NN models, initializing model parameters with random weights is necessary to break the symmetry during backpropagation—otherwise, a multilayer NN would be no more useful than a single-layer NN like logistic regression. When creating a PyTorch tensor, we can also use a random initialization scheme. PyTorch can generate random numbers based on a variety of proba - bility distributions (see https://pytorch.org/docs/stable/torch.html#random-sampling ). In the following example, we will take a look at some standard initialization methods that are also available in the torch.nn.init module (see https://pytorch.org/docs/stable/nn.init.html ). So, let’s look at how we can create a tensor with Glorot initialization, which is a classic random ini- tialization scheme that was proposed by Xavier Glorot and Yoshua Bengio. For this, we first create an empty tensor and an operator called init as an object of class GlorotNormal . Then, we fill this tensor with values according to the Glorot initialization by calling the xavier_normal_() method. In the following example, we initialize a tensor of shape 2×3: >>> import torch.nn as nn >>> torch.manual_seed( 1) >>> w = torch.empty( 2, 3) >>> nn.init.xavier_normal_(w) >>> print(w) tensor([[ 0.4183, 0.1688, 0.0390], [ 0.3930, -0.2858, -0.1051]])method_() is an in-place method in PyTorch that is used for operations without making a copy of the input. Going Deeper – The Mechanics of PyTorch 414 Now, to put this into the context of a more practical use case, let’s see how we can define two Tensor objects inside the base nn.Module class: >>> class MyModule (nn.Module): ... def __init__(self): ... super().__init__() ... self.w1 = torch.empty( 2, 3, requires_grad= True) ... nn.init.xavier_normal_(self.w1) ... self.w2 = torch.empty( 1, 2, requires_grad= True) ... nn.init.xavier_normal_(self.w2) These two tensors can be then used as weights whose gradients will be computed via automatic dif- ferentiation.Xavier (or Glorot) initialization In the early development of deep learning, it was", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 374, "start_word": 119680, "end_word": 120080, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000375": {"text": "context of a more practical use case, let’s see how we can define two Tensor objects inside the base nn.Module class: >>> class MyModule (nn.Module): ... def __init__(self): ... super().__init__() ... self.w1 = torch.empty( 2, 3, requires_grad= True) ... nn.init.xavier_normal_(self.w1) ... self.w2 = torch.empty( 1, 2, requires_grad= True) ... nn.init.xavier_normal_(self.w2) These two tensors can be then used as weights whose gradients will be computed via automatic dif- ferentiation.Xavier (or Glorot) initialization In the early development of deep learning, it was observed that random uniform or random normal weight initialization could often result in poor model performance during training. In 2010, Glorot and Bengio investigated the effect of initialization and proposed a novel, more robust initialization scheme to facilitate the training of deep networks. The general idea behind Xavier initialization is to roughly balance the variance of the gradients across different layers. Otherwise, some layers may get too much attention during training while the other layers lag behind. According to the research paper by Glorot and Bengio, if we want to initialize the weights in a uniform distribution, we should choose the interval of this uniform distribution as follows: 𝑊𝑊𝑊𝑊𝑊𝑊𝑊𝑊𝑊𝑊𝑊𝑊𝑊𝑊𝑊𝑊𝑊𝑊𝑊√6 √𝑊𝑊𝑖𝑖𝑖𝑖+𝑊𝑊𝑜𝑜𝑜𝑜𝑜𝑜,√6 √𝑊𝑊𝑖𝑖𝑖𝑖+𝑊𝑊𝑜𝑜𝑜𝑜𝑜𝑜) Here, nin is the number of input neurons that are multiplied by the weights, and n out is the number of output neurons that feed into the next layer. For initializing the weights from Gaussian (normal) distribution, we recommend that you choose the standard deviation of this Gaussian to be: 𝜎𝜎𝜎√2 √𝑛𝑛𝑖𝑖𝑖𝑖+𝑛𝑛𝑜𝑜𝑜𝑜𝑜𝑜 PyTorch supports Xavier initialization in both uniform and normal distributions of weights. For more information about Glorot and Bengio’s initialization scheme, including the ratio - nale and mathematical motivation, we recommend the original paper (Understanding the difficulty of deep feedforward neural networks, Xavier Glorot and Yoshua Bengio, 2010), which is freely available at http://proceedings.mlr.press/v9/glorot10a/glorot10a.pdf . Chapter 13 415 Computing gradients via automatic differentiation As you already know, optimizing NNs requires computing the gradients of the loss with respect to the NN weights. This is required for optimization algorithms such as stochastic gradient descent (SGD ). In addition, gradients have other applications, such as diagnosing the network to find out why an NN model is making a particular prediction for a test example. Therefore, in this section, we will cover how to compute gradients of a computation with respect to its input variables. Computing the gradients of the loss with respect to trainable variables PyTorch supports automatic differentiation,", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 375, "start_word": 120000, "end_word": 120400, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000376": {"text": "respect to the NN weights. This is required for optimization algorithms such as stochastic gradient descent (SGD ). In addition, gradients have other applications, such as diagnosing the network to find out why an NN model is making a particular prediction for a test example. Therefore, in this section, we will cover how to compute gradients of a computation with respect to its input variables. Computing the gradients of the loss with respect to trainable variables PyTorch supports automatic differentiation, which can be thought of as an implementation of the chain rule for computing gradients of nested functions. Note that for the sake of simplicity, we will use the term gradient to refer to both partial derivatives and gradients. When we define a series of operations that results in some output or even intermediate tensors, PyTorch provides a context for calculating gradients of these computed tensors with respect to its dependent nodes in the computation graph. To compute these gradients, we can call the backward method from the torch.autograd module. It computes the sum of gradients of the given tensor with regard to leaf nodes (terminal nodes) in the graph. Let’s work with a simple example where we will compute z = wx + b and define the loss as the squared loss between the target y and prediction z , Loss = (y – z)2. In the more general case, where we may have multiple predictions and targets, we compute the loss as the sum of the squared error, 𝐿𝐿𝐿𝐿𝐿𝐿𝐿𝐿 𝐿∑(𝑦𝑦𝑖𝑖−𝑧𝑧𝑖𝑖)2 𝑖𝑖 . In order to implement this computation in PyTorch, we will define the model parameters, w and b, as variables (tensors with the requires_gradient attribute set to True ), and the input, x and y, as default tensors. We will compute the loss tensor and use it to compute the gradients of the model parameters, w and b, as follows: >>> w = torch.tensor( 1.0, requires_grad= True) >>> b = torch.tensor( 0.5, requires_grad= True) >>> x = torch.tensor([ 1.4]) >>> y = torch.tensor([ 2.1]) >>> z = torch.add(torch.mul(w, x), b) >>> loss = (y-z). pow(2).sum()Partial derivatives and gradients A partial derivative 𝜕𝜕𝜕𝜕 𝜕𝜕𝜕𝜕1 can be understood as the rate of change of a multivariate func- tion—a function with multiple inputs, f (x1, x2, ...), with respect to one of its inputs (here: x 1). The gradient, ∇𝑓𝑓 , of a function is a vector composed of all", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 376, "start_word": 120320, "end_word": 120720, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000377": {"text": ">>> b = torch.tensor( 0.5, requires_grad= True) >>> x = torch.tensor([ 1.4]) >>> y = torch.tensor([ 2.1]) >>> z = torch.add(torch.mul(w, x), b) >>> loss = (y-z). pow(2).sum()Partial derivatives and gradients A partial derivative 𝜕𝜕𝜕𝜕 𝜕𝜕𝜕𝜕1 can be understood as the rate of change of a multivariate func- tion—a function with multiple inputs, f (x1, x2, ...), with respect to one of its inputs (here: x 1). The gradient, ∇𝑓𝑓 , of a function is a vector composed of all the inputs’ partial derivatives, ∇𝑓𝑓 𝑓(𝜕𝜕𝜕𝜕 𝜕𝜕𝜕𝜕1,𝜕𝜕𝜕𝜕 𝜕𝜕𝜕𝜕2,…) . Going Deeper – The Mechanics of PyTorch 416 >>> loss.backward() >>> print('dL/dw : ' , w.grad) >>> print('dL/db : ' , b.grad) dL/dw : tensor(-0.5600) dL/db : tensor(-0.4000) Computing the value z is a forward pass in an NN. We used the backward method on the loss tensor to compute 𝜕𝜕𝜕𝜕𝜕𝜕𝜕𝜕𝜕𝜕 𝜕𝜕𝜕𝜕 and 𝜕𝜕𝜕𝜕𝜕𝜕𝜕𝜕𝜕𝜕 𝜕𝜕𝜕𝜕 . Since this is a very simple example, we can obtain 𝜕𝜕𝜕𝜕𝜕𝜕𝜕𝜕𝜕𝜕 𝜕𝜕𝜕𝜕= 2𝑥𝑥(𝑤𝑤𝑥𝑥+𝑏𝑏𝑏𝑏𝑏) symbolically to verify that the computed gradients match the results we obtained in the previous code example: >>> # verifying the computed gradient >>> print(2 * x * ((w * x + b) - y)) tensor([-0.5600], grad_fn=<MulBackward0>) We leave the verification of b as an exercise for the reader. Understanding automatic differentiation Automatic differentiation represents a set of computational techniques for computing gradients of arbitrary arithmetic operations. During this process, gradients of a computation (expressed as a series of operations) are obtained by accumulating the gradients through repeated applications of the chain rule. To better understand the concept behind automatic differentiation, let’s consider a series of nested computations, y = f(g(h(x))), with input x and output y. This can be broken into a series of steps: • u0 = x • u1 = h(x) • u2 = g(u 1) • u3 = f(u 2) = y The derivative 𝑑𝑑𝑑𝑑 𝑑𝑑𝑑𝑑 can be computed in two different ways: forward accumulation, which starts with 𝑑𝑑𝑑𝑑3 𝑑𝑑𝑑𝑑=𝑑𝑑𝑑𝑑3 𝑑𝑑𝑑𝑑2𝑑𝑑𝑑𝑑2 𝑑𝑑𝑑𝑑0 , and reverse accumulation, which starts with 𝑑𝑑𝑑𝑑 𝑑𝑑𝑑𝑑0=𝑑𝑑𝑑𝑑 𝑑𝑑𝑑𝑑1𝑑𝑑𝑑𝑑1 𝑑𝑑𝑑𝑑0 . Note that PyTorch uses the latter, reverse accumulation, which is more efficient for implementing backpropagation. Adversarial examples Computing gradients of the loss with respect to the input example is used for generating adversari- al examples (or adversarial attacks). In computer vision, adversarial examples are examples that are generated by adding some small, imperceptible noise (or perturbations) to the input example, which results in a", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 377, "start_word": 120640, "end_word": 121040, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000378": {"text": "𝑑𝑑𝑑𝑑3 𝑑𝑑𝑑𝑑=𝑑𝑑𝑑𝑑3 𝑑𝑑𝑑𝑑2𝑑𝑑𝑑𝑑2 𝑑𝑑𝑑𝑑0 , and reverse accumulation, which starts with 𝑑𝑑𝑑𝑑 𝑑𝑑𝑑𝑑0=𝑑𝑑𝑑𝑑 𝑑𝑑𝑑𝑑1𝑑𝑑𝑑𝑑1 𝑑𝑑𝑑𝑑0 . Note that PyTorch uses the latter, reverse accumulation, which is more efficient for implementing backpropagation. Adversarial examples Computing gradients of the loss with respect to the input example is used for generating adversari- al examples (or adversarial attacks). In computer vision, adversarial examples are examples that are generated by adding some small, imperceptible noise (or perturbations) to the input example, which results in a deep NN misclassifying them. Covering adversarial examples is beyond the scope of this book, but if you are interested, you can find the original paper by Christian Szegedy et al., Intriguing properties of neural networks at https://arxiv.org/pdf/1312.6199.pdf . Chapter 13 417 Simplifying implementations of common architectures via the torch.nn module You have already seen some examples of building a feedforward NN model (for instance, a multilayer perceptron) and defining a sequence of layers using the nn.Module class. Before we take a deeper dive into nn.Module , let’s briefly look at another approach for conjuring those layers via nn.Sequential . Implementing models based on nn.Sequential With nn.Sequential (https://pytorch.org/docs/master/generated/torch.nn.Sequential. html#sequential ), the layers stored inside the model are connected in a cascaded way. In the follow - ing example, we will build a model with two densely (fully) connected layers: >>> model = nn.Sequential( ... nn.Linear( 4, 16), ... nn.ReLU(), ... nn.Linear( 16, 32), ... nn.ReLU() ... ) >>> model Sequential( (0): Linear(in_features=4, out_features=16, bias=True) (1): ReLU() (2): Linear(in_features=16, out_features=32, bias=True) (3): ReLU() ) We specified the layers and instantiated the model after passing the layers to the nn.Sequential class. The output of the first fully connected layer is used as the input to the first ReLU layer. The output of the first ReLU layer becomes the input for the second fully connected layer. Finally, the output of the second fully connected layer is used as the input to the second ReLU layer. We can further configure these layers, for example, by applying different activation functions, initial- izers, or regularization methods to the parameters. A comprehensive and complete list of available options for most of these categories can be found in the official documentation: • Choosing activation functions: https://pytorch.org/docs/stable/nn.html#non-linear- activations-weighted-sum-nonlinearity • Initializing the layer parameters via nn.init : https://pytorch.org/docs/stable/nn.init. html • Applying L2 regularization to the layer parameters (to prevent overfitting) via the parameter weight_decay of some optimizers in torch.optim : https://pytorch.org/docs/stable/optim.", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 378, "start_word": 120960, "end_word": 121360, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000379": {"text": "layer. We can further configure these layers, for example, by applying different activation functions, initial- izers, or regularization methods to the parameters. A comprehensive and complete list of available options for most of these categories can be found in the official documentation: • Choosing activation functions: https://pytorch.org/docs/stable/nn.html#non-linear- activations-weighted-sum-nonlinearity • Initializing the layer parameters via nn.init : https://pytorch.org/docs/stable/nn.init. html • Applying L2 regularization to the layer parameters (to prevent overfitting) via the parameter weight_decay of some optimizers in torch.optim : https://pytorch.org/docs/stable/optim. html Going Deeper – The Mechanics of PyTorch 418 • Applying L1 regularization to the layer parameters (to prevent overfitting) by adding the L1 penalty term to the loss tensor, which we will implement next In the following code example, we will configure the first fully connected layer by specifying the initial value distribution for the weight. Then, we will configure the second fully connected layer by computing the L1 penalty term for the weight matrix: >>> nn.init.xavier_uniform_(model[ 0].weight) >>> l1_weight = 0.01 >>> l1_penalty = l1_weight * model[ 2].weight. abs().sum() Here, we initialized the weight of the first linear layer with Xavier initialization. And we computed the L1 norm of the weight of the second linear layer. Furthermore, we can also specify the type of optimizer and the loss function for training. Again, a comprehensive list of all available options can be found in the official documentation: • Optimizers via torch.optim : https://pytorch.org/docs/stable/optim.html#algorithms • Loss functions: https://pytorch.org/docs/stable/nn.html#loss-functions Choosing a loss function Regarding the choices for optimization algorithms, SGD and Adam are the most widely used methods. The choice of loss function depends on the task; for example, you might use mean square error loss for a regression problem. The family of cross-entropy loss functions supplies the possible choices for classification tasks, which are extensively discussed in Chapter 14, Classifying Images with Deep Convolutional Neural Networks. Furthermore, you can use the techniques you have learned from previous chapters (such as techniques for model evaluation from Chapter 6, Learning Best Practices for Model Evaluation and Hyperparameter Tuning) combined with the appropriate metrics for the problem. For example, precision and recall, accuracy, area under the curve (AUC ), and false negative and false positive scores are appropriate metrics for evaluating classification models. In this example, we will use the SGD optimizer, and cross-entropy loss for binary classification: >>> loss_fn = nn.BCELoss() >>> optimizer = torch.optim.SGD(model.parameters(), lr= 0.001) Chapter 13 419 Next, we", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 379, "start_word": 121280, "end_word": 121680, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000380": {"text": "techniques for model evaluation from Chapter 6, Learning Best Practices for Model Evaluation and Hyperparameter Tuning) combined with the appropriate metrics for the problem. For example, precision and recall, accuracy, area under the curve (AUC ), and false negative and false positive scores are appropriate metrics for evaluating classification models. In this example, we will use the SGD optimizer, and cross-entropy loss for binary classification: >>> loss_fn = nn.BCELoss() >>> optimizer = torch.optim.SGD(model.parameters(), lr= 0.001) Chapter 13 419 Next, we will look at a more practical example: solving the classic XOR classification problem. First, we will use the nn.Sequential() class to build the model. Along the way, you will also learn about the capacity of a model for handling nonlinear decision boundaries. Then, we will cover building a model via nn.Module that will give us more flexibility and control over the layers of the network. Solving an XOR classification problem The XOR classification problem is a classic problem for analyzing the capacity of a model with regard to capturing the nonlinear decision boundary between two classes. We generate a toy dataset of 200 training examples with two features (x 0, x1) drawn from a uniform distribution between [–1, 1). Then, we assign the ground truth label for training example i according to the following rule: 𝑦𝑦(𝑖𝑖)={0if 𝑥𝑥0(𝑖𝑖)×𝑥𝑥1(𝑖𝑖)<0 1 otherwise We will use half of the data (100 training examples) for training and the remaining half for validation. The code for generating the data and splitting it into the training and validation datasets is as follows: >>> import matplotlib.pyplot as plt >>> import numpy as np >>> torch.manual_seed( 1) >>> np.random.seed( 1) >>> x = np.random.uniform(low=- 1, high= 1, size=( 200, 2)) >>> y = np.ones( len(x)) >>> y[x[:, 0] * x[:, 1]<0] = 0 >>> n_train = 100 >>> x_train = torch.tensor(x[:n_train, :], dtype=torch.float32) >>> y_train = torch.tensor(y[:n_train], dtype=torch.float32) >>> x_valid = torch.tensor(x[n_train:, :], dtype=torch.float32) >>> y_valid = torch.tensor(y[n_train:], dtype=torch.float32) >>> fig = plt.figure(figsize=( 6, 6)) >>> plt.plot(x[y== 0, 0], x[y== 0, 1], 'o', alpha= 0.75, markersize= 10) >>> plt.plot(x[y== 1, 0], x[y== 1, 1], '<', alpha= 0.75, markersize= 10) >>> plt.xlabel( r'$x_1$' , size=15) >>> plt.ylabel( r'$x_2$' , size=15) >>> plt.show() Going Deeper – The Mechanics of PyTorch 420 The code results in the following scatterplot of the training and validation examples, shown with different markers based on their class label: Figure 13.2: Scatterplot of training and validation examples", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 380, "start_word": 121600, "end_word": 122000, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000381": {"text": ">>> fig = plt.figure(figsize=( 6, 6)) >>> plt.plot(x[y== 0, 0], x[y== 0, 1], 'o', alpha= 0.75, markersize= 10) >>> plt.plot(x[y== 1, 0], x[y== 1, 1], '<', alpha= 0.75, markersize= 10) >>> plt.xlabel( r'$x_1$' , size=15) >>> plt.ylabel( r'$x_2$' , size=15) >>> plt.show() Going Deeper – The Mechanics of PyTorch 420 The code results in the following scatterplot of the training and validation examples, shown with different markers based on their class label: Figure 13.2: Scatterplot of training and validation examples In the previous subsection, we covered the essential tools that we need to implement a classifier in PyTorch. We now need to decide what architecture we should choose for this task and dataset. As a general rule of thumb, the more layers we have, and the more neurons we have in each layer, the larger the capacity of the model will be. Here, the model capacity can be thought of as a measure of how readily the model can approximate complex functions. While having more parameters means the network can fit more complex functions, larger models are usually harder to train (and prone to overfitting). In practice, it is always a good idea to start with a simple model as a baseline, for example, a single-layer NN like logistic regression: >>> model = nn.Sequential( ... nn.Linear( 2, 1), ... nn.Sigmoid() ... ) >>> model Sequential( (0): Linear(in_features=2, out_features=1, bias=True) (1): Sigmoid() ) Chapter 13 421 After defining the model, we will initialize the cross-entropy loss function for binary classification and the SGD optimizer: >>> loss_fn = nn.BCELoss() >>> optimizer = torch.optim.SGD(model.parameters(), lr= 0.001) Next, we will create a data loader that uses a batch size of 2 for the train data: >>> from torch.utils.data import DataLoader, TensorDataset >>> train_ds = TensorDataset(x_train, y_train) >>> batch_size = 2 >>> torch.manual_seed( 1) >>> train_dl = DataLoader(train_ds, batch_size, shuffle= True) Now we will train the model for 200 epochs and record a history of training epochs: >>> torch.manual_seed( 1) >>> num_epochs = 200 >>> def train(model, num_epochs, train_dl, x_valid, y_valid): ... loss_hist_train = [ 0] * num_epochs ... accuracy_hist_train = [ 0] * num_epochs ... loss_hist_valid = [ 0] * num_epochs ... accuracy_hist_valid = [ 0] * num_epochs ... for epoch in range (num_epochs): ... for x_batch, y_batch in train_dl: ... pred = model(x_batch)[:, 0] ... loss = loss_fn(pred, y_batch) ... loss.backward() ... optimizer.step() ... optimizer.zero_grad() ... loss_hist_train[epoch] += loss.item() ... is_correct = ((pred>=", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 381, "start_word": 121920, "end_word": 122320, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000382": {"text": "training epochs: >>> torch.manual_seed( 1) >>> num_epochs = 200 >>> def train(model, num_epochs, train_dl, x_valid, y_valid): ... loss_hist_train = [ 0] * num_epochs ... accuracy_hist_train = [ 0] * num_epochs ... loss_hist_valid = [ 0] * num_epochs ... accuracy_hist_valid = [ 0] * num_epochs ... for epoch in range (num_epochs): ... for x_batch, y_batch in train_dl: ... pred = model(x_batch)[:, 0] ... loss = loss_fn(pred, y_batch) ... loss.backward() ... optimizer.step() ... optimizer.zero_grad() ... loss_hist_train[epoch] += loss.item() ... is_correct = ((pred>= 0.5).float() == y_batch). float() ... accuracy_hist_train[epoch] += is_correct.mean() ... loss_hist_train[epoch] /= n_train ... accuracy_hist_train[epoch] /= n_train/batch_size ... pred = model(x_valid)[:, 0] ... loss = loss_fn(pred, y_valid) ... loss_hist_valid[epoch] = loss.item() ... is_correct = ((pred>= 0.5).float() == y_valid). float() ... accuracy_hist_valid[epoch] += is_correct.mean() ... return loss_hist_train, loss_hist_valid, \\ ... accuracy_hist_train, accuracy_hist_valid >>> history = train(model, num_epochs, train_dl, x_valid, y_valid) Going Deeper – The Mechanics of PyTorch 422 Notice that the history of training epochs includes the train loss and validation loss and the train accu - racy and validation accuracy, which is useful for visual inspection after training. In the following code, we will plot the learning curves, including the training and validation loss, as well as their accuracies. The following code will plot the training performance: >>> fig = plt.figure(figsize=( 16, 4)) >>> ax = fig.add_subplot( 1, 2, 1) >>> plt.plot(history[ 0], lw=4) >>> plt.plot(history[ 1], lw=4) >>> plt.legend([ 'Train loss' , 'Validation loss' ], fontsize= 15) >>> ax.set_xlabel( 'Epochs' , size=15) >>> ax = fig.add_subplot( 1, 2, 2) >>> plt.plot(history[ 2], lw=4) >>> plt.plot(history[ 3], lw=4) >>> plt.legend([ 'Train acc.' , 'Validation acc.' ], fontsize= 15) >>> ax.set_xlabel( 'Epochs' , size=15) This results in the following figure, with two separate panels for the losses and accuracies: Figure 13.3: Loss and accuracy results As you can see, a simple model with no hidden layer can only derive a linear decision boundary, which is unable to solve the XOR problem. As a consequence, we can observe that the loss terms for both the training and the validation datasets are very high, and the classification accuracy is very low. To derive a nonlinear decision boundary, we can add one or more hidden layers connected via nonlinear activation functions. The universal approximation theorem states that a feedforward NN with a single hidden layer and a relatively large number of hidden units can approximate arbitrary continuous func - tions relatively well. Thus, one approach", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 382, "start_word": 122240, "end_word": 122640, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000383": {"text": "a consequence, we can observe that the loss terms for both the training and the validation datasets are very high, and the classification accuracy is very low. To derive a nonlinear decision boundary, we can add one or more hidden layers connected via nonlinear activation functions. The universal approximation theorem states that a feedforward NN with a single hidden layer and a relatively large number of hidden units can approximate arbitrary continuous func - tions relatively well. Thus, one approach for tackling the XOR problem more satisfactorily is to add a hidden layer and compare different numbers of hidden units until we observe satisfactory results on the validation dataset. Adding more hidden units would correspond to increasing the width of a layer. Alternatively, we can also add more hidden layers, which will make the model deeper. The advantage of making a network deeper rather than wider is that fewer parameters are required to achieve a comparable model capacity. Chapter 13 423 However, a downside of deep (versus wide) models is that deep models are prone to vanishing and exploding gradients, which make them harder to train. As an exercise, try adding one, two, three, and four hidden layers, each with four hidden units. In the following example, we will take a look at the results of a feedforward NN with two hidden layers: >>> model = nn.Sequential( ... nn.Linear( 2, 4), ... nn.ReLU(), ... nn.Linear( 4, 4), ... nn.ReLU(), ... nn.Linear( 4, 1), ... nn.Sigmoid() ... ) >>> loss_fn = nn.BCELoss() >>> optimizer = torch.optim.SGD(model.parameters(), lr= 0.015) >>> model Sequential( (0): Linear(in_features=2, out_features=4, bias=True) (1): ReLU() (2): Linear(in_features=4, out_features=4, bias=True) (3): ReLU() (4): Linear(in_features=4, out_features=1, bias=True) (5): Sigmoid() ) >>> history = train(model, num_epochs, train_dl, x_valid, y_valid) We can repeat the previous code for visualization, which produces the following: Figure 13.4: Loss and accuracy results after adding two hidden layers Now, we can see that the model is able to derive a nonlinear decision boundary for this data, and the model reaches 100 percent accuracy on the training dataset. The validation dataset’s accuracy is 95 percent, which indicates that the model is slightly overfitting. Going Deeper – The Mechanics of PyTorch 424 Making model building more flexible with nn.Module In the previous example, we used the PyTorch Sequential class to create a fully connected NN with multiple layers. This is a very common and convenient way of building models. However,", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 383, "start_word": 122560, "end_word": 122960, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000384": {"text": "derive a nonlinear decision boundary for this data, and the model reaches 100 percent accuracy on the training dataset. The validation dataset’s accuracy is 95 percent, which indicates that the model is slightly overfitting. Going Deeper – The Mechanics of PyTorch 424 Making model building more flexible with nn.Module In the previous example, we used the PyTorch Sequential class to create a fully connected NN with multiple layers. This is a very common and convenient way of building models. However, it unfortu- nately doesn’t allow us to create more complex models that have multiple input, output, or intermediate branches. That’s where nn.Module comes in handy. The alternative way to build complex models is by subclassing nn.Module . In this approach, we create a new class derived from nn.Module and define the method, __init__() , as a constructor. The forward() method is used to specify the forward pass. In the constructor function, __init__() , we define the layers as attributes of the class so that they can be accessed via the self reference attribute. Then, in the forward() method, we specify how these layers are to be used in the forward pass of the NN. The code for defining a new class that implements the previous model is as follows: >>> class MyModule (nn.Module): ... def __init__(self): ... super().__init__() ... l1 = nn.Linear( 2, 4) ... a1 = nn.ReLU() ... l2 = nn.Linear( 4, 4) ... a2 = nn.ReLU() ... l3 = nn.Linear( 4, 1) ... a3 = nn.Sigmoid() ... l = [l1, a1, l2, a2, l3, a3] ... self.module_list = nn.ModuleList(l) ... ... def forward (self, x): ... for f in self.module_list: ... x = f(x) ... return x Notice that we put all layers in the nn.ModuleList object, which is just a list object composed of nn.Module items. This makes the code more readable and easier to follow. Once we define an instance of this new class, we can train it as we did previously: >>> model = MyModule() >>> model MyModule( (module_list): ModuleList( (0): Linear(in_features=2, out_features=4, bias=True) (1): ReLU() (2): Linear(in_features=4, out_features=4, bias=True) (3): ReLU() Chapter 13 425 (4): Linear(in_features=4, out_features=1, bias=True) (5): Sigmoid() ) ) >>> loss_fn = nn.BCELoss() >>> optimizer = torch.optim.SGD(model.parameters(), lr= 0.015) >>> history = train(model, num_epochs, train_dl, x_valid, y_valid) Next, besides the train history, we will use the mlxtend library to visualize the validation data and the decision boundary. Mlxtend can be installed", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 384, "start_word": 122880, "end_word": 123280, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000385": {"text": "train it as we did previously: >>> model = MyModule() >>> model MyModule( (module_list): ModuleList( (0): Linear(in_features=2, out_features=4, bias=True) (1): ReLU() (2): Linear(in_features=4, out_features=4, bias=True) (3): ReLU() Chapter 13 425 (4): Linear(in_features=4, out_features=1, bias=True) (5): Sigmoid() ) ) >>> loss_fn = nn.BCELoss() >>> optimizer = torch.optim.SGD(model.parameters(), lr= 0.015) >>> history = train(model, num_epochs, train_dl, x_valid, y_valid) Next, besides the train history, we will use the mlxtend library to visualize the validation data and the decision boundary. Mlxtend can be installed via conda or pip as follows: conda install mlxtend -c conda-forge pip install mlxtend To compute the decision boundary of our model, we need to add a predict() method in the MyModule class: >>> def predict (self, x): ... x = torch.tensor(x, dtype=torch.float32) ... pred = self.forward(x)[:, 0] ... return (pred>= 0.5).float() It will return the predicted class (0 or 1) for a sample. The following code will plot the training performance along with the decision region bias: >>> from mlxtend.plotting import plot_decision_regions >>> fig = plt.figure(figsize=( 16, 4)) >>> ax = fig.add_subplot( 1, 3, 1) >>> plt.plot(history[ 0], lw=4) >>> plt.plot(history[ 1], lw=4) >>> plt.legend([ 'Train loss' , 'Validation loss' ], fontsize= 15) >>> ax.set_xlabel( 'Epochs' , size=15) >>> ax = fig.add_subplot( 1, 3, 2) >>> plt.plot(history[ 2], lw=4) >>> plt.plot(history[ 3], lw=4) >>> plt.legend([ 'Train acc.' , 'Validation acc.' ], fontsize= 15) >>> ax.set_xlabel( 'Epochs' , size=15) >>> ax = fig.add_subplot( 1, 3, 3) >>> plot_decision_regions(X=x_valid.numpy(), ... y=y_valid.numpy().astype(np.integer), ... clf=model) >>> ax.set_xlabel( r'$x_1$' , size=15) Going Deeper – The Mechanics of PyTorch 426 >>> ax.xaxis.set_label_coords( 1, -0.025) >>> ax.set_ylabel( r'$x_2$' , size=15) >>> ax.yaxis.set_label_coords(- 0.025, 1) >>> plt.show() This results in Figure 13.5, with three separate panels for the losses, accuracies, and the scatterplot of the validation examples, along with the decision boundary: Figure 13.5: Results, including a scatterplot Writing custom layers in PyTorch In cases where we want to define a new layer that is not already supported by PyTorch, we can define a new class derived from the nn.Module class. This is especially useful when designing a new layer or customizing an existing layer. To illustrate the concept of implementing custom layers, let’s consider a simple example. Imagine we want to define a new linear layer that computes 𝑤𝑤(𝑥𝑥𝑥𝑥𝑥)𝑥𝑏𝑏 , where 𝜖𝜖 refers to a random variable as a noise variable. To implement this computation, we define a new class as a subclass of nn.Module .", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 385, "start_word": 123200, "end_word": 123600, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000386": {"text": "supported by PyTorch, we can define a new class derived from the nn.Module class. This is especially useful when designing a new layer or customizing an existing layer. To illustrate the concept of implementing custom layers, let’s consider a simple example. Imagine we want to define a new linear layer that computes 𝑤𝑤(𝑥𝑥𝑥𝑥𝑥)𝑥𝑏𝑏 , where 𝜖𝜖 refers to a random variable as a noise variable. To implement this computation, we define a new class as a subclass of nn.Module . For this new class, we have to define both the constructor __init__() method and the forward() method. In the constructor, we define the variables and other required tensors for our customized layer. We can create variables and initialize them in the constructor if the input_size is given to the constructor. Alternatively, we can delay the variable initialization (for instance, if we do not know the exact input shape upfront) and delegate it to another method for late variable creation. To look at a concrete example, we are going to define a new layer called NoisyLinear , which imple - ments the computation 𝑤𝑤(𝑥𝑥𝑥𝑥𝑥)𝑥𝑏𝑏 , which was mentioned in the preceding paragraph: >>> class NoisyLinear (nn.Module): ... def __init__ (self, input_size, output_size, ... noise_stddev= 0.1): ... super().__init__() ... w = torch.Tensor(input_size, output_size) ... self.w = nn.Parameter(w) # nn.Parameter is a Tensor ... # that's a module parameter. Chapter 13 427 ... nn.init.xavier_uniform_(self.w) ... b = torch.Tensor(output_size).fill_( 0) ... self.b = nn.Parameter(b) ... self.noise_stddev = noise_stddev ... ... def forward (self, x, training= False): ... if training: ... noise = torch.normal( 0.0, self.noise_stddev, x.shape) ... x_new = torch.add(x, noise) ... else: ... x_new = x ... return torch.add(torch.mm(x_new, self.w), self.b) In the constructor, we have added an argument, noise_stddev , to specify the standard deviation for the distribution of 𝜖𝜖 , which is sampled from a Gaussian distribution. Furthermore, notice that in the forward() method, we have used an additional argument, training=False . We use it to distinguish whether the layer is used during training or only for prediction (this is sometimes also called infer- ence) or evaluation. Also, there are certain methods that behave differently in training and prediction modes. You will encounter an example of such a method, Dropout , in the upcoming chapters. In the previous code snippet, we also specified that the random vector, 𝜖𝜖 , was to be generated and added to the input during training only", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 386, "start_word": 123520, "end_word": 123920, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000387": {"text": ". We use it to distinguish whether the layer is used during training or only for prediction (this is sometimes also called infer- ence) or evaluation. Also, there are certain methods that behave differently in training and prediction modes. You will encounter an example of such a method, Dropout , in the upcoming chapters. In the previous code snippet, we also specified that the random vector, 𝜖𝜖 , was to be generated and added to the input during training only and not used for inference or evaluation. Before we go a step further and use our custom NoisyLinear layer in a model, let’s test it in the context of a simple example. 1. In the following code, we will define a new instance of this layer, and execute it on an input tensor. Then, we will call the layer three times on the same input tensor: >>> torch.manual_seed( 1) >>> noisy_layer = NoisyLinear( 4, 2) >>> x = torch.zeros(( 1, 4)) >>> print(noisy_layer(x, training= True)) tensor([[ 0.1154, -0.0598]], grad_fn=<AddBackward0>) >>> print(noisy_layer(x, training= True)) tensor([[ 0.0432, -0.0375]], grad_fn=<AddBackward0>) >>> print(noisy_layer(x, training= False)) tensor([[0., 0.]], grad_fn=<AddBackward0>) Going Deeper – The Mechanics of PyTorch 428 2. Now, let’s create a new model similar to the previous one for solving the XOR classification task. As before, we will use the nn.Module class for model building, but this time, we will use our NoisyLinear layer as the first hidden layer of the multilayer perceptron. The code is as follows: >>> class MyNoisyModule (nn.Module): ... def __init__(self): ... super().__init__() ... self.l1 = NoisyLinear( 2, 4, 0.07 ) ... self.a1 = nn.ReLU() ... self.l2 = nn.Linear( 4, 4) ... self.a2 = nn.ReLU() ... self.l3 = nn.Linear( 4, 1) ... self.a3 = nn.Sigmoid() ... ... def forward (self, x, training= False): ... x = self.l1(x, training) ... x = self.a1(x) ... x = self.l2(x) ... x = self.a2(x) ... x = self.l3(x) ... x = self.a3(x) ... return x ... ... def predict (self, x): ... x = torch.tensor(x, dtype=torch.float32) ... pred = self.forward(x)[:, 0] ... return (pred>= 0.5).float() ... >>> torch.manual_seed( 1) >>> model = MyNoisyModule() >>> model MyNoisyModule( (l1): NoisyLinear() (a1): ReLU() (l2): Linear(in_features=4, out_features=4, bias=True)Note that the outputs for the first two calls differ because the NoisyLinear layer added random noise to the input tensor. The third call outputs [0, 0] as we didn’t add noise by specifying training=False . Chapter 13 429 (a2): ReLU()", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 387, "start_word": 123840, "end_word": 124240, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000388": {"text": "x ... ... def predict (self, x): ... x = torch.tensor(x, dtype=torch.float32) ... pred = self.forward(x)[:, 0] ... return (pred>= 0.5).float() ... >>> torch.manual_seed( 1) >>> model = MyNoisyModule() >>> model MyNoisyModule( (l1): NoisyLinear() (a1): ReLU() (l2): Linear(in_features=4, out_features=4, bias=True)Note that the outputs for the first two calls differ because the NoisyLinear layer added random noise to the input tensor. The third call outputs [0, 0] as we didn’t add noise by specifying training=False . Chapter 13 429 (a2): ReLU() (l3): Linear(in_features=4, out_features=1, bias=True) (a3): Sigmoid() ) 3. Similarly, we will train the model as we did previously. At this time, to compute the predic- tion on the training batch, we use pred = model(x_batch, True)[:, 0] instead of pred = model(x_batch)[:, 0] : >>> loss_fn = nn.BCELoss() >>> optimizer = torch.optim.SGD(model.parameters(), lr= 0.015) >>> torch.manual_seed( 1) >>> loss_hist_train = [ 0] * num_epochs >>> accuracy_hist_train = [ 0] * num_epochs >>> loss_hist_valid = [ 0] * num_epochs >>> accuracy_hist_valid = [ 0] * num_epochs >>> for epoch in range (num_epochs): ... for x_batch, y_batch in train_dl: ... pred = model(x_batch, True)[:, 0] ... loss = loss_fn(pred, y_batch) ... loss.backward() ... optimizer.step() ... optimizer.zero_grad() ... loss_hist_train[epoch] += loss.item() ... is_correct = ( ... (pred>= 0.5).float() == y_batch ... ). float() ... accuracy_hist_train[epoch] += is_correct.mean() ... loss_hist_train[epoch] /= 100/batch_size ... accuracy_hist_train[epoch] /= 100/batch_size ... pred = model(x_valid)[:, 0] ... loss = loss_fn(pred, y_valid) ... loss_hist_valid[epoch] = loss.item() ... is_correct = ((pred>= 0.5).float() == y_valid). float() ... accuracy_hist_valid[epoch] += is_correct.mean() 4. After the model is trained, we can plot the losses, accuracies, and the decision boundary: >>> fig = plt.figure(figsize=( 16, 4)) >>> ax = fig.add_subplot( 1, 3, 1) >>> plt.plot(loss_hist_train, lw= 4) >>> plt.plot(loss_hist_valid, lw= 4) Going Deeper – The Mechanics of PyTorch 430 >>> plt.legend([ 'Train loss' , 'Validation loss' ], fontsize= 15) >>> ax.set_xlabel( 'Epochs' , size=15) >>> ax = fig.add_subplot( 1, 3, 2) >>> plt.plot(accuracy_hist_train, lw= 4) >>> plt.plot(accuracy_hist_valid, lw= 4) >>> plt.legend([ 'Train acc.' , 'Validation acc.' ], fontsize= 15) >>> ax.set_xlabel( 'Epochs' , size=15) >>> ax = fig.add_subplot( 1, 3, 3) >>> plot_decision_regions( ... X=x_valid.numpy(), ... y=y_valid.numpy().astype(np.integer), ... clf=model ... ) >>> ax.set_xlabel( r'$x_1$' , size=15) >>> ax.xaxis.set_label_coords( 1, -0.025) >>> ax.set_ylabel( r'$x_2$' , size=15) >>> ax.yaxis.set_label_coords(- 0.025, 1) >>> plt.show() 5. The resulting figure will be as follows: Figure 13.6: Results using NoisyLinear as the first hidden layer Here, our goal was to learn how", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 388, "start_word": 124160, "end_word": 124560, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000389": {"text": "plt.plot(accuracy_hist_valid, lw= 4) >>> plt.legend([ 'Train acc.' , 'Validation acc.' ], fontsize= 15) >>> ax.set_xlabel( 'Epochs' , size=15) >>> ax = fig.add_subplot( 1, 3, 3) >>> plot_decision_regions( ... X=x_valid.numpy(), ... y=y_valid.numpy().astype(np.integer), ... clf=model ... ) >>> ax.set_xlabel( r'$x_1$' , size=15) >>> ax.xaxis.set_label_coords( 1, -0.025) >>> ax.set_ylabel( r'$x_2$' , size=15) >>> ax.yaxis.set_label_coords(- 0.025, 1) >>> plt.show() 5. The resulting figure will be as follows: Figure 13.6: Results using NoisyLinear as the first hidden layer Here, our goal was to learn how to define a new custom layer subclassed from nn.Module and to use it as we would use any other standard torch.nn layer. Although, with this particular example, NoisyLinear did not help to improve the performance, please keep in mind that our objective was to mainly learn how to write a customized layer from scratch. In general, writing a new customized layer can be useful in other applications, for example, if you develop a new algorithm that depends on a new layer beyond the existing ones. Chapter 13 431 Project one – predicting the fuel efficiency of a car So far, in this chapter, we have mostly focused on the torch.nn module. We used nn.Sequential to construct the models for simplicity. Then, we made model building more flexible with nn.Module and implemented feedforward NNs, to which we added customized layers. In this section, we will work on a real-world project of predicting the fuel efficiency of a car in miles per gallon (MPG). We will cover the underlying steps in machine learning tasks, such as data preprocessing, feature engineering, training, prediction (inference), and evaluation. Working with feature columns In machine learning and deep learning applications, we can encounter various different types of fea - tures: continuous, unordered categorical (nominal), and ordered categorical (ordinal). You will recall that in Chapter 4, Building Good Training Datasets – Data Preprocessing, we covered different types of features and learned how to handle each type. Note that while numeric data can be either continuous or discrete, in the context of machine learning with PyTorch, “numeric” data specifically refers to continuous data of floating point type. Sometimes, feature sets are comprised of a mixture of different feature types. For example, consider a scenario with a set of seven different features, as shown in Figure 13.7: Figure 13.7: Auto MPG data structure Going Deeper – The Mechanics of PyTorch 432 The features shown in the figure (model year,", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 389, "start_word": 124480, "end_word": 124880, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000390": {"text": "that while numeric data can be either continuous or discrete, in the context of machine learning with PyTorch, “numeric” data specifically refers to continuous data of floating point type. Sometimes, feature sets are comprised of a mixture of different feature types. For example, consider a scenario with a set of seven different features, as shown in Figure 13.7: Figure 13.7: Auto MPG data structure Going Deeper – The Mechanics of PyTorch 432 The features shown in the figure (model year, cylinders, displacement, horsepower, weight, acceler - ation, and origin) were obtained from the Auto MPG dataset, which is a common machine learning benchmark dataset for predicting the fuel efficiency of a car in MPG. The full dataset and its descrip - tion are available from UCI’s machine learning repository at https://archive.ics.uci.edu/ml/ datasets/auto+mpg . We are going to treat five features from the Auto MPG dataset (number of cylinders, displacement, horsepower, weight, and acceleration) as “numeric” (here, continuous) features. The model year can be regarded as an ordered categorical (ordinal) feature. Lastly, the manufacturing origin can be regarded as an unordered categorical (nominal) feature with three possible discrete values, 1, 2, and 3, which correspond to the US, Europe, and Japan, respectively. Let’s first load the data and apply the necessary preprocessing steps, including dropping the incomplete rows, partitioning the dataset into training and test datasets, as well as standardizing the continuous features: >>> import pandas as pd >>> url = 'http://archive.ics.uci.edu/ml/' \\ ... 'machine-learning-databases/auto-mpg/auto-mpg.data' >>> column_names = [ 'MPG', 'Cylinders' , 'Displacement' , 'Horsepower' , ... 'Weight' , 'Acceleration' , 'Model Year' , 'Origin' ] >>> df = pd.read_csv(url, names=column_names, ... na_values = \"?\", comment= '\\t', ... sep= \" \", skipinitialspace= True) >>> >>> ## drop the NA rows >>> df = df.dropna() >>> df = df.reset_index(drop= True) >>> >>> ## train/test splits: >>> import sklearn >>> import sklearn.model_selection >>> df_train, df_test = sklearn.model_selection.train_test_split( ... df, train_size= 0.8, random_state= 1 ... ) >>> train_stats = df_train.describe().transpose() >>> >>> numeric_column_names = [ ... 'Cylinders' , 'Displacement' , ... 'Horsepower' , 'Weight' , ... 'Acceleration' ... ] Chapter 13 433 >>> df_train_norm, df_test_norm = df_train.copy(), df_test.copy() >>> for col_name in numeric_column_names: ... mean = train_stats.loc[col_name, 'mean'] ... std = train_stats.loc[col_name, 'std'] ... df_train_norm.loc[:, col_name] = \\ ... (df_train_norm.loc[:, col_name] - mean)/std ... df_test_norm.loc[:, col_name] = \\ ... (df_test_norm.loc[:, col_name] - mean)/std >>> df_train_norm.tail() This results in the following: Figure 13.8: Preprocessed Auto", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 390, "start_word": 124800, "end_word": 125200, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000391": {"text": "... ) >>> train_stats = df_train.describe().transpose() >>> >>> numeric_column_names = [ ... 'Cylinders' , 'Displacement' , ... 'Horsepower' , 'Weight' , ... 'Acceleration' ... ] Chapter 13 433 >>> df_train_norm, df_test_norm = df_train.copy(), df_test.copy() >>> for col_name in numeric_column_names: ... mean = train_stats.loc[col_name, 'mean'] ... std = train_stats.loc[col_name, 'std'] ... df_train_norm.loc[:, col_name] = \\ ... (df_train_norm.loc[:, col_name] - mean)/std ... df_test_norm.loc[:, col_name] = \\ ... (df_test_norm.loc[:, col_name] - mean)/std >>> df_train_norm.tail() This results in the following: Figure 13.8: Preprocessed Auto MG data The pandas DataFrame that we created via the previous code snippet contains five columns with values of the type float . These columns will constitute the continuous features. Next, let’s group the rather fine-grained model year ( ModelYear ) information into buckets to simplify the learning task for the model that we are going to train later. Concretely, we are going to assign each car into one of four year buckets, as follows: bucket = {0if year < 73 1if 73≤ year < 76 2if 76≤ year < 79 3if year ≥ 79 Note that the chosen intervals were selected arbitrarily to illustrate the concepts of “bucketing.” In order to group the cars into these buckets, we will first define three cut-off values: [73, 76, 79] for the model year feature. These cut-off values are used to specify half-closed intervals, for instance, (–∞, 73), [73, 76), [76, 79), and [76, ∞). Then, the original numeric features will be passed to the torch.bucketize function ( https://pytorch.org/docs/stable/generated/torch.bucketize.html ) to generate the indices of the buckets. The code is as follows: >>> boundaries = torch.tensor([ 73, 76, 79]) >>> v = torch.tensor(df_train_norm[ 'Model Year' ].values) >>> df_train_norm[ 'Model Year Bucketed' ] = torch.bucketize( Going Deeper – The Mechanics of PyTorch 434 ... v, boundaries, right= True ... ) >>> v = torch.tensor(df_test_norm[ 'Model Year' ].values) >>> df_test_norm[ 'Model Year Bucketed' ] = torch.bucketize( ... v, boundaries, right= True ... ) >>> numeric_column_names.append( 'Model Year Bucketed' ) We added this bucketized feature column to the Python list numeric_column_names . Next, we will proceed with defining a list for the unordered categorical feature, Origin . In PyTorch, There are two ways to work with a categorical feature: using an embedding layer via nn.Embedding (https://pytorch.org/docs/stable/generated/torch.nn.Embedding.html ), or using one-hot-en - coded vectors (also called indicator). In the encoding approach, for example, index 0 will be encoded as [1, 0, 0], index 1 will be", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 391, "start_word": 125120, "end_word": 125520, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000392": {"text": "numeric_column_names.append( 'Model Year Bucketed' ) We added this bucketized feature column to the Python list numeric_column_names . Next, we will proceed with defining a list for the unordered categorical feature, Origin . In PyTorch, There are two ways to work with a categorical feature: using an embedding layer via nn.Embedding (https://pytorch.org/docs/stable/generated/torch.nn.Embedding.html ), or using one-hot-en - coded vectors (also called indicator). In the encoding approach, for example, index 0 will be encoded as [1, 0, 0], index 1 will be encoded as [0, 1, 0], and so on. On the other hand, the embedding layer maps each index to a vector of random numbers of the type float , which can be trained. (You can think of the embedding layer as a more efficient implementation of a one-hot encoding multiplied with a trainable weight matrix.) When the number of categories is large, using the embedding layer with fewer dimensions than the number of categories can improve the performance. In the following code snippet, we will use the one-hot-encoding approach on the categorical feature in order to convert it into the dense format: >>> from torch.nn.functional import one_hot >>> total_origin = len(set(df_train_norm[ 'Origin' ])) >>> origin_encoded = one_hot(torch.from_numpy( ... df_train_norm[ 'Origin' ].values) % total_origin) >>> x_train_numeric = torch.tensor( ... df_train_norm[numeric_column_names].values) >>> x_train = torch.cat([x_train_numeric, origin_encoded], 1).float () >>> origin_encoded = one_hot(torch.from_numpy( ... df_test_norm[ 'Origin' ].values) % total_origin) >>> x_test_numeric = torch.tensor( ... df_test_norm[numeric_column_names].values) >>> x_test = torch.cat([x_test_numeric, origin_encoded], 1).float () After encoding the categorical feature into a three-dimensional dense feature, we concatenated it with the numeric features we processed in the previous step. Finally, we will create the label tensors from the ground truth MPG values as follows: >>> y_train = torch.tensor(df_train_norm[ 'MPG'].values). float() >>> y_test = torch.tensor(df_test_norm[ 'MPG'].values). float() Chapter 13 435 In this section, we have covered the most common approaches for preprocessing and creating fea - tures in PyTorch. Training a DNN regression model Now, after constructing the mandatory features and labels, we will create a data loader that uses a batch size of 8 for the train data: >>> train_ds = TensorDataset(x_train, y_train) >>> batch_size = 8 >>> torch.manual_seed( 1) >>> train_dl = DataLoader(train_ds, batch_size, shuffle= True) Next, we will build a model with two fully connected layers where one has 8 hidden units and another has 4: >>> hidden_units = [ 8, 4] >>> input_size = x_train.shape[ 1] >>> all_layers = [] >>> for hidden_unit in", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 392, "start_word": 125440, "end_word": 125840, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000393": {"text": "mandatory features and labels, we will create a data loader that uses a batch size of 8 for the train data: >>> train_ds = TensorDataset(x_train, y_train) >>> batch_size = 8 >>> torch.manual_seed( 1) >>> train_dl = DataLoader(train_ds, batch_size, shuffle= True) Next, we will build a model with two fully connected layers where one has 8 hidden units and another has 4: >>> hidden_units = [ 8, 4] >>> input_size = x_train.shape[ 1] >>> all_layers = [] >>> for hidden_unit in hidden_units: ... layer = nn.Linear(input_size, hidden_unit) ... all_layers.append(layer) ... all_layers.append(nn.ReLU()) ... input_size = hidden_unit >>> all_layers.append(nn.Linear(hidden_units[- 1], 1)) >>> model = nn.Sequential(*all_layers) >>> model Sequential( (0): Linear(in_features=9, out_features=8, bias=True) (1): ReLU() (2): Linear(in_features=8, out_features=4, bias=True) (3): ReLU() (4): Linear(in_features=4, out_features=1, bias=True) ) After defining the model, we will define the MSE loss function for regression and use stochastic gra - dient descent for optimization: >>> loss_fn = nn.MSELoss() >>> optimizer = torch.optim.SGD(model.parameters(), lr= 0.001) Now we will train the model for 200 epochs and display the train loss for every 20 epochs: >>> torch.manual_seed( 1) >>> num_epochs = 200 >>> log_epochs = 20 Going Deeper – The Mechanics of PyTorch 436 >>> for epoch in range (num_epochs): ... loss_hist_train = 0 ... for x_batch, y_batch in train_dl: ... pred = model(x_batch)[:, 0] ... loss = loss_fn(pred, y_batch) ... loss.backward() ... optimizer.step() ... optimizer.zero_grad() ... loss_hist_train += loss.item() ... if epoch % log_epochs== 0: ... print(f'Epoch {epoch} Loss ' ... f'{loss_hist_train/ len(train_dl): .4f}') Epoch 0 Loss 536.1047 Epoch 20 Loss 8.4361 Epoch 40 Loss 7.8695 Epoch 60 Loss 7.1891 Epoch 80 Loss 6.7062 Epoch 100 Loss 6.7599 Epoch 120 Loss 6.3124 Epoch 140 Loss 6.6864 Epoch 160 Loss 6.7648 Epoch 180 Loss 6.2156 After 200 epochs, the train loss was around 5. We can now evaluate the regression performance of the trained model on the test dataset. To predict the target values on new data points, we can feed their features to the model: >>> with torch.no_grad(): ... pred = model(x_test. float())[:, 0] ... loss = loss_fn(pred, y_test) ... print(f'Test MSE: {loss.item(): .4f}') ... print(f'Test MAE: {nn.L1Loss()(pred, y_test).item(): .4f}') Test MSE: 9.6130 Test MAE: 2.1211 The MSE on the test set is 9.6, and the mean absolute error (MAE ) is 2.1. After this regression project, we will work on a classification project in the next section. Project two – classifying MNIST handwritten digits For this classification project, we are going", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 393, "start_word": 125760, "end_word": 126160, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000394": {"text": "to the model: >>> with torch.no_grad(): ... pred = model(x_test. float())[:, 0] ... loss = loss_fn(pred, y_test) ... print(f'Test MSE: {loss.item(): .4f}') ... print(f'Test MAE: {nn.L1Loss()(pred, y_test).item(): .4f}') Test MSE: 9.6130 Test MAE: 2.1211 The MSE on the test set is 9.6, and the mean absolute error (MAE ) is 2.1. After this regression project, we will work on a classification project in the next section. Project two – classifying MNIST handwritten digits For this classification project, we are going to categorize MNIST handwritten digits. In the previous section, we covered the four essential steps for machine learning in PyTorch in detail, which we will need to repeat in this section. Chapter 13 437 You will recall that in Chapter 12 you learned the way of loading available datasets from the torchvision module. First, we are going to load the MNIST dataset using the torchvision module. 1. The setup step includes loading the dataset and specifying hyperparameters (the size of the train set and test set, and the size of mini-batches): >>> import torchvision >>> from torchvision import transforms >>> image_path = './' >>> transform = transforms.Compose([ ... transforms.ToTensor() ... ]) >>> mnist_train_dataset = torchvision.datasets.MNIST( ... root=image_path, train= True, ... transform=transform, download= False ... ) >>> mnist_test_dataset = torchvision.datasets.MNIST( ... root=image_path, train= False, ... transform=transform, download= False ... ) >>> batch_size = 64 >>> torch.manual_seed( 1) >>> train_dl = DataLoader(mnist_train_dataset, ... batch_size, shuffle= True) Here, we constructed a data loader with batches of 64 samples. Next, we will preprocess the loaded datasets. 2. We preprocess the input features and the labels. The features in this project are the pixels of the images we read from Step 1 . We defined a custom transformation using torchvision. transforms.Compose . In this simple case, our transformation consisted only of one method, ToTensor() . The ToTensor() method converts the pixel features into a floating type tensor and also normalizes the pixels from the [0, 255] to [0, 1] range. In Chapter 14, Classifying Imag- es with Deep Convolutional Neural Networks, we will see some additional data transformation methods when we work with more complex image datasets. The labels are integers from 0 to 9 representing ten digits. Hence, we don’t need to do any scaling or further conversion. Note that we can access the raw pixels using the data attribute, and don’t forget to scale them to the range [0, 1]. We will construct", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 394, "start_word": 126080, "end_word": 126480, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000395": {"text": "255] to [0, 1] range. In Chapter 14, Classifying Imag- es with Deep Convolutional Neural Networks, we will see some additional data transformation methods when we work with more complex image datasets. The labels are integers from 0 to 9 representing ten digits. Hence, we don’t need to do any scaling or further conversion. Note that we can access the raw pixels using the data attribute, and don’t forget to scale them to the range [0, 1]. We will construct the model in the next step once the data is preprocessed. Going Deeper – The Mechanics of PyTorch 438 3. Construct the NN model: >>> hidden_units = [ 32, 16] >>> image_size = mnist_train_dataset[ 0][0].shape >>> input_size = image_size[ 0] * image_size[ 1] * image_size[ 2] >>> all_layers = [nn.Flatten()] >>> for hidden_unit in hidden_units: ... layer = nn.Linear(input_size, hidden_unit) ... all_layers.append(layer) ... all_layers.append(nn.ReLU()) ... input_size = hidden_unit >>> all_layers.append(nn.Linear(hidden_units[- 1], 10)) >>> model = nn.Sequential(*all_layers) >>> model Sequential( (0): Flatten(start_dim=1, end_dim=-1) (1): Linear(in_features=784, out_features=32, bias=True) (2): ReLU() (3): Linear(in_features=32, out_features=16, bias=True) (4): ReLU() (5): Linear(in_features=16, out_features=10, bias=True) ) 4. Use the model for training, evaluation, and prediction: >>> loss_fn = nn.CrossEntropyLoss() >>> optimizer = torch.optim.Adam(model.parameters(), lr= 0.001) >>> torch.manual_seed( 1) >>> num_epochs = 20 >>> for epoch in range (num_epochs): ... accuracy_hist_train = 0 ... for x_batch, y_batch in train_dl:Note that the model starts with a flatten layer that flattens an input image into a one-dimensional tensor. This is because the input images are in the shape of [1, 28, 28]. The model has two hidden layers, with 32 and 16 units respectively. And it ends with an output layer of ten units representing ten classes, activated by a softmax function. In the next step, we will train the model on the train set and evaluate it on the test set. Chapter 13 439 ... pred = model(x_batch) ... loss = loss_fn(pred, y_batch) ... loss.backward() ... optimizer.step() ... optimizer.zero_grad() ... is_correct = ( ... torch.argmax(pred, dim= 1) == y_batch ... ). float() ... accuracy_hist_train += is_correct. sum() ... accuracy_hist_train /= len(train_dl.dataset) ... print(f'Epoch {epoch} Accuracy ' ... f'{accuracy_hist_train: .4f}') Epoch 0 Accuracy 0.8531 ... Epoch 9 Accuracy 0.9691 ... Epoch 19 Accuracy 0.9813 We used the cross-entropy loss function for multiclass classification and the Adam optimizer for gradient descent. We will talk about the Adam optimizer in Chapter 14. We trained the model for 20 epochs and displayed the", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 395, "start_word": 126400, "end_word": 126800, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000396": {"text": "... is_correct = ( ... torch.argmax(pred, dim= 1) == y_batch ... ). float() ... accuracy_hist_train += is_correct. sum() ... accuracy_hist_train /= len(train_dl.dataset) ... print(f'Epoch {epoch} Accuracy ' ... f'{accuracy_hist_train: .4f}') Epoch 0 Accuracy 0.8531 ... Epoch 9 Accuracy 0.9691 ... Epoch 19 Accuracy 0.9813 We used the cross-entropy loss function for multiclass classification and the Adam optimizer for gradient descent. We will talk about the Adam optimizer in Chapter 14. We trained the model for 20 epochs and displayed the train accuracy for every epoch. The trained model reached an accuracy of 96.3 percent on the training set and we will evaluate it on the testing set: >>> pred = model(mnist_test_dataset.data / 255.) >>> is_correct = ( ... torch.argmax(pred, dim= 1) == ... mnist_test_dataset.targets ... ).float() >>> print(f'Test accuracy: {is_correct.mean(): .4f}') Test accuracy: 0.9645 The test accuracy is 95.6 percent. You have learned how to solve a classification problem using PyTorch. Higher-level PyTorch APIs: a short introduction to PyTorch-Lightning In recent years, the PyTorch community developed several different libraries and APIs on top of Py - Torch. Notable examples include fastai ( https://docs.fast.ai/ ), Catalyst ( https://github.com/ catalyst-team/catalyst ), PyTorch Lightning ( https://www.pytorchlightning.ai ), (https:// lightning-flash.readthedocs.io/en/latest/quickstart.html ), and PyTorch-Ignite ( https:// github.com/pytorch/ignite ). Going Deeper – The Mechanics of PyTorch 440 In this section, we will explore PyTorch Lightning (Lightning for short), which is a widely used Py - Torch library that makes training deep neural networks simpler by removing much of the boilerplate code. However, while Lightning’s focus lies in simplicity and flexibility, it also allows us to use many advanced features such as multi-GPU support and fast low-precision training, which you can learn about in the official documentation at https://pytorch-lightning.rtfd.io/en/latest/ . In an earlier section, Project two – classifying MNIST handwritten digits, we implemented a multilayer perceptron for classifying handwritten digits in the MNIST dataset. In the next subsections, we will reimplement this classifier using Lightning. Setting up the PyTorch Lightning model We start by implementing the model, which we will train in the next subsections. Defining a model for Lightning is relatively straightforward as it is based on regular Python and PyTorch code. All that is required to implement a Lightning model is to use LightningModule instead of the regular PyTorch module. To take advantage of PyTorch’s convenience functions, such as the trainer API and automatic logging, we just define a few specifically named methods, which we", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 396, "start_word": 126720, "end_word": 127120, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000397": {"text": "the PyTorch Lightning model We start by implementing the model, which we will train in the next subsections. Defining a model for Lightning is relatively straightforward as it is based on regular Python and PyTorch code. All that is required to implement a Lightning model is to use LightningModule instead of the regular PyTorch module. To take advantage of PyTorch’s convenience functions, such as the trainer API and automatic logging, we just define a few specifically named methods, which we will see in the following code: import pytorch_lightning as pl import torch import torch.nn as nn from torchmetrics import Accuracy class MultiLayerPerceptron (pl.LightningModule): def __init__ (self, image_shape=( 1, 28, 28), hidden_units=( 32, 16)): super().__init__()There is also a bonus introduction to PyTorch-Ignite at https://github.com/rasbt/ machine-learning-book/blob/main/ch13/ch13_part4_ignite.ipynb . Installing PyTorch Lightning Lightning can be installed via pip or conda, depending on your preference. For instance, the command for installing Lightning via pip is as follows: pip install pytorch-lightning The following is the command for installing Lightning via conda: conda install pytorch-lightning -c conda-forge The code in the following subsections is based on PyTorch Lightning version 1.5, which you can install by replacing pytorch-lightning with pytorch-lightning==1.5 in these commands. Chapter 13 441 # new PL attributes: self.train_acc = Accuracy() self.valid_acc = Accuracy() self.test_acc = Accuracy() # Model similar to previous section: input_size = image_shape[ 0] * image_shape[ 1] * image_shape[ 2] all_layers = [nn.Flatten()] for hidden_unit in hidden_units: layer = nn.Linear(input_size, hidden_unit) all_layers.append(layer) all_layers.append(nn.ReLU()) input_size = hidden_unit all_layers.append(nn.Linear(hidden_units[- 1], 10)) self.model = nn.Sequential(*all_layers) def forward (self, x): x = self.model(x) return x def training_step (self, batch, batch_idx): x, y = batch logits = self(x) loss = nn.functional.cross_entropy(self(x), y) preds = torch.argmax(logits, dim= 1) self.train_acc.update(preds, y) self.log( \"train_loss\" , loss, prog_bar= True) return loss def training_epoch_end (self, outs): self.log( \"train_acc\" , self.train_acc.compute()) def validation_step (self, batch, batch_idx): x, y = batch logits = self(x) loss = nn.functional.cross_entropy(self(x), y) preds = torch.argmax(logits, dim= 1) self.valid_acc.update(preds, y) self.log( \"valid_loss\" , loss, prog_bar= True) self.log( \"valid_acc\" , self.valid_acc.compute(), prog_bar= True) Going Deeper – The Mechanics of PyTorch 442 return loss def test_step (self, batch, batch_idx): x, y = batch logits = self(x) loss = nn.functional.cross_entropy(self(x), y) preds = torch.argmax(logits, dim= 1) self.test_acc.update(preds, y) self.log( \"test_loss\" , loss, prog_bar= True) self.log( \"test_acc\" , self.test_acc.compute(), prog_bar= True) return loss def configure_optimizers (self): optimizer = torch.optim.Adam(self.parameters(), lr= 0.001) return optimizer Let’s now discuss the different methods one by one. As you", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 397, "start_word": 127040, "end_word": 127440, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000398": {"text": "self.log( \"valid_loss\" , loss, prog_bar= True) self.log( \"valid_acc\" , self.valid_acc.compute(), prog_bar= True) Going Deeper – The Mechanics of PyTorch 442 return loss def test_step (self, batch, batch_idx): x, y = batch logits = self(x) loss = nn.functional.cross_entropy(self(x), y) preds = torch.argmax(logits, dim= 1) self.test_acc.update(preds, y) self.log( \"test_loss\" , loss, prog_bar= True) self.log( \"test_acc\" , self.test_acc.compute(), prog_bar= True) return loss def configure_optimizers (self): optimizer = torch.optim.Adam(self.parameters(), lr= 0.001) return optimizer Let’s now discuss the different methods one by one. As you can see, the __init__ constructor contains the same model code that we used in a previous subsection. What’s new is that we added the accuracy attributes such as self.train_acc = Accuracy() . These will allow us to track the accuracy during training. Accuracy was imported from the torchmetrics module, which should be automatically installed with Lightning. If you cannot import torchmetrics , you can try to install it via pip install torchmetrics . More information can be found at https://torchmetrics.readthedocs.io/en/latest/ pages/quickstart.html . The forward method implements a simple forward pass that returns the logits (outputs of the last fully connected layer of our network before the softmax layer) when we call our model on the input data. The logits, computed via the forward method by calling self(x) , are used for the training, validation, and test steps, which we’ll describe next. The training_step , training_epoch_end , validation_step , test_step , and configure_optimizers methods are methods that are specifically recognized by Lightning. For instance, training_step de- fines a single forward pass during training, where we also keep track of the accuracy and loss so that we can analyze these later. Note that we compute the accuracy via self.train_acc.update(preds, y) but don’t log it yet. The training_step method is executed on each individual batch during training, and via the training_epoch_end method, which is executed at the end of each training epoch, we compute the training set accuracy from the accuracy values we accumulated via training. The validation_step and test_step methods define, analogous to the training_step method, how the validation and test evaluation process should be computed. Similar to training_step , each validation_step and test_step receives a single batch, which is why we log the accuracy via respective accuracy attributes derived from Accuracy of torchmetric . However, note that validation_step is only called in certain intervals, for example, after each training epoch. This is why we log the validation accuracy inside the validation", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 398, "start_word": 127360, "end_word": 127760, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000399": {"text": "accumulated via training. The validation_step and test_step methods define, analogous to the training_step method, how the validation and test evaluation process should be computed. Similar to training_step , each validation_step and test_step receives a single batch, which is why we log the accuracy via respective accuracy attributes derived from Accuracy of torchmetric . However, note that validation_step is only called in certain intervals, for example, after each training epoch. This is why we log the validation accuracy inside the validation step, whereas with the training accuracy, we log it after each training epoch, otherwise, the accuracy plot that we inspect later will look too noisy. Chapter 13 443 Finally, via the configure_optimizers method, we specify the optimizer used for training. The fol- lowing two subsections will discuss how we can set up the dataset and how we can train the model. Setting up the data loaders for Lightning There are three main ways in which we can prepare the dataset for Lightning. We can: • Make the dataset part of the model • Set up the data loaders as usual and feed them to the fit method of a Lightning Trainer—the Trainer is introduced in the next subsection • Create a LightningDataModule Here, we are going to use a LightningDataModule , which is the most organized approach. The LightningDataModule consists of five main methods, as we can see in the following: from torch.utils.data import DataLoader from torch.utils.data import random_split from torchvision.datasets import MNIST from torchvision import transforms class MnistDataModule (pl.LightningDataModule): def __init__ (self, data_path= './'): super().__init__() self.data_path = data_path self.transform = transforms.Compose([transforms.ToTensor()]) def prepare_data (self): MNIST(root=self.data_path, download= True) def setup(self, stage= None): # stage is either 'fit', 'validate', 'test', or 'predict' # here note relevant mnist_all = MNIST( root=self.data_path, train= True, transform=self.transform, download= False ) self.train, self.val = random_split( mnist_all, [ 55000, 5000], generator=torch.Generator().manual_ seed(1) ) Going Deeper – The Mechanics of PyTorch 444 self.test = MNIST( root=self.data_path, train= False, transform=self.transform, download= False ) def train_dataloader (self): return DataLoader(self.train, batch_size= 64, num_workers= 4) def val_dataloader (self): return DataLoader(self.val, batch_size= 64, num_workers= 4) def test_dataloader (self): return DataLoader(self.test, batch_size= 64, num_workers= 4) In the prepare_data method, we define general steps, such as downloading the dataset. In the setup method, we define the datasets used for training, validation, and testing. Note that MNIST does not have a dedicated validation split, which is why we use the random_split function to divide the 60,000-ex", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 399, "start_word": 127680, "end_word": 128080, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000400": {"text": "transform=self.transform, download= False ) def train_dataloader (self): return DataLoader(self.train, batch_size= 64, num_workers= 4) def val_dataloader (self): return DataLoader(self.val, batch_size= 64, num_workers= 4) def test_dataloader (self): return DataLoader(self.test, batch_size= 64, num_workers= 4) In the prepare_data method, we define general steps, such as downloading the dataset. In the setup method, we define the datasets used for training, validation, and testing. Note that MNIST does not have a dedicated validation split, which is why we use the random_split function to divide the 60,000-ex - ample training set into 55,000 examples for training and 5,000 examples for validation. The data loader methods are self-explanatory and define how the respective datasets are loaded. Now, we can initialize the data module and use it for training, validation, and testing in the next subsections: torch.manual_seed( 1) mnist_dm = MnistDataModule() Training the model using the PyTorch Lightning Trainer class Now we can reap the rewards from setting up the model with the specifically named methods, as well as the Lightning data module. Lightning implements a Trainer class that makes the training model super convenient by taking care of all the intermediate steps, such as calling zero_grad() , backward() , and optimizer.step() for us. Also, as a bonus, it lets us easily specify one or more GPUs to use (if available): mnistclassifier = MultiLayerPerceptron() if torch.cuda.is_available(): # if you have GPUs trainer = pl.Trainer(max_epochs= 10, gpus= 1) else: trainer = pl.Trainer(max_epochs= 10) trainer.fit(model=mnistclassifier, datamodule=mnist_dm) Chapter 13 445 Via the preceding code, we train our multilayer perceptron for 10 epochs. During training, we see a handy progress bar that keeps track of the epoch and core metrics such as the training and validation losses: Epoch 9: 100% 939/939 [00:07<00:00, 130.42it/s, loss=0.1, v_num=0, train_ loss=0.260, valid_loss=0.166, valid_acc=0.949] After the training has finished, we can also inspect the metrics we logged in more detail, as we will see in the next subsection. Evaluating the model using TensorBoard In the previous section, we experienced the convenience of the Trainer class. Another nice feature of Lightning is its logging capabilities. Recall that we specified several self.log steps in our Light- ning model earlier. After, and even during training, we can visualize them in TensorBoard. (Note that Lightning supports other loggers as well; for more information, please see the official documentation at https://pytorch-lightning.readthedocs.io/en/latest/common/loggers.html .) By default, Lightning tracks the training in a subfolder named lightning_logs . To visualize the training runs, you can execute the", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 400, "start_word": 128000, "end_word": 128400, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000401": {"text": "experienced the convenience of the Trainer class. Another nice feature of Lightning is its logging capabilities. Recall that we specified several self.log steps in our Light- ning model earlier. After, and even during training, we can visualize them in TensorBoard. (Note that Lightning supports other loggers as well; for more information, please see the official documentation at https://pytorch-lightning.readthedocs.io/en/latest/common/loggers.html .) By default, Lightning tracks the training in a subfolder named lightning_logs . To visualize the training runs, you can execute the following code in the command-line terminal, which will open TensorBoard in your browser: tensorboard --logdir lightning_logs/ Alternatively, if you are running the code in a Jupyter notebook, you can add the following code to a Jupyter notebook cell to show the TensorBoard dashboard in the notebook directly: %load_ext tensorboard %tensorboard --logdir lightning_logs/Installing TensorBoard TensorBoard can be installed via pip or conda, depending on your preference. For instance, the command for installing TensorBoard via pip is as follows: pip install tensorboard The following is the command for installing Lightning via conda: conda install tensorboard -c conda-forge The code in the following subsection is based on TensorBoard version 2.4, which you can install by replacing tensorboard with tensorboard==2.4 in these commands. Going Deeper – The Mechanics of PyTorch 446 Figure 13.9 shows the TensorBoard dashboard with the logged training and validation accuracy. Note that there is a version_0 toggle shown in the lower-left corner. If you run the training code multiple times, Lightning will track them as separate subfolders: version_0 , version_1 , version_2 , and so forth: Figure 13.9: TensorBoard dashboard Chapter 13 447 By looking at the training and validation accuracies in Figure 13.9, we can hypothesize that training the model for a few additional epochs can improve performance. Lightning allows us to load a trained model and train it for additional epochs conveniently. As men- tioned previously, Lightning tracks the individual training runs via subfolders. In Figure 13.10, we see the contents of the version_0 subfolder, which contains log files and a model checkpoint for reloading the model: Figure 13.10: PyTorch Lightning log files For instance, we can use the following code to load the latest model checkpoint from this folder and train the model via fit: if torch.cuda.is_available(): # if you have GPUs trainer = pl.Trainer(max_epochs= 15, resume_from_checkpoint= './lightning_ logs/version_0/checkpoints/epoch=8-step=7739.ckpt' , gpus=1) else: trainer = pl.Trainer(max_epochs= 15, resume_from_checkpoint= './lightning_ logs/version_0/checkpoints/epoch=8-step=7739.ckpt' ) trainer.fit(model=mnistclassifier, datamodule=mnist_dm) Going Deeper – The Mechanics", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 401, "start_word": 128320, "end_word": 128720, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000402": {"text": "see the contents of the version_0 subfolder, which contains log files and a model checkpoint for reloading the model: Figure 13.10: PyTorch Lightning log files For instance, we can use the following code to load the latest model checkpoint from this folder and train the model via fit: if torch.cuda.is_available(): # if you have GPUs trainer = pl.Trainer(max_epochs= 15, resume_from_checkpoint= './lightning_ logs/version_0/checkpoints/epoch=8-step=7739.ckpt' , gpus=1) else: trainer = pl.Trainer(max_epochs= 15, resume_from_checkpoint= './lightning_ logs/version_0/checkpoints/epoch=8-step=7739.ckpt' ) trainer.fit(model=mnistclassifier, datamodule=mnist_dm) Going Deeper – The Mechanics of PyTorch 448 Here, we set max_epochs to 15, which trained the model for 5 additional epochs (previously, we trained it for 10 epochs). Now, let’s take a look at the TensorBoard dashboard in Figure 13.11 and see whether training the model for a few additional epochs was worthwhile: Figure 13.11: TensorBoard dashboard after training for five more epochs Chapter 13 449 As we can see in Figure 13.11, TensorBoard allows us to show the results from the additional training epochs (version_1 ) next to the previous ones ( version_0 ), which is very convenient. Indeed, we can see that training for five more epochs improved the validation accuracy. At this point, we may decide to train the model for more epochs, which we leave as an exercise to you. Once we are finished with training, we can evaluate the model on the test set using the following code: trainer.test(model=mnistclassifier, datamodule=mnist_dm) The resulting test set performance, after training for 15 epochs in total, is approximately 95 percent: [{'test_loss': 0.14912301301956177, 'test_acc': 0.9499600529670715}] Note that PyTorch Lightning also saves the model automatically for us. If you want to reuse the model later, you can conveniently load it via the following code: model = MultiLayerPerceptron.load_from_checkpoint( \"path/to/checkpoint.ckpt\" ) Summary In this chapter, we covered PyTorch’s most essential and useful features. We started by discussing PyTorch’s dynamic computation graph, which makes implementing computations very convenient. We also covered the semantics of defining PyTorch tensor objects as model parameters. After we considered the concept of computing partial derivatives and gradients of arbitrary functions, we covered the torch.nn module in more detail. It provides us with a user-friendly interface for building more complex deep NN models. Finally, we concluded this chapter by solving a regression and classification problem using what we have discussed so far. Now that we have covered the core mechanics of PyTorch, the next chapter will introduce the concept behind convolutional neural network (", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 402, "start_word": 128640, "end_word": 129040, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000403": {"text": "as model parameters. After we considered the concept of computing partial derivatives and gradients of arbitrary functions, we covered the torch.nn module in more detail. It provides us with a user-friendly interface for building more complex deep NN models. Finally, we concluded this chapter by solving a regression and classification problem using what we have discussed so far. Now that we have covered the core mechanics of PyTorch, the next chapter will introduce the concept behind convolutional neural network ( CNN) architectures for deep learning. CNNs are powerful models and have shown great performance in the field of computer vision.Learn more about PyTorch Lightning To learn more about Lightning, please visit the official website, which contains tutorials and examples, at https://pytorch-lightning.readthedocs.io . Lightning also has an active community on Slack that welcomes new users and con - tributors. To find out more, please visit the official Lightning website at https://www. pytorchlightning.ai . Going Deeper – The Mechanics of PyTorch 450 Join our book’s Discord space Join the book’s Discord workspace for a monthly Ask me Anything session with the authors: https://packt.link/MLwPyTorch 14 Classifying Images with Deep Convolutional Neural Networks In the previous chapter, we looked in depth at different aspects of the PyTorch neural network and automatic differentiation modules, you became familiar with tensors and decorating functions, and you learned how to work with torch.nn . In this chapter, you will now learn about convolutional neural networks ( CNNs) for image classification. We will start by discussing the basic building blocks of CNNs, using a bottom-up approach. Then, we will take a deeper dive into the CNN architecture and explore how to implement CNNs in PyTorch. In this chapter, we will cover the following topics: • Convolution operations in one and two dimensions • The building blocks of CNN architectures • Implementing deep CNNs in PyTorch • Data augmentation techniques for improving the generalization performance • Implementing a facial CNN classifier for recognizing if someone is smiling or not The building blocks of CNNs CNNs are a family of models that were originally inspired by how the visual cortex of the human brain works when recognizing objects. The development of CNNs goes back to the 1990s, when Yann LeCun and his colleagues proposed a novel NN architecture for classifying handwritten digits from images (Handwritten Digit Recognition with a Back-Propagation Network by Y. LeCun, and colleagues, 1989, published at the Neural", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 403, "start_word": 128960, "end_word": 129360, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000404": {"text": "classifier for recognizing if someone is smiling or not The building blocks of CNNs CNNs are a family of models that were originally inspired by how the visual cortex of the human brain works when recognizing objects. The development of CNNs goes back to the 1990s, when Yann LeCun and his colleagues proposed a novel NN architecture for classifying handwritten digits from images (Handwritten Digit Recognition with a Back-Propagation Network by Y. LeCun, and colleagues, 1989, published at the Neural Information Processing Systems (NeurIPS) conference). Classifying Images with Deep Convolutional Neural Networks 452 Due to the outstanding performance of CNNs for image classification tasks, this particular type of feedforward NN gained a lot of attention and led to tremendous improvements in machine learning for computer vision. Several years later, in 2019, Yann LeCun received the Turing award (the most prestigious award in computer science) for his contributions to the field of artificial intelligence (AI ), along with two other researchers, Yoshua Bengio and Geoffrey Hinton, whose names you encountered in previous chapters. In the following sections, we will discuss the broader concepts of CNNs and why convolutional ar - chitectures are often described as “feature extraction layers.” Then, we will delve into the theoretical definition of the type of convolution operation that is commonly used in CNNs and walk through examples of computing convolutions in one and two dimensions. Understanding CNNs and feature hierarchies Successfully extracting salient (relevant ) features is key to the performance of any machine learning algorithm, and traditional machine learning models rely on input features that may come from a domain expert or are based on computational feature extraction techniques. Certain types of NNs, such as CNNs, can automatically learn the features from raw data that are most useful for a particular task. For this reason, it’s common to consider CNN layers as feature extractors: the early layers (those right after the input layer) extract low-level features from raw data, and the later layers (often fully connected layers, as in a multilayer perceptron (MLP )) use these features to predict a continuous target value or class label. Certain types of multilayer NNs, and in particular, deep CNNs, construct a so-called feature hierarchy by combining the low-level features in a layer-wise fashion to form high-level features. For example, if we’re dealing with images, then low-level features, such as edges and blobs, are extracted from the earlier layers,", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 404, "start_word": 129280, "end_word": 129680, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000405": {"text": "features from raw data, and the later layers (often fully connected layers, as in a multilayer perceptron (MLP )) use these features to predict a continuous target value or class label. Certain types of multilayer NNs, and in particular, deep CNNs, construct a so-called feature hierarchy by combining the low-level features in a layer-wise fashion to form high-level features. For example, if we’re dealing with images, then low-level features, such as edges and blobs, are extracted from the earlier layers, which are combined to form high-level features. These high-level features can form more complex shapes, such as the general contours of objects like buildings, cats, or dogs.The human visual cortex The original discovery of how the visual cortex of our brain functions was made by David H. Hubel and Torsten Wiesel in 1959, when they inserted a microelectrode into the primary visual cortex of an anesthetized cat. They observed that neurons respond differently after projecting different patterns of light in front of the cat. This eventually led to the discovery of the different layers of the visual cortex. While the primary layer mainly detects edges and straight lines, higher-order layers focus more on extracting complex shapes and patterns. Chapter 14 453 As you can see in Figure 14.1, a CNN computes feature maps from an input image, where each element comes from a local patch of pixels in the input image: Figure 14.1: Creating feature maps from an image (photo by Alexander Dummer on Unsplash) This local patch of pixels is referred to as the local receptive field. CNNs will usually perform very well on image-related tasks, and that’s largely due to two important ideas: • Sparse connectivity: A single element in the feature map is connected to only a small patch of pixels. (This is very different from connecting to the whole input image, as in the case of MLPs. You may find it useful to look back and compare how we implemented a fully connected network that connected to the whole image in Chapter 11, Implementing a Multilayer Artificial Neural Network from Scratch.) • Parameter sharing: The same weights are used for different patches of the input image. As a direct consequence of these two ideas, replacing a conventional, fully connected MLP with a convolution layer substantially decreases the number of weights (parameters) in the network, and we will see an improvement in the ability to capture salient", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 405, "start_word": 129600, "end_word": 130000, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000406": {"text": "compare how we implemented a fully connected network that connected to the whole image in Chapter 11, Implementing a Multilayer Artificial Neural Network from Scratch.) • Parameter sharing: The same weights are used for different patches of the input image. As a direct consequence of these two ideas, replacing a conventional, fully connected MLP with a convolution layer substantially decreases the number of weights (parameters) in the network, and we will see an improvement in the ability to capture salient features. In the context of image data, it makes sense to assume that nearby pixels are typically more relevant to each other than pixels that are far away from each other. Typically, CNNs are composed of several convolutional and subsampling layers that are followed by one or more fully connected layers at the end. The fully connected layers are essentially an MLP, where every input unit, i, is connected to every output unit, j, with weight w ij (which we covered in more detail in Chapter 11). Please note that subsampling layers, commonly known as pooling layers, do not have any learnable parameters; for instance, there are no weights or bias units in pooling layers. However, both the convolutional and fully connected layers have weights and biases that are optimized during training. Classifying Images with Deep Convolutional Neural Networks 454 In the following sections, we will study convolutional and pooling layers in more detail and see how they work. To understand how convolution operations work, let’s start with a convolution in one dimension, which is sometimes used for working with certain types of sequence data, such as text. After discussing one-dimensional convolutions, we will work through the typical two-dimensional ones that are commonly applied to two-dimensional images. Performing discrete convolutions A discrete convolution (or simply convolution) is a fundamental operation in a CNN. Therefore, it’s important to understand how this operation works. In this section, we will cover the mathematical definition and discuss some of the naive algorithms to compute convolutions of one-dimensional tensors (vectors) and two-dimensional tensors (matrices). Please note that the formulas and descriptions in this section are solely for understanding how con- volution operations in CNNs work. Indeed, much more efficient implementations of convolutional operations already exist in packages such as PyTorch, as you will see later in this chapter. Discrete convolutions in one dimension Let’s start with some basic definitions and notations that we are going", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 406, "start_word": 129920, "end_word": 130320, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000407": {"text": "definition and discuss some of the naive algorithms to compute convolutions of one-dimensional tensors (vectors) and two-dimensional tensors (matrices). Please note that the formulas and descriptions in this section are solely for understanding how con- volution operations in CNNs work. Indeed, much more efficient implementations of convolutional operations already exist in packages such as PyTorch, as you will see later in this chapter. Discrete convolutions in one dimension Let’s start with some basic definitions and notations that we are going to use. A discrete convolution for two vectors, x and w, is denoted by 𝒚𝒚𝒚𝒚𝒚𝒚𝒚𝒚 , in which vector x is our input (sometimes called signal) and w is called the filter or kernel . A discrete convolution is mathematically defined as follows: 𝒚𝒚𝒚𝒚𝒚𝒚𝒚𝒚𝒚𝒚𝒚 [𝑖𝑖]𝒚∑𝑥𝑥 [𝑖𝑖𝑖𝑖𝑖 ] 𝑤𝑤[𝑖𝑖]+∞ 𝑘𝑘𝑘𝑘 ∞ As mentioned earlier, the brackets, [ ], are used to denote the indexing for vector elements. The index, i, runs through each element of the output vector, y . There are two odd things in the preceding formula that we need to clarify: –∞ to +∞ indices and negative indexing for x.Mathematical notation In this chapter, we will use subscript to denote the size of a multidimensional array (ten- sor); for example, 𝐴𝐴𝑛𝑛1×𝑛𝑛2 is a two-dimensional array of size n 1×n 2. We use brackets, [ ], to denote the indexing of a multidimensional array. For example, A [i, j] refers to the element at index i, j of matrix A. Furthermore, note that we use a special symbol, ∗ , to denote the convolution operation between two vectors or matrices, which is not to be confused with the multiplication operator, *, in Python. Chapter 14 455 The fact that the sum runs through indices from –∞ to +∞ seems odd, mainly because in machine learning applications, we always deal with finite feature vectors. For example, if x has 10 features with indices 0, 1, 2, ..., 8, 9, then indices –∞: –1 and 10: +∞ are out of bounds for x. Therefore, to correctly compute the summation shown in the preceding formula, it is assumed that x and w are filled with zeros. This will result in an output vector, y, that also has infinite size, with lots of zeros as well. Since this is not useful in practical situations, x is padded only with a finite number of zeros. This process is called zero-padding or simply padding. Here,", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 407, "start_word": 130240, "end_word": 130640, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000408": {"text": "indices –∞: –1 and 10: +∞ are out of bounds for x. Therefore, to correctly compute the summation shown in the preceding formula, it is assumed that x and w are filled with zeros. This will result in an output vector, y, that also has infinite size, with lots of zeros as well. Since this is not useful in practical situations, x is padded only with a finite number of zeros. This process is called zero-padding or simply padding. Here, the number of zeros padded on each side is denoted by p. An example padding of a one-dimensional vector, x, is shown in Figure 14.2: Figure 14.2: An example of padding Let’s assume that the original input, x , and filter, w , have n and m elements, respectively, where 𝑚𝑚𝑚𝑚𝑚 . Therefore, the padded vector, xp, has size n + 2p. The practical formula for computing a discrete con- volution will change to the following: 𝒚𝒚𝒚𝒚𝒚𝒚𝒚𝒚𝒚𝒚𝒚 [𝑖𝑖]𝒚∑𝑥𝑥𝑝𝑝[𝑖𝑖𝑖𝑖𝑖𝑖𝑖𝑖 ] 𝑤𝑤[𝑖𝑖]𝑘𝑘𝑘𝑘𝑘𝑘𝑘 𝑘𝑘𝑘𝑘 Now that we have solved the infinite index issue, the second issue is indexing x with i + m – k. The important point to notice here is that x and w are indexed in different directions in this summation. Computing the sum with one index going in the reverse direction is equivalent to computing the sum with both indices in the forward direction after flipping one of those vectors, x or w, after they are padded. Then, we can simply compute their dot product. Let’s assume we flip (rotate) the filter, w, to get the rotated filter, wr. Then, the dot product, x [i: i + m].wr, is computed to get one element, y [i], where x[i: i + m] is a patch of x with size m. This operation is repeated like in a sliding window approach to get all the output elements. Classifying Images with Deep Convolutional Neural Networks 456 The following figure provides an example with x = [3 2 1 7 1 2 5 4] and 𝒘𝒘𝒘 [1 2 3 4 1 1 4] so that the first three output elements are computed: Figure 14.3: The steps for computing a discrete convolution You can see in the preceding example that the padding size is zero (p = 0). Notice that the rotated filter, wr, is shifted by two cells each time we shift. This shift is another hyperparameter of a convolution, the stride, s.", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 408, "start_word": 130560, "end_word": 130960, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000409": {"text": "with x = [3 2 1 7 1 2 5 4] and 𝒘𝒘𝒘 [1 2 3 4 1 1 4] so that the first three output elements are computed: Figure 14.3: The steps for computing a discrete convolution You can see in the preceding example that the padding size is zero (p = 0). Notice that the rotated filter, wr, is shifted by two cells each time we shift. This shift is another hyperparameter of a convolution, the stride, s. In this example, the stride is two, s = 2. Note that the stride has to be a positive number smaller than the size of the input vector. We will talk more about padding and strides in the next section. Cross-correlation Cross-correlation (or simply correlation) between an input vector and a filter is denoted by 𝒚𝒚𝒚𝒚𝒚𝒚𝒚𝒚 and is very much like a sibling of a convolution, with a small difference: in cross-correlation, the multiplication is performed in the same direction. Therefore, it is not a requirement to rotate the filter matrix, w , in each dimension. Mathematically, cross-correlation is defined as follows: 𝒚𝒚𝒚𝒚𝒚𝒚𝒚𝒚𝒚𝒚𝒚 [𝑖𝑖]𝒚∑𝑥𝑥 [𝑖𝑖𝑖𝑖𝑖 ] 𝑤𝑤[𝑖𝑖]+∞ 𝑘𝑘𝑘𝑘 ∞ The same rules for padding and stride may be applied to cross-correlation as well. Note that most deep learning frameworks (including PyTorch) implement cross-correlation but refer to it as convolution, which is a common convention in the deep learning field. Chapter 14 457 Padding inputs to control the size of the output feature maps So far, we’ve only used zero-padding in convolutions to compute finite-sized output vectors. Technically, padding can be applied with any 𝑝𝑝𝑝𝑝 . Depending on the choice of p, boundary cells may be treated differently than the cells located in the middle of x. Now, consider an example where n = 5 and m = 3. Then, with p = 0, x[0] is only used in computing one output element (for instance, y[0]), while x[1] is used in the computation of two output elements (for instance, y[0] and y[1]). So, you can see that this different treatment of elements of x can artificially put more emphasis on the middle element, x[2], since it has appeared in most computations. We can avoid this issue if we choose p = 2, in which case, each element of x will be involved in computing three elements of y. Furthermore, the size of the output, y, also depends on the choice of", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 409, "start_word": 130880, "end_word": 131280, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000410": {"text": "the computation of two output elements (for instance, y[0] and y[1]). So, you can see that this different treatment of elements of x can artificially put more emphasis on the middle element, x[2], since it has appeared in most computations. We can avoid this issue if we choose p = 2, in which case, each element of x will be involved in computing three elements of y. Furthermore, the size of the output, y, also depends on the choice of the padding strategy we use. There are three modes of padding that are commonly used in practice: full, same, and valid. In full mode, the padding parameter, p, is set to p = m – 1. Full padding increases the dimensions of the output; thus, it is rarely used in CNN architectures. The same padding mode is usually used to ensure that the output vector has the same size as the input vector, x. In this case, the padding parameter, p, is computed according to the filter size, along with the requirement that the input size and output size are the same. Finally, computing a convolution in valid mode refers to the case where p = 0 (no padding). Figure 14.4 illustrates the three different padding modes for a simple 5×5 pixel input with a kernel size of 3×3 and a stride of 1: Figure 14.4: The three modes of padding The most commonly used padding mode in CNNs is same padding. One of its advantages over the other padding modes is that same padding preserves the size of the vector—or the height and width of the input images when we are working on image-related tasks in computer vision—which makes designing a network architecture more convenient. Classifying Images with Deep Convolutional Neural Networks 458 One big disadvantage of valid padding versus full and same padding is that the volume of the tensors will decrease substantially in NNs with many layers, which can be detrimental to the network’s per - formance. In practice, you should preserve the spatial size using same padding for the convolutional layers and decrease the spatial size via pooling layers or convolutional layers with stride 2 instead, as described in Striving for Simplicity: The All Convolutional Net ICLR (workshop track), by Jost Tobias Springenberg, Alexey Dosovitskiy, and others, 2015 ( https://arxiv.org/abs/1412.6806 ). As for full padding, its size results in an output larger than the input size.", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 410, "start_word": 131200, "end_word": 131600, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000411": {"text": "which can be detrimental to the network’s per - formance. In practice, you should preserve the spatial size using same padding for the convolutional layers and decrease the spatial size via pooling layers or convolutional layers with stride 2 instead, as described in Striving for Simplicity: The All Convolutional Net ICLR (workshop track), by Jost Tobias Springenberg, Alexey Dosovitskiy, and others, 2015 ( https://arxiv.org/abs/1412.6806 ). As for full padding, its size results in an output larger than the input size. Full padding is usually used in signal processing applications where it is important to minimize boundary effects. However, in a deep learning context, boundary effects are usually not an issue, so we rarely see full padding being used in practice. Determining the size of the convolution output The output size of a convolution is determined by the total number of times that we shift the filter, w, along the input vector. Let’s assume that the input vector is of size n and the filter is of size m . Then, the size of the output resulting from 𝒚𝒚𝒚𝒚𝒚𝒚𝒚𝒚 , with padding p and stride s , would be deter - mined as follows: 𝑜𝑜𝑜𝑜𝑛𝑛𝑛𝑛𝑛𝑛𝑛𝑛𝑛 𝑠𝑠⌋𝑛1 Here, ⌊⋅⌋ denotes the floor operation. Consider the following two cases: • Compute the output size for an input vector of size 10 with a convolution kernel of size 5, padding 2, and stride 1: 𝑛𝑛𝑛10,𝑚𝑚𝑛𝑚,𝑚𝑚𝑚𝑚𝑚𝑚𝑛𝑚,𝑚𝑚𝑚𝑚𝑚𝑚𝑛 1𝑚 𝑚𝑚𝑛𝑚10+𝑚×𝑚−𝑚 1]+1𝑛10 (Note that in this case, the output size turns out to be the same as the input; therefore, we can conclude this to be same padding mode.) • How does the output size change for the same input vector when we have a kernel of size 3 and stride 2? 𝑛𝑛𝑛10,𝑚𝑚𝑛𝑚,𝑚𝑚𝑚𝑚𝑚𝑚𝑛𝑚,𝑚𝑚𝑚𝑚𝑚𝑚𝑛𝑚 𝑚 𝑚𝑚𝑛𝑚10+𝑚×𝑚−𝑚 𝑚]+1𝑛6 The floor operation The floor operation returns the largest integer that is equal to or smaller than the input, for example: floor(1.77)=⌊1.77⌋=1 Chapter 14 459 If you are interested in learning more about the size of the convolution output, we recommend the manuscript A guide to convolution arithmetic for deep learning by Vincent Dumoulin and Francesco Visin, which is freely available at https://arxiv.org/abs/1603.07285 . Finally, in order to learn how to compute convolutions in one dimension, a naive implementation is shown in the following code block, and the results are compared with the numpy.convolve function. The code is as follows: >>> import numpy as np >>> def conv1d(x, w, p= 0, s=1):", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 411, "start_word": 131520, "end_word": 131920, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000412": {"text": "about the size of the convolution output, we recommend the manuscript A guide to convolution arithmetic for deep learning by Vincent Dumoulin and Francesco Visin, which is freely available at https://arxiv.org/abs/1603.07285 . Finally, in order to learn how to compute convolutions in one dimension, a naive implementation is shown in the following code block, and the results are compared with the numpy.convolve function. The code is as follows: >>> import numpy as np >>> def conv1d(x, w, p= 0, s=1): ... w_rot = np.array(w[::- 1]) ... x_padded = np.array(x) ... if p > 0: ... zero_pad = np.zeros(shape=p) ... x_padded = np.concatenate([ ... zero_pad, x_padded, zero_pad ... ]) ... res = [] ... for i in range (0, int((len(x_padded) - len(w_rot))) + 1, s): ... res.append(np. sum(x_padded[i:i+w_rot.shape[ 0]] * w_rot)) ... return np.array(res) >>> ## Testing: >>> x = [1, 3, 2, 4, 5, 6, 1, 3] >>> w = [1, 0, 3, 1, 2] >>> print('Conv1d Implementation:' , ... conv1d(x, w, p= 2, s=1)) Conv1d Implementation: [ 5. 14. 16. 26. 24. 34. 19. 22.] >>> print('NumPy Results:' , ... np.convolve(x, w, mode= 'same')) NumPy Results: [ 5 14 16 26 24 34 19 22] So far, we have mostly focused on convolutions for vectors (1D convolutions). We started with the 1D case to make the concepts easier to understand. In the next section, we will cover 2D convolutions in more detail, which are the building blocks of CNNs for image-related tasks. Performing a discrete convolution in 2D The concepts you learned in the previous sections are easily extendible to 2D. When we deal with 2D inputs, such as a matrix, 𝑿𝑿𝑛𝑛1×𝑛𝑛2 , and the filter matrix, 𝑾𝑾𝑚𝑚1×𝑚𝑚2 , where 𝑚𝑚1≤𝑛𝑛1 and 𝑚𝑚2≤𝑛𝑛2 , then the matrix 𝒀𝒀𝒀𝒀𝒀𝒀𝒀𝒀 is the result of a 2D convolution between X and W. This is defined mathematically as follows: 𝒀𝒀𝒀𝒀𝒀𝒀𝒀𝒀𝒀𝒀𝒀 [𝑖𝑖𝑖 𝑖𝑖]𝒀∑ ∑𝑋𝑋 [𝑖𝑖𝑖𝑖𝑖 1𝑖𝑖𝑖𝑖𝑖𝑖 2] 𝑊𝑊[𝑖𝑖1𝑖𝑖𝑖2]+∞ 𝑘𝑘2=−∞+∞ 𝑘𝑘1=−∞ Classifying Images with Deep Convolutional Neural Networks 460 Notice that if you omit one of the dimensions, the remaining formula is exactly the same as the one we used previously to compute the convolution in 1D. In fact, all the previously mentioned techniques, such as zero padding, rotating the filter matrix, and the use of strides, are also applicable to 2D convo - lutions, provided that they are extended to both dimensions independently. Figure 14.5 demonstrates the 2D convolution of an input matrix of", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 412, "start_word": 131840, "end_word": 132240, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000413": {"text": "Convolutional Neural Networks 460 Notice that if you omit one of the dimensions, the remaining formula is exactly the same as the one we used previously to compute the convolution in 1D. In fact, all the previously mentioned techniques, such as zero padding, rotating the filter matrix, and the use of strides, are also applicable to 2D convo - lutions, provided that they are extended to both dimensions independently. Figure 14.5 demonstrates the 2D convolution of an input matrix of size 8×8, using a kernel of size 3×3. The input matrix is padded with zeros with p = 1. As a result, the output of the 2D convolution will have a size of 8×8: Figure 14.5: The output of a 2D convolution The following example illustrates the computation of a 2D convolution between an input matrix, X 3×3, and a kernel matrix, W3×3, using padding p = (1, 1) and stride s = (2, 2). According to the specified pad- ding, one layer of zeros is added on each side of the input matrix, which results in the padded matrix 𝑿𝑿5×5padded , as follows: Figure 14.6: Computing a 2D convolution between an input and kernel matrix With the preceding filter, the rotated filter will be: 𝑾𝑾𝑟𝑟=[0.5 1 0.5 0.1 0.4 0.3 0.4 0.7 0.5] Chapter 14 461 Note that this rotation is not the same as the transpose matrix. To get the rotated filter in NumPy, we can write W_rot=W[::-1,::-1] . Next, we can shift the rotated filter matrix along the padded input matrix, Xpadded, like a sliding window, and compute the sum of the element-wise product, which is denoted by the ⨀ operator in Figure 14.7: Figure 14.7: Computing the sum of the element-wise product The result will be the 2×2 matrix, Y. Let’s also implement the 2D convolution according to the naive algorithm described. The scipy.signal package provides a way to compute 2D convolution via the scipy.signal.convolve2d function: >>> import numpy as np >>> import scipy.signal >>> def conv2d(X, W, p=( 0, 0), s=( 1, 1)): ... W_rot = np.array(W)[::- 1,::-1] ... X_orig = np.array(X) ... n1 = X_orig.shape[ 0] + 2*p[0] ... n2 = X_orig.shape[ 1] + 2*p[1] ... X_padded = np.zeros(shape=(n1, n2)) ... X_padded[p[ 0]:p[0]+X_orig.shape[ 0], ... p[ 1]:p[1]+X_orig.shape[ 1]] = X_orig ... ... res = [] ... for i in range (0, ... int((X_padded.shape[ 0] - \\ ... W_rot.shape[ 0])/s[0])+1, s[0]): ... res.append([]) Classifying Images", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 413, "start_word": 132160, "end_word": 132560, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000414": {"text": ">>> import numpy as np >>> import scipy.signal >>> def conv2d(X, W, p=( 0, 0), s=( 1, 1)): ... W_rot = np.array(W)[::- 1,::-1] ... X_orig = np.array(X) ... n1 = X_orig.shape[ 0] + 2*p[0] ... n2 = X_orig.shape[ 1] + 2*p[1] ... X_padded = np.zeros(shape=(n1, n2)) ... X_padded[p[ 0]:p[0]+X_orig.shape[ 0], ... p[ 1]:p[1]+X_orig.shape[ 1]] = X_orig ... ... res = [] ... for i in range (0, ... int((X_padded.shape[ 0] - \\ ... W_rot.shape[ 0])/s[0])+1, s[0]): ... res.append([]) Classifying Images with Deep Convolutional Neural Networks 462 ... for j in range (0, ... int((X_padded.shape[ 1] - \\ ... W_rot.shape[ 1])/s[1])+1, s[1]): ... X_sub = X_padded[i:i+W_rot.shape[ 0], ... j:j+W_rot.shape[ 1]] ... res[- 1].append(np. sum(X_sub * W_rot)) ... return(np.array(res)) >>> X = [[1, 3, 2, 4], [ 5, 6, 1, 3], [ 1, 2, 0, 2], [ 3, 4, 3, 2]] >>> W = [[1, 0, 3], [ 1, 2, 1], [ 0, 1, 1]] >>> print('Conv2d Implementation:\\n' , ... conv2d(X, W, p=( 1, 1), s=( 1, 1))) Conv2d Implementation: [[ 11. 25. 32. 13.] [ 19. 25. 24. 13.] [ 13. 28. 25. 17.] [ 11. 17. 14. 9.]] >>> print('SciPy Results:\\n' , ... scipy.signal.convolve2d(X, W, mode= 'same')) SciPy Results: [[11 25 32 13] [19 25 24 13] [13 28 25 17] [11 17 14 9]] Efficient algorithms for computing convolution We provided a naive implementation to compute a 2D convolution for the purpose of understanding the concepts. However, this implementation is very inefficient in terms of memory requirements and computational complexity. Therefore, it should not be used in real-world NN applications. One aspect is that the filter matrix is actually not rotated in most tools like PyTorch. More - over, in recent years, much more efficient algorithms have been developed that use the Fourier transform to compute convolutions. It is also important to note that in the context of NNs, the size of a convolution kernel is usually much smaller than the size of the input image. For example, modern CNNs usually use kernel sizes such as 1×1, 3×3, or 5×5, for which effi - cient algorithms have been designed that can carry out the convolutional operations much more efficiently, such as Winograd’s minimal filtering algorithm. These algorithms are beyond the scope of this book, but if you are interested in learning more, you can read the manuscript Fast Algorithms for Convolutional Neural Networks by Andrew Lavin and Scott Gray", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 414, "start_word": 132480, "end_word": 132880, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000415": {"text": "than the size of the input image. For example, modern CNNs usually use kernel sizes such as 1×1, 3×3, or 5×5, for which effi - cient algorithms have been designed that can carry out the convolutional operations much more efficiently, such as Winograd’s minimal filtering algorithm. These algorithms are beyond the scope of this book, but if you are interested in learning more, you can read the manuscript Fast Algorithms for Convolutional Neural Networks by Andrew Lavin and Scott Gray , 2015, which is freely available at https://arxiv.org/abs/1509.09308 . Chapter 14 463 In the next section, we will discuss subsampling or pooling, which is another important operation often used in CNNs. Subsampling layers Subsampling is typically applied in two forms of pooling operations in CNNs: max-pooling and mean-pooling (also known as average-pooling). The pooling layer is usually denoted by 𝑃𝑃𝑛𝑛1×𝑛𝑛2 . Here, the subscript determines the size of the neighborhood (the number of adjacent pixels in each dimension) where the max or mean operation is performed. We refer to such a neighborhood as the pooling size. The operation is described in Figure 14.8. Here, max-pooling takes the maximum value from a neigh- borhood of pixels, and mean-pooling computes their average: Figure 14.8: An example of max-pooling and mean-pooling The advantage of pooling is twofold: • Pooling (max-pooling) introduces a local invariance. This means that small changes in a local neighborhood do not change the result of max-pooling. Therefore, it helps with generating features that are more robust to noise in the input data. Refer to the following example, which shows that the max-pooling of two different input matrices, X 1 and X 2, results in the same output: 𝑿𝑿1= [ 10 255 125 0170 100 70 255 105 25 25 70 2550150010 10 0255 10 10 150 20 70 15 200 100 95 0 35 25 100 20 060] 𝑿𝑿2= [ 100 100 100 50 100 50 95 255 100 125 125 170 80 40 10 10 125 150 255 30 150 20 120 125 30 30 150 100 70 70 70 30 100 200 70 95 ] } max pooling 𝑃𝑃 2×2→ [255 125 170 255 150 150 70 200 95] • Pooling decreases the size of features, which results in higher computational efficiency. Fur - thermore, reducing the number of features may reduce the degree of overfitting as well. Classifying Images with Deep Convolutional Neural Networks 464 While", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 415, "start_word": 132800, "end_word": 133200, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000416": {"text": "125 125 170 80 40 10 10 125 150 255 30 150 20 120 125 30 30 150 100 70 70 70 30 100 200 70 95 ] } max pooling 𝑃𝑃 2×2→ [255 125 170 255 150 150 70 200 95] • Pooling decreases the size of features, which results in higher computational efficiency. Fur - thermore, reducing the number of features may reduce the degree of overfitting as well. Classifying Images with Deep Convolutional Neural Networks 464 While pooling is still an essential part of many CNN architectures, several CNN architectures have also been developed without using pooling layers. Instead of using pooling layers to reduce the feature size, researchers use convolutional layers with a stride of 2. In a sense, you can think of a convolutional layer with stride 2 as a pooling layer with learnable weights. If you are interested in an empirical comparison of different CNN architectures developed with and without pooling layers, we recommend reading the research article Striving for Simplicity: The All Convolutional Net by Jost Tobias Springenberg, Alexey Dosovitskiy, Thomas Brox, and Martin Riedmiller. This article is freely available at https://arxiv.org/abs/1412.6806 . Putting everything together – implementing a CNN So far, you have learned about the basic building blocks of CNNs. The concepts illustrated in this chap - ter are not really more difficult than traditional multilayer NNs. We can say that the most important operation in a traditional NN is matrix multiplication. For instance, we use matrix multiplications to compute the pre-activations (or net inputs), as in z = Wx + b. Here, x is a column vector ( ℝ𝑛𝑛𝑛𝑛 matrix) representing pixels, and W is the weight matrix connecting the pixel inputs to each hidden unit. In a CNN, this operation is replaced by a convolution operation, as in 𝒁𝒁𝒁𝒁𝒁𝒁𝒁𝒁𝒁𝒁𝒁 , where X is a matrix representing the pixels in a height×width arrangement. In both cases, the pre-activations are passed to an activation function to obtain the activation of a hidden unit, 𝑨𝑨𝑨𝑨𝑨(𝒁𝒁) , where 𝜎𝜎 is the activation function. Furthermore, you will recall that subsampling is another building block of a CNN, which may appear in the form of pooling, as was described in the previous section. Working with multiple input or color channels An input to a convolutional layer may contain one or more 2D arrays or matrices with dimensions N 1×N2 (for example, the image height and", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 416, "start_word": 133120, "end_word": 133520, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000417": {"text": "to an activation function to obtain the activation of a hidden unit, 𝑨𝑨𝑨𝑨𝑨(𝒁𝒁) , where 𝜎𝜎 is the activation function. Furthermore, you will recall that subsampling is another building block of a CNN, which may appear in the form of pooling, as was described in the previous section. Working with multiple input or color channels An input to a convolutional layer may contain one or more 2D arrays or matrices with dimensions N 1×N2 (for example, the image height and width in pixels). These N 1×N2 matrices are called channels. Conven- tional implementations of convolutional layers expect a rank-3 tensor representation as an input, for example, a three-dimensional array, 𝑿𝑿𝑁𝑁1×𝑁𝑁2×𝐶𝐶𝑖𝑖𝑖𝑖 , where C in is the number of input channels. For example, let’s consider images as input to the first layer of a CNN. If the image is colored and uses the RGB color mode, then C in = 3 (for the red, green, and blue color channels in RGB). However, if the image is in gray - scale, then we have C in = 1, because there is only one channel with the grayscale pixel intensity values.Overlapping versus non-overlapping pooling Traditionally, pooling is assumed to be non-overlapping. Pooling is typically performed on non-overlapping neighborhoods, which can be done by setting the stride parameter equal to the pooling size. For example, a non-overlapping pooling layer, 𝑃𝑃𝑛𝑛1×𝑛𝑛2 , requires a stride parameter s = (n 1, n2). On the other hand, overlapping pooling occurs if the stride is smaller than the pooling size. An example where overlapping pooling is used in a con- volutional network is described in ImageNet Classification with Deep Convolutional Neural Networks by A. Krizhevsky, I. Sutskever, and G. Hinton, 2012, which is freely available as a manuscript at https://papers.nips.cc/paper/4824-imagenet-classification- with-deep-convolutional-neural-networks . Chapter 14 465 Now that you are familiar with the structure of input data, the next question is, how can we incorporate multiple input channels in the convolution operation that we discussed in the previous sections? The answer is very simple: we perform the convolution operation for each channel separately and then add the results together using the matrix summation. The convolution associated with each channel (c) has its own kernel matrix as W[:, :, c].Reading an image file When we work with images, we can read images into NumPy arrays using the uint8 (unsigned 8-bit integer) data type to reduce memory usage compared to 16-bit,", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 417, "start_word": 133440, "end_word": 133840, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000418": {"text": "the convolution operation that we discussed in the previous sections? The answer is very simple: we perform the convolution operation for each channel separately and then add the results together using the matrix summation. The convolution associated with each channel (c) has its own kernel matrix as W[:, :, c].Reading an image file When we work with images, we can read images into NumPy arrays using the uint8 (unsigned 8-bit integer) data type to reduce memory usage compared to 16-bit, 32-bit, or 64-bit integer types, for example. Unsigned 8-bit integers take values in the range [0, 255], which are sufficient to store the pixel information in RGB images, which also take values in the same range. In Chapter 12, Parallelizing Neural Network Training with PyTorch, you saw that PyTorch provides a module for loading/storing and manipulating images via torchvision . Let’s recap how to read an image (this example RGB image is located in the code bundle folder that is provided with this chapter): >>> import torch >>> from torchvision.io import read_image >>> img = read_image( 'example-image.png' ) >>> print('Image shape:' , img.shape) Image shape: torch.Size([3, 252, 221]) >>> print('Number of channels:' , img.shape[ 0]) Number of channels: 3 >>> print('Image data type:' , img.dtype) Image data type: torch.uint8 >>> print(img[:, 100:102, 100:102]) tensor([[[179, 182], [180, 182]], [[134, 136], [135, 137]], [[110, 112], [111, 113]]], dtype=torch.uint8) Note that with torchvision , the input and output image tensors are in the format of Tensor[channels, image_height, image_width] . Classifying Images with Deep Convolutional Neural Networks 466 The total pre-activation result is computed in the following formula: Given an example 𝑿𝑿 𝑛𝑛1×𝑛𝑛2×𝐶𝐶𝑖𝑖𝑖𝑖, a kernel matrix 𝑾𝑾 𝑚𝑚1×𝑚𝑚2×𝐶𝐶𝑖𝑖𝑖𝑖, and a bias value 𝑏𝑏 ⟹ { 𝒁𝒁𝐶𝐶𝐶𝐶𝑛𝑛𝐶𝐶=∑𝑾𝑾[:,:,𝑐𝑐]∗𝑿𝑿[:,:,𝑐𝑐]𝐶𝐶𝑖𝑖𝑖𝑖 𝑐𝑐𝑐𝑐 Pre-activation: 𝒁𝒁 =𝒁𝒁𝐶𝐶𝐶𝐶𝑛𝑛𝐶𝐶+𝑏𝑏𝑐𝑐 Feature map: 𝑨𝑨 =𝑨𝑨(𝒁𝒁) The final result, A , is a feature map. Usually, a convolutional layer of a CNN has more than one feature map. If we use multiple feature maps, the kernel tensor becomes four-dimensional: width× height× Cin×Cout. Here, width×height is the kernel size, C in is the number of input channels, and C out is the number of output feature maps. So, now let’s include the number of output feature maps in the preceding formula and update it, as follows: Given an example 𝑿𝑿 𝑛𝑛1×𝑛𝑛2×𝐶𝐶𝑖𝑖𝑖𝑖, a kernel matrix 𝑾𝑾 𝑚𝑚1×𝑚𝑚2×𝐶𝐶𝑖𝑖𝑖𝑖×𝐶𝐶𝑜𝑜𝑜𝑜𝑜𝑜, and a bias vector 𝒃𝒃 𝐶𝐶𝑜𝑜𝑜𝑜𝑜𝑜 ⟹ { 𝒁𝒁𝐶𝐶𝐶𝐶𝑛𝑛𝑛𝑛[:,:,𝑘𝑘]=∑𝑾𝑾[:,:,𝑐𝑐,𝑘𝑘]∗𝑿𝑿[:,:,𝑐𝑐]𝐶𝐶𝑖𝑖𝑖𝑖 𝑐𝑐𝑐𝑐 𝒁𝒁[:,:,𝑘𝑘]=𝒁𝒁𝐶𝐶𝐶𝐶𝑛𝑛𝑛𝑛[:,:,𝑘𝑘]+𝑏𝑏[𝑘𝑘] 𝑨𝑨[:,:,𝑘𝑘]=𝜎𝜎(𝒁𝒁[:,:,𝑘𝑘]) To conclude our discussion of computing convolutions in the", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 418, "start_word": 133760, "end_word": 134160, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000419": {"text": "tensor becomes four-dimensional: width× height× Cin×Cout. Here, width×height is the kernel size, C in is the number of input channels, and C out is the number of output feature maps. So, now let’s include the number of output feature maps in the preceding formula and update it, as follows: Given an example 𝑿𝑿 𝑛𝑛1×𝑛𝑛2×𝐶𝐶𝑖𝑖𝑖𝑖, a kernel matrix 𝑾𝑾 𝑚𝑚1×𝑚𝑚2×𝐶𝐶𝑖𝑖𝑖𝑖×𝐶𝐶𝑜𝑜𝑜𝑜𝑜𝑜, and a bias vector 𝒃𝒃 𝐶𝐶𝑜𝑜𝑜𝑜𝑜𝑜 ⟹ { 𝒁𝒁𝐶𝐶𝐶𝐶𝑛𝑛𝑛𝑛[:,:,𝑘𝑘]=∑𝑾𝑾[:,:,𝑐𝑐,𝑘𝑘]∗𝑿𝑿[:,:,𝑐𝑐]𝐶𝐶𝑖𝑖𝑖𝑖 𝑐𝑐𝑐𝑐 𝒁𝒁[:,:,𝑘𝑘]=𝒁𝒁𝐶𝐶𝐶𝐶𝑛𝑛𝑛𝑛[:,:,𝑘𝑘]+𝑏𝑏[𝑘𝑘] 𝑨𝑨[:,:,𝑘𝑘]=𝜎𝜎(𝒁𝒁[:,:,𝑘𝑘]) To conclude our discussion of computing convolutions in the context of NNs, let’s look at the example in Figure 14.9, which shows a convolutional layer, followed by a pooling layer. In this example, there are three input channels. The kernel tensor is four-dimensional. Each kernel matrix is denoted as m1×m 2, and there are three of them, one for each input channel. Furthermore, there are five such kernels, accounting for five output feature maps. Finally, there is a pooling layer for subsampling the feature maps: Figure 14.9: Implementing a CNN Chapter 14 467 Lastly, as was already mentioned, the convolution operations typically are carried out by treating an input image with multiple color channels as a stack of matrices; that is, we perform the convolution on each matrix separately and then add the results, as was illustrated in the previous figure. However, convolutions can also be extended to 3D volumes if you are working with 3D datasets, for example, as shown in the paper VoxNet: A 3D Convolutional Neural Network for Real-Time Object Recognition by Daniel Maturana and Sebastian Scherer, 2015, which can be accessed at https://www.ri.cmu.edu/ pub_files/2015/9/voxnet_maturana_scherer_iros15.pdf . In the next section, we will talk about how to regularize an NN. Regularizing an NN with L2 regularization and dropout Choosing the size of a network, whether we are dealing with a traditional (fully connected) NN or a CNN, has always been a challenging problem. For instance, the size of a weight matrix and the number of layers need to be tuned to achieve a reasonably good performance.How many trainable parameters exist in the preceding example? To illustrate the advantages of convolution, parameter sharing, and sparse connectivity, let’s work through an example. The convolutional layer in the network shown in Figure 14.9 is a four-dimensional tensor. So, there are m 1×m2×3×5 parameters associated with the kernel. Furthermore, there is a bias vector for each output feature map of the convolu- tional layer. Thus, the size of the bias vector", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 419, "start_word": 134080, "end_word": 134480, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000420": {"text": "to be tuned to achieve a reasonably good performance.How many trainable parameters exist in the preceding example? To illustrate the advantages of convolution, parameter sharing, and sparse connectivity, let’s work through an example. The convolutional layer in the network shown in Figure 14.9 is a four-dimensional tensor. So, there are m 1×m2×3×5 parameters associated with the kernel. Furthermore, there is a bias vector for each output feature map of the convolu- tional layer. Thus, the size of the bias vector is 5. Pooling layers do not have any (trainable) parameters; therefore, we can write the following: m1 × m 2 × 3 × 5 + 5 If the input tensor is of size n 1×n 2×3, assuming that the convolution is performed with the same-padding mode, then the size of the output feature maps would be n 1 × n 2 × 5. Note that if we use a fully connected layer instead of a convolutional layer, this number will be much larger. In the case of a fully connected layer, the number of parameters for the weight matrix to reach the same number of output units would have been as follows: (n1 × n 2 × 3) × (n 1 × n 2 × 5) = (n 1 × n 2)2 × 3 × 5 In addition, the size of the bias vector is n 1 × n 2 × 5 (one bias element for each output unit). Given that m 1 < n 1 and m 2 < n 2, we can see that the difference in the number of trainable parameters is significant. Classifying Images with Deep Convolutional Neural Networks 468 You will recall from Chapter 13, Going Deeper – The Mechanics of PyTorch , that a simple network without a hidden layer could only capture a linear decision boundary, which is not sufficient for dealing with an exclusive or (or XOR) or similar problem. The capacity of a network refers to the level of complex - ity of the function that it can learn to approximate. Small networks, or networks with a relatively small number of parameters, have a low capacity and are therefore likely to underfit, resulting in poor performance, since they cannot learn the underlying structure of complex datasets. However, very large networks may result in overfitting, where the network will memorize the training data and do extremely well on the training dataset while", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 420, "start_word": 134400, "end_word": 134800, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000421": {"text": "of a network refers to the level of complex - ity of the function that it can learn to approximate. Small networks, or networks with a relatively small number of parameters, have a low capacity and are therefore likely to underfit, resulting in poor performance, since they cannot learn the underlying structure of complex datasets. However, very large networks may result in overfitting, where the network will memorize the training data and do extremely well on the training dataset while achieving a poor performance on the held-out test dataset. When we deal with real-world machine learning problems, we do not know how large the network should be a priori. One way to address this problem is to build a network with a relatively large capacity (in practice, we want to choose a capacity that is slightly larger than necessary) to do well on the training dataset. Then, to prevent overfitting, we can apply one or multiple regularization schemes to achieve good generalization performance on new data, such as the held-out test dataset. In Chapters 3 and 4, we covered L1 and L2 regularization. Both techniques can prevent or reduce the effect of overfitting by adding a penalty to the loss that results in shrinking the weight parameters during training. While both L1 and L2 regularization can be used for NNs as well, with L2 being the more common choice of the two, there are other methods for regularizing NNs, such as dropout, which we discuss in this section. But before we move on to discussing dropout, to use L2 regularization within a convolutional or fully connected network (recall, fully connected layers are implemented via torch.nn.Linear in PyTorch), you can simply add the L2 penalty of a particular layer to the loss function in PyTorch, as follows: >>> import torch.nn as nn >>> loss_func = nn.BCELoss() >>> loss = loss_func(torch.tensor([ 0.9]), torch.tensor([ 1.0])) >>> l2_lambda = 0.001 >>> conv_layer = nn.Conv2d(in_channels= 3, ... out_channels= 5, ... kernel_size= 5) >>> l2_penalty = l2_lambda * sum( ... [(p** 2).sum() for p in conv_layer.parameters()] ... ) >>> loss_with_penalty = loss + l2_penalty >>> linear_layer = nn.Linear( 10, 16) Chapter 14 469 >>> l2_penalty = l2_lambda * sum( ... [(p** 2).sum() for p in linear_layer.parameters()] ... ) >>> loss_with_penalty = loss + l2_penalty In recent years, dropout has emerged as a popular technique for regularizing (deep) NNs to avoid overfitting, thus improving the generalization performance", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 421, "start_word": 134720, "end_word": 135120, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000422": {"text": "3, ... out_channels= 5, ... kernel_size= 5) >>> l2_penalty = l2_lambda * sum( ... [(p** 2).sum() for p in conv_layer.parameters()] ... ) >>> loss_with_penalty = loss + l2_penalty >>> linear_layer = nn.Linear( 10, 16) Chapter 14 469 >>> l2_penalty = l2_lambda * sum( ... [(p** 2).sum() for p in linear_layer.parameters()] ... ) >>> loss_with_penalty = loss + l2_penalty In recent years, dropout has emerged as a popular technique for regularizing (deep) NNs to avoid overfitting, thus improving the generalization performance (Dropout: A Simple Way to Prevent Neural Networks from Overfitting by N. Srivastava, G. Hinton, A. Krizhevsky, I. Sutskever, and R. Salakhutdin - ov, Journal of Machine Learning Research 15.1, pages 1929-1958, 2014, http://www.jmlr.org/papers/ volume15/srivastava14a/srivastava14a.pdf ). Dropout is usually applied to the hidden units of higher layers and works as follows: during the training phase of an NN, a fraction of the hidden units is randomly dropped at every iteration with probability p drop (or keep probability p keep = 1 – p drop). This dropout probability is determined by the user and the common choice is p = 0.5, as discussed in the previously mentioned article by Nitish Srivastava and others, 2014. When dropping a certain fraction of input neurons, the weights associated with the remaining neurons are rescaled to account for the missing (dropped) neurons. The effect of this random dropout is that the network is forced to learn a redundant representation of the data. Therefore, the network cannot rely on the activation of any set of hidden units, since they may be turned off at any time during training, and is forced to learn more general and robust patterns from the data.Weight decay versus L2 regularization An alternative way to use L2 regularization is by setting the weight_decay parameter in a PyTorch optimizer to a positive value, for example: optimizer = torch.optim.SGD( model.parameters(), weight_decay=l2_lambda, ... ) While L2 regularization and weight_decay are not strictly identical, it can be shown that they are equivalent when using stochastic gradient descent (SGD ) optimizers. Interested readers can find more information in the article Decoupled Weight Decay Regularization by Ilya Loshchilov and Frank Hutter, 2019, which is freely available at https://arxiv.org/ abs/1711.05101 . Classifying Images with Deep Convolutional Neural Networks 470 This random dropout can effectively prevent overfitting. Figure 14.10 shows an example of applying dropout with probability p = 0.5 during the training phase, whereby half of the neurons will", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 422, "start_word": 135040, "end_word": 135440, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000423": {"text": "be shown that they are equivalent when using stochastic gradient descent (SGD ) optimizers. Interested readers can find more information in the article Decoupled Weight Decay Regularization by Ilya Loshchilov and Frank Hutter, 2019, which is freely available at https://arxiv.org/ abs/1711.05101 . Classifying Images with Deep Convolutional Neural Networks 470 This random dropout can effectively prevent overfitting. Figure 14.10 shows an example of applying dropout with probability p = 0.5 during the training phase, whereby half of the neurons will become inactive randomly (dropped units are selected randomly in each forward pass of training). However, during prediction, all neurons will contribute to computing the pre-activations of the next layer: Figure 14.10: Applying dropout during the training phase As shown here, one important point to remember is that units may drop randomly during training only, whereas for the evaluation (inference) phase, all the hidden units must be active (for instance, pdrop = 0 or p keep = 1). To ensure that the overall activations are on the same scale during training and pre - diction, the activations of the active neurons have to be scaled appropriately (for example, by halving the activation if the dropout probability was set to p = 0.5). However, since it is inconvenient to always scale activations when making predictions, PyTorch and other tools scale the activations during training (for example, by doubling the activations if the dropout probability was set to p = 0.5). This approach is commonly referred to as inverse dropout. While the relationship is not immediately obvious, dropout can be interpreted as the consensus (av - eraging) of an ensemble of models. As discussed in Chapter 7, Combining Different Models for Ensemble Learning, in ensemble learning, we train several models independently. During prediction, we then use the consensus of all the trained models. We already know that model ensembles are known to perform better than single models. In deep learning, however, both training several models and collecting and averaging the output of multiple models is computationally expensive. Here, dropout offers a workaround, with an efficient way to train many models at once and compute their average predictions at test or prediction time. Chapter 14 471 As mentioned previously, the relationship between model ensembles and dropout is not immediately obvious. However, consider that in dropout, we have a different model for each mini-batch (due to setting the weights to zero randomly during each forward", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 423, "start_word": 135360, "end_word": 135760, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000424": {"text": "several models and collecting and averaging the output of multiple models is computationally expensive. Here, dropout offers a workaround, with an efficient way to train many models at once and compute their average predictions at test or prediction time. Chapter 14 471 As mentioned previously, the relationship between model ensembles and dropout is not immediately obvious. However, consider that in dropout, we have a different model for each mini-batch (due to setting the weights to zero randomly during each forward pass). Then, via iterating over the mini-batches, we essentially sample over M = 2h models, where h is the number of hidden units. The restriction and aspect that distinguishes dropout from regular ensembling, however, is that we share the weights over these “different models,” which can be seen as a form of regularization. Then, during “inference” (for instance, predicting the labels in the test dataset), we can average over all these different models that we sampled over during training. This is very expensive, though. Then, averaging the models, that is, computing the geometric mean of the class-membership proba - bility that is returned by a model, i, can be computed as follows: 𝑝𝑝𝐸𝐸𝐸𝐸𝐸𝐸𝐸𝐸𝐸𝐸𝐸𝐸𝐸𝐸𝐸𝐸=[∏𝑝𝑝{𝑖𝑖}𝑀𝑀 𝑗𝑗𝑗𝑗]𝑗 𝑀𝑀 Now, the trick behind dropout is that this geometric mean of the model ensembles (here, M models) can be approximated by scaling the predictions of the last (or final) model sampled during training by a factor of 1/(1 – p), which is much cheaper than computing the geometric mean explicitly using the previous equation. (In fact, the approximation is exactly equivalent to the true geometric mean if we consider linear models.) Loss functions for classification In Chapter 12, Parallelizing Neural Network Training with PyTorch, we saw different activation functions, such as ReLU, sigmoid, and tanh. Some of these activation functions, like ReLU, are mainly used in the intermediate (hidden) layers of an NN to add non-linearities to our model. But others, like sigmoid (for binary) and softmax (for multiclass), are added at the last (output) layer, which results in class-member - ship probabilities as the output of the model. If the sigmoid or softmax activations are not included at the output layer, then the model will compute the logits instead of the class-membership probabilities. Focusing on classification problems here, depending on the type of problem (binary versus multiclass) and the type of output (logits versus probabilities), we should choose the appropriate loss function to train", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 424, "start_word": 135680, "end_word": 136080, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000425": {"text": "and softmax (for multiclass), are added at the last (output) layer, which results in class-member - ship probabilities as the output of the model. If the sigmoid or softmax activations are not included at the output layer, then the model will compute the logits instead of the class-membership probabilities. Focusing on classification problems here, depending on the type of problem (binary versus multiclass) and the type of output (logits versus probabilities), we should choose the appropriate loss function to train our model. Binary cross-entropy is the loss function for a binary classification (with a single output unit), and categorical cross-entropy is the loss function for multiclass classification. In the torch.nn module, the categorical cross-entropy loss takes in ground truth labels as integers (for ex - ample, y=2, out of three classes, 0, 1, and 2). Classifying Images with Deep Convolutional Neural Networks 472 Figure 14.11 describes two loss functions available in torch.nn for dealing with both cases: binary classification and multiclass with integer labels. Each one of these two loss functions also has the option to receive the predictions in the form of logits or class-membership probabilities: Figure 14.11: Two examples of loss functions in PyTorch Please note that computing the cross-entropy loss by providing the logits, and not the class-member - ship probabilities, is usually preferred due to numerical stability reasons. For binary classification, we can either provide logits as inputs to the loss function nn.BCEWithLogitsLoss() , or compute the probabilities based on the logits and feed them to the loss function nn.BCELoss() . For multiclass classification, we can either provide logits as inputs to the loss function nn.CrossEntropyLoss() , or compute the log probabilities based on the logits and feed them to the negative log-likelihood loss function nn.NLLLoss() . The following code will show you how to use these loss functions with two different formats, where either the logits or class-membership probabilities are given as inputs to the loss functions: >>> ####### Binary Cross-entropy >>> logits = torch.tensor([ 0.8]) >>> probas = torch.sigmoid(logits) >>> target = torch.tensor([ 1.0]) >>> bce_loss_fn = nn.BCELoss() >>> bce_logits_loss_fn = nn.BCEWithLogitsLoss() >>> print(f'BCE (w Probas): {bce_loss_fn(probas, target): .4f}') BCE (w Probas): 0.3711 >>> print(f'BCE (w Logits): ' ... f'{bce_logits_loss_fn(logits, target): .4f}') BCE (w Logits): 0.3711 Chapter 14 473 >>> ####### Categorical Cross-entropy >>> logits = torch.tensor([[ 1.5, 0.8, 2.1]]) >>> probas = torch.softmax(logits, dim= 1) >>> target = torch.tensor([ 2]) >>> cce_loss_fn =", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 425, "start_word": 136000, "end_word": 136400, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000426": {"text": "loss functions: >>> ####### Binary Cross-entropy >>> logits = torch.tensor([ 0.8]) >>> probas = torch.sigmoid(logits) >>> target = torch.tensor([ 1.0]) >>> bce_loss_fn = nn.BCELoss() >>> bce_logits_loss_fn = nn.BCEWithLogitsLoss() >>> print(f'BCE (w Probas): {bce_loss_fn(probas, target): .4f}') BCE (w Probas): 0.3711 >>> print(f'BCE (w Logits): ' ... f'{bce_logits_loss_fn(logits, target): .4f}') BCE (w Logits): 0.3711 Chapter 14 473 >>> ####### Categorical Cross-entropy >>> logits = torch.tensor([[ 1.5, 0.8, 2.1]]) >>> probas = torch.softmax(logits, dim= 1) >>> target = torch.tensor([ 2]) >>> cce_loss_fn = nn.NLLLoss() >>> cce_logits_loss_fn = nn.CrossEntropyLoss() >>> print(f'CCE (w Probas): ' ... f'{cce_logits_loss_fn(logits, target): .4f}') CCE (w Probas): 0.5996 >>> print(f'CCE (w Logits): ' ... f'{cce_loss_fn(torch.log(probas), target): .4f}') CCE (w Logits): 0.5996 Note that sometimes, you may come across an implementation where a categorical cross-entropy loss is used for binary classification. Typically, when we have a binary classification task, the model returns a single output value for each example. We interpret this single model output as the proba - bility of the positive class (for example, class 1), P(class = 1|x). In a binary classification problem, it is implied that P(class = 0|x)= 1 – P(class = 1|x); hence, we do not need a second output unit in order to obtain the probability of the negative class. However, sometimes practitioners choose to return two outputs for each training example and interpret them as probabilities of each class: P(class = 0|x) versus P(class = 1|x). Then, in such a case, using a softmax function (instead of the logistic sigmoid) to normalize the outputs (so that they sum to 1) is recommended, and categorical cross-entropy is the appropriate loss function. Implementing a deep CNN using PyTorch In Chapter 13, as you may recall, we solved the handwritten digit recognition problem using the torch. nn module. You may also recall that we achieved about 95.6 percent accuracy using an NN with two linear hidden layers. Now, let’s implement a CNN and see whether it can achieve a better predictive performance compared to the previous model for classifying handwritten digits. Note that the fully connected layers that we saw in Chapter 13 were able to perform well on this problem. However, in some applications, such as reading bank account numbers from handwritten digits, even tiny mistakes can be very costly. Therefore, it is crucial to reduce this error as much as possible. The multilayer CNN architecture The architecture of the network that we are going", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 426, "start_word": 136320, "end_word": 136720, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000427": {"text": "can achieve a better predictive performance compared to the previous model for classifying handwritten digits. Note that the fully connected layers that we saw in Chapter 13 were able to perform well on this problem. However, in some applications, such as reading bank account numbers from handwritten digits, even tiny mistakes can be very costly. Therefore, it is crucial to reduce this error as much as possible. The multilayer CNN architecture The architecture of the network that we are going to implement is shown in Figure 14.12. The inputs are 28×28 grayscale images. Considering the number of channels (which is 1 for grayscale images) and a batch of input images, the input tensor’s dimensions will be batchsize×28×28×1. Classifying Images with Deep Convolutional Neural Networks 474 The input data goes through two convolutional layers that have a kernel size of 5×5. The first convo - lution has 32 output feature maps, and the second one has 64 output feature maps. Each convolution layer is followed by a subsampling layer in the form of a max-pooling operation, P 2×2. Then a fully connected layer passes the output to a second fully connected layer, which acts as the final softmax output layer. The architecture of the network that we are going to implement is shown in Figure 14.12: Figure 14.12: A deep CNN The dimensions of the tensors in each layer are as follows: • Input: [batchsize×28×28×1] • Conv_1: [batchsize×28×28×32] • Pooling_1: [batchsize×14×14×32] • Conv_2: [batchsize×14×14×64] • Pooling_2: [batchsize×7×7×64] • FC_1: [batchsize×1024] • FC_2 and softmax layer: [batchsize×10] For the convolutional kernels, we are using stride=1 such that the input dimensions are preserved in the resulting feature maps. For the pooling layers, we are using kernel_size=2 to subsample the image and shrink the size of the output feature maps. We will implement this network using the PyTorch NN module. Loading and preprocessing the data First, we will load the MNIST dataset using the torchvision module and construct the training and test sets, as we did in Chapter 13: >>> import torchvision >>> from torchvision import transforms >>> image_path = './' >>> transform = transforms.Compose([ ... transforms.ToTensor() ... ]) Chapter 14 475 >>> mnist_dataset = torchvision.datasets.MNIST( ... root=image_path, train= True, ... transform=transform, download= True ... ) >>> from torch.utils.data import Subset >>> mnist_valid_dataset = Subset(mnist_dataset, ... torch.arange( 10000)) >>> mnist_train_dataset = Subset(mnist_dataset, ... torch.arange( ... 10000, len(mnist_dataset) ... )) >>> mnist_test_dataset = torchvision.datasets.MNIST( ...", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 427, "start_word": 136640, "end_word": 137040, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000428": {"text": "torchvision module and construct the training and test sets, as we did in Chapter 13: >>> import torchvision >>> from torchvision import transforms >>> image_path = './' >>> transform = transforms.Compose([ ... transforms.ToTensor() ... ]) Chapter 14 475 >>> mnist_dataset = torchvision.datasets.MNIST( ... root=image_path, train= True, ... transform=transform, download= True ... ) >>> from torch.utils.data import Subset >>> mnist_valid_dataset = Subset(mnist_dataset, ... torch.arange( 10000)) >>> mnist_train_dataset = Subset(mnist_dataset, ... torch.arange( ... 10000, len(mnist_dataset) ... )) >>> mnist_test_dataset = torchvision.datasets.MNIST( ... root=image_path, train= False, ... transform=transform, download= False ... ) The MNIST dataset comes with a pre-specified training and test dataset partitioning scheme, but we also want to create a validation split from the train partition. Hence, we used the first 10,000 training examples for validation. Note that the images are not sorted by class label, so we do not have to worry about whether those validation set images are from the same classes. Next, we will construct the data loader with batches of 64 images for the training set and validation set, respectively: >>> from torch.utils.data import DataLoader >>> batch_size = 64 >>> torch.manual_seed( 1) >>> train_dl = DataLoader(mnist_train_dataset, ... batch_size, ... shuffle= True) >>> valid_dl = DataLoader(mnist_valid_dataset, ... batch_size, ... shuffle= False) The features we read are of values in the range [0, 1]. Also, we already converted the images to tensors. The labels are integers from 0 to 9, representing ten digits. Hence, we don’t need to do any scaling or further conversion. Now, after preparing the dataset, we are ready to implement the CNN we just described. Classifying Images with Deep Convolutional Neural Networks 476 Implementing a CNN using the torch.nn module For implementing a CNN in PyTorch, we use the torch.nn Sequential class to stack different layers, such as convolution, pooling, and dropout, as well as the fully connected layers. The torch.nn module provides classes for each one: nn.Conv2d for a two-dimensional convolution layer; nn.MaxPool2d and nn.AvgPool2d for subsampling (max-pooling and average-pooling); and nn.Dropout for regularization using dropout. We will go over each of these classes in more detail. Configuring CNN layers in PyTorch Constructing a layer with the Conv2d class requires us to specify the number of output channels (which is equivalent to the number of output feature maps, or the number of output filters) and kernel sizes. In addition, there are optional parameters that we can use to configure a convolutional layer. The most", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 428, "start_word": 136960, "end_word": 137360, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000429": {"text": "nn.AvgPool2d for subsampling (max-pooling and average-pooling); and nn.Dropout for regularization using dropout. We will go over each of these classes in more detail. Configuring CNN layers in PyTorch Constructing a layer with the Conv2d class requires us to specify the number of output channels (which is equivalent to the number of output feature maps, or the number of output filters) and kernel sizes. In addition, there are optional parameters that we can use to configure a convolutional layer. The most commonly used ones are the strides (with a default value of 1 in both x, y dimensions) and pad- ding, which controls the amount of implicit padding on both dimensions. Additional configuration parameters are listed in the official documentation: https://pytorch.org/docs/stable/generated/ torch.nn.Conv2d.html . It is worth mentioning that usually, when we read an image, the default dimension for the channels is the first dimension of the tensor array (or the second dimension considering the batch dimension). This is called the NCHW format, where N stands for the number of images within the batch, C stands for channels, and H and W stand for height and width, respectively. Note that the Conv2D class assumes that inputs are in NCHW format by default. (Other tools, such as TensorFlow, use NHWC format.) However, if you come across some data whose channels are placed at the last dimension, you would need to swap the axes in your data to move the channels to the first dimension (or the second dimension considering the batch dimension). After the layer is constructed, it can be called by providing a four-dimensional tensor, with the first dimension reserved for a batch of examples; the second dimension corresponds to the channel; and the other two dimensions are the spatial dimensions. As shown in the architecture of the CNN model that we want to build, each convolution layer is followed by a pooling layer for subsampling (reducing the size of feature maps). The MaxPool2d and AvgPool2d classes construct the max-pooling and average-pooling layers, respectively. The kernel_size argu - ment determines the size of the window (or neighborhood) that will be used to compute the max or mean operations. Furthermore, the stride parameter can be used to configure the pooling layer, as we discussed earlier. Finally, the Dropout class will construct the dropout layer for regularization, with the argument p that denotes the drop probability p drop, which is used to determine the", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 429, "start_word": 137280, "end_word": 137680, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000430": {"text": "The MaxPool2d and AvgPool2d classes construct the max-pooling and average-pooling layers, respectively. The kernel_size argu - ment determines the size of the window (or neighborhood) that will be used to compute the max or mean operations. Furthermore, the stride parameter can be used to configure the pooling layer, as we discussed earlier. Finally, the Dropout class will construct the dropout layer for regularization, with the argument p that denotes the drop probability p drop, which is used to determine the probability of dropping the input units during training, as we discussed earlier. When calling this layer, its behavior can be controlled via model.train() and model.eval() , to specify whether this call will be made during training or during the inference. When using dropout, alternating between these two modes is crucial to ensure that it behaves correctly; for instance, nodes are only randomly dropped during training, not evalu- ation or inference. Chapter 14 477 Constructing a CNN in PyTorch Now that you have learned about these classes, we can construct the CNN model that was shown in the previous figure. In the following code, we will use the Sequential class and add the convolution and pooling layers: >>> model = nn.Sequential() >>> model.add_module( ... 'conv1', ... nn.Conv2d( ... in_channels= 1, out_channels= 32, ... kernel_size= 5, padding= 2 ... ) ... ) >>> model.add_module( 'relu1', nn.ReLU()) >>> model.add_module( 'pool1', nn.MaxPool2d(kernel_size= 2)) >>> model.add_module( ... 'conv2', ... nn.Conv2d( ... in_channels= 32, out_channels= 64, ... kernel_size= 5, padding= 2 ... ) ... ) >>> model.add_module( 'relu2', nn.ReLU()) >>> model.add_module( 'pool2', nn.MaxPool2d(kernel_size= 2)) So far, we have added two convolution layers to the model. For each convolutional layer, we used a kernel of size 5×5 and padding=2 . As discussed earlier, using same padding mode preserves the spatial dimensions (vertical and horizontal dimensions) of the feature maps such that the inputs and outputs have the same height and width (and the number of channels may only differ in terms of the number of filters used). As mentioned before, the spatial dimension of the output feature map is calculated by: 𝑜𝑜𝑜𝑜𝑛𝑛𝑛𝑛𝑛𝑛𝑛𝑛𝑛 𝑠𝑠]𝑛1 where n is the spatial dimension of the input feature map, and p, m, and s denote the padding, kernel size, and stride, respectively. We obtain p = 2 in order to achieve o = i. The max-pooling layers with pooling size 2×2 and stride of 2 will reduce the spatial dimensions by half.", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 430, "start_word": 137600, "end_word": 138000, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000431": {"text": "only differ in terms of the number of filters used). As mentioned before, the spatial dimension of the output feature map is calculated by: 𝑜𝑜𝑜𝑜𝑛𝑛𝑛𝑛𝑛𝑛𝑛𝑛𝑛 𝑠𝑠]𝑛1 where n is the spatial dimension of the input feature map, and p, m, and s denote the padding, kernel size, and stride, respectively. We obtain p = 2 in order to achieve o = i. The max-pooling layers with pooling size 2×2 and stride of 2 will reduce the spatial dimensions by half. (Note that if the stride parameter is not specified in MaxPool2D , by default, it is set equal to the pooling kernel size.) Classifying Images with Deep Convolutional Neural Networks 478 While we can calculate the size of the feature maps at this stage manually, PyTorch provides a conve - nient method to compute this for us: >>> x = torch.ones(( 4, 1, 28, 28)) >>> model(x).shape torch.Size([4, 64, 7, 7]) By providing the input shape as a tuple (4, 1, 28, 28) (4 images within the batch, 1 channel, and image size 28×28), specified in this example, we calculated the output to have a shape (4, 64, 7, 7) , indicating feature maps with 64 channels and a spatial size of 7×7. The first dimension corresponds to the batch dimension, for which we used 4 arbitrarily. The next layer that we want to add is a fully connected layer for implementing a classifier on top of our convolutional and pooling layers. The input to this layer must have rank 2, that is, shape [batch- size × input_units]. Thus, we need to flatten the output of the previous layers to meet this requirement for the fully connected layer: >>> model.add_module( 'flatten' , nn.Flatten()) >>> x = torch.ones(( 4, 1, 28, 28)) >>> model(x).shape torch.Size([4, 3136]) As the output shape indicates, the input dimensions for the fully connected layer are correctly set up. Next, we will add two fully connected layers with a dropout layer in between: >>> model.add_module( 'fc1', nn.Linear( 3136, 1024)) >>> model.add_module( 'relu3', nn.ReLU()) >>> model.add_module( 'dropout' , nn.Dropout(p= 0.5)) >>> model.add_module( 'fc2', nn.Linear( 1024, 10)) The last fully connected layer, named 'fc2' , has 10 output units for the 10 class labels in the MNIST dataset. In practice, we usually use the sofmax activation to obtain the class-membership probabili- ties of each input example, assuming that the classes are mutually exclusive, so the probabilities for each example", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 431, "start_word": 137920, "end_word": 138320, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000432": {"text": "with a dropout layer in between: >>> model.add_module( 'fc1', nn.Linear( 3136, 1024)) >>> model.add_module( 'relu3', nn.ReLU()) >>> model.add_module( 'dropout' , nn.Dropout(p= 0.5)) >>> model.add_module( 'fc2', nn.Linear( 1024, 10)) The last fully connected layer, named 'fc2' , has 10 output units for the 10 class labels in the MNIST dataset. In practice, we usually use the sofmax activation to obtain the class-membership probabili- ties of each input example, assuming that the classes are mutually exclusive, so the probabilities for each example sum to 1. However, the softmax function is already used internally inside PyTorch’s CrossEntropyLoss implementation, which is why don’t have to explicitly add it as a layer after the output layer above. The following code will create the loss function and optimizer for the model: >>> loss_fn = nn.CrossEntropyLoss() >>> optimizer = torch.optim.Adam(model.parameters(), lr= 0.001) Chapter 14 479 Now we can train the model by defining the following function: >>> def train(model, num_epochs, train_dl, valid_dl): ... loss_hist_train = [ 0] * num_epochs ... accuracy_hist_train = [ 0] * num_epochs ... loss_hist_valid = [ 0] * num_epochs ... accuracy_hist_valid = [ 0] * num_epochs ... for epoch in range (num_epochs): ... model.train() ... for x_batch, y_batch in train_dl: ... pred = model(x_batch) ... loss = loss_fn(pred, y_batch) ... loss.backward() ... optimizer.step() ... optimizer.zero_grad() ... loss_hist_train[epoch] += loss.item()*y_batch.size( 0) ... is_correct = ( ... torch.argmax(pred, dim= 1) == y_batch ... ). float() ... accuracy_hist_train[epoch] += is_correct. sum() ... loss_hist_train[epoch] /= len(train_dl.dataset) ... accuracy_hist_train[epoch] /= len(train_dl.dataset) ... ... model. eval()The Adam optimizer Note that in this implementation, we used the torch.optim.Adam class for training the CNN model. The Adam optimizer is a robust, gradient-based optimization method suited to nonconvex optimization and machine learning problems. Two popular optimization methods inspired Adam: RMSProp and AdaGrad . The key advantage of Adam is in the choice of update step size derived from the running average of gradient moments. Please feel free to read more about the Adam optimizer in the manuscript, Adam: A Method for Stochastic Optimization by Diederik P. Kingma and Jimmy Lei Ba, 2014. The article is freely available at https://arxiv.org/abs/1412.6980 . Classifying Images with Deep Convolutional Neural Networks 480 ... with torch.no_grad(): ... for x_batch, y_batch in valid_dl: ... pred = model(x_batch) ... loss = loss_fn(pred, y_batch) ... loss_hist_valid[epoch] += \\ ... loss.item()*y_batch.size( 0) ... is_correct = ( ... torch.argmax(pred, dim= 1) == y_batch ... ). float() ... accuracy_hist_valid[epoch] += is_correct. sum() ...", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 432, "start_word": 138240, "end_word": 138640, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000433": {"text": "Adam optimizer in the manuscript, Adam: A Method for Stochastic Optimization by Diederik P. Kingma and Jimmy Lei Ba, 2014. The article is freely available at https://arxiv.org/abs/1412.6980 . Classifying Images with Deep Convolutional Neural Networks 480 ... with torch.no_grad(): ... for x_batch, y_batch in valid_dl: ... pred = model(x_batch) ... loss = loss_fn(pred, y_batch) ... loss_hist_valid[epoch] += \\ ... loss.item()*y_batch.size( 0) ... is_correct = ( ... torch.argmax(pred, dim= 1) == y_batch ... ). float() ... accuracy_hist_valid[epoch] += is_correct. sum() ... loss_hist_valid[epoch] /= len(valid_dl.dataset) ... accuracy_hist_valid[epoch] /= len(valid_dl.dataset) ... ... print(f'Epoch {epoch+1} accuracy: ' ... f'{accuracy_hist_train[epoch]: .4f} val_accuracy: ' ... f'{accuracy_hist_valid[epoch]: .4f}') ... return loss_hist_train, loss_hist_valid, \\ ... accuracy_hist_train, accuracy_hist_valid Note that using the designated settings for training model.train() and evaluation model.eval() will automatically set the mode for the dropout layer and rescale the hidden units appropriately so that we do not have to worry about that at all. Next, we will train this CNN model and use the validation dataset that we created for monitoring the learning progress: >>> torch.manual_seed( 1) >>> num_epochs = 20 >>> hist = train(model, num_epochs, train_dl, valid_dl) Epoch 1 accuracy: 0.9503 val_accuracy: 0.9802 ... Epoch 9 accuracy: 0.9968 val_accuracy: 0.9892 ... Epoch 20 accuracy: 0.9979 val_accuracy: 0.9907 Once the 20 epochs of training are finished, we can visualize the learning curves: >>> import matplotlib.pyplot as plt >>> x_arr = np.arange( len(hist[0])) + 1 >>> fig = plt.figure(figsize=( 12, 4)) >>> ax = fig.add_subplot( 1, 2, 1) >>> ax.plot(x_arr, hist[ 0], '-o', label= 'Train loss' ) >>> ax.plot(x_arr, hist[ 1], '--<', label= 'Validation loss' ) Chapter 14 481 >>> ax.legend(fontsize= 15) >>> ax = fig.add_subplot( 1, 2, 2) >>> ax.plot(x_arr, hist[ 2], '-o', label= 'Train acc.' ) >>> ax.plot(x_arr, hist[ 3], '--<', ... label= 'Validation acc.' ) >>> ax.legend(fontsize= 15) >>> ax.set_xlabel( 'Epoch', size=15) >>> ax.set_ylabel( 'Accuracy' , size=15) >>> plt.show() Figure 14.13: Loss and accuracy graphs for the training and validation data Now, we evaluate the trained model on the test dataset: >>> pred = model(mnist_test_dataset.data.unsqueeze( 1) / 255.) >>> is_correct = ( ... torch.argmax(pred, dim= 1) == mnist_test_dataset.targets ... ).float() >>> print(f'Test accuracy: {is_correct.mean(): .4f}') Test accuracy: 0.9914 The CNN model achieves an accuracy of 99.07 percent. Remember that in Chapter 13, we got approx - imately 95 percent accuracy using only fully connected (instead of convolutional) layers. Finally, we can get the prediction results in the form of class-membership probabilities and convert them", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 433, "start_word": 138560, "end_word": 138960, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000434": {"text": "the trained model on the test dataset: >>> pred = model(mnist_test_dataset.data.unsqueeze( 1) / 255.) >>> is_correct = ( ... torch.argmax(pred, dim= 1) == mnist_test_dataset.targets ... ).float() >>> print(f'Test accuracy: {is_correct.mean(): .4f}') Test accuracy: 0.9914 The CNN model achieves an accuracy of 99.07 percent. Remember that in Chapter 13, we got approx - imately 95 percent accuracy using only fully connected (instead of convolutional) layers. Finally, we can get the prediction results in the form of class-membership probabilities and convert them to predicted labels by using the torch.argmax function to find the element with the maximum probability. We will do this for a batch of 12 examples and visualize the input and predicted labels: >>> fig = plt.figure(figsize=( 12, 4)) >>> for i in range (12): ... ax = fig.add_subplot( 2, 6, i+ 1) ... ax.set_xticks([]); ax.set_yticks([]) Classifying Images with Deep Convolutional Neural Networks 482 ... img = mnist_test_dataset[i][ 0][0, :, :] ... pred = model(img.unsqueeze( 0).unsqueeze( 1)) ... y_pred = torch.argmax(pred) ... ax.imshow(img, cmap= 'gray_r' ) ... ax.text( 0.9, 0.1, y_pred.item(), ... size= 15, color= 'blue', ... horizontalalignment= 'center' , ... verticalalignment= 'center' , ... transform=ax.transAxes) >>> plt.show() Figure 14.14 shows the handwritten inputs and their predicted labels: Figure 14.14: Predicted labels for handwritten digits In this set of plotted examples, all the predicted labels are correct. We leave the task of showing some of the misclassified digits, as we did in Chapter 11, Implementing a Multilayer Artificial Neural Network from Scratch, as an exercise for the reader. Smile classification from face images using a CNN In this section, we are going to implement a CNN for smile classification from face images using the CelebA dataset. As you saw in Chapter 12, the CelebA dataset contains 202,599 images of celebrities’ faces. In addition, 40 binary facial attributes are available for each image, including whether a celebrity is smiling (or not) and their age (young or old). Based on what you have learned so far, the goal of this section is to build and train a CNN model for predicting the smile attribute from these face images. Here, for simplicity, we will only be using a small portion of the training data (16,000 training examples) to speed up the training process. However, to improve the generalization performance and reduce overfitting on such a small dataset, we will use a technique called data augmentation. Chapter 14 483 Loading the CelebA dataset First,", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 434, "start_word": 138880, "end_word": 139280, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000435": {"text": "have learned so far, the goal of this section is to build and train a CNN model for predicting the smile attribute from these face images. Here, for simplicity, we will only be using a small portion of the training data (16,000 training examples) to speed up the training process. However, to improve the generalization performance and reduce overfitting on such a small dataset, we will use a technique called data augmentation. Chapter 14 483 Loading the CelebA dataset First, let’s load the data similarly to how we did in the previous section for the MNIST dataset. CelebA data comes in three partitions: a training dataset, a validation dataset, and a test dataset. Next, we will count the number of examples in each partition: >>> image_path = './' >>> celeba_train_dataset = torchvision.datasets.CelebA( ... image_path, split= 'train', ... target_type= 'attr', download= True ... ) >>> celeba_valid_dataset = torchvision.datasets.CelebA( ... image_path, split= 'valid', ... target_type= 'attr', download= True ... ) >>> celeba_test_dataset = torchvision.datasets.CelebA( ... image_path, split= 'test', ... target_type= 'attr', download= True ... ) >>> >>> print('Train set:' , len(celeba_train_dataset)) Train set: 162770 >>> print('Validation set:' , len(celeba_valid_dataset)) Validation: 19867 >>> print('Test set:' , len(celeba_test_dataset)) Test set: 19962 Next, we will discuss data augmentation as a technique for boosting the performance of deep NNs. Image transformation and data augmentation Data augmentation summarizes a broad set of techniques for dealing with cases where the train -Alternative ways to download the CelebA dataset The CelebA dataset is relatively large (approximately 1.5 GB) and the torchvision down- load link is notoriously unstable. If you encounter problems executing the previous code, you can download the files from the official CelebA website manually (https://mmlab. ie.cuhk.edu.hk/projects/CelebA.html ) or use our download link: https://drive. google.com/file/d/1m8-EBPgi5MRubrm6iQjafK2QMHDBMSfJ/view?usp=sharing. If you use our download link, it will download a celeba.zip file, which you need to unpack in the current directory where you are running the code. Also, after downloading and unzip - ping the celeba folder, you need to rerun the code above with the setting download=False instead of download=True . In case you are encountering problems with this approach, please do not hesitate to open a new issue or start a discussion at https://github.com/ rasbt/machine-learning-book so that we can provide you with additional information. Classifying Images with Deep Convolutional Neural Networks 484 ing data is limited. For instance, certain data augmentation techniques allow us to modify or even artificially synthesize more", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 435, "start_word": 139200, "end_word": 139600, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000436": {"text": "ping the celeba folder, you need to rerun the code above with the setting download=False instead of download=True . In case you are encountering problems with this approach, please do not hesitate to open a new issue or start a discussion at https://github.com/ rasbt/machine-learning-book so that we can provide you with additional information. Classifying Images with Deep Convolutional Neural Networks 484 ing data is limited. For instance, certain data augmentation techniques allow us to modify or even artificially synthesize more data and thereby boost the performance of a machine or deep learning model by reducing overfitting. While data augmentation is not only for image data, there is a set of transformations uniquely applicable to image data, such as cropping parts of an image, flipping, and changing the contrast, brightness, and saturation. Let’s see some of these transformations that are available via the torchvision.transforms module. In the following code block, we will first get five examples from the celeba_train_dataset dataset and apply five different types of transformation: 1) cropping an image to a bounding box, 2) flipping an image horizontally, 3) adjusting the contrast, 4) adjusting the brightness, and 5) center-cropping an image and resizing the resulting image back to its original size, (218, 178). In the following code, we will visualize the results of these transformations, showing each one in a separate column for comparison: >>> fig = plt.figure(figsize=( 16, 8.5)) >>> ## Column 1: cropping to a bounding-box >>> ax = fig.add_subplot( 2, 5, 1) >>> img, attr = celeba_train_dataset[ 0] >>> ax.set_title( 'Crop to a \\nbounding-box' , size=15) >>> ax.imshow(img) >>> ax = fig.add_subplot( 2, 5, 6) >>> img_cropped = transforms.functional.crop(img, 50, 20, 128 , 128) >>> ax.imshow(img_cropped) >>> >>> ## Column 2: flipping (horizontally) >>> ax = fig.add_subplot( 2, 5, 2) >>> img, attr = celeba_train_dataset[ 1] >>> ax.set_title( 'Flip (horizontal)' , size=15) >>> ax.imshow(img) >>> ax = fig.add_subplot( 2, 5, 7) >>> img_flipped = transforms.functional.hflip(img) >>> ax.imshow(img_flipped) >>> >>> ## Column 3: adjust contrast >>> ax = fig.add_subplot( 2, 5, 3) >>> img, attr = celeba_train_dataset[ 2] >>> ax.set_title( 'Adjust constrast' , size=15) >>> ax.imshow(img) >>> ax = fig.add_subplot( 2, 5, 8) >>> img_adj_contrast = transforms.functional.adjust_contrast( ... img, contrast_factor= 2 ... ) >>> ax.imshow(img_adj_contrast) >>> >>> ## Column 4: adjust brightness >>> ax = fig.add_subplot( 2, 5, 4) Chapter 14 485 >>> img, attr = celeba_train_dataset[ 3] >>> ax.set_title( 'Adjust brightness' , size=15) >>> ax.imshow(img) >>>", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 436, "start_word": 139520, "end_word": 139920, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000437": {"text": "ax.imshow(img_flipped) >>> >>> ## Column 3: adjust contrast >>> ax = fig.add_subplot( 2, 5, 3) >>> img, attr = celeba_train_dataset[ 2] >>> ax.set_title( 'Adjust constrast' , size=15) >>> ax.imshow(img) >>> ax = fig.add_subplot( 2, 5, 8) >>> img_adj_contrast = transforms.functional.adjust_contrast( ... img, contrast_factor= 2 ... ) >>> ax.imshow(img_adj_contrast) >>> >>> ## Column 4: adjust brightness >>> ax = fig.add_subplot( 2, 5, 4) Chapter 14 485 >>> img, attr = celeba_train_dataset[ 3] >>> ax.set_title( 'Adjust brightness' , size=15) >>> ax.imshow(img) >>> ax = fig.add_subplot( 2, 5, 9) >>> img_adj_brightness = transforms.functional.adjust_brightness( ... img, brightness_factor= 1.3 ... ) >>> ax.imshow(img_adj_brightness) >>> >>> ## Column 5: cropping from image center >>> ax = fig.add_subplot( 2, 5, 5) >>> img, attr = celeba_train_dataset[ 4] >>> ax.set_title( 'Center crop\\nand resize' , size=15) >>> ax.imshow(img) >>> ax = fig.add_subplot( 2, 5, 10) >>> img_center_crop = transforms.functional.center_crop( ... img, [ 0.7*218, 0.7*178] ... ) >>> img_resized = transforms.functional.resize( ... img_center_crop, size=( 218, 178) ... ) >>> ax.imshow(img_resized) >>> plt.show() Figure 14.15 shows the results: Figure 14.15: Different image transformations In Figure 14.15, the original images are shown in the first row and their transformed versions in the Classifying Images with Deep Convolutional Neural Networks 486 second row. Note that for the first transformation (leftmost column), the bounding box is specified by four numbers: the coordinate of the upper-left corner of the bounding box (here x=20, y=50), and the width and height of the box (width=128, height=128). Also note that the origin (the coordinates at the location denoted as (0, 0)) for images loaded by PyTorch (as well as other packages such as imageio ) is the upper-left corner of the image. The transformations in the previous code block are deterministic. However, all such transformations can also be randomized, which is recommended for data augmentation during model training. For example, a random bounding box (where the coordinates of the upper-left corner are selected ran- domly) can be cropped from an image, an image can be randomly flipped along either the horizontal or vertical axes with a probability of 0.5, or the contrast of an image can be changed randomly, where the contrast_factor is selected at random, but with uniform distribution, from a range of values. In addition, we can create a pipeline of these transformations. For example, we can first randomly crop an image, then flip it randomly, and finally, resize it to the desired size. The code", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 437, "start_word": 139840, "end_word": 140240, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000438": {"text": "from an image, an image can be randomly flipped along either the horizontal or vertical axes with a probability of 0.5, or the contrast of an image can be changed randomly, where the contrast_factor is selected at random, but with uniform distribution, from a range of values. In addition, we can create a pipeline of these transformations. For example, we can first randomly crop an image, then flip it randomly, and finally, resize it to the desired size. The code is as follows (since we have random elements, we set the random seed for reproducibility): >>> torch.manual_seed( 1) >>> fig = plt.figure(figsize=( 14, 12)) >>> for i, (img, attr) in enumerate (celeba_train_dataset): ... ax = fig.add_subplot( 3, 4, i* 4+1) ... ax.imshow(img) ... if i == 0: ... ax.set_title( 'Orig.', size=15) ... ... ax = fig.add_subplot( 3, 4, i* 4+2) ... img_transform = transforms.Compose([ ... transforms.RandomCrop([ 178, 178]) ... ]) ... img_cropped = img_transform(img) ... ax.imshow(img_cropped) ... if i == 0: ... ax.set_title( 'Step 1: Random crop' , size=15) ... ... ax = fig.add_subplot( 3, 4, i* 4+3) ... img_transform = transforms.Compose([ ... transforms.RandomHorizontalFlip() ... ]) ... img_flip = img_transform(img_cropped) ... ax.imshow(img_flip) ... if i == 0: ... ax.set_title( 'Step 2: Random flip' , size=15) Chapter 14 487 ... ... ax = fig.add_subplot( 3, 4, i* 4+4) ... img_resized = transforms.functional.resize( ... img_flip, size=( 128, 128) ... ) ... ax.imshow(img_resized) ... if i == 0: ... ax.set_title( 'Step 3: Resize' , size=15) ... if i == 2: ... break >>> plt.show() Figure 14.16 shows random transformations on three example images: Figure 14.16: Random image transformations Note that each time we iterate through these three examples, we get slightly different images due to random transformations. For convenience, we can define transform functions to use this pipeline for data augmentation during Classifying Images with Deep Convolutional Neural Networks 488 dataset loading. In the following code, we will define the function get_smile , which will extract the smile label from the 'attributes' list: >>> get_smile = lambda attr: attr[ 18] We will define the transform_train function that will produce the transformed image (where we will first randomly crop the image, then flip it randomly, and finally, resize it to the desired size 64×64): >>> transform_train = transforms.Compose([ ... transforms.RandomCrop([ 178, 178]), ... transforms.RandomHorizontalFlip(), ... transforms.Resize([ 64, 64]), ... transforms.ToTensor(), ... ]) We will only apply data augmentation to the training examples, however, and", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 438, "start_word": 140160, "end_word": 140560, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000439": {"text": "which will extract the smile label from the 'attributes' list: >>> get_smile = lambda attr: attr[ 18] We will define the transform_train function that will produce the transformed image (where we will first randomly crop the image, then flip it randomly, and finally, resize it to the desired size 64×64): >>> transform_train = transforms.Compose([ ... transforms.RandomCrop([ 178, 178]), ... transforms.RandomHorizontalFlip(), ... transforms.Resize([ 64, 64]), ... transforms.ToTensor(), ... ]) We will only apply data augmentation to the training examples, however, and not to the validation or test images. The code for the validation or test set is as follows (where we will first simply crop the image and then resize it to the desired size 64×64): >>> transform = transforms.Compose([ ... transforms.CenterCrop([ 178, 178]), ... transforms.Resize([ 64, 64]), ... transforms.ToTensor(), ... ]) Now, to see data augmentation in action, let’s apply the transform_train function to our training dataset and iterate over the dataset five times: >>> from torch.utils.data import DataLoader >>> celeba_train_dataset = torchvision.datasets.CelebA( ... image_path, split= 'train', ... target_type= 'attr', download= False, ... transform=transform_train, target_transform=get_smile ... ) >>> torch.manual_seed( 1) >>> data_loader = DataLoader(celeba_train_dataset, batch_size= 2) >>> fig = plt.figure(figsize=( 15, 6)) >>> num_epochs = 5 >>> for j in range (num_epochs): ... img_batch, label_batch = next(iter(data_loader)) ... img = img_batch[ 0] Chapter 14 489 ... ax = fig.add_subplot( 2, 5, j + 1) ... ax.set_xticks([]) ... ax.set_yticks([]) ... ax.set_title( f'Epoch {j}:', size= 15) ... ax.imshow(img.permute( 1, 2, 0)) ... ... img = img_batch[ 1] ... ax = fig.add_subplot( 2, 5, j + 6) ... ax.set_xticks([]) ... ax.set_yticks([]) ... ax.imshow(img.permute( 1, 2, 0)) >>> plt.show() Figure 14.17 shows the five resulting transformations for data augmentation on two example images: Figure 14.17: The result of five image transformations Next, we will apply the transform function to our validation and test datasets: >>> celeba_valid_dataset = torchvision.datasets.CelebA( ... image_path, split= 'valid', ... target_type= 'attr', download= False, ... transform=transform, target_transform=get_smile ... ) >>> celeba_test_dataset = torchvision.datasets.CelebA( ... image_path, split= 'test', ... target_type= 'attr', download= False, ... transform=transform, target_transform=get_smile ... ) Classifying Images with Deep Convolutional Neural Networks 490 Furthermore, instead of using all the available training and validation data, we will take a subset of 16,000 training examples and 1,000 examples for validation, as our goal here is to intentionally train our model with a small dataset: >>> from torch.utils.data import Subset >>> celeba_train_dataset = Subset(celeba_train_dataset, ... torch.arange( 16000)) >>> celeba_valid_dataset = Subset(celeba_valid_dataset, ...", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 439, "start_word": 140480, "end_word": 140880, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000440": {"text": "= torchvision.datasets.CelebA( ... image_path, split= 'test', ... target_type= 'attr', download= False, ... transform=transform, target_transform=get_smile ... ) Classifying Images with Deep Convolutional Neural Networks 490 Furthermore, instead of using all the available training and validation data, we will take a subset of 16,000 training examples and 1,000 examples for validation, as our goal here is to intentionally train our model with a small dataset: >>> from torch.utils.data import Subset >>> celeba_train_dataset = Subset(celeba_train_dataset, ... torch.arange( 16000)) >>> celeba_valid_dataset = Subset(celeba_valid_dataset, ... torch.arange( 1000)) >>> print('Train set:' , len(celeba_train_dataset)) Train set: 16000 >>> print('Validation set:' , len(celeba_valid_dataset)) Validation set: 1000 Now, we can create data loaders for three datasets: >>> batch_size = 32 >>> torch.manual_seed( 1) >>> train_dl = DataLoader(celeba_train_dataset, ... batch_size, shuffle= True) >>> valid_dl = DataLoader(celeba_valid_dataset, ... batch_size, shuffle= False) >>> test_dl = DataLoader(celeba_test_dataset, ... batch_size, shuffle= False) Now that the data loaders are ready, we will develop a CNN model, and train and evaluate it in the next section. Training a CNN smile classifier By now, building a model with torch.nn module and training it should be straightforward. The design of our CNN is as follows: the CNN model receives input images of size 3×64×64 (the images have three color channels). The input data goes through four convolutional layers to make 32, 64, 128, and 256 feature maps using filters with a kernel size of 3×3 and padding of 1 for same padding. The first three convolution layers are followed by max-pooling, P 2×2. Two dropout layers are also included for regularization: >>> model = nn.Sequential() >>> model.add_module( ... 'conv1', ... nn.Conv2d( ... in_channels= 3, out_channels= 32, ... kernel_size= 3, padding= 1 ... ) Chapter 14 491 ... ) >>> model.add_module( 'relu1', nn.ReLU()) >>> model.add_module( 'pool1', nn.MaxPool2d(kernel_size= 2)) >>> model.add_module( 'dropout1' , nn.Dropout(p= 0.5)) >>> >>> model.add_module( ... 'conv2', ... nn.Conv2d( ... in_channels= 32, out_channels= 64, ... kernel_size= 3, padding= 1 ... ) ... ) >>> model.add_module( 'relu2', nn.ReLU()) >>> model.add_module( 'pool2', nn.MaxPool2d(kernel_size= 2)) >>> model.add_module( 'dropout2' , nn.Dropout(p= 0.5)) >>> >>> model.add_module( ... 'conv3', ... nn.Conv2d( ... in_channels= 64, out_channels= 128, ... kernel_size= 3, padding= 1 ... ) ... ) >>> model.add_module( 'relu3', nn.ReLU()) >>> model.add_module( 'pool3', nn.MaxPool2d(kernel_size= 2)) >>> >>> model.add_module( ... 'conv4', ... nn.Conv2d( ... in_channels= 128, out_channels= 256, ... kernel_size= 3, padding= 1 ... ) ... ) >>> model.add_module( 'relu4', nn.ReLU()) Let’s see the shape of the output feature maps after applying these layers using", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 440, "start_word": 140800, "end_word": 141200, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000441": {"text": ">>> model.add_module( 'pool2', nn.MaxPool2d(kernel_size= 2)) >>> model.add_module( 'dropout2' , nn.Dropout(p= 0.5)) >>> >>> model.add_module( ... 'conv3', ... nn.Conv2d( ... in_channels= 64, out_channels= 128, ... kernel_size= 3, padding= 1 ... ) ... ) >>> model.add_module( 'relu3', nn.ReLU()) >>> model.add_module( 'pool3', nn.MaxPool2d(kernel_size= 2)) >>> >>> model.add_module( ... 'conv4', ... nn.Conv2d( ... in_channels= 128, out_channels= 256, ... kernel_size= 3, padding= 1 ... ) ... ) >>> model.add_module( 'relu4', nn.ReLU()) Let’s see the shape of the output feature maps after applying these layers using a toy batch input (four images arbitrarily): >>> x = torch.ones(( 4, 3, 64, 64)) >>> model(x).shape torch.Size([4, 256, 8, 8]) Classifying Images with Deep Convolutional Neural Networks 492 There are 256 feature maps (or channels) of size 8×8. Now, we can add a fully connected layer to get to the output layer with a single unit. If we reshape (flatten) the feature maps, the number of input units to this fully connected layer will be 8 × 8 × 256 = 16,384. Alternatively, let’s consider a new layer, called global average-pooling, which computes the average of each feature map separately, thereby reducing the hidden units to 256. We can then add a fully connected layer. Although we have not dis- cussed global average-pooling explicitly, it is conceptually very similar to other pooling layers. Global average-pooling can be viewed, in fact, as a special case of average-pooling when the pooling size is equal to the size of the input feature maps. To understand this, consider Figure 14.18, showing an example of input feature maps of shape batch- size×8×64×64. The channels are numbered k =0, 1, ..., 7. The global average-pooling operation calculates the average of each channel so that the output will have the shape [batchsize×8]. After this, we will squeeze the output of the global average-pooling layer. Without squeezing the output, the shape would be [batchsize×8×1×1], as the global average-pooling would reduce the spatial dimension of 64×64 to 1×1: Figure 14.18: Input feature maps Therefore, given that, in our case, the shape of the feature maps prior to this layer is [batchsize×256×8×8], we expect to get 256 units as output, that is, the shape of the output will be [batchsize×256]. Let’s add this layer and recompute the output shape to verify that this is true: >>> model.add_module( 'pool4', nn.AvgPool2d(kernel_size= 8)) >>> model.add_module( 'flatten' , nn.Flatten()) >>> x = torch.ones(( 4, 3, 64, 64)) >>> model(x).shape Chapter 14 493 torch.Size([4,", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 441, "start_word": 141120, "end_word": 141520, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000442": {"text": "Figure 14.18: Input feature maps Therefore, given that, in our case, the shape of the feature maps prior to this layer is [batchsize×256×8×8], we expect to get 256 units as output, that is, the shape of the output will be [batchsize×256]. Let’s add this layer and recompute the output shape to verify that this is true: >>> model.add_module( 'pool4', nn.AvgPool2d(kernel_size= 8)) >>> model.add_module( 'flatten' , nn.Flatten()) >>> x = torch.ones(( 4, 3, 64, 64)) >>> model(x).shape Chapter 14 493 torch.Size([4, 256]) Finally, we can add a fully connected layer to get a single output unit. In this case, we can specify the activation function to be 'sigmoid' : >>> model.add_module( 'fc', nn.Linear( 256, 1)) >>> model.add_module( 'sigmoid' , nn.Sigmoid()) >>> x = torch.ones(( 4, 3, 64, 64)) >>> model(x).shape torch.Size([4, 1]) >>> model Sequential( (conv1): Conv2d(3, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (relu1): ReLU() (pool1): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_ mode=False) (dropout1): Dropout(p=0.5, inplace=False) (conv2): Conv2d(32, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (relu2): ReLU() (pool2): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_ mode=False) (dropout2): Dropout(p=0.5, inplace=False) (conv3): Conv2d(64, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (relu3): ReLU() (pool3): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_ mode=False) (conv4): Conv2d(128, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (relu4): ReLU() (pool4): AvgPool2d(kernel_size=8, stride=8, padding=0) (flatten): Flatten(start_dim=1, end_dim=-1) (fc): Linear(in_features=256, out_features=1, bias=True) (sigmoid): Sigmoid() ) The next step is to create a loss function and optimizer (Adam optimizer again). For a binary classifi- cation with a single probabilistic output, we use BCELoss for the loss function: >>> loss_fn = nn.BCELoss() >>> optimizer = torch.optim.Adam(model.parameters(), lr= 0.001) Classifying Images with Deep Convolutional Neural Networks 494 Now we can train the model by defining the following function: >>> def train(model, num_epochs, train_dl, valid_dl): ... loss_hist_train = [ 0] * num_epochs ... accuracy_hist_train = [ 0] * num_epochs ... loss_hist_valid = [ 0] * num_epochs ... accuracy_hist_valid = [ 0] * num_epochs ... for epoch in range (num_epochs): ... model.train() ... for x_batch, y_batch in train_dl: ... pred = model(x_batch)[:, 0] ... loss = loss_fn(pred, y_batch.float()) ... loss.backward() ... optimizer.step() ... optimizer.zero_grad() ... loss_hist_train[epoch] += loss.item()*y_batch.size( 0) ... is_correct = ((pred>= 0.5).float() == y_batch). float() ... accuracy_hist_train[epoch] += is_correct. sum() ... loss_hist_train[epoch] /= len(train_dl.dataset) ... accuracy_hist_train[epoch] /= len(train_dl.dataset) ... ... model. eval() ... with torch.no_grad(): ... for x_batch, y_batch in valid_dl: ... pred = model(x_batch)[:, 0] ... loss = loss_fn(pred, y_batch.float()) ... loss_hist_valid[epoch] += \\ ... loss.item() * y_batch.size(", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 442, "start_word": 141440, "end_word": 141840, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000443": {"text": "model.train() ... for x_batch, y_batch in train_dl: ... pred = model(x_batch)[:, 0] ... loss = loss_fn(pred, y_batch.float()) ... loss.backward() ... optimizer.step() ... optimizer.zero_grad() ... loss_hist_train[epoch] += loss.item()*y_batch.size( 0) ... is_correct = ((pred>= 0.5).float() == y_batch). float() ... accuracy_hist_train[epoch] += is_correct. sum() ... loss_hist_train[epoch] /= len(train_dl.dataset) ... accuracy_hist_train[epoch] /= len(train_dl.dataset) ... ... model. eval() ... with torch.no_grad(): ... for x_batch, y_batch in valid_dl: ... pred = model(x_batch)[:, 0] ... loss = loss_fn(pred, y_batch.float()) ... loss_hist_valid[epoch] += \\ ... loss.item() * y_batch.size( 0) ... is_correct = \\ ... ((pred>= 0.5).float() == y_batch). float() ... accuracy_hist_valid[epoch] += is_correct. sum() ... loss_hist_valid[epoch] /= len(valid_dl.dataset) ... accuracy_hist_valid[epoch] /= len(valid_dl.dataset) ... ... print(f'Epoch {epoch+1} accuracy: ' ... f'{accuracy_hist_train[epoch]: .4f} val_accuracy: ' ... f'{accuracy_hist_valid[epoch]: .4f}') ... return loss_hist_train, loss_hist_valid, \\ ... accuracy_hist_train, accuracy_hist_valid Chapter 14 495 Next, we will train this CNN model for 30 epochs and use the validation dataset that we created for monitoring the learning progress: >>> torch.manual_seed( 1) >>> num_epochs = 30 >>> hist = train(model, num_epochs, train_dl, valid_dl) Epoch 1 accuracy: 0.6286 val_accuracy: 0.6540 ... Epoch 15 accuracy: 0.8544 val_accuracy: 0.8700 ... Epoch 30 accuracy: 0.8739 val_accuracy: 0.8710 Let’s now visualize the learning curve and compare the training and validation loss and accuracies after each epoch: >>> x_arr = np.arange( len(hist[0])) + 1 >>> fig = plt.figure(figsize=( 12, 4)) >>> ax = fig.add_subplot( 1, 2, 1) >>> ax.plot(x_arr, hist[ 0], '-o', label= 'Train loss' ) >>> ax.plot(x_arr, hist[ 1], '--<', label= 'Validation loss' ) >>> ax.legend(fontsize= 15) >>> ax = fig.add_subplot( 1, 2, 2) >>> ax.plot(x_arr, hist[ 2], '-o', label= 'Train acc.' ) >>> ax.plot(x_arr, hist[ 3], '--<', ... label= 'Validation acc.' ) >>> ax.legend(fontsize= 15) >>> ax.set_xlabel( 'Epoch', size=15) >>> ax.set_ylabel( 'Accuracy' , size=15) >>> plt.show() Figure 14.19: A comparison of the training and validation results Classifying Images with Deep Convolutional Neural Networks 496 Once we are happy with the learning curves, we can evaluate the model on the hold-out test dataset: >>> accuracy_test = 0 >>> model.eval() >>> with torch.no_grad(): ... for x_batch, y_batch in test_dl: ... pred = model(x_batch)[:, 0] ... is_correct = ((pred>= 0.5).float() == y_batch). float() ... accuracy_test += is_correct. sum() >>> accuracy_test /= len(test_dl.dataset) >>> print(f'Test accuracy: {accuracy_test: .4f}') Test accuracy: 0.8446 Finally, we already know how to get the prediction results on some test examples. In the following code, we will take a small subset of 10 examples from the last batch of our pre-processed", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 443, "start_word": 141760, "end_word": 142160, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000444": {"text": "dataset: >>> accuracy_test = 0 >>> model.eval() >>> with torch.no_grad(): ... for x_batch, y_batch in test_dl: ... pred = model(x_batch)[:, 0] ... is_correct = ((pred>= 0.5).float() == y_batch). float() ... accuracy_test += is_correct. sum() >>> accuracy_test /= len(test_dl.dataset) >>> print(f'Test accuracy: {accuracy_test: .4f}') Test accuracy: 0.8446 Finally, we already know how to get the prediction results on some test examples. In the following code, we will take a small subset of 10 examples from the last batch of our pre-processed test dataset (test_dl ). Then, we will compute the probabilities of each example being from class 1 (which corre - sponds to smile based on the labels provided in CelebA) and visualize the examples along with their ground truth label and the predicted probabilities: >>> pred = model(x_batch)[:, 0] * 100 >>> fig = plt.figure(figsize=( 15, 7)) >>> for j in range (10, 20): ... ax = fig.add_subplot( 2, 5, j-10+1) ... ax.set_xticks([]); ax.set_yticks([]) ... ax.imshow(x_batch[j].permute( 1, 2, 0)) ... if y_batch[j] == 1: ... label= 'Smile' ... else: ... label = 'Not Smile' ... ax.text( ... 0.5, -0.15, ... f'GT: {label:s} \\nPr(Smile)= {pred[j]: .0f}%', ... size= 16, ... horizontalalignment= 'center' , ... verticalalignment= 'center' , ... transform=ax.transAxes ... ) >>> plt.show() Chapter 14 497 In Figure 14.20, you can see 10 example images along with their ground truth labels and the probabil- ities that they belong to class 1, smile: Figure 14.20: Image labels and their probabilities that they belong to class 1 The probabilities of class 1 (that is, smile according to CelebA) are provided below each image. As you can see, our trained model is completely accurate on this set of 10 test examples. As an optional exercise, you are encouraged to try using the entire training dataset instead of the small subset we created. Furthermore, you can change or modify the CNN architecture. For example, you can change the dropout probabilities and the number of filters in the different convolutional layers. Also, you could replace the global average-pooling with a fully connected layer. If you are using the entire training dataset with the CNN architecture we trained in this chapter, you should be able to achieve above 90 percent accuracy. Summary In this chapter, we learned about CNNs and their main components. We started with the convolution operation and looked at 1D and 2D implementations. Then, we covered another type of layer that is found in", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 444, "start_word": 142080, "end_word": 142480, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000445": {"text": "in the different convolutional layers. Also, you could replace the global average-pooling with a fully connected layer. If you are using the entire training dataset with the CNN architecture we trained in this chapter, you should be able to achieve above 90 percent accuracy. Summary In this chapter, we learned about CNNs and their main components. We started with the convolution operation and looked at 1D and 2D implementations. Then, we covered another type of layer that is found in several common CNN architectures: the subsampling or so-called pooling layers. We primarily focused on the two most common forms of pooling: max-pooling and average-pooling. Next, putting all these individual concepts together, we implemented deep CNNs using the torch.nn module. The first network we implemented was applied to the already familiar MNIST handwritten digit recognition problem. Then, we implemented a second CNN on a more complex dataset consisting of face images and trained the CNN for smile classification. Along the way, you also learned about data augmentation and dif- ferent transformations that we can apply to face images using the torchvision.transforms module. Classifying Images with Deep Convolutional Neural Networks 498 In the next chapter, we will move on to recurrent neural networks (RNNs ). RNNs are used for learn- ing the structure of sequence data, and they have some fascinating applications, including language translation and image captioning. Join our book’s Discord space Join the book’s Discord workspace for a monthly Ask me Anything session with the authors: https://packt.link/MLwPyTorch 15 Modeling Sequential Data Using Recurrent Neural Networks In the previous chapter, we focused on convolutional neural networks (CNNs). We covered the build- ing blocks of CNN architectures and how to implement deep CNNs in PyTorch. Finally, you learned how to use CNNs for image classification. In this chapter, we will explore recurrent neural networks (RNNs ) and see their application in modeling sequential data. We will cover the following topics: • Introducing sequential data • RNNs for modeling sequences • Long short-term memory • Truncated backpropagation through time • Implementing a multilayer RNN for sequence modeling in PyTorch • Project one: RNN sentiment analysis of the IMDb movie review dataset • Project two: RNN character-level language modeling with LSTM cells, using text data from Jules Verne’s The Mysterious Island • Using gradient clipping to avoid exploding gradients Introducing sequential data Let’s begin our discussion of RNNs by looking at the nature of", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 445, "start_word": 142400, "end_word": 142800, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000446": {"text": "sequential data • RNNs for modeling sequences • Long short-term memory • Truncated backpropagation through time • Implementing a multilayer RNN for sequence modeling in PyTorch • Project one: RNN sentiment analysis of the IMDb movie review dataset • Project two: RNN character-level language modeling with LSTM cells, using text data from Jules Verne’s The Mysterious Island • Using gradient clipping to avoid exploding gradients Introducing sequential data Let’s begin our discussion of RNNs by looking at the nature of sequential data, which is more com- monly known as sequence data or sequences. We will look at the unique properties of sequences that make them different from other kinds of data. We will then see how to represent sequential data and explore the various categories of models for sequential data, which are based on the input and output of a model. This will help us to explore the relationship between RNNs and sequences in this chapter. Modeling Sequential Data Using Recurrent Neural Networks 500 Modeling sequential data – order matters What makes sequences unique, compared to other types of data, is that elements in a sequence ap - pear in a certain order and are not independent of each other. Typical machine learning algorithms for supervised learning assume that the input is independent and identically distributed (IID) data, which means that the training examples are mutually independent and have the same underlying distribution. In this regard, based on the mutual independence assumption, the order in which the training examples are given to the model is irrelevant. For example, if we have a sample consisting of n training examples, x(1), x(2), ..., x(n), the order in which we use the data for training our machine learning algorithm does not matter. An example of this scenario would be the Iris dataset that we worked with previously. In the Iris dataset, each flower has been measured independently, and the measurements of one flower do not influence the measurements of another flower. However, this assumption is not valid when we deal with sequences—by definition, order matters. Predicting the market value of a particular stock would be an example of this scenario. For instance, assume we have a sample of n training examples, where each training example represents the market value of a certain stock on a particular day. If our task is to predict the stock market value for the next three days, it", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 446, "start_word": 142720, "end_word": 143120, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000447": {"text": "do not influence the measurements of another flower. However, this assumption is not valid when we deal with sequences—by definition, order matters. Predicting the market value of a particular stock would be an example of this scenario. For instance, assume we have a sample of n training examples, where each training example represents the market value of a certain stock on a particular day. If our task is to predict the stock market value for the next three days, it would make sense to consider the previous stock prices in a date-sorted order to derive trends rather than utilize these training examples in a randomized order. Sequential data versus time series data Time series data is a special type of sequential data where each example is associated with a dimen- sion for time. In time series data, samples are taken at successive timestamps, and therefore, the time dimension determines the order among the data points. For example, stock prices and voice or speech records are time series data. On the other hand, not all sequential data has the time dimension. For example, in text data or DNA sequences, the examples are ordered, but text or DNA does not qualify as time series data. As you will see, in this chapter, we will focus on examples of natural language processing (NLP) and text modeling that are not time series data. However, note that RNNs can also be used for time series data, which is beyond the scope of this book. Representing sequences We’ve established that order among data points is important in sequential data, so we next need to find a way to leverage this ordering information in a machine learning model. Throughout this chapter, we will represent sequences as 〈𝒙𝒙(1),𝒙𝒙(2),…,𝒙𝒙(𝑇𝑇)〉 . The superscript indices indicate the order of the instances, and the length of the sequence is T. For a sensible example of sequences, consider time series data, where each example point, x(t), belongs to a particular time, t . Figure 15.1 shows an example of time series data where both the input features (x’s) and the target labels (y’s) naturally follow the order according to their time axis; therefore, both the x’s and y’s are sequences. Chapter 15 501 Figure 15.1: An example of time series data As we have already mentioned, the standard NN models that we have covered so far, such as multilayer perceptrons (MLPs ) and", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 447, "start_word": 143040, "end_word": 143440, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000448": {"text": "example point, x(t), belongs to a particular time, t . Figure 15.1 shows an example of time series data where both the input features (x’s) and the target labels (y’s) naturally follow the order according to their time axis; therefore, both the x’s and y’s are sequences. Chapter 15 501 Figure 15.1: An example of time series data As we have already mentioned, the standard NN models that we have covered so far, such as multilayer perceptrons (MLPs ) and CNNs for image data, assume that the training examples are independent of each other and thus do not incorporate ordering information. We can say that such models do not have a memory of previously seen training examples. For instance, the samples are passed through the feedforward and backpropagation steps, and the weights are updated independently of the order in which the training examples are processed. RNNs, by contrast, are designed for modeling sequences and are capable of remembering past informa - tion and processing new events accordingly, which is a clear advantage when working with sequence data. The different categories of sequence modeling Sequence modeling has many fascinating applications, such as language translation (for example, translating text from English to German), image captioning, and text generation. However, in order to choose an appropriate architecture and approach, we have to understand and be able to distinguish between these different sequence modeling tasks. Figure 15.2, based on the explanations in the excellent article The Unreasonable Effectiveness of Recurrent Neural Networks, by Andrej Karpathy, 2015 ( http:// karpathy.github.io/2015/05/21/rnn-effectiveness/ ), summarizes the most common sequence modeling tasks, which depend on the relationship categories of input and output data. Figure 15.2: The most common sequencing tasks Modeling Sequential Data Using Recurrent Neural Networks 502 Let’s discuss the different relationship categories between input and output data, which were depicted in the previous figure, in more detail. If neither the input nor output data represent sequences, then we are dealing with standard data, and we could simply use a multilayer perceptron (or another clas- sification model previously covered in this book) to model such data. However, if either the input or output is a sequence, the modeling task likely falls into one of these categories: • Many-to-one: The input data is a sequence, but the output is a fixed-size vector or scalar, not a sequence. For example, in sentiment analysis, the input is text-based (for example, a", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 448, "start_word": 143360, "end_word": 143760, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000449": {"text": "we are dealing with standard data, and we could simply use a multilayer perceptron (or another clas- sification model previously covered in this book) to model such data. However, if either the input or output is a sequence, the modeling task likely falls into one of these categories: • Many-to-one: The input data is a sequence, but the output is a fixed-size vector or scalar, not a sequence. For example, in sentiment analysis, the input is text-based (for example, a movie review) and the output is a class label (for example, a label denoting whether a reviewer liked the movie). • One-to-many: The input data is in standard format and not a sequence, but the output is a sequence. An example of this category is image captioning—the input is an image and the output is an English phrase summarizing the content of that image. • Many-to-many : Both the input and output arrays are sequences. This category can be further divided based on whether the input and output are synchronized. An example of a synchronized many-to-many modeling task is video classification, where each frame in a video is labeled. An example of a delayed many-to-many modeling task would be translating one language into another. For instance, an entire English sentence must be read and processed by a machine before its translation into German is produced. Now, after summarizing the three broad categories of sequence modeling, we can move forward to discussing the structure of an RNN. RNNs for modeling sequences In this section, before we start implementing RNNs in PyTorch, we will discuss the main concepts of RNNs. We will begin by looking at the typical structure of an RNN, which includes a recursive com- ponent to model sequence data. Then, we will examine how the neuron activations are computed in a typical RNN. This will create a context for us to discuss the common challenges in training RNNs, and we will then discuss solutions to these challenges, such as LSTM and gated recurrent units ( GRUs ). Understanding the dataflow in RNNs Let’s start with the architecture of an RNN. Figure 15.3 shows the dataflow in a standard feedforward NN and in an RNN side by side for comparison: Figure 15.3: The dataflow of a standard feedforward NN and an RNN Chapter 15 503 Both of these networks have only one hidden layer. In this representation, the units are", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 449, "start_word": 143680, "end_word": 144080, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000450": {"text": "we will then discuss solutions to these challenges, such as LSTM and gated recurrent units ( GRUs ). Understanding the dataflow in RNNs Let’s start with the architecture of an RNN. Figure 15.3 shows the dataflow in a standard feedforward NN and in an RNN side by side for comparison: Figure 15.3: The dataflow of a standard feedforward NN and an RNN Chapter 15 503 Both of these networks have only one hidden layer. In this representation, the units are not displayed, but we assume that the input layer (x), hidden layer (h), and output layer (o) are vectors that contain many units. In a standard feedforward network, information flows from the input to the hidden layer, and then from the hidden layer to the output layer. On the other hand, in an RNN, the hidden layer receives its input from both the input layer of the current time step and the hidden layer from the previous time step. The flow of information in adjacent time steps in the hidden layer allows the network to have a mem- ory of past events. This flow of information is usually displayed as a loop, also known as a recurrent edge in graph notation, which is how this general RNN architecture got its name. Similar to multilayer perceptrons, RNNs can consist of multiple hidden layers. Note that it’s a common convention to refer to RNNs with one hidden layer as a single-layer RNN, which is not to be confused with single-layer NNs without a hidden layer, such as Adaline or logistic regression. Figure 15.4 illus- trates an RNN with one hidden layer (top) and an RNN with two hidden layers (bottom): Figure 15.4: Examples of an RNN with one and two hidden layersDetermining the type of output from an RNN This generic RNN architecture could correspond to the two sequence modeling catego - ries where the input is a sequence. Typically, a recurrent layer can return a sequence as output, 〈𝒐𝒐(0),𝒐𝒐(1),…,𝒐𝒐(𝑇𝑇)〉 , or simply return the last output (at t = T, that is, o(T)). Thus, it could be either many-to-many, or it could be many-to-one if, for example, we only use the last element, o(T), as the final output. We will see later how this is handled in the PyTorch torch.nn module, when we take a de - tailed look at the behavior of a recurrent layer with respect to returning a", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 450, "start_word": 144000, "end_word": 144400, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000451": {"text": "layer can return a sequence as output, 〈𝒐𝒐(0),𝒐𝒐(1),…,𝒐𝒐(𝑇𝑇)〉 , or simply return the last output (at t = T, that is, o(T)). Thus, it could be either many-to-many, or it could be many-to-one if, for example, we only use the last element, o(T), as the final output. We will see later how this is handled in the PyTorch torch.nn module, when we take a de - tailed look at the behavior of a recurrent layer with respect to returning a sequence as output. Modeling Sequential Data Using Recurrent Neural Networks 504 To examine the architecture of RNNs and the flow of information, a compact representation with a recurrent edge can be unfolded, which you can see in Figure 15.4. As we know, each hidden unit in a standard NN receives only one input—the net preactivation as - sociated with the input layer. In contrast, each hidden unit in an RNN receives two distinct sets of input—the preactivation from the input layer and the activation of the same hidden layer from the previous time step, t – 1. At the first time step, t = 0, the hidden units are initialized to zeros or small random values. Then, at a time step where t > 0, the hidden units receive their input from the data point at the current time, x(t), and the previous values of hidden units at t – 1, indicated as h(t–1). Similarly, in the case of a multilayer RNN, we can summarize the information flow as follows: • layer = 1: Here, the hidden layer is represented as 𝒉𝒉1(𝑡𝑡) and it receives its input from the data point, x(t), and the hidden values in the same layer, but at the previous time step, 𝒉𝒉1(𝑡𝑡𝑡1) . • layer = 2: The second hidden layer, 𝒉𝒉2(𝑡𝑡) , receives its inputs from the outputs of the layer below at the current time step ( 𝒐𝒐1(𝑡𝑡) ) and its own hidden values from the previous time step, 𝒉𝒉2(𝑡𝑡𝑡𝑡) . Since, in this case, each recurrent layer must receive a sequence as input, all the recurrent layers except the last one must return a sequence as output (that is, we will later have to set return_sequences=True ). The behavior of the last recurrent layer depends on the type of problem. Computing activations in an RNN Now that you understand the structure and general flow of information in an RNN, let’s get more", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 451, "start_word": 144320, "end_word": 144720, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000452": {"text": "values from the previous time step, 𝒉𝒉2(𝑡𝑡𝑡𝑡) . Since, in this case, each recurrent layer must receive a sequence as input, all the recurrent layers except the last one must return a sequence as output (that is, we will later have to set return_sequences=True ). The behavior of the last recurrent layer depends on the type of problem. Computing activations in an RNN Now that you understand the structure and general flow of information in an RNN, let’s get more spe - cific and compute the actual activations of the hidden layers, as well as the output layer. For simplicity, we will consider just a single hidden layer; however, the same concept applies to multilayer RNNs. Each directed edge (the connections between boxes) in the representation of an RNN that we just looked at is associated with a weight matrix. Those weights do not depend on time, t; therefore, they are shared across the time axis. The different weight matrices in a single-layer RNN are as follows: • Wxh: The weight matrix between the input, x(t), and the hidden layer, h • Whh: The weight matrix associated with the recurrent edge • Who: The weight matrix between the hidden layer and output layer These weight matrices are depicted in Figure 15.5: Figure 15.5: Applying weights to a single-layer RNN Chapter 15 505 In certain implementations, you may observe that the weight matrices, W xh and W hh, are concatenated to a combined matrix, W h = [W xh; W hh]. Later in this section, we will make use of this notation as well. Computing the activations is very similar to standard multilayer perceptrons and other types of feed- forward NNs. For the hidden layer, the net input, zh (preactivation), is computed through a linear combination; that is, we compute the sum of the multiplications of the weight matrices with the corresponding vectors and add the bias unit: 𝒛𝒛ℎ(𝑡𝑡)=𝑾𝑾𝑥𝑥ℎ𝒙𝒙(𝑡𝑡)+𝑾𝑾ℎℎ𝒉𝒉(𝑡𝑡𝑡𝑡)+𝒃𝒃ℎ Then, the activations of the hidden units at the time step, t, are calculated as follows: 𝒉𝒉(𝑡𝑡)=𝜎𝜎ℎ(𝒛𝒛ℎ(𝑡𝑡))=𝜎𝜎ℎ(𝑾𝑾𝑥𝑥ℎ𝒙𝒙(𝑡𝑡)+𝑾𝑾ℎℎ𝒉𝒉(𝑡𝑡𝑡𝑡)+𝒃𝒃ℎ) Here, b h is the bias vector for the hidden units and 𝜎𝜎𝜎𝜎𝜎 is the activation function of the hidden layer. In case you want to use the concatenated weight matrix, W h = [W xh; Whh], the formula for computing hidden units will change, as follows: 𝒉𝒉(𝑡𝑡)=𝜎𝜎ℎ([𝑾𝑾𝑥𝑥ℎ;𝑾𝑾ℎℎ][𝒙𝒙(𝑡𝑡) 𝒉𝒉(𝑡𝑡𝑡𝑡)]+𝒃𝒃ℎ) Once the activations of the hidden units at the current time step are computed, then the", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 452, "start_word": 144640, "end_word": 145040, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000453": {"text": "activations of the hidden units at the time step, t, are calculated as follows: 𝒉𝒉(𝑡𝑡)=𝜎𝜎ℎ(𝒛𝒛ℎ(𝑡𝑡))=𝜎𝜎ℎ(𝑾𝑾𝑥𝑥ℎ𝒙𝒙(𝑡𝑡)+𝑾𝑾ℎℎ𝒉𝒉(𝑡𝑡𝑡𝑡)+𝒃𝒃ℎ) Here, b h is the bias vector for the hidden units and 𝜎𝜎𝜎𝜎𝜎 is the activation function of the hidden layer. In case you want to use the concatenated weight matrix, W h = [W xh; Whh], the formula for computing hidden units will change, as follows: 𝒉𝒉(𝑡𝑡)=𝜎𝜎ℎ([𝑾𝑾𝑥𝑥ℎ;𝑾𝑾ℎℎ][𝒙𝒙(𝑡𝑡) 𝒉𝒉(𝑡𝑡𝑡𝑡)]+𝒃𝒃ℎ) Once the activations of the hidden units at the current time step are computed, then the activations of the output units will be computed, as follows: 𝒐𝒐(𝑡𝑡)=𝜎𝜎0(𝑾𝑾ℎ𝑜𝑜𝒉𝒉(𝑡𝑡)+𝒃𝒃0) To help clarify this further, Figure 15.6 shows the process of computing these activations with both formulations: Figure 15.6: Computing the activations Modeling Sequential Data Using Recurrent Neural Networks 506 Hidden recurrence versus output recurrence So far, you have seen recurrent networks in which the hidden layer has the recurrent property. How - ever, note that there is an alternative model in which the recurrent connection comes from the output layer. In this case, the net activations from the output layer at the previous time step, ot–1, can be added in one of two ways: • To the hidden layer at the current time step, ht (shown in Figure 15.7 as output-to-hidden recurrence) • To the output layer at the current time step, ot (shown in Figure 15.7 as output-to-output re - currence)Training RNNs using backpropagation through time (BPTT) The learning algorithm for RNNs was introduced in 1990: Backpropagation Through Time: What It Does and How to Do It (Paul Werbos, Proceedings of IEEE, 78(10): 1550-1560, 1990). The derivation of the gradients might be a bit complicated, but the basic idea is that the overall loss, L, is the sum of all the loss functions at times t = 1 to t = T: 𝐿𝐿𝐿𝐿𝐿𝐿(𝑡𝑡)𝑇𝑇 𝑡𝑡𝑡𝑡 Since the loss at time t is dependent on the hidden units at all previous time steps 1 : t, the gradient will be computed as follows: 𝜕𝜕𝜕𝜕(𝑡𝑡) 𝜕𝜕𝜕𝜕ℎℎ=𝜕𝜕𝜕𝜕(𝑡𝑡) 𝜕𝜕𝜕𝜕(𝑡𝑡)×𝜕𝜕𝜕𝜕(𝑡𝑡) 𝜕𝜕𝜕𝜕(𝑡𝑡)×(∑𝜕𝜕𝜕𝜕(𝑡𝑡) 𝜕𝜕𝜕𝜕(𝑘𝑘)×𝜕𝜕𝜕𝜕(𝑘𝑘) 𝜕𝜕𝜕𝜕ℎℎ𝑡𝑡 𝑘𝑘𝑘𝑘) Here, 𝜕𝜕𝜕𝜕(𝑡𝑡) 𝜕𝜕𝜕𝜕(𝑘𝑘) is computed as a multiplication of adjacent time steps: 𝜕𝜕𝜕𝜕(𝑡𝑡) 𝜕𝜕𝜕𝜕(𝑘𝑘)=∏𝜕𝜕𝜕𝜕(𝑖𝑖) 𝜕𝜕𝜕𝜕(𝑖𝑖𝑖𝑖)𝑡𝑡 𝑖𝑖𝑖𝑘𝑘𝑖𝑖 Chapter 15 507 Figure 15.7: Different recurrent connection models As shown in Figure 15.7, the differences between these architectures can be clearly seen in the recur - ring connections. Following our notation, the weights associated with the recurrent connection will be denoted for the hidden-to-hidden recurrence by W hh, for the output-to-hidden recurrence", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 453, "start_word": 144960, "end_word": 145360, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000454": {"text": "be computed as follows: 𝜕𝜕𝜕𝜕(𝑡𝑡) 𝜕𝜕𝜕𝜕ℎℎ=𝜕𝜕𝜕𝜕(𝑡𝑡) 𝜕𝜕𝜕𝜕(𝑡𝑡)×𝜕𝜕𝜕𝜕(𝑡𝑡) 𝜕𝜕𝜕𝜕(𝑡𝑡)×(∑𝜕𝜕𝜕𝜕(𝑡𝑡) 𝜕𝜕𝜕𝜕(𝑘𝑘)×𝜕𝜕𝜕𝜕(𝑘𝑘) 𝜕𝜕𝜕𝜕ℎℎ𝑡𝑡 𝑘𝑘𝑘𝑘) Here, 𝜕𝜕𝜕𝜕(𝑡𝑡) 𝜕𝜕𝜕𝜕(𝑘𝑘) is computed as a multiplication of adjacent time steps: 𝜕𝜕𝜕𝜕(𝑡𝑡) 𝜕𝜕𝜕𝜕(𝑘𝑘)=∏𝜕𝜕𝜕𝜕(𝑖𝑖) 𝜕𝜕𝜕𝜕(𝑖𝑖𝑖𝑖)𝑡𝑡 𝑖𝑖𝑖𝑘𝑘𝑖𝑖 Chapter 15 507 Figure 15.7: Different recurrent connection models As shown in Figure 15.7, the differences between these architectures can be clearly seen in the recur - ring connections. Following our notation, the weights associated with the recurrent connection will be denoted for the hidden-to-hidden recurrence by W hh, for the output-to-hidden recurrence by W oh, and for the output-to-output recurrence by W oo. In some articles in literature, the weights associated with the recurrent connections are also denoted by W rec. To see how this works in practice, let’s manually compute the forward pass for one of these recurrent types. Using the torch.nn module, a recurrent layer can be defined via RNN, which is similar to the hidden-to-hidden recurrence. In the following code, we will create a recurrent layer from RNN and perform a forward pass on an input sequence of length 3 to compute the output. We will also manually compute the forward pass and compare the results with those of RNN. Modeling Sequential Data Using Recurrent Neural Networks 508 First, let’s create the layer and assign the weights and biases for our manual computations: >>> import torch >>> import torch.nn as nn >>> torch.manual_seed( 1) >>> rnn_layer = nn.RNN(input_size= 5, hidden_size= 2, ... num_layers= 1, batch_first= True) >>> w_xh = rnn_layer.weight_ih_l0 >>> w_hh = rnn_layer.weight_hh_l0 >>> b_xh = rnn_layer.bias_ih_l0 >>> b_hh = rnn_layer.bias_hh_l0 >>> print('W_xh shape:' , w_xh.shape) >>> print('W_hh shape:' , w_hh.shape) >>> print('b_xh shape:' , b_xh.shape) >>> print('b_hh shape:' , b_hh.shape) W_xh shape: torch.Size([2, 5]) W_hh shape: torch.Size([2, 2]) b_xh shape: torch.Size([2]) b_hh shape: torch.Size([2]) The input shape for this layer is (batch_size, sequence_length, 5) , where the first dimension is the batch dimension (as we set batch_first=True ), the second dimension corresponds to the sequence, and the last dimension corresponds to the features. Notice that we will output a sequence, which, for an input sequence of length 3, will result in the output sequence 〈𝒐𝒐(0),𝒐𝒐(1),𝒐𝒐(2)〉 . Also, RNN uses one layer by default, and you can set num_layers to stack multiple RNN layers together to form a stacked RNN. Now, we will call the forward pass on the rnn_layer and manually compute the outputs at each time step and compare them: >>> x_seq = torch.tensor([[ 1.0]*5, [2.0]*5,", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 454, "start_word": 145280, "end_word": 145680, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000455": {"text": "last dimension corresponds to the features. Notice that we will output a sequence, which, for an input sequence of length 3, will result in the output sequence 〈𝒐𝒐(0),𝒐𝒐(1),𝒐𝒐(2)〉 . Also, RNN uses one layer by default, and you can set num_layers to stack multiple RNN layers together to form a stacked RNN. Now, we will call the forward pass on the rnn_layer and manually compute the outputs at each time step and compare them: >>> x_seq = torch.tensor([[ 1.0]*5, [2.0]*5, [3.0]*5]).float() >>> ## output of the simple RNN: >>> output, hn = rnn_layer(torch.reshape(x_seq, ( 1, 3, 5))) >>> ## manually computing the output: >>> out_man = [] >>> for t in range (3): ... xt = torch.reshape(x_seq[t], ( 1, 5)) ... print(f'Time step {t} =>') ... print(' Input :' , xt.numpy()) ... ... ht = torch.matmul(xt, torch.transpose(w_xh, 0, 1)) + b_hh ... print(' Hidden :' , ht.detach().numpy() ... Chapter 15 509 ... if t > 0: ... prev_h = out_man[t- 1] ... else: ... prev_h = torch.zeros((ht.shape)) ... ot = ht + torch.matmul(prev_h, torch.transpose(w_hh, 0, 1)) \\ ... + b_hh ... ot = torch.tanh(ot) ... out_man.append(ot) ... print(' Output (manual) :' , ot.detach().numpy()) ... print(' RNN output :' , output[:, t].detach().numpy()) ... print() Time step 0 => Input : [[1. 1. 1. 1. 1.]] Hidden : [[-0.4701929 0.5863904]] Output (manual) : [[-0.3519801 0.52525216]] RNN output : [[-0.3519801 0.52525216]] Time step 1 => Input : [[2. 2. 2. 2. 2.]] Hidden : [[-0.88883156 1.2364397 ]] Output (manual) : [[-0.68424344 0.76074266]] RNN output : [[-0.68424344 0.76074266]] Time step 2 => Input : [[3. 3. 3. 3. 3.]] Hidden : [[-1.3074701 1.886489 ]] Output (manual) : [[-0.8649416 0.90466356]] RNN output : [[-0.8649416 0.90466356]] In our manual forward computation, we used the hyperbolic tangent (tanh) activation function since it is also used in RNN (the default activation). As you can see from the printed results, the outputs from the manual forward computations exactly match the output of the RNN layer at each time step. Hopefully, this hands-on task has enlightened you on the mysteries of recurrent networks. The challenges of learning long-range interactions BPTT, which was briefly mentioned earlier, introduces some new challenges. Because of the multipli- cative factor, 𝜕𝜕𝜕𝜕(𝑡𝑡) 𝜕𝜕𝜕𝜕(𝑘𝑘) , in computing the gradients of a loss function, the so-called vanishing and exploding gradient problems arise. Modeling Sequential Data Using Recurrent Neural Networks 510 These problems are explained by the examples in", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 455, "start_word": 145600, "end_word": 146000, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000456": {"text": "the output of the RNN layer at each time step. Hopefully, this hands-on task has enlightened you on the mysteries of recurrent networks. The challenges of learning long-range interactions BPTT, which was briefly mentioned earlier, introduces some new challenges. Because of the multipli- cative factor, 𝜕𝜕𝜕𝜕(𝑡𝑡) 𝜕𝜕𝜕𝜕(𝑘𝑘) , in computing the gradients of a loss function, the so-called vanishing and exploding gradient problems arise. Modeling Sequential Data Using Recurrent Neural Networks 510 These problems are explained by the examples in Figure 15.8, which shows an RNN with only one hidden unit for simplicity: Figure 15.8: Problems in computing the gradients of the loss function Basically, 𝜕𝜕𝜕𝜕(𝑡𝑡) 𝜕𝜕𝜕𝜕(𝑘𝑘) has t – k multiplications; therefore, multiplying the weight, w, by itself t – k times results in a factor, wt–k. As a result, if |w| < 1, this factor becomes very small when t – k is large. On the other hand, if the weight of the recurrent edge is |w| > 1, then wt–k becomes very large when t – k is large. Note that a large t – k refers to long-range dependencies. We can see that a naive solution to avoid vanishing or exploding gradients can be reached by ensuring |w| = 1. If you are interested and would like to investigate this in more detail, read On the difficulty of training recurrent neural networks by R. Pascanu, T. Mikolov, and Y. Bengio, 2012 ( https://arxiv.org/pdf/1211.5063.pdf ). In practice, there are at least three solutions to this problem: • Gradient clipping • Truncated backpropagation through time (TBPTT ) • LSTM Using gradient clipping, we specify a cut-off or threshold value for the gradients, and we assign this cut-off value to gradient values that exceed this value. In contrast, TBPTT simply limits the number of time steps that the signal can backpropagate after each forward pass. For example, even if the sequence has 100 elements or steps, we may only backpropagate the most recent 20 time steps. While both gradient clipping and TBPTT can solve the exploding gradient problem, the truncation limits the number of steps that the gradient can effectively flow back and properly update the weights. On the other hand, LSTM, designed in 1997 by Sepp Hochreiter and Jürgen Schmidhuber, has been more successful in vanishing and exploding gradient problems while modeling long-range dependencies through the use of memory cells. Let’s discuss LSTM in more detail. Chapter 15", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 456, "start_word": 145920, "end_word": 146320, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000457": {"text": "backpropagate the most recent 20 time steps. While both gradient clipping and TBPTT can solve the exploding gradient problem, the truncation limits the number of steps that the gradient can effectively flow back and properly update the weights. On the other hand, LSTM, designed in 1997 by Sepp Hochreiter and Jürgen Schmidhuber, has been more successful in vanishing and exploding gradient problems while modeling long-range dependencies through the use of memory cells. Let’s discuss LSTM in more detail. Chapter 15 511 Long short-term memory cells As stated previously, LSTMs were first introduced to overcome the vanishing gradient problem (Long Short-Term Memory by S. Hochreiter and J. Schmidhuber , Neural Computation , 9(8): 1735-1780, 1997). The building block of an LSTM is a memory cell, which essentially represents or replaces the hidden layer of standard RNNs. In each memory cell, there is a recurrent edge that has the desirable weight, w = 1, as we discussed, to overcome the vanishing and exploding gradient problems. The values associated with this recurrent edge are collectively called the cell state. The unfolded structure of a modern LSTM cell is shown in Figure 15.9: Figure 15.9: The structure of an LSTM cell Notice that the cell state from the previous time step, C(t–1), is modified to get the cell state at the cur - rent time step, C(t), without being multiplied directly by any weight factor. The flow of information in this memory cell is controlled by several computation units (often called gates) that will be described here. In the figure, ⨀ refers to the element-wise product (element-wise multiplication) and ⨁ means element-wise summation (element-wise addition). Furthermore, x(t) refers to the input data at time t, and h(t–1) indicates the hidden units at time t – 1. Four boxes are indicated with an activation function, either the sigmoid function ( 𝜎𝜎 ) or tanh, and a set of weights; these boxes apply a linear combination by performing matrix-vector multiplications on their inputs (which are h(t–1) and x(t)). These units of com- putation with sigmoid activation functions, whose output units are passed through ⨀ , are called gates. In an LSTM cell, there are three different types of gates, which are known as the forget gate, the input gate, and the output gate: The forget gate (f t) allows the memory cell to reset the cell state without growing indefinitely. In fact, the forget gate decides", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 457, "start_word": 146240, "end_word": 146640, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000458": {"text": "by performing matrix-vector multiplications on their inputs (which are h(t–1) and x(t)). These units of com- putation with sigmoid activation functions, whose output units are passed through ⨀ , are called gates. In an LSTM cell, there are three different types of gates, which are known as the forget gate, the input gate, and the output gate: The forget gate (f t) allows the memory cell to reset the cell state without growing indefinitely. In fact, the forget gate decides which information is allowed to go through and which information to suppress. Now, f t is computed as follows: 𝒇𝒇𝑡𝑡= 𝜎𝜎𝜎𝜎𝜎 𝑥𝑥𝑥𝑥𝒙𝒙(𝑡𝑡)+𝜎𝜎ℎ𝑥𝑥𝒉𝒉(𝑡𝑡𝑡𝑡)+𝒃𝒃𝑥𝑥) Modeling Sequential Data Using Recurrent Neural Networks 512 Note that the forget gate was not part of the original LSTM cell; it was added a few years later to im- prove the original model (Learning to Forget: Continual Prediction with LSTM by F. Gers, J. Schmidhuber, and F. Cummins, Neural Computation 12, 2451-2471, 2000). The input gate (i t) and candidate value ( 𝑪𝑪̃𝑡𝑡 ) are responsible for updating the cell state. They are com- puted as follows: 𝒊𝒊𝑡𝑡= 𝜎𝜎𝜎𝜎𝜎 𝑥𝑥𝑥𝑥𝒙𝒙(𝑡𝑡)+𝜎𝜎ℎ𝑥𝑥𝒉𝒉(𝑡𝑡𝑡𝑡)+𝒃𝒃𝑥𝑥) 𝑪𝑪̃𝑡𝑡= tanh𝜎𝜎𝜎𝑥𝑥𝑥𝑥𝒙𝒙(𝑡𝑡)+𝜎𝜎ℎ𝑥𝑥𝒉𝒉(𝑡𝑡𝑡𝑡)+𝒃𝒃𝑥𝑥) The cell state at time t is computed as follows: 𝑪𝑪(𝑡𝑡)= (𝑪𝑪(𝑡𝑡𝑡𝑡)⨀𝒇𝒇𝑡𝑡)⨁(𝒊𝒊𝑡𝑡⨀𝐶𝐶̃𝑡𝑡) The output gate (o t) decides how to update the values of hidden units: 𝒐𝒐𝑡𝑡= 𝜎𝜎𝜎𝜎𝜎 𝑥𝑥𝑥𝑥𝒙𝒙(𝑡𝑡)+𝜎𝜎ℎ𝑥𝑥𝒉𝒉(𝑡𝑡𝑡𝑡)+𝒃𝒃𝑥𝑥) Given this, the hidden units at the current time step are computed as follows: 𝒉𝒉(𝑡𝑡)=𝒐𝒐𝑡𝑡⨀tanh(𝑪𝑪(𝑡𝑡)) The structure of an LSTM cell and its underlying computations might seem very complex and hard to implement. However, the good news is that PyTorch has already implemented everything in optimized wrapper functions, which allows us to define our LSTM cells easily and efficiently. We will apply RNNs and LSTMs to real-world datasets later in this chapter. Other advanced RNN models LSTMs provide a basic approach for modeling long-range dependencies in sequences. Yet, it is important to note that there are many variations of LSTMs described in literature (An Empirical Exploration of Recurrent Network Architectures by Rafal Jozefowicz, Wojciech Zaremba, and Ilya Sutskever , Proceedings of ICML , 2342-2350, 2015). Also worth noting is a more recent approach, gated recurrent unit (GRU ), which was proposed in 2014. GRUs have a simpler architecture than LSTMs; therefore, they are computationally more efficient, while their performance in some tasks, such as polyphonic music modeling, is comparable to LSTMs. If you are interested in learning more about these modern RNN architectures, refer to the", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 458, "start_word": 146560, "end_word": 146960, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000459": {"text": "of Recurrent Network Architectures by Rafal Jozefowicz, Wojciech Zaremba, and Ilya Sutskever , Proceedings of ICML , 2342-2350, 2015). Also worth noting is a more recent approach, gated recurrent unit (GRU ), which was proposed in 2014. GRUs have a simpler architecture than LSTMs; therefore, they are computationally more efficient, while their performance in some tasks, such as polyphonic music modeling, is comparable to LSTMs. If you are interested in learning more about these modern RNN architectures, refer to the paper, Empirical Evaluation of Gated Recurrent Neural Networks on Sequence Modeling by Junyoung Chung and others, 2014 (https://arxiv.org/pdf/1412.3555v1.pdf ). Chapter 15 513 Implementing RNNs for sequence modeling in PyTorch Now that we have covered the underlying theory behind RNNs, we are ready to move on to the more practical portion of this chapter: implementing RNNs in PyTorch. During the rest of this chapter, we will apply RNNs to two common problem tasks: 1. Sentiment analysis 2. Language modeling These two projects, which we will walk through together in the following pages, are both fascinating but also quite involved. Thus, instead of providing the code all at once, we will break the implementation up into several steps and discuss the code in detail. If you like to have a big picture overview and want to see all the code at once before diving into the discussion, take a look at the code implementation first. Project one – predicting the sentiment of IMDb movie reviews You may recall from Chapter 8, Applying Machine Learning to Sentiment Analysis, that sentiment analysis is concerned with analyzing the expressed opinion of a sentence or a text document. In this section and the following subsections, we will implement a multilayer RNN for sentiment analysis using a many-to-one architecture. In the next section, we will implement a many-to-many RNN for an application of language modeling. While the chosen examples are purposefully simple to introduce the main concepts of RNNs, language modeling has a wide range of interesting applications, such as building chatbots—giving computers the ability to directly talk and interact with humans. Preparing the movie review data In Chapter 8, we preprocessed and cleaned the review dataset. And we will do the same now. First, we will import the necessary modules and read the data from torchtext (which we will install via pip install torchtext ; version 0.10.0 was used as of late 2021) as follows: >>>", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 459, "start_word": 146880, "end_word": 147280, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000460": {"text": "of RNNs, language modeling has a wide range of interesting applications, such as building chatbots—giving computers the ability to directly talk and interact with humans. Preparing the movie review data In Chapter 8, we preprocessed and cleaned the review dataset. And we will do the same now. First, we will import the necessary modules and read the data from torchtext (which we will install via pip install torchtext ; version 0.10.0 was used as of late 2021) as follows: >>> from torchtext.datasets import IMDB >>> train_dataset = IMDB(split= 'train') >>> test_dataset = IMDB(split= 'test') Each set has 25,000 samples. And each sample of the datasets consists of two elements, the sentiment label representing the target label we want to predict ( neg refers to negative sentiment and pos refers to positive sentiment), and the movie review text (the input features). The text component of these movie reviews is sequences of words, and the RNN model classifies each sequence as a positive ( 1) or negative ( 0) review. Modeling Sequential Data Using Recurrent Neural Networks 514 However, before we can feed the data into an RNN model, we need to apply several preprocessing steps: 1. Split the training dataset into separate training and validation partitions. 2. Identify the unique words in the training dataset 3. Map each unique word to a unique integer and encode the review text into encoded integers (an index of each unique word) 4. Divide the dataset into mini-batches as input to the model Let’s proceed with the first step: creating a training and validation partition from the train_dataset we read earlier: >>> ## Step 1: create the datasets >>> from torch.utils.data.dataset import random_split >>> torch.manual_seed( 1) >>> train_dataset, valid_dataset = random_split( ... list(train_dataset), [ 20000, 5000]) The original training dataset contains 25,000 examples. 20,000 examples are randomly chosen for training, and 5,000 for validation. To prepare the data for input to an NN, we need to encode it into numeric values, as was mentioned in steps 2 and 3. To do this, we will first find the unique words (tokens) in the training dataset. While finding unique tokens is a process for which we can use Python datasets, it can be more efficient to use the Counter class from the collections package, which is part of Python’s standard library. In the following code, we will instantiate a new Counter object (token_counts ) that will collect", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 460, "start_word": 147200, "end_word": 147600, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000461": {"text": "to encode it into numeric values, as was mentioned in steps 2 and 3. To do this, we will first find the unique words (tokens) in the training dataset. While finding unique tokens is a process for which we can use Python datasets, it can be more efficient to use the Counter class from the collections package, which is part of Python’s standard library. In the following code, we will instantiate a new Counter object (token_counts ) that will collect the unique word frequencies. Note that in this particular application (and in contrast to the bag-of-words model), we are only interested in the set of unique words and won’t require the word counts, which are created as a side product. To split the text into words (or tokens), we will reuse the tokenizer function we developed in Chapter 8, which also removes HTML markups as well as punctuation and other non-letter characters: The code for collecting unique tokens is as follows: >>> ## Step 2: find unique tokens (words) >>> import re >>> from collections import Counter, OrderedDict >>> >>> def tokenizer (text): ... text = re.sub( '<[^>]*>' , '', text) ... emoticons = re.findall( ... '(?::|;|=)(?:-)?(?:\\)|\\(|D|P)' , text.lower() ... ) ... text = re.sub( '[\\W]+', ' ', text.lower()) +\\ ... ' '.join(emoticons).replace( '-', '') ... tokenized = text.split() Chapter 15 515 ... return tokenized >>> >>> token_counts = Counter() >>> for label, line in train_dataset: ... tokens = tokenizer(line) ... token_counts.update(tokens) >>> print('Vocab-size:' , len(token_counts)) Vocab-size: 69023 If you want to learn more about Counter , refer to its documentation at https://docs.python.org/3/ library/collections.html#collections.Counter . Next, we are going to map each unique word to a unique integer. This can be done manually using a Python dictionary, where the keys are the unique tokens (words) and the value associated with each key is a unique integer. However, the torchtext package already provides a class, Vocab , which we can use to create such a mapping and encode the entire dataset. First, we will create a vocab object by passing the ordered dictionary mapping tokens to their corresponding occurrence frequencies (the ordered dictionary is the sorted token_counts ). Second, we will prepend two special tokens to the vocabulary – the padding and the unknown token: >>> ## Step 3: encoding each unique token into integers >>> from torchtext.vocab import vocab >>> sorted_by_freq_tuples = sorted( ... token_counts.items(), key= lambda x: x[1], reverse=", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 461, "start_word": 147520, "end_word": 147920, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000462": {"text": "to create such a mapping and encode the entire dataset. First, we will create a vocab object by passing the ordered dictionary mapping tokens to their corresponding occurrence frequencies (the ordered dictionary is the sorted token_counts ). Second, we will prepend two special tokens to the vocabulary – the padding and the unknown token: >>> ## Step 3: encoding each unique token into integers >>> from torchtext.vocab import vocab >>> sorted_by_freq_tuples = sorted( ... token_counts.items(), key= lambda x: x[1], reverse= True ... ) >>> ordered_dict = OrderedDict(sorted_by_freq_tuples) >>> vocab = vocab(ordered_dict) >>> vocab.insert_token( \"<pad>\", 0) >>> vocab.insert_token( \"<unk>\", 1) >>> vocab.set_default_index( 1) To demonstrate how to use the vocab object, we will convert an example input text into a list of integer values: >>> print([vocab[token] for token in ['this' , 'is', ... 'an', 'example' ]]) [11, 7, 35, 457] Note that there might be some tokens in the validation or testing data that are not present in the training data and are thus not included in the mapping. If we have q tokens (that is, the size of token_counts passed to Vocab , which in this case is 69,023), then all tokens that haven’t been seen before, and are thus not included in token_counts , will be assigned the integer 1 (a placeholder for the unknown to - ken). In other words, the index 1 is reserved for unknown words. Another reserved value is the integer 0, which serves as a placeholder, a so-called padding token, for adjusting the sequence length. Later, when we are building an RNN model in PyTorch, we will consider this placeholder, 0, in more detail. Modeling Sequential Data Using Recurrent Neural Networks 516 We can define the text_pipeline function to transform each text in the dataset accordingly and the label_pipeline function to convert each label to 1 or 0: >>> ## Step 3-A: define the functions for transformation >>> text_pipeline =\\ ... lambda x: [vocab[token] for token in tokenizer(x)] >>> label_pipeline = lambda x: 1. if x == 'pos' else 0. We will generate batches of samples using DataLoader and pass the data processing pipelines declared previously to the argument collate_fn . We will wrap the text encoding and label transformation function into the collate_batch function: >>> ## Step 3-B: wrap the encode and transformation function ... def collate_batch (batch): ... label_list, text_list, lengths = [], [], [] ... for _label, _text in batch: ...", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 462, "start_word": 147840, "end_word": 148240, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000463": {"text": "for token in tokenizer(x)] >>> label_pipeline = lambda x: 1. if x == 'pos' else 0. We will generate batches of samples using DataLoader and pass the data processing pipelines declared previously to the argument collate_fn . We will wrap the text encoding and label transformation function into the collate_batch function: >>> ## Step 3-B: wrap the encode and transformation function ... def collate_batch (batch): ... label_list, text_list, lengths = [], [], [] ... for _label, _text in batch: ... label_list.append(label_pipeline(_label)) ... processed_text = torch.tensor(text_pipeline(_text), ... dtype=torch.int64) ... text_list.append(processed_text) ... lengths.append(processed_text.size( 0)) ... label_list = torch.tensor(label_list) ... lengths = torch.tensor(lengths) ... padded_text_list = nn.utils.rnn.pad_sequence( ... text_list, batch_first= True) ... return padded_text_list, label_list, lengths >>> >>> ## Take a small batch >>> from torch.utils.data import DataLoader >>> dataloader = DataLoader(train_dataset, batch_size= 4, ... shuffle= False, collate_fn=collate_batch) So far, we’ve converted sequences of words into sequences of integers, and labels of pos or neg into 1 or 0. However, there is one issue that we need to resolve—the sequences currently have different lengths (as shown in the result of executing the following code for four examples). Although, in general, RNNs can handle sequences with different lengths, we still need to make sure that all the sequences in a mini-batch have the same length to store them efficiently in a tensor. PyTorch provides an efficient method, pad_sequence() , which will automatically pad the consecutive elements that are to be combined into a batch with placeholder values (0s) so that all sequences within a batch will have the same shape. In the previous code, we already created a data loader of a small batch size from the training dataset and applied the collate_batch function, which itself included a pad_sequence() call. Chapter 15 517 However, to illustrate how padding works, we will take the first batch and print the sizes of the indi- vidual elements before combining these into mini-batches, as well as the dimensions of the resulting mini-batches: >>> text_batch, label_batch, length_batch = next(iter(dataloader)) >>> print(text_batch) tensor([[ 35, 1742, 7, 449, 723, 6, 302, 4, ... 0, 0, 0, 0, 0, 0, 0, 0]], >>> print(label_batch) tensor([1., 1., 1., 0.]) >>> print(length_batch) tensor([165, 86, 218, 145]) >>> print(text_batch.shape) torch.Size([4, 218]) As you can observe from the printed tensor shapes, the number of columns in the first batch is 218, which resulted from combining the first four examples into a single batch and using the", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 463, "start_word": 148160, "end_word": 148560, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000464": {"text": "of the resulting mini-batches: >>> text_batch, label_batch, length_batch = next(iter(dataloader)) >>> print(text_batch) tensor([[ 35, 1742, 7, 449, 723, 6, 302, 4, ... 0, 0, 0, 0, 0, 0, 0, 0]], >>> print(label_batch) tensor([1., 1., 1., 0.]) >>> print(length_batch) tensor([165, 86, 218, 145]) >>> print(text_batch.shape) torch.Size([4, 218]) As you can observe from the printed tensor shapes, the number of columns in the first batch is 218, which resulted from combining the first four examples into a single batch and using the maximum size of these examples. This means that the other three examples (whose lengths are 165, 86, and 145, respectively) in this batch are padded as much as necessary to match this size. Finally, let’s divide all three datasets into data loaders with a batch size of 32: >>> batch_size = 32 >>> train_dl = DataLoader(train_dataset, batch_size=batch_size, ... shuffle= True, collate_fn=collate_batch) >>> valid_dl = DataLoader(valid_dataset, batch_size=batch_size, ... shuffle= False, collate_fn=collate_batch) >>> test_dl = DataLoader(test_dataset, batch_size=batch_size, ... shuffle= False, collate_fn=collate_batch) Now, the data is in a suitable format for an RNN model, which we are going to implement in the fol- lowing subsections. In the next subsection, however, we will first discuss feature embedding, which is an optional but highly recommended preprocessing step that is used to reduce the dimensionality of the word vectors. Embedding layers for sentence encoding During the data preparation in the previous step, we generated sequences of the same length. The elements of these sequences were integer numbers that corresponded to the indices of unique words. These word indices can be converted into input features in several different ways. One naive way is to apply one-hot encoding to convert the indices into vectors of zeros and ones. Then, each word will be mapped to a vector whose size is the number of unique words in the entire dataset. Given that the number of unique words (the size of the vocabulary) can be in the order of 104 – 105, which will also be the number of our input features, a model trained on such features may suffer from the curse of dimensionality. Furthermore, these features are very sparse since all are zero except one. Modeling Sequential Data Using Recurrent Neural Networks 518 A more elegant approach is to map each word to a vector of a fixed size with real-valued elements (not necessarily integers). In contrast to the one-hot encoded vectors, we can use finite-sized vectors to", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 464, "start_word": 148480, "end_word": 148880, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000465": {"text": "– 105, which will also be the number of our input features, a model trained on such features may suffer from the curse of dimensionality. Furthermore, these features are very sparse since all are zero except one. Modeling Sequential Data Using Recurrent Neural Networks 518 A more elegant approach is to map each word to a vector of a fixed size with real-valued elements (not necessarily integers). In contrast to the one-hot encoded vectors, we can use finite-sized vectors to represent an infinite number of real numbers. (In theory, we can extract infinite real numbers from a given interval, for example [–1, 1].) This is the idea behind embedding, which is a feature-learning technique that we can utilize here to automatically learn the salient features to represent the words in our dataset. Given the number of unique words, n words, we can select the size of the embedding vectors (a.k.a., embedding dimension) to be much smaller than the number of unique words (embedding_dim << n words) to represent the entire vocabulary as input features. The advantages of embedding over one-hot encoding are as follows: • A reduction in the dimensionality of the feature space to decrease the effect of the curse of dimensionality • The extraction of salient features since the embedding layer in an NN can be optimized (or learned) The following schematic representation shows how embedding works by mapping token indices to a trainable embedding matrix: Figure 15.10: A breakdown of how embedding works Chapter 15 519 Given a set of tokens of size n + 2 (n is the size of the token set, plus index 0 is reserved for the pad- ding placeholder, and 1 is for the words not present in the token set), an embedding matrix of size (n + 2) × embedding_dim will be created where each row of this matrix represents numeric features associated with a token. Therefore, when an integer index, i, is given as input to the embedding, it will look up the corresponding row of the matrix at index i and return the numeric features. The em- bedding matrix serves as the input layer to our NN models. In practice, creating an embedding layer can simply be done using nn.Embedding . Let’s see an example where we will create an embedding layer and apply it to a batch of two samples, as follows: >>> embedding = nn.Embedding( ... num_embeddings=", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 465, "start_word": 148800, "end_word": 149200, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000466": {"text": "i, is given as input to the embedding, it will look up the corresponding row of the matrix at index i and return the numeric features. The em- bedding matrix serves as the input layer to our NN models. In practice, creating an embedding layer can simply be done using nn.Embedding . Let’s see an example where we will create an embedding layer and apply it to a batch of two samples, as follows: >>> embedding = nn.Embedding( ... num_embeddings= 10, ... embedding_dim= 3, ... padding_idx= 0) >>> # a batch of 2 samples of 4 indices each >>> text_encoded_input = torch.LongTensor([[ 1,2,4,5],[ 4,3,2,0]]) >>> print(embedding(text_encoded_input)) tensor([[[-0.7027, 0.3684, -0.5512], [-0.4147, 1.7891, -1.0674], [ 1.1400, 0.1595, -1.0167], [ 0.0573, -1.7568, 1.9067]], [[ 1.1400, 0.1595, -1.0167], [-0.8165, -0.0946, -0.1881], [-0.4147, 1.7891, -1.0674], [ 0.0000, 0.0000, 0.0000]]], grad_fn=<EmbeddingBackward>) The input to this model (embedding layer) must have rank 2 with the dimensionality batchsize × in- put_length, where input_length is the length of sequences (here, 4). For example, an input sequence in the mini-batch could be <1, 5, 9, 2>, where each element of this sequence is the index of the unique words. The output will have the dimensionality batchsize × input_length × embedding_dim, where em- bedding_dim is the size of the embedding features (here, set to 3). The other argument provided to the embedding layer, num_embeddings , corresponds to the unique integer values that the model will receive as input (for instance, n + 2, set here to 10). Therefore, the embedding matrix in this case has the size 10×6. padding_idx indicates the token index for padding (here, 0), which, if specified, will not contribute to the gradient updates during training. In our example, the length of the original sequence of the second sample is 3, and we padded it with 1 more element 0. The embedding output of the padded element is [0, 0, 0]. Modeling Sequential Data Using Recurrent Neural Networks 520 Building an RNN model Now we’re ready to build an RNN model. Using the nn.Module class, we can combine the embedding layer, the recurrent layers of the RNN, and the fully connected non-recurrent layers. For the recurrent layers, we can use any of the following implementations: • RNN: a regular RNN layer, that is, a fully connected recurrent layer • LSTM : a long short-term memory RNN, which is useful for capturing the long-term dependencies • GRU: a recurrent", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 466, "start_word": 149120, "end_word": 149520, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000467": {"text": "520 Building an RNN model Now we’re ready to build an RNN model. Using the nn.Module class, we can combine the embedding layer, the recurrent layers of the RNN, and the fully connected non-recurrent layers. For the recurrent layers, we can use any of the following implementations: • RNN: a regular RNN layer, that is, a fully connected recurrent layer • LSTM : a long short-term memory RNN, which is useful for capturing the long-term dependencies • GRU: a recurrent layer with a gated recurrent unit, as proposed in Learning Phrase Representations Using RNN Encoder–Decoder for Statistical Machine Translation by K. Cho et al., 2014 ( https:// arxiv.org/abs/1406.1078v3 ), as an alternative to LSTMs To see how a multilayer RNN model can be built using one of these recurrent layers, in the following example, we will create an RNN model with two recurrent layers of type RNN. Finally, we will add a non-recurrent fully connected layer as the output layer, which will return a single output value as the prediction: >>> class RNN(nn.Module): ... def __init__(self, input_size, hidden_size): ... super().__init__() ... self.rnn = nn.RNN(input_size, hidden_size, num_layers= 2, ... batch_first= True) ... # self.rnn = nn.GRU(input_size, hidden_size, num_layers, ... # batch_first=True) ... # self.rnn = nn.LSTM(input_size, hidden_size, num_layers, ... # batch_first=True) ... self.fc = nn.Linear(hidden_size, 1) ... ... def forward (self, x): ... _, hidden = self.rnn(x) ... out = hidden[- 1, :, :] # we use the final hidden state ... # from the last hidden layer as ... # the input to the fully connected ... # layer ... out = self.fc(out) ... return out >>> >>> model = RNN( 64, 32) >>> print(model) >>> model(torch.randn( 5, 3, 64)) RNN( (rnn): RNN(64, 32, num_layers=2, batch_first=True) (fc): Linear(in_features=32, out_features=1, bias=True) ) Chapter 15 521 tensor([[ 0.0010], [ 0.2478], [ 0.0573], [ 0.1637], [-0.0073]], grad_fn=<AddmmBackward>) As you can see, building an RNN model using these recurrent layers is pretty straightforward. In the next subsection, we will go back to our sentiment analysis task and build an RNN model to solve that. Building an RNN model for the sentiment analysis task Since we have very long sequences, we are going to use an LSTM layer to account for long-range effects. We will create an RNN model for sentiment analysis, starting with an embedding layer producing word embeddings of feature size 20 ( embed_dim=20 ). Then, a recurrent layer of type LSTM will", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 467, "start_word": 149440, "end_word": 149840, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000468": {"text": "the next subsection, we will go back to our sentiment analysis task and build an RNN model to solve that. Building an RNN model for the sentiment analysis task Since we have very long sequences, we are going to use an LSTM layer to account for long-range effects. We will create an RNN model for sentiment analysis, starting with an embedding layer producing word embeddings of feature size 20 ( embed_dim=20 ). Then, a recurrent layer of type LSTM will be added. Finally, we will add a fully connected layer as a hidden layer and another fully connected layer as the output layer, which will return a single class-membership probability value via the logistic sigmoid activation as the prediction: >>> class RNN(nn.Module): ... def __init__(self, vocab_size, embed_dim, rnn_hidden_size, ... fc_hidden_size): ... super().__init__() ... self.embedding = nn.Embedding(vocab_size, ... embed_dim, ... padding_idx= 0) ... self.rnn = nn.LSTM(embed_dim, rnn_hidden_size, ... batch_first= True) ... self.fc1 = nn.Linear(rnn_hidden_size, fc_hidden_size) ... self.relu = nn.ReLU() ... self.fc2 = nn.Linear(fc_hidden_size, 1) ... self.sigmoid = nn.Sigmoid() ... ... def forward (self, text, lengths): ... out = self.embedding(text) ... out = nn.utils.rnn.pack_padded_sequence( ... out, lengths.cpu().numpy(), enforce_sorted=False, batch_first=True ... ) ... out, (hidden, cell) = self.rnn(out) ... out = hidden[- 1, :, :] ... out = self.fc1(out) ... out = self.relu(out) ... out = self.fc2(out) ... out = self.sigmoid(out) ... return out Modeling Sequential Data Using Recurrent Neural Networks 522 >>> >>> vocab_size = len(vocab) >>> embed_dim = 20 >>> rnn_hidden_size = 64 >>> fc_hidden_size = 64 >>> torch.manual_seed( 1) >>> model = RNN(vocab_size, embed_dim, rnn_hidden_size, fc_hidden_size) >>> model RNN( (embedding): Embedding(69025, 20, padding_idx=0) (rnn): LSTM(20, 64, batch_first=True) (fc1): Linear(in_features=64, out_features=64, bias=True) (relu): ReLU() (fc2): Linear(in_features=64, out_features=1, bias=True) (sigmoid): Sigmoid() ) Now we will develop the train function to train the model on the given dataset for one epoch and return the classification accuracy and loss: >>> def train(dataloader): ... model.train() ... total_acc, total_loss = 0, 0 ... for text_batch, label_batch, lengths in dataloader: ... optimizer.zero_grad() ... pred = model(text_batch, lengths)[:, 0] ... loss = loss_fn(pred, label_batch) ... loss.backward() ... optimizer.step() ... total_acc += ( ... (pred >= 0.5).float() == label_batch ... ). float().sum().item() ... total_loss += loss.item()*label_batch.size( 0) ... return total_acc/ len(dataloader.dataset), \\ ... total_loss/ len(dataloader.dataset) Similarly, we will develop the evaluate function to measure the model’s performance on a given dataset: >>> def evaluate (dataloader): ... model. eval() ... total_acc, total_loss = 0, 0 Chapter 15 523 ... with", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 468, "start_word": 149760, "end_word": 150160, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000469": {"text": "lengths in dataloader: ... optimizer.zero_grad() ... pred = model(text_batch, lengths)[:, 0] ... loss = loss_fn(pred, label_batch) ... loss.backward() ... optimizer.step() ... total_acc += ( ... (pred >= 0.5).float() == label_batch ... ). float().sum().item() ... total_loss += loss.item()*label_batch.size( 0) ... return total_acc/ len(dataloader.dataset), \\ ... total_loss/ len(dataloader.dataset) Similarly, we will develop the evaluate function to measure the model’s performance on a given dataset: >>> def evaluate (dataloader): ... model. eval() ... total_acc, total_loss = 0, 0 Chapter 15 523 ... with torch.no_grad(): ... for text_batch, label_batch, lengths in dataloader: ... pred = model(text_batch, lengths)[:, 0] ... loss = loss_fn(pred, label_batch) ... total_acc += ( ... (pred>= 0.5).float() == label_batch ... ). float().sum().item() ... total_loss += loss.item()*label_batch.size( 0) ... return total_acc/ len(dataloader.dataset), \\ ... total_loss/ len(dataloader.dataset) The next step is to create a loss function and optimizer (Adam optimizer). For a binary classification with a single class-membership probability output, we use the binary cross-entropy loss ( BCELoss ) as the loss function: >>> loss_fn = nn.BCELoss() >>> optimizer = torch.optim.Adam(model.parameters(), lr= 0.001) Now we will train the model for 10 epochs and display the training and validation performances: >>> num_epochs = 10 >>> torch.manual_seed( 1) >>> for epoch in range (num_epochs): ... acc_train, loss_train = train(train_dl) ... acc_valid, loss_valid = evaluate(valid_dl) ... print(f'Epoch {epoch} accuracy: {acc_train: .4f}' ... f' val_accuracy: {acc_valid: .4f}') Epoch 0 accuracy: 0.5843 val_accuracy: 0.6240 Epoch 1 accuracy: 0.6364 val_accuracy: 0.6870 Epoch 2 accuracy: 0.8020 val_accuracy: 0.8194 Epoch 3 accuracy: 0.8730 val_accuracy: 0.8454 Epoch 4 accuracy: 0.9092 val_accuracy: 0.8598 Epoch 5 accuracy: 0.9347 val_accuracy: 0.8630 Epoch 6 accuracy: 0.9507 val_accuracy: 0.8636 Epoch 7 accuracy: 0.9655 val_accuracy: 0.8654 Epoch 8 accuracy: 0.9765 val_accuracy: 0.8528 Epoch 9 accuracy: 0.9839 val_accuracy: 0.8596 After training this model for 10 epochs, we will evaluate it on the test data: >>> acc_test, _ = evaluate(test_dl) >>> print(f'test_accuracy: {acc_test: .4f}') test_accuracy: 0.8512 Modeling Sequential Data Using Recurrent Neural Networks 524 It showed 85 percent accuracy. (Note that this result is not the best when compared to the state-of-the- art methods used on the IMDb dataset. The goal was simply to show how an RNN works in PyTorch.) More on the bidirectional RNN In addition, we will set the bidirectional configuration of the LSTM to True , which will make the recurrent layer pass through the input sequences from both directions, start to end, as well as in the reverse direction: >>> class RNN(nn.Module): ... def __init__(self,", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 469, "start_word": 150080, "end_word": 150480, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000470": {"text": "that this result is not the best when compared to the state-of-the- art methods used on the IMDb dataset. The goal was simply to show how an RNN works in PyTorch.) More on the bidirectional RNN In addition, we will set the bidirectional configuration of the LSTM to True , which will make the recurrent layer pass through the input sequences from both directions, start to end, as well as in the reverse direction: >>> class RNN(nn.Module): ... def __init__(self, vocab_size, embed_dim, ... rnn_hidden_size, fc_hidden_size): ... super().__init__() ... self.embedding = nn.Embedding( ... vocab_size, embed_dim, padding_idx= 0 ... ) ... self.rnn = nn.LSTM(embed_dim, rnn_hidden_size, ... batch_first= True, bidirectional= True) ... self.fc1 = nn.Linear(rnn_hidden_size* 2, fc_hidden_size) ... self.relu = nn.ReLU() ... self.fc2 = nn.Linear(fc_hidden_size, 1) ... self.sigmoid = nn.Sigmoid() ... ... def forward (self, text, lengths): ... out = self.embedding(text) ... out = nn.utils.rnn.pack_padded_sequence( ... out, lengths.cpu().numpy(), enforce_sorted=False, batch_first=True ... ) ... _, (hidden, cell) = self.rnn(out) ... out = torch.cat((hidden[- 2, :, :], ... hidden[- 1, :, :]), dim= 1) ... out = self.fc1(out) ... out = self.relu(out) ... out = self.fc2(out) ... out = self.sigmoid(out) ... return out >>> >>> torch.manual_seed( 1) >>> model = RNN(vocab_size, embed_dim, ... rnn_hidden_size, fc_hidden_size) >>> model Chapter 15 525 RNN( (embedding): Embedding(69025, 20, padding_idx=0) (rnn): LSTM(20, 64, batch_first=True, bidirectional=True) (fc1): Linear(in_features=128, out_features=64, bias=True) (relu): ReLU() (fc2): Linear(in_features=64, out_features=1, bias=True) (sigmoid): Sigmoid() ) The bidirectional RNN layer makes two passes over each input sequence: a forward pass and a reverse or backward pass (note that this is not to be confused with the forward and backward passes in the context of backpropagation). The resulting hidden states of these forward and backward passes are usually concatenated into a single hidden state. Other merge modes include summation, multiplication (multiplying the results of the two passes), and averaging (taking the average of the two). We can also try other types of recurrent layers, such as the regular RNN. However, as it turns out, a model built with regular recurrent layers won’t be able to reach a good predictive performance (even on the training data). For example, if you try replacing the bidirectional LSTM layer in the previous code with a unidirectional nn.RNN (instead of nn.LSTM ) layer and train the model on full-length sequences, you may observe that the loss will not even decrease during training. The reason is that the sequences in this dataset are too long,", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 470, "start_word": 150400, "end_word": 150800, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000471": {"text": "However, as it turns out, a model built with regular recurrent layers won’t be able to reach a good predictive performance (even on the training data). For example, if you try replacing the bidirectional LSTM layer in the previous code with a unidirectional nn.RNN (instead of nn.LSTM ) layer and train the model on full-length sequences, you may observe that the loss will not even decrease during training. The reason is that the sequences in this dataset are too long, so a model with an RNN layer cannot learn the long-term dependencies and may suffer from vanishing or exploding gradient problems. Project two – character-level language modeling in PyTorch Language modeling is a fascinating application that enables machines to perform human language-re - lated tasks, such as generating English sentences. One of the interesting studies in this area is Gen- erating Text with Recurrent Neural Networks by Ilya Sutskever, James Martens, and Geoffrey E. Hinton, Proceedings of the 28th International Conference on Machine Learning (ICML-11), 2011 ( https://pdfs. semanticscholar.org/93c2/0e38c85b69fc2d2eb314b3c1217913f7db11.pdf ). In the model that we will build now, the input is a text document, and our goal is to develop a model that can generate new text that is similar in style to the input document. Examples of such input are a book or a computer program in a specific programming language. In character-level language modeling, the input is broken down into a sequence of characters that are fed into our network one character at a time. The network will process each new character in conjunction with the memory of the previously seen characters to predict the next one. Modeling Sequential Data Using Recurrent Neural Networks 526 Figure 15.11 shows an example of character-level language modeling (note that EOS stands for “end of sequence”): Figure 15.11: Character-level language modeling We can break this implementation down into three separate steps: preparing the data, building the RNN model, and performing next-character prediction and sampling to generate new text. Preprocessing the dataset In this section, we will prepare the data for character-level language modeling. To obtain the input data, visit the Project Gutenberg website at https://www.gutenberg.org/ , which provides thousands of free e-books. For our example, you can download the book The Mysterious Island, by Jules Verne (published in 1874) in plain text format from https://www.gutenberg.org/ files/1268/1268-0.txt . Note that this link will take you directly to the download page. If you are", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 471, "start_word": 150720, "end_word": 151120, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000472": {"text": "and sampling to generate new text. Preprocessing the dataset In this section, we will prepare the data for character-level language modeling. To obtain the input data, visit the Project Gutenberg website at https://www.gutenberg.org/ , which provides thousands of free e-books. For our example, you can download the book The Mysterious Island, by Jules Verne (published in 1874) in plain text format from https://www.gutenberg.org/ files/1268/1268-0.txt . Note that this link will take you directly to the download page. If you are using macOS or a Linux op - erating system, you can download the file with the following command in the terminal: curl -O https://www.gutenberg.org/files/1268/1268-0.txt If this resource becomes unavailable in the future, a copy of this text is also included in this chapter’s code directory in the book’s code repository at https://github.com/rasbt/machine-learning-book . Once we have downloaded the dataset, we can read it into a Python session as plain text. Using the following code, we will read the text directly from the downloaded file and remove portions from the beginning and the end (these contain certain descriptions of the Gutenberg project). Then, we will create a Python variable, char_set , that represents the set of unique characters observed in this text: >>> import numpy as np >>> ## Reading and processing text >>> with open('1268-0.txt' , 'r', encoding= \"utf8\") as fp: ... text=fp.read() >>> start_indx = text.find( 'THE MYSTERIOUS ISLAND' ) >>> end_indx = text.find( 'End of the Project Gutenberg' ) >>> text = text[start_indx:end_indx] >>> char_set = set(text) Chapter 15 527 >>> print('Total Length:' , len(text)) Total Length: 1112350 >>> print('Unique Characters:' , len(char_set)) Unique Characters: 80 After downloading and preprocessing the text, we have a sequence consisting of 1,112,350 characters in total and 80 unique characters. However, most NN libraries and RNN implementations cannot deal with input data in string format, which is why we have to convert the text into a numeric format. To do this, we will create a simple Python dictionary that maps each character to an integer, char2int . We will also need a reverse mapping to convert the results of our model back to text. Although the reverse can be done using a dictionary that associates integer keys with character values, using a NumPy array and indexing the array to map indices to those unique characters is more efficient. Figure 15.12 shows an example of converting characters into integers and the reverse for", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 472, "start_word": 151040, "end_word": 151440, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000473": {"text": "will create a simple Python dictionary that maps each character to an integer, char2int . We will also need a reverse mapping to convert the results of our model back to text. Although the reverse can be done using a dictionary that associates integer keys with character values, using a NumPy array and indexing the array to map indices to those unique characters is more efficient. Figure 15.12 shows an example of converting characters into integers and the reverse for the words \"Hello\" and \"world\" : Figure 15.12: Character and integer mappings Building the dictionary to map characters to integers, and reverse mapping via indexing a NumPy array, as was shown in the previous figure, is as follows: >>> chars_sorted = sorted(char_set) >>> char2int = {ch:i for i,ch in enumerate (chars_sorted)} >>> char_array = np.array(chars_sorted) >>> text_encoded = np.array( ... [char2int[ch] for ch in text], ... dtype=np.int32 ... ) >>> print('Text encoded shape:' , text_encoded.shape) Text encoded shape: (1112350,) >>> print(text[:15], '== Encoding ==>' , text_encoded[: 15]) >>> print(text_encoded[ 15:21], '== Reverse ==>' , ... ''.join(char_array[text_encoded[ 15:21]])) THE MYSTERIOUS == Encoding ==> [44 32 29 1 37 48 43 44 29 42 33 39 45 43 1] [33 43 36 25 38 28] == Reverse ==> ISLAND Modeling Sequential Data Using Recurrent Neural Networks 528 The text_encoded NumPy array contains the encoded values for all the characters in the text. Now, we will print out the mappings of the first five characters from this array: >>> for ex in text_encoded[: 5]: ... print('{} -> {}' .format(ex, char_array[ex])) 44 -> T 32 -> H 29 -> E 1 -> 37 -> M Now, let’s step back and look at the big picture of what we are trying to do. For the text generation task, we can formulate the problem as a classification task. Suppose we have a set of sequences of text characters that are incomplete, as shown in Figure 15.13: Figure 15.13: Predicting the next character for a text sequence In Figure 15.13, we can consider the sequences shown in the left-hand box to be the input. In order to generate new text, our goal is to design a model that can predict the next character of a given input sequence, where the input sequence represents an incomplete text. For example, after seeing “Deep Learn,” the model should predict “i” as the next character. Given that we have 80 unique", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 473, "start_word": 151360, "end_word": 151760, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000474": {"text": "Figure 15.13: Predicting the next character for a text sequence In Figure 15.13, we can consider the sequences shown in the left-hand box to be the input. In order to generate new text, our goal is to design a model that can predict the next character of a given input sequence, where the input sequence represents an incomplete text. For example, after seeing “Deep Learn,” the model should predict “i” as the next character. Given that we have 80 unique characters, this problem becomes a multiclass classification task. Chapter 15 529 Starting with a sequence of length 1 (that is, one single letter), we can iteratively generate new text based on this multiclass classification approach, as illustrated in Figure 15.14: Figure 15.14: Generating next text based on this multiclass classification approach To implement the text generation task in PyTorch, let’s first clip the sequence length to 40. This means that the input tensor, x, consists of 40 tokens. In practice, the sequence length impacts the quality of the generated text. Longer sequences can result in more meaningful sentences. For shorter sequences, however, the model might focus on capturing individual words correctly, while ignoring the context for the most part. Although longer sequences usually result in more meaningful sentences, as men- tioned, for long sequences, the RNN model will have problems capturing long-range dependencies. Thus, in practice, finding a sweet spot and good value for the sequence length is a hyperparameter optimization problem, which we have to evaluate empirically. Here, we are going to choose 40, as it offers a good trade-off. As you can see in the previous figure, the inputs, x, and targets, y, are offset by one character. Hence, we will split the text into chunks of size 41: the first 40 characters will form the input sequence, x, and the last 40 elements will form the target sequence, y. Modeling Sequential Data Using Recurrent Neural Networks 530 We have already stored the entire encoded text in its original order in text_encoded . We will first create text chunks consisting of 41 characters each. We will further get rid of the last chunk if it is shorter than 41 characters. As a result, the new chunked dataset, named text_chunks , will always contain sequences of size 41. The 41-character chunks will then be used to construct the sequence x (that is, the input), as well as the sequence", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 474, "start_word": 151680, "end_word": 152080, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000475": {"text": "We have already stored the entire encoded text in its original order in text_encoded . We will first create text chunks consisting of 41 characters each. We will further get rid of the last chunk if it is shorter than 41 characters. As a result, the new chunked dataset, named text_chunks , will always contain sequences of size 41. The 41-character chunks will then be used to construct the sequence x (that is, the input), as well as the sequence y (that is, the target), both of which will have 40 elements. For instance, sequence x will consist of the elements with indices [0, 1, ..., 39]. Furthermore, since sequence y will be shifted by one position with respect to x, its corresponding indices will be [1, 2, ..., 40]. Then, we will transform the result into a Dataset object by applying a self-defined Dataset class: >>> import torch >>> from torch.utils.data import Dataset >>> seq_length = 40 >>> chunk_size = seq_length + 1 >>> text_chunks = [text_encoded[i:i+chunk_size] ... for i in range (len(text_encoded)-chunk_size)] >>> from torch.utils.data import Dataset >>> class TextDataset (Dataset ): ... def __init__(self, text_chunks): ... self.text_chunks = text_chunks ... ... def __len__(self): ... return len(self.text_chunks) ... ... def __getitem__(self, idx): ... text_chunk = self.text_chunks[idx] ... return text_chunk[:- 1].long(), text_chunk[ 1:].long() >>> >>> seq_dataset = TextDataset(torch.tensor(text_chunks)) Let’s take a look at some example sequences from this transformed dataset: >>> for i, (seq, target) in enumerate (seq_dataset): ... print(' Input (x): ' , ... repr(''.join(char_array[seq]))) ... print('Target (y): ' , ... repr(''.join(char_array[target]))) ... print() ... if i == 1: ... break Input (x): 'THE MYSTERIOUS ISLAND ***\\n\\n\\n\\n\\nProduced b' Target (y): 'HE MYSTERIOUS ISLAND ***\\n\\n\\n\\n\\nProduced by' Input (x): 'HE MYSTERIOUS ISLAND ***\\n\\n\\n\\n\\nProduced by' Target (y): 'E MYSTERIOUS ISLAND ***\\n\\n\\n\\n\\nProduced by ' Chapter 15 531 Finally, the last step in preparing the dataset is to transform this dataset into mini-batches: >>> from torch.utils.data import DataLoader >>> batch_size = 64 >>> torch.manual_seed( 1) >>> seq_dl = DataLoader(seq_dataset, batch_size=batch_size, ... shuffle= True, drop_last= True) Building a character-level RNN model Now that the dataset is ready, building the model will be relatively straightforward: >>> import torch.nn as nn >>> class RNN(nn.Module): ... def __init__(self, vocab_size, embed_dim, rnn_hidden_size): ... super().__init__() ... self.embedding = nn.Embedding(vocab_size, embed_dim) ... self.rnn_hidden_size = rnn_hidden_size ... self.rnn = nn.LSTM(embed_dim, rnn_hidden_size, ... batch_first= True) ... self.fc = nn.Linear(rnn_hidden_size, vocab_size) ... ... def forward (self, x, hidden, cell): ... out = self.embedding(x).unsqueeze(", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 475, "start_word": 152000, "end_word": 152400, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000476": {"text": "torch.manual_seed( 1) >>> seq_dl = DataLoader(seq_dataset, batch_size=batch_size, ... shuffle= True, drop_last= True) Building a character-level RNN model Now that the dataset is ready, building the model will be relatively straightforward: >>> import torch.nn as nn >>> class RNN(nn.Module): ... def __init__(self, vocab_size, embed_dim, rnn_hidden_size): ... super().__init__() ... self.embedding = nn.Embedding(vocab_size, embed_dim) ... self.rnn_hidden_size = rnn_hidden_size ... self.rnn = nn.LSTM(embed_dim, rnn_hidden_size, ... batch_first= True) ... self.fc = nn.Linear(rnn_hidden_size, vocab_size) ... ... def forward (self, x, hidden, cell): ... out = self.embedding(x).unsqueeze( 1) ... out, (hidden, cell) = self.rnn(out, (hidden, cell)) ... out = self.fc(out).reshape(out.size( 0), -1) ... return out, hidden, cell ... ... def init_hidden (self, batch_size): ... hidden = torch.zeros( 1, batch_size, self.rnn_hidden_size) ... cell = torch.zeros( 1, batch_size, self.rnn_hidden_size) ... return hidden, cell Notice that we will need to have the logits as outputs of the model so that we can sample from the model predictions in order to generate new text. We will get to this sampling part later. Then, we can specify the model parameters and create an RNN model: >>> vocab_size = len(char_array) >>> embed_dim = 256 >>> rnn_hidden_size = 512 >>> torch.manual_seed( 1) >>> model = RNN(vocab_size, embed_dim, rnn_hidden_size) >>> model RNN( (embedding): Embedding(80, 256) Modeling Sequential Data Using Recurrent Neural Networks 532 (rnn): LSTM(256, 512, batch_first=True) (fc): Linear(in_features=512, out_features=80, bias=True) (softmax): LogSoftmax(dim=1) ) The next step is to create a loss function and optimizer (Adam optimizer). For a multiclass classifi- cation (we have vocab_size=80 classes) with a single logits output for each target character, we use CrossEntropyLoss as the loss function: >>> loss_fn = nn.CrossEntropyLoss() >>> optimizer = torch.optim.Adam(model.parameters(), lr= 0.001) Now we will train the model for 10,000 epochs. In each epoch, we will use only one batch randomly chosen from the data loader, seq_dl . We will also display the training loss for every 500 epochs: >>> num_epochs = 10000 >>> torch.manual_seed( 1) >>> for epoch in range (num_epochs): ... hidden, cell = model.init_hidden(batch_size) ... seq_batch, target_batch = next(iter(seq_dl)) ... optimizer.zero_grad() ... loss = 0 ... for c in range (seq_length): ... pred, hidden, cell = model(seq_batch[:, c], hidden, cell) ... loss += loss_fn(pred, target_batch[:, c]) ... loss.backward() ... optimizer.step() ... loss = loss.item()/seq_length ... if epoch % 500 == 0: ... print(f'Epoch {epoch} loss: {loss:.4f}') Epoch 0 loss: 1.9689 Epoch 500 loss: 1.4064 Epoch 1000 loss: 1.3155 Epoch 1500 loss: 1.2414 Epoch 2000 loss: 1.1697 Epoch 2500 loss: 1.1840 Epoch 3000", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 476, "start_word": 152320, "end_word": 152720, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000477": {"text": "= model.init_hidden(batch_size) ... seq_batch, target_batch = next(iter(seq_dl)) ... optimizer.zero_grad() ... loss = 0 ... for c in range (seq_length): ... pred, hidden, cell = model(seq_batch[:, c], hidden, cell) ... loss += loss_fn(pred, target_batch[:, c]) ... loss.backward() ... optimizer.step() ... loss = loss.item()/seq_length ... if epoch % 500 == 0: ... print(f'Epoch {epoch} loss: {loss:.4f}') Epoch 0 loss: 1.9689 Epoch 500 loss: 1.4064 Epoch 1000 loss: 1.3155 Epoch 1500 loss: 1.2414 Epoch 2000 loss: 1.1697 Epoch 2500 loss: 1.1840 Epoch 3000 loss: 1.1469 Epoch 3500 loss: 1.1633 Epoch 4000 loss: 1.1788 Epoch 4500 loss: 1.0828 Epoch 5000 loss: 1.1164 Epoch 5500 loss: 1.0821 Epoch 6000 loss: 1.0764 Chapter 15 533 Epoch 6500 loss: 1.0561 Epoch 7000 loss: 1.0631 Epoch 7500 loss: 0.9904 Epoch 8000 loss: 1.0053 Epoch 8500 loss: 1.0290 Epoch 9000 loss: 1.0133 Epoch 9500 loss: 1.0047 Next, we can evaluate the model to generate new text, starting with a given short string. In the next section, we will define a function to evaluate the trained model. Evaluation phase – generating new text passages The RNN model we trained in the previous section returns the logits of size 80 for each unique char - acter. These logits can be readily converted to probabilities, via the softmax function, that a particular character will be encountered as the next character. To predict the next character in the sequence, we can simply select the element with the maximum logit value, which is equivalent to selecting the char - acter with the highest probability. However, instead of always selecting the character with the highest likelihood, we want to (randomly) sample from the outputs; otherwise, the model will always produce the same text. PyTorch already provides a class, torch.distributions.categorical.Categorical , which we can use to draw random samples from a categorical distribution. To see how this works, let’s generate some random samples from three categories [0, 1, 2], with input logits [1, 1, 1]: >>> from torch.distributions.categorical import Categorical >>> torch.manual_seed( 1) >>> logits = torch.tensor([[ 1.0, 1.0, 1.0]]) >>> print('Probabilities:' , ... nn.functional.softmax(logits, dim= 1).numpy()[ 0]) Probabilities: [0.33333334 0.33333334 0.33333334] >>> m = Categorical(logits=logits) >>> samples = m.sample(( 10,)) >>> print(samples.numpy()) [[0] [0] [0] [0] [1] [0] [1] [2] [1] [1]] Modeling Sequential Data Using Recurrent Neural Networks 534 As you can see, with the given logits, the categories have the same probabilities (that is, equiprobable categories). Therefore, if we use a large sample", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 477, "start_word": 152640, "end_word": 153040, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000478": {"text": "from torch.distributions.categorical import Categorical >>> torch.manual_seed( 1) >>> logits = torch.tensor([[ 1.0, 1.0, 1.0]]) >>> print('Probabilities:' , ... nn.functional.softmax(logits, dim= 1).numpy()[ 0]) Probabilities: [0.33333334 0.33333334 0.33333334] >>> m = Categorical(logits=logits) >>> samples = m.sample(( 10,)) >>> print(samples.numpy()) [[0] [0] [0] [0] [1] [0] [1] [2] [1] [1]] Modeling Sequential Data Using Recurrent Neural Networks 534 As you can see, with the given logits, the categories have the same probabilities (that is, equiprobable categories). Therefore, if we use a large sample size (num_samples → ∞), we would expect the number of occurrences of each category to reach ≈ 1/3 of the sample size. If we change the logits to [1, 1, 3], then we would expect to observe more occurrences for category 2 (when a very large number of examples are drawn from this distribution): >>> torch.manual_seed( 1) >>> logits = torch.tensor([[ 1.0, 1.0, 3.0]]) >>> print('Probabilities:' , nn.functional.softmax(logits, dim= 1).numpy()[ 0]) Probabilities: [0.10650698 0.10650698 0.78698605] >>> m = Categorical(logits=logits) >>> samples = m.sample(( 10,)) >>> print(samples.numpy()) [[0] [2] [2] [1] [2] [1] [2] [2] [2] [2]] Using Categorical , we can generate examples based on the logits computed by our model. We will define a function, sample() , that receives a short starting string, starting_str , and generate a new string, generated_str , which is initially set to the input string. starting_str is encoded to a sequence of integers, encoded_input . encoded_input is passed to the RNN model one character at a time to update the hidden states. The last character of encoded_input is passed to the model to generate a new character. Note that the output of the RNN model represents the logits (here, a vector of size 80, which is the total number of possible characters) for the next character after observing the input sequence by the model. Here, we only use the logits output (that is, o(T)), which is passed to the Categorical class to generate a new sample. This new sample is converted to a character, which is then appended to the end of the generated string, generated_text , increasing its length by 1. Then, this process is repeated until the length of the generated string reaches the desired value. The process of consuming the generated sequence as input for generating new elements is called autoregression. The code for the sample() function is as follows: >>> def sample(model, starting_str, ... len_generated_text= 500, ... scale_factor= 1.0): Chapter", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 478, "start_word": 152960, "end_word": 153360, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000479": {"text": "new sample. This new sample is converted to a character, which is then appended to the end of the generated string, generated_text , increasing its length by 1. Then, this process is repeated until the length of the generated string reaches the desired value. The process of consuming the generated sequence as input for generating new elements is called autoregression. The code for the sample() function is as follows: >>> def sample(model, starting_str, ... len_generated_text= 500, ... scale_factor= 1.0): Chapter 15 535 ... encoded_input = torch.tensor( ... [char2int[s] for s in starting_str] ... ) ... encoded_input = torch.reshape( ... encoded_input, ( 1, -1) ... ) ... generated_str = starting_str ... ... model. eval() ... hidden, cell = model.init_hidden( 1) ... for c in range (len(starting_str)- 1): ... _, hidden, cell = model( ... encoded_input[:, c].view( 1), hidden, cell ... ) ... ... last_char = encoded_input[:, - 1] ... for i in range (len_generated_text): ... logits, hidden, cell = model( ... last_char.view( 1), hidden, cell ... ) ... logits = torch.squeeze(logits, 0) ... scaled_logits = logits * scale_factor ... m = Categorical(logits=scaled_logits) ... last_char = m.sample() ... generated_str += str(char_array[last_char]) ... ... return generated_str Let’s now generate some new text: >>> torch.manual_seed( 1) >>> print(sample(model, starting_str= 'The island' )) The island had been made and ovylore with think, captain?\" asked Neb; \"we do.\" It was found, they full to time to remove. About this neur prowers, perhaps ended? It is might be rather rose?\" \"Forward!\" exclaimed Pencroft, \"they were it? It seems to me?\" \"The dog Top--\" Modeling Sequential Data Using Recurrent Neural Networks 536 \"What can have been struggling sventy.\" Pencroft calling, themselves in time to try them what proves that the sailor and Neb bounded this tenarvan's feelings, and then still hid head a grand furiously watched to the dorner nor his only As you can see, the model generates mostly correct words, and, in some cases, the sentences are par - tially meaningful. You can further tune the training parameters, such as the length of input sequences for training, and the model architecture. Furthermore, to control the predictability of the generated samples (that is, generating text following the learned patterns from the training text versus adding more randomness), the logits computed by the RNN model can be scaled before being passed to Categorical for sampling. The scaling factor, 𝛼𝛼 , can be interpreted as an analog to the", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 479, "start_word": 153280, "end_word": 153680, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000480": {"text": "are par - tially meaningful. You can further tune the training parameters, such as the length of input sequences for training, and the model architecture. Furthermore, to control the predictability of the generated samples (that is, generating text following the learned patterns from the training text versus adding more randomness), the logits computed by the RNN model can be scaled before being passed to Categorical for sampling. The scaling factor, 𝛼𝛼 , can be interpreted as an analog to the temperature in physics. Higher temperatures result in more entropy or randomness versus more predictable behavior at lower temperatures. By scaling the logits with 𝛼𝛼𝛼𝛼 , the probabilities computed by the softmax function become more uniform, as shown in the following code: >>> logits = torch.tensor([[ 1.0, 1.0, 3.0]]) >>> print('Probabilities before scaling: ' , ... nn.functional.softmax(logits, dim= 1).numpy()[ 0]) >>> print('Probabilities after scaling with 0.5:' , ... nn.functional.softmax( 0.5*logits, dim= 1).numpy()[ 0]) >>> print('Probabilities after scaling with 0.1:' , ... nn.functional.softmax( 0.1*logits, dim= 1).numpy()[ 0]) Probabilities before scaling: [0.10650698 0.10650698 0.78698604] Probabilities after scaling with 0.5: [0.21194156 0.21194156 0.57611688] Probabilities after scaling with 0.1: [0.31042377 0.31042377 0.37915245] As you can see, scaling the logits by 𝛼𝛼𝛼𝛼 results in near-uniform probabilities [0.31, 0.31, 0.38]. Now, we can compare the generated text with 𝛼𝛼 𝛼 𝛼𝛼𝛼 and 𝛼𝛼 𝛼 𝛼𝛼𝛼 , as shown in the following points: • 𝛼𝛼 𝛼 𝛼𝛼𝛼 𝛼 𝛼𝛼𝛼𝛼𝛼𝛼𝛼𝛼𝛼𝛼𝛼𝛼𝛼𝛼𝛼𝛼 : >>> torch.manual_seed( 1) >>> print(sample(model, starting_str= 'The island' , ... scale_factor= 2.0)) The island is one of the colony?\" asked the sailor, \"there is not to be able to come to the shores of the Pacific.\" \"Yes,\" replied the engineer, \"and if it is not the position of the forest, and the marshy way have been said, the dog was not first on the shore, and found themselves to the corral. Chapter 15 537 The settlers had the sailor was still from the surface of the sea, they were not received for the sea. The shore was to be able to inspect the windows of Granite House. The sailor turned the sailor was the hor • 𝛼𝛼 𝛼 𝛼𝛼𝛼 𝛼 𝛼𝛼𝛼𝛼𝛼𝛼𝛼𝛼𝛼𝛼𝛼𝛼𝛼𝛼𝛼 : >>> torch.manual_seed( 1) >>> print(sample(model, starting_str= 'The island' , ... scale_factor= 0.5)) The island deep incomele. Manyl's', House, won's calcon-sglenderlessly,\" everful ineriorouins., pyra\" into truth. Sometinivabes, iskumar gave-zen.\" Bleshed but what cotch quadrap which little cedass fell oprely by-andonem. Peditivall--\"i dove Gurgeon. What resolt-eartnated to him", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 480, "start_word": 153600, "end_word": 154000, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000481": {"text": "were not received for the sea. The shore was to be able to inspect the windows of Granite House. The sailor turned the sailor was the hor • 𝛼𝛼 𝛼 𝛼𝛼𝛼 𝛼 𝛼𝛼𝛼𝛼𝛼𝛼𝛼𝛼𝛼𝛼𝛼𝛼𝛼𝛼𝛼 : >>> torch.manual_seed( 1) >>> print(sample(model, starting_str= 'The island' , ... scale_factor= 0.5)) The island deep incomele. Manyl's', House, won's calcon-sglenderlessly,\" everful ineriorouins., pyra\" into truth. Sometinivabes, iskumar gave-zen.\" Bleshed but what cotch quadrap which little cedass fell oprely by-andonem. Peditivall--\"i dove Gurgeon. What resolt-eartnated to him ran trail. Withinhe)tiny turns returned, after owner plan bushelsion lairs; they were know? Whalerin branch I pites, Dougg!-iteun,\" returnwe aid masses atong thoughts! Dak, Hem-arches yone, Veay wantzer? Woblding, Herbert, omep The results show that scaling the logits with 𝛼𝛼 𝛼 𝛼𝛼𝛼 (increasing the temperature) generates more random text. There is a trade-off between the novelty of the generated text and its correctness. In this section, we worked with character-level text generation, which is a sequence-to-sequence (seq2seq) modeling task. While this example may not be very useful by itself, it is easy to think of several useful applications for these types of models; for example, a similar RNN model can be trained as a chatbot to assist users with simple queries. Summary In this chapter, you first learned about the properties of sequences that make them different from other types of data, such as structured data or images. We then covered the foundations of RNNs for sequence modeling. You learned how a basic RNN model works and discussed its limitations with regard to capturing long-term dependencies in sequence data. Next, we covered LSTM cells, which consist of a gating mechanism to reduce the effect of exploding and vanishing gradient problems, which are common in basic RNN models. Modeling Sequential Data Using Recurrent Neural Networks 538 After discussing the main concepts behind RNNs, we implemented several RNN models with different recurrent layers using PyTorch. In particular, we implemented an RNN model for sentiment analysis, as well as an RNN model for generating text. In the next chapter, we will see how we can augment an RNN with an attention mechanism, which helps it with modeling long-range dependencies in translation tasks. Then, we will introduce a new deep learning architecture called transformer, which has recently been used to further push the state of the art in the natural language processing domain. Join our book’s Discord space Join the book’s Discord workspace for", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 481, "start_word": 153920, "end_word": 154320, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000482": {"text": "for sentiment analysis, as well as an RNN model for generating text. In the next chapter, we will see how we can augment an RNN with an attention mechanism, which helps it with modeling long-range dependencies in translation tasks. Then, we will introduce a new deep learning architecture called transformer, which has recently been used to further push the state of the art in the natural language processing domain. Join our book’s Discord space Join the book’s Discord workspace for a monthly Ask me Anything session with the authors: https://packt.link/MLwPyTorch 16 Transformers – Improving Natural Language Processing with Attention Mechanisms In the previous chapter, we learned about recurrent neural networks (RNNs ) and their applications in natural language processing (NLP ) through a sentiment analysis project. However, a new architec- ture has recently emerged that has been shown to outperform the RNN-based sequence-to-sequence (seq2seq) models in several NLP tasks. This is the so-called transformer architecture. Transformers have revolutionized natural language processing and have been at the forefront of many impressive applications ranging from automated language translation ( https://ai.googleblog. com/2020/06/recent-advances-in-google-translate.html ) and modeling fundamental properties of protein sequences ( https://www.pnas.org/content/118/15/e2016239118.short ) to creating an AI that helps people write code ( https://github.blog/2021-06-29-introducing-github-copilot- ai-pair-programmer ). In this chapter, you will learn about the basic mechanisms of attention and self-attention and see how they are used in the original transformer architecture. Then, equipped with an understanding of how transformers work, we will explore some of the most influential NLP models that emerged from this architecture and learn how to use a large-scale language model, the so-called BERT model, in PyTorch. We will cover the following topics: • Improving RNNs with an attention mechanism • Introducing the stand-alone self-attention mechanism • Understanding the original transformer architecture • Comparing transformer-based large-scale language models • Fine-tuning BERT for sentiment classification Transformers – Improving Natural Language Processing with Attention Mechanisms 540 Adding an attention mechanism to RNNs In this section, we discuss the motivation behind developing an attention mechanism, which helps predictive models to focus on certain parts of the input sequence more than others, and how it was originally used in the context of RNNs. Note that this section provides a historical perspective explaining why the attention mechanism was developed. If individual mathematical details appear complicated, you can feel free to skip over them as they are not needed for the next section, explaining the self-at-", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 482, "start_word": 154240, "end_word": 154640, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000483": {"text": "In this section, we discuss the motivation behind developing an attention mechanism, which helps predictive models to focus on certain parts of the input sequence more than others, and how it was originally used in the context of RNNs. Note that this section provides a historical perspective explaining why the attention mechanism was developed. If individual mathematical details appear complicated, you can feel free to skip over them as they are not needed for the next section, explaining the self-at- tention mechanism for transformers, which is the focus of this chapter. Attention helps RNNs with accessing information To understand the development of an attention mechanism, consider the traditional RNN model for a seq2seq task like language translation, which parses the entire input sequence (for instance, one or more sentences) before producing the translation, as shown in Figure 16.1: Figure 16.1: A traditional RNN encoder-decoder architecture for a seq2seq modeling task Chapter 16 541 Why is the RNN parsing the whole input sentence before producing the first output? This is motivat- ed by the fact that translating a sentence word by word would likely result in grammatical errors, as illustrated in Figure 16.2: Figure 16.2: Translating a sentence word by word can lead to grammatical errors However, as illustrated in Figure 16.2, one limitation of this seq2seq approach is that the RNN is trying to remember the entire input sequence via one single hidden unit before translating it. Compressing all the information into one hidden unit may cause loss of information, especially for long sequences. Thus, similar to how humans translate sentences, it may be beneficial to have access to the whole input sequence at each time step. In contrast to a regular RNN, an attention mechanism lets the RNN access all input elements at each given time step. However, having access to all input sequence elements at each time step can be overwhelming. So, to help the RNN focus on the most relevant elements of the input sequence, the attention mechanism assigns different attention weights to each input element. These attention weights designate how important or relevant a given input sequence element is at a given time step. For example, revisiting Figure 16.2, the words “mir, helfen, zu” may be more relevant for producing the output word “help” than the words “kannst, du, Satz.” The next subsection introduces an RNN architecture that was outfitted with an attention mechanism to help", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 483, "start_word": 154560, "end_word": 154960, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000484": {"text": "the most relevant elements of the input sequence, the attention mechanism assigns different attention weights to each input element. These attention weights designate how important or relevant a given input sequence element is at a given time step. For example, revisiting Figure 16.2, the words “mir, helfen, zu” may be more relevant for producing the output word “help” than the words “kannst, du, Satz.” The next subsection introduces an RNN architecture that was outfitted with an attention mechanism to help process long sequences for language translation. Transformers – Improving Natural Language Processing with Attention Mechanisms 542 The original attention mechanism for RNNs In this subsection, we will summarize the mechanics of the attention mechanism that was originally developed for language translation and first appeared in the following paper: Neural Machine Transla- tion by Jointly Learning to Align and Translate by Bahdanau, D., Cho, K., and Bengio, Y., 2014, https:// arxiv.org/abs/1409.0473 . Given an input sequence 𝑥𝑥 𝑥 𝑥𝑥𝑥(1),𝑥𝑥(2),…,𝑥𝑥(𝑇𝑇)) , the attention mechanism assigns a weight to each element 𝑥𝑥(𝑖𝑖) (or, to be more specific, its hidden representation) and helps the model identify which part of the input it should focus on. For example, suppose our input is a sentence, and a word with a larger weight contributes more to our understanding of the whole sentence. The RNN with the atten- tion mechanism shown in Figure 16.3 (modeled after the previously mentioned paper) illustrates the overall concept of generating the second output word: Figure 16.3: RNN with attention mechanism The attention-based architecture depicted in the figure consists of two RNN models, which we will explain in the next subsections. Chapter 16 543 Processing the inputs using a bidirectional RNN The first RNN (RNN #1) of the attention-based RNN in Figure 16.3 is a bidirectional RNN that generates context vectors, 𝑐𝑐𝑖𝑖 . You can think of a context vector as an augmented version of the input vector, 𝑥𝑥(𝑖𝑖) . In other words, the 𝑐𝑐𝑖𝑖 input vector also incorporates information from all other input elements via an attention mechanism. As we can see in Figure 16.3, RNN #2 then uses this context vector, prepared by RNN #1, to generate the outputs. In the remainder of this subsection, we will discuss how RNN #1 works, and we will revisit RNN #2 in the next subsection. The bidirectional RNN #1 processes the input sequence x in the regular forward direction ( 1...𝑇𝑇 ) as well", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 484, "start_word": 154880, "end_word": 155280, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000485": {"text": "the 𝑐𝑐𝑖𝑖 input vector also incorporates information from all other input elements via an attention mechanism. As we can see in Figure 16.3, RNN #2 then uses this context vector, prepared by RNN #1, to generate the outputs. In the remainder of this subsection, we will discuss how RNN #1 works, and we will revisit RNN #2 in the next subsection. The bidirectional RNN #1 processes the input sequence x in the regular forward direction ( 1...𝑇𝑇 ) as well as backward ( 𝑇𝑇𝑇𝑇𝑇𝑇 ). Parsing a sequence in the backward direction has the same effect as revers- ing the original input sequence—think of reading a sentence in reverse order. The rationale behind this is to capture additional information since current inputs may have a dependence on sequence elements that came either before or after it in a sentence, or both. Consequently, from reading the input sequence twice (that is, forward and backward), we have two hidden states for each input sequence element. For instance, for the second input sequence element 𝑥𝑥(2) , we obtain the hidden state ℎ𝐹𝐹(2) from the forward pass and the hidden state ℎ𝐵𝐵(2) from the backward pass. These two hidden states are then concatenated to form the hidden state ℎ(2) . For example, if both ℎ𝐹𝐹(2) and ℎ𝐵𝐵(2) are 128-dimensional vectors, the concatenated hidden state ℎ(2) will consist of 256 elements. We can consider this concatenated hidden state as the “annotation” of the source word since it contains the information of the jth word in both directions. In the next section, we will see how these concatenated hidden states are further processed and used by the second RNN to generate the outputs. Generating outputs from context vectors In Figure 16.3, we can consider RNN #2 as the main RNN that is generating the outputs. In addition to the hidden states, it receives so-called context vectors as input. A context vector 𝑐𝑐𝑖𝑖 is a weighted version of the concatenated hidden states, ℎ(1)…ℎ(𝑇𝑇) , which we obtained from RNN #1 in the previous subsection. We can compute the context vector of the ith input as a weighted sum: 𝑐𝑐𝑖𝑖=∑𝛼𝛼 𝑖𝑖𝑖𝑖ℎ(𝑖𝑖)𝑇𝑇 𝑖𝑖𝑗𝑗 Here, 𝛼𝛼𝑖𝑖𝑖𝑖 represents the attention weights over the input sequence 𝑗𝑗𝑗𝑗𝑗𝑗𝑗𝑗𝑗 in the context of the ith input sequence element. Note that each i th input sequence element has a unique set of attention weights. We will discuss the computation of the attention weights 𝛼𝛼𝑖𝑖𝑖𝑖 in", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 485, "start_word": 155200, "end_word": 155600, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000486": {"text": "of the concatenated hidden states, ℎ(1)…ℎ(𝑇𝑇) , which we obtained from RNN #1 in the previous subsection. We can compute the context vector of the ith input as a weighted sum: 𝑐𝑐𝑖𝑖=∑𝛼𝛼 𝑖𝑖𝑖𝑖ℎ(𝑖𝑖)𝑇𝑇 𝑖𝑖𝑗𝑗 Here, 𝛼𝛼𝑖𝑖𝑖𝑖 represents the attention weights over the input sequence 𝑗𝑗𝑗𝑗𝑗𝑗𝑗𝑗𝑗 in the context of the ith input sequence element. Note that each i th input sequence element has a unique set of attention weights. We will discuss the computation of the attention weights 𝛼𝛼𝑖𝑖𝑖𝑖 in the next subsection. For the remainder of this subsection, let us discuss how the context vectors are used via the second RNN in the preceding figure (RNN #2). Just like a vanilla (regular) RNN, RNN #2 also uses hidden states. Considering the hidden layer between the aforementioned “annotation” and final output, let us denote the hidden state at time 𝑖𝑖 as 𝑠𝑠(𝑖𝑖𝑖 . Now, RNN #2 receives the aforementioned context vector 𝑐𝑐𝑖𝑖 at each time step i as input. Transformers – Improving Natural Language Processing with Attention Mechanisms 544 In Figure 16.3, we saw that the hidden state 𝑠𝑠(𝑖𝑖𝑖 depends on the previous hidden state 𝑠𝑠(𝑖𝑖𝑖𝑖𝑖 , the previous target word 𝑦𝑦(𝑖𝑖𝑖𝑖𝑖 , and the context vector 𝑐𝑐(𝑖𝑖𝑖 , which are used to generate the predicted output 𝑜𝑜(𝑖𝑖𝑖 for target word 𝑦𝑦(𝑖𝑖𝑖 at time i. Note that the sequence vector 𝒚𝒚 refers to the sequence vector representing the correct translation of input sequence 𝒙𝒙 that is available during training. During training, the true label (word) 𝑦𝑦(𝑖𝑖𝑖 is fed into the next state 𝑠𝑠(𝑖𝑖𝑖𝑖𝑖 ; since this true label information is not available for prediction (inference), we feed the predicted output 𝑜𝑜(𝑖𝑖𝑖 instead, as depicted in the previous figure. To summarize what we have just discussed above, the attention-based RNN consists of two RNNs. RNN #1 prepares context vectors from the input sequence elements, and RNN #2 receives the context vectors as input. The context vectors are computed via a weighted sum over the inputs, where the weights are the attention weights 𝛼𝛼𝑖𝑖𝑖𝑖. The next subsection discusses how we compute these attention weights. Computing the attention weights Finally, let us visit the last missing piece in our puzzle—attention weights. Because these weights pairwise connect the inputs (annotations) and the outputs (contexts), each attention weight 𝛼𝛼𝑖𝑖𝑖𝑖 has two subscripts: j refers to the index position of the input and i corresponds to the output index posi- tion. The attention weight 𝛼𝛼𝑖𝑖𝑖𝑖 is", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 486, "start_word": 155520, "end_word": 155920, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000487": {"text": "sum over the inputs, where the weights are the attention weights 𝛼𝛼𝑖𝑖𝑖𝑖. The next subsection discusses how we compute these attention weights. Computing the attention weights Finally, let us visit the last missing piece in our puzzle—attention weights. Because these weights pairwise connect the inputs (annotations) and the outputs (contexts), each attention weight 𝛼𝛼𝑖𝑖𝑖𝑖 has two subscripts: j refers to the index position of the input and i corresponds to the output index posi- tion. The attention weight 𝛼𝛼𝑖𝑖𝑖𝑖 is a normalized version of the alignment score 𝑒𝑒𝑖𝑖𝑖𝑖 , where the alignment score evaluates how well the input around position j matches with the output at position i. To be more specific, the attention weight is computed by normalizing the alignment scores as follows: 𝛼𝛼𝑖𝑖𝑖𝑖=exp(𝑒𝑒𝑖𝑖𝑖𝑖) ∑exp(𝑒𝑒𝑖𝑖𝑖𝑖)𝑇𝑇 𝑖𝑖𝑘𝑘 Note that this equation is similar to the softmax function, which we discussed in Chapter 12, Paral- lelizing Neural Network Training with PyTorch, in the section Estimating class probabilities in multiclass classification via the softmax function. Consequently, the attention weights 𝛼𝛼𝑖𝑖𝑖 ... 𝛼𝛼𝑖𝑖𝑖𝑖 sum up to 1. Now, to summarize, we can structure the attention-based RNN model into three parts. The first part computes bidirectional annotations of the input. The second part consists of the recurrent block, which is very much like the original RNN, except that it uses context vectors instead of the original input. The last part concerns the computation of the attention weights and context vectors, which describe the relationship between each pair of input and output elements. The transformer architecture also utilizes an attention mechanism, but unlike the attention-based RNN, it solely relies on the self-attention mechanism and does not include the recurrent process found in the RNN. In other words, a transformer model processes the whole input sequence all at once instead of reading and processing the sequence one element at a time. In the next section, we will introduce a basic form of the self-attention mechanism before we discuss the transformer architecture in more detail in the following section. Introducing the self-attention mechanism In the previous section, we saw that attention mechanisms can help RNNs with remembering context when working with long sequences. As we will see in the next section, we can have an architecture entirely based on attention, without the recurrent parts of an RNN. This attention-based architecture is known as transformer, and we will discuss it in more detail later. Chapter 16 545 In", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 487, "start_word": 155840, "end_word": 156240, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000488": {"text": "we discuss the transformer architecture in more detail in the following section. Introducing the self-attention mechanism In the previous section, we saw that attention mechanisms can help RNNs with remembering context when working with long sequences. As we will see in the next section, we can have an architecture entirely based on attention, without the recurrent parts of an RNN. This attention-based architecture is known as transformer, and we will discuss it in more detail later. Chapter 16 545 In fact, transformers can appear a bit complicated at first glance. So, before we discuss transformers in the next section, let us dive into the self-attention mechanism used in transformers. In fact, as we will see, this self-attention mechanism is just a different flavor of the attention mechanism that we discussed in the previous section. We can think of the previously discussed attention mechanism as an operation that connects two different modules, that is, the encoder and decoder of the RNN. As we will see, self-attention focuses only on the input and captures only dependencies between the input elements. without connecting two modules. In the first subsection, we will introduce a basic form of self-attention without any learning param- eters, which is very much like a pre-processing step to the input. Then in the second subsection, we will introduce the common version of self-attention that is used in the transformer architecture and involves learnable parameters. Starting with a basic form of self-attention To introduce self-attention, let’s assume we have an input sequence of length T, 𝒙𝒙(1),…,𝒙𝒙(𝑇𝑇), as well as an output sequence, 𝒛𝒛(1),𝒛𝒛(2),…,𝒛𝒛(𝑇𝑇) . To avoid confusion, we will use 𝒐𝒐 as the final output of the whole transformer model and 𝒛𝒛 as the output of the self-attention layer because it is an intermediate step in the model. Each ith element in these sequences, 𝒙𝒙(𝑖𝑖) and 𝒛𝒛(𝑖𝑖) , are vectors of size d (that is, 𝒙𝒙(𝑖𝑖)∈𝑅𝑅𝑑𝑑 ) representing the feature information for the input at position i, which is similar to RNNs. Then, for a seq2seq task, the goal of self-attention is to model the dependencies of the current input element to all other input elements. To achieve this, self-attention mechanisms are composed of three stages. First, we derive importance weights based on the similarity between the current element and all other elements in the sequence. Second, we normalize the weights, which usually involves the use of the already famil- iar", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 488, "start_word": 156160, "end_word": 156560, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000489": {"text": "for the input at position i, which is similar to RNNs. Then, for a seq2seq task, the goal of self-attention is to model the dependencies of the current input element to all other input elements. To achieve this, self-attention mechanisms are composed of three stages. First, we derive importance weights based on the similarity between the current element and all other elements in the sequence. Second, we normalize the weights, which usually involves the use of the already famil- iar softmax function. Third, we use these weights in combination with the corresponding sequence elements to compute the attention value. More formally, the output of self-attention, 𝒛𝒛(𝑖𝑖), is the weighted sum of all T input sequences, 𝒙𝒙(𝑗𝑗) (where 𝑗𝑗𝑗𝑗𝑗𝑗𝑗𝑗𝑗 ). For instance, for the i th input element, the corresponding output value is computed as follows: 𝒛𝒛(𝑖𝑖)=∑𝛼𝛼 𝑖𝑖𝑖𝑖𝒙𝒙(𝑖𝑖)𝑇𝑇 𝑖𝑖𝑗𝑗 Hence, we can think of 𝒛𝒛(𝑖𝑖) as a context-aware embedding vector in input vector 𝒙𝒙(𝑖𝑖) that involves all other input sequence elements weighted by their respective attention weights. Here, the attention weights, 𝛼𝛼𝑖𝑖𝑖𝑖 , are computed based on the similarity between the current input element, 𝒙𝒙(𝑖𝑖) , and all other elements in the input sequence, 𝒙𝒙(1)...𝒙𝒙(𝑇𝑇) . More concretely, this similarity is computed in two steps explained in the next paragraphs. First, we compute the dot product between the current input element, 𝒙𝒙(𝑖𝑖) , and another element in the input sequence, 𝒙𝒙(𝑗𝑗) : ω𝑖𝑖𝑖𝑖=𝒙𝒙(𝑖𝑖)⊤𝒙𝒙(𝑖𝑖) Transformers – Improving Natural Language Processing with Attention Mechanisms 546 Before we normalize the ω𝑖𝑖𝑖𝑖 values to obtain the attention weights, a𝑖𝑖𝑖𝑖 , let’s illustrate how we compute the ω𝑖𝑖𝑖𝑖 values with a code example. Here, let’s assume we have an input sentence “can you help me to translate this sentence” that has already been mapped to an integer representation via a dictionary as explained in Chapter 15, Modeling Sequential Data Using Recurrent Neural Networks: >>> import torch >>> sentence = torch.tensor( >>> [0, # can >>> 7, # you >>> 1, # help >>> 2, # me >>> 5, # to >>> 6, # translate >>> 4, # this >>> 3] # sentence >>> ) >>> sentence tensor([0, 7, 1, 2, 5, 6, 4, 3]) Let’s also assume that we already encoded this sentence into a real-number vector representation via an embedding layer. Here, our embedding size is 16, and we assume that the dictionary size is 10. The following code will produce the word embeddings of", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 489, "start_word": 156480, "end_word": 156880, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000490": {"text": "# you >>> 1, # help >>> 2, # me >>> 5, # to >>> 6, # translate >>> 4, # this >>> 3] # sentence >>> ) >>> sentence tensor([0, 7, 1, 2, 5, 6, 4, 3]) Let’s also assume that we already encoded this sentence into a real-number vector representation via an embedding layer. Here, our embedding size is 16, and we assume that the dictionary size is 10. The following code will produce the word embeddings of our eight words: >>> torch.manual_seed( 123) >>> embed = torch.nn.Embedding( 10, 16) >>> embedded_sentence = embed(sentence).detach() >>> embedded_sentence.shape torch.Size([8, 16]) Now, we can compute ω𝑖𝑖𝑖𝑖 as the dot product between the ith and jth word embeddings. We can do this for all ω𝑖𝑖𝑖𝑖 values as follows: >>> omega = torch.empty( 8, 8) >>> for i, x_i in enumerate (embedded_sentence): >>> for j, x_j in enumerate (embedded_sentence): >>> omega[i, j] = torch.dot(x_i, x_j) While the preceding code is easy to read and understand, for loops can be very inefficient, so let’s compute this using matrix multiplication instead: >>> omega_mat = embedded_sentence.matmul(embedded_sentence.T) Chapter 16 547 We can use the torch.allclose function to check that this matrix multiplication produces the expect - ed results. If two tensors contain the same values, torch.allclose returns True , as we can see here: >>> torch.allclose(omega_mat, omega) True We have learned how to compute the similarity-based weights for the ith input and all inputs in the sequence ( 𝒙𝒙(1) to 𝒙𝒙(T) ), the “raw” weights ( 𝜔𝜔𝑖𝑖𝑖 to 𝜔𝜔𝑖𝑖𝑖 ). We can obtain the attention weights, 𝛼𝛼𝑖𝑖𝑖𝑖 , by normalizing the 𝜔𝜔𝑖𝑖𝑖𝑖 values via the familiar softmax function, as follows: 𝛼𝛼𝑖𝑖𝑖𝑖=exp(ω 𝑖𝑖𝑖𝑖) ∑exp(𝜔𝜔 𝑖𝑖𝑖𝑖)𝑇𝑇 𝑖𝑖𝑗𝑗= softmax([ω 𝑖𝑖𝑖𝑖]𝑖𝑖𝑗𝑗𝑗𝑇𝑇) Notice that the denominator involves a sum over all input elements ( 1...𝑇𝑇 ). Hence, due to applying this softmax function, the weights will sum to 1 after this normalization, that is, ∑𝛼𝛼𝑖𝑖𝑖𝑖𝑇𝑇 𝑖𝑖𝑗𝑗=1 We can compute the attention weights using PyTorch’s softmax function as follows: >>> import torch.nn.functional as F >>> attention_weights = F.softmax(omega, dim= 1) >>> attention_weights.shape torch.Size([8, 8]) Note that attention_weights is an 8×8 matrix, where each element represents an attention weight, 𝛼𝛼𝑖𝑖𝑖𝑖 . For instance, if we are processing the i th input word, the i th row of this matrix contains the corresponding attention weights for all words in the sentence. These attention weights indicate how relevant each word is to the ith word. Hence,", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 490, "start_word": 156800, "end_word": 157200, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000491": {"text": "using PyTorch’s softmax function as follows: >>> import torch.nn.functional as F >>> attention_weights = F.softmax(omega, dim= 1) >>> attention_weights.shape torch.Size([8, 8]) Note that attention_weights is an 8×8 matrix, where each element represents an attention weight, 𝛼𝛼𝑖𝑖𝑖𝑖 . For instance, if we are processing the i th input word, the i th row of this matrix contains the corresponding attention weights for all words in the sentence. These attention weights indicate how relevant each word is to the ith word. Hence, the columns in this attention matrix should sum to 1, which we can confirm via the following code: >>> attention_weights. sum(dim=1) tensor([1.0000, 1.0000, 1.0000, 1.0000, 1.0000, 1.0000, 1.0000, 1.0000]) Now that we have seen how to compute the attention weights, let us recap and summarize the three main steps behind the self-attention operation: 1. For a given input element, 𝒙𝒙(𝑖𝑖) , and each j th element in the set {1, ..., T}, compute the dot product, 𝒙𝒙(𝑖𝑖)⊤𝒙𝒙(𝑗𝑗) 2. Obtain the attention weight, 𝛼𝛼𝑖𝑖𝑖𝑖 , by normalizing the dot products using the softmax function 3. Compute the output, 𝒛𝒛(𝑖𝑖) , as the weighted sum over the entire input sequence: 𝒛𝒛(𝑖𝑖)=∑𝛼𝛼𝑖𝑖𝑖𝑖𝒙𝒙(𝑖𝑖) 𝑇𝑇 𝑖𝑖𝑗𝑗 Transformers – Improving Natural Language Processing with Attention Mechanisms 548 These steps are further illustrated in Figure 16.4: Figure 16.4: A basic self-attention process for illustration purposes Lastly, let us see a code example for computing the context vectors, 𝒛𝒛(𝑖𝑖) , as the attention-weighted sum of the inputs (step 3 in Figure 16.4). In particular, let’s assume we are computing the context vector for the second input word, that is, 𝒛𝒛(2) : >>> x_2 = embedded_sentence[ 1, :] >>> context_vec_2 = torch.zeros(x_2.shape) >>> for j in range (8): ... x_j = embedded_sentence[j, :] ... context_vec_2 += attention_weights[ 1, j] * x_j >>> context_vec_2 tensor([-9.3975e-01, -4.6856e-01, 1.0311e+00, -2.8192e-01, 4.9373e-01, -1.2896e-02, -2.7327e-01, -7.6358e-01, 1.3958e+00, -9.9543e-01, -7.1288e-04, 1.2449e+00, -7.8077e-02, 1.2765e+00, -1.4589e+00, -2.1601e+00]) Chapter 16 549 Again, we can achieve this more efficiently by using matrix multiplication. Using the following code, we are computing the context vectors for all eight input words: >>> context_vectors = torch.matmul( ... attention_weights, embedded_sentence) Similar to the input word embeddings stored in embedded_sentence , the context_vectors matrix has dimensionality 8×16 . The second row in this matrix contains the context vector for the second input word, and we can check the implementation using torch.allclose() again: >>> torch.allclose(context_vec_2, context_vectors[ 1]) True As we can see, the manual for loop", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 491, "start_word": 157120, "end_word": 157520, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000492": {"text": "by using matrix multiplication. Using the following code, we are computing the context vectors for all eight input words: >>> context_vectors = torch.matmul( ... attention_weights, embedded_sentence) Similar to the input word embeddings stored in embedded_sentence , the context_vectors matrix has dimensionality 8×16 . The second row in this matrix contains the context vector for the second input word, and we can check the implementation using torch.allclose() again: >>> torch.allclose(context_vec_2, context_vectors[ 1]) True As we can see, the manual for loop and matrix computations of the second context vector yielded the same results. This section implemented a basic form of self-attention, and in the next section, we will modify this implementation using learnable parameter matrices that can be optimized during neural network training. Parameterizing the self-attention mechanism: scaled dot-product attention Now that you have been introduced to the basic concept behind self-attention, this subsection sum- marizes the more advanced self-attention mechanism called scaled dot-product attention that is used in the transformer architecture. Note that in the previous subsection, we did not involve any learnable parameters when computing the outputs. In other words, using the previously introduced basic self-attention mechanism, the transformer model is rather limited regarding how it can update or change the attention values during model optimization for a given sequence. To make the self-at- tention mechanism more flexible and amenable to model optimization, we will introduce three ad- ditional weight matrices that can be fit as model parameters during model training. We denote these three weight matrices as 𝑼𝑼𝑞𝑞 , 𝑼𝑼𝑘𝑘 , and 𝑼𝑼𝑣𝑣 . They are used to project the inputs into query, key, and value sequence elements, as follows: • Query sequence: 𝒒𝒒(𝑖𝑖)=𝑼𝑼𝑞𝑞𝒙𝒙(𝑖𝑖) for 𝑖𝑖𝑖[1,𝑇𝑇] • Key sequence: 𝒌𝒌(𝑖𝑖)=𝑼𝑼 𝑘𝑘𝒙𝒙(𝑖𝑖) for 𝑖𝑖𝑖[1,𝑇𝑇] • Value sequence: 𝒗𝒗(𝑖𝑖)=𝑼𝑼𝑣𝑣𝒙𝒙(𝑖𝑖) for 𝑖𝑖𝑖[1,𝑇𝑇] Transformers – Improving Natural Language Processing with Attention Mechanisms 550 Figure 16.5 illustrates how these individual components are used to compute the context-aware em- bedding vector corresponding to the second input element: Figure 16.5: Computing the context-aware embedding vector of the second sequence element Here, both 𝒒𝒒(𝑖𝑖) and 𝒌𝒌(𝑖𝑖) are vectors of size 𝑑𝑑𝑘𝑘 . Therefore, the projection matrices 𝑼𝑼𝑞𝑞 and 𝑼𝑼𝑘𝑘 have the shape 𝑑𝑑𝑘𝑘×𝑑𝑑 , while 𝑼𝑼𝑣𝑣 has the shape 𝑑𝑑𝑣𝑣×𝑑𝑑 . (Note that 𝑑𝑑 is the dimensionality of each word vector, 𝒙𝒙(𝑖𝑖) .) For simplicity, we can design these vectors to have the same shape, for example, using 𝑑𝑑𝑘𝑘=𝑑𝑑𝑣𝑣=𝑑𝑑 . To provide additional intuition via code,", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 492, "start_word": 157440, "end_word": 157840, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000493": {"text": "second input element: Figure 16.5: Computing the context-aware embedding vector of the second sequence element Here, both 𝒒𝒒(𝑖𝑖) and 𝒌𝒌(𝑖𝑖) are vectors of size 𝑑𝑑𝑘𝑘 . Therefore, the projection matrices 𝑼𝑼𝑞𝑞 and 𝑼𝑼𝑘𝑘 have the shape 𝑑𝑑𝑘𝑘×𝑑𝑑 , while 𝑼𝑼𝑣𝑣 has the shape 𝑑𝑑𝑣𝑣×𝑑𝑑 . (Note that 𝑑𝑑 is the dimensionality of each word vector, 𝒙𝒙(𝑖𝑖) .) For simplicity, we can design these vectors to have the same shape, for example, using 𝑑𝑑𝑘𝑘=𝑑𝑑𝑣𝑣=𝑑𝑑 . To provide additional intuition via code, we can initialize these projection matrices as follows: >>> torch.manual_seed( 123) >>> d = embedded_sentence.shape[ 1] >>> U_query = torch.rand(d, d) >>> U_key = torch.rand(d, d) >>> U_value = torch.rand(d, d)Query, key, and value terminology The terms query, key, and value that were used in the original transformer paper are in- spired by information retrieval systems and databases. For example, if we enter a query, it is matched against the key values for which certain values are retrieved. Chapter 16 551 Using the query projection matrix, we can then compute the query sequence. For this example, con- sider the second input element, 𝒙𝒙(𝑖𝑖) , as our query, as illustrated in Figure 16.5: >>> x_2 = embedded_sentence[ 1] >>> query_2 = U_query.matmul(x_2) In a similar fashion, we can compute the key and value sequences, 𝒌𝒌(𝑖𝑖) and 𝒗𝒗(𝑖𝑖) : >>> key_2 = U_key.matmul(x_2) >>> value_2 = U_value.matmul(x_2) However, as we can see from Figure 16.5, we also need the key and value sequences for all other input elements, which we can compute as follows: >>> keys = U_key.matmul(embedded_sentence.T).T >>> values = U_value.matmul(embedded_sentence.T).T In the key matrix, the ith row corresponds to the key sequence of the ith input element, and the same applies to the value matrix. We can confirm this by using torch.allclose() again, which should return True : >>> keys = U_key.matmul(embedded_sentence.T).T >>> torch.allclose(key_2, keys[ 1]) >>> values = U_value.matmul(embedded_sentence.T).T >>> torch.allclose(value_2, values[ 1]) In the previous section, we computed the unnormalized weights, 𝜔𝜔𝑖𝑖𝑖𝑖 , as the pairwise dot product between the given input sequence element, 𝒙𝒙(𝑖𝑖) , and the jth sequence element, 𝒙𝒙(𝑗𝑗) . Now, in this pa - rameterized version of self-attention, we compute 𝜔𝜔𝑖𝑖𝑖𝑖 as the dot product between the query and key: 𝜔𝜔𝑖𝑖𝑖𝑖=𝒒𝒒(𝑖𝑖)⊤𝒌𝒌(𝑖𝑖) For example, the following code computes the unnormalized attention weight, 𝜔𝜔23 , that is, the dot product between our query and the third input sequence element: >>> omega_23 = query_2.dot(keys[ 2]) >>> omega_23", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 493, "start_word": 157760, "end_word": 158160, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000494": {"text": "the unnormalized weights, 𝜔𝜔𝑖𝑖𝑖𝑖 , as the pairwise dot product between the given input sequence element, 𝒙𝒙(𝑖𝑖) , and the jth sequence element, 𝒙𝒙(𝑗𝑗) . Now, in this pa - rameterized version of self-attention, we compute 𝜔𝜔𝑖𝑖𝑖𝑖 as the dot product between the query and key: 𝜔𝜔𝑖𝑖𝑖𝑖=𝒒𝒒(𝑖𝑖)⊤𝒌𝒌(𝑖𝑖) For example, the following code computes the unnormalized attention weight, 𝜔𝜔23 , that is, the dot product between our query and the third input sequence element: >>> omega_23 = query_2.dot(keys[ 2]) >>> omega_23 tensor(14.3667) Since we will be needing these later, we can scale up this computation to all keys: >>> omega_2 = query_2.matmul(keys.T) >>> omega_2 tensor([-25.1623, 9.3602, 14.3667, 32.1482, 53.8976, 46.6626, -1.2131, -32.9391]) Transformers – Improving Natural Language Processing with Attention Mechanisms 552 The next step in self-attention is to go from the unnormalized attention weights, 𝜔𝜔𝑖𝑖𝑖𝑖 , to the normalized attention weights, 𝛼𝛼𝑖𝑖𝑖𝑖 , using the softmax function. We can then further use 1/√𝑚𝑚 to scale 𝜔𝜔𝑖𝑖𝑖𝑖 before normalizing it via the softmax function, as follows: 𝛼𝛼𝑖𝑖𝑖𝑖= softmax(ω𝑖𝑖𝑖𝑖 √𝑚𝑚) Note that scaling 𝜔𝜔𝑖𝑖𝑖𝑖 by 1/√𝑚𝑚 , where typically 𝑚𝑚𝑚𝑚𝑚 𝑘𝑘 , ensures that the Euclidean length of the weight vectors will be approximately in the same range. The following code is for implementing this normalization to compute the attention weights for the entire input sequence with respect to the second input element as the query: >>> attention_weights_2 = F.softmax(omega_2 / d** 0.5, dim=0) >>> attention_weights_2 tensor([2.2317e-09, 1.2499e-05, 4.3696e-05, 3.7242e-03, 8.5596e-01, 1.4025e-01, 8.8896e-07, 3.1936e-10]) Finally, the output is a weighted average of value sequences: 𝒛𝒛(𝑖𝑖)=∑𝛼𝛼𝑖𝑖𝑖𝑖𝒗𝒗(𝑖𝑖) 𝑇𝑇 𝑖𝑖𝑗𝑗 , which can be imple - mented as follows: >>> context_vector_2 = attention_weights_2.matmul(values) >>> context_vector_2 tensor([-1.2226, -3.4387, -4.3928, -5.2125, -1.1249, -3.3041, -1.4316, -3.2765, -2.5114, -2.6105, -1.5793, -2.8433, -2.4142, -0.3998, -1.9917, -3.3499]) In this section, we introduced a self-attention mechanism with trainable parameters that lets us com- pute context-aware embedding vectors by involving all input elements, which are weighted by their respective attention scores. In the next section, we will learn about the transformer architecture, a neural network architecture centered around the self-attention mechanism introduced in this section. Attention is all we need: introducing the original transformer architecture Interestingly, the original transformer architecture is based on an attention mechanism that was first used in an RNN. Originally, the intention behind using an attention mechanism was to improve the text generation capabilities of RNNs when working with long sentences. However, only a few years after ex -", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 494, "start_word": 158080, "end_word": 158480, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000495": {"text": "next section, we will learn about the transformer architecture, a neural network architecture centered around the self-attention mechanism introduced in this section. Attention is all we need: introducing the original transformer architecture Interestingly, the original transformer architecture is based on an attention mechanism that was first used in an RNN. Originally, the intention behind using an attention mechanism was to improve the text generation capabilities of RNNs when working with long sentences. However, only a few years after ex - perimenting with attention mechanisms for RNNs, researchers found that an attention-based language model was even more powerful when the recurrent layers were deleted. This led to the development of the transformer architecture, which is the main topic of this chapter and the remaining sections. The transformer architecture was first proposed in the NeurIPS 2017 paper Attention Is All You Need by A. Vaswani and colleagues ( https://arxiv.org/abs/1706.03762 ). Thanks to the self-attention mechanism, a transformer model can capture long-range dependencies among the elements in an input sequence—in an NLP context; for example, this helps the model better “understand” the mean- ing of an input sentence. Chapter 16 553 Although this transformer architecture was originally designed for language translation, it can be generalized to other tasks such as English constituency parsing, text generation, and text classification. Later, we will discuss popular language models, such as BERT and GPT, which were derived from this original transformer architecture. Figure 16.6, which we adapted from the original transformer paper, illustrates the main architecture and components we will be discussing in this section: Figure 16.6: The original transformer architecture Transformers – Improving Natural Language Processing with Attention Mechanisms 554 In the following subsections, we go over this original transformer model step by step, by decompos- ing it into two main blocks: an encoder and a decoder. The encoder receives the original sequential input and encodes the embeddings using a multi-head self-attention module. The decoder takes in the processed input and outputs the resulting sequence (for instance, the translated sentence) using a masked form of self-attention. Encoding context embeddings via multi-head attention The overall goal of the encoder block is to take in a sequential input 𝑿𝑿 𝑿 𝑿𝑿𝑿(1),𝑿𝑿(2),…,𝑿𝑿(𝑇𝑇)) and map it into a continuous representation 𝒁𝒁 𝒁 𝒁𝒁𝒁(1),𝒁𝒁(2),…,𝒁𝒁(𝑇𝑇)) that is then passed on to the decoder. The encoder is a stack of six identical layers. Six is not a magic number here but merely a", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 495, "start_word": 158400, "end_word": 158800, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000496": {"text": "in the processed input and outputs the resulting sequence (for instance, the translated sentence) using a masked form of self-attention. Encoding context embeddings via multi-head attention The overall goal of the encoder block is to take in a sequential input 𝑿𝑿 𝑿 𝑿𝑿𝑿(1),𝑿𝑿(2),…,𝑿𝑿(𝑇𝑇)) and map it into a continuous representation 𝒁𝒁 𝒁 𝒁𝒁𝒁(1),𝒁𝒁(2),…,𝒁𝒁(𝑇𝑇)) that is then passed on to the decoder. The encoder is a stack of six identical layers. Six is not a magic number here but merely a hyperparam - eter choice made in the original transformer paper. You can adjust the number of layers according to the model performance. Inside each of these identical layers, there are two sublayers: one computes the multi-head self-attention, which we will discuss below, and the other one is a fully connected layer, which you have already encountered in previous chapters. Let’s first talk about the multi-head self-attention, which is a simple modification of scaled dot-product attention covered earlier in this chapter. In the scaled dot-product attention, we used three matrices (corresponding to query, value, and key) to transform the input sequence. In the context of multi-head attention, we can think of this set of three matrices as one attention head. As indicated by its name, in multi-head attention, we now have multiple of such heads (sets of query, value, and key matrices) similar to how convolutional neural networks can have multiple kernels. To explain the concept of multi-head self-attention with ℎ heads in more detail, let’s break it down into the following steps. First, we read in the sequential input 𝑿𝑿 𝑿 𝑿𝑿𝑿(1),𝑿𝑿(2),…,𝑿𝑿(𝑇𝑇)) . Suppose each element is embedded by a vector of length d. Here, the input can be embedded into a 𝑇𝑇𝑇𝑇𝑇 matrix. Then, we create ℎ sets of the query, key, and value learning parameter matrices: • 𝑼𝑼𝒒𝒒1,𝑼𝑼𝒌𝒌1,𝑼𝑼𝒗𝒗1 • 𝑼𝑼𝒒𝒒2,𝑼𝑼𝒌𝒌2,𝑼𝑼𝒗𝒗2 • ... • 𝑼𝑼𝒒𝒒ℎ,𝑼𝑼𝒌𝒌ℎ,𝑼𝑼𝒗𝒗ℎ Because we are using these weight matrices to project each element 𝒙𝒙(𝑖𝑖) for the required dimen - sion-matching in the matrix multiplications, both 𝑼𝑼𝒒𝒒𝑗𝑗 and 𝑼𝑼𝒌𝒌𝑗𝑗 have the shape 𝑑𝑑𝑘𝑘×𝑑𝑑 , and 𝑼𝑼𝑣𝑣𝑗𝑗 has the shape 𝑑𝑑𝑣𝑣×𝑑𝑑 . As a result, both resulting sequences, query and key, have length 𝑑𝑑𝑘𝑘 , and the resulting value sequence has length 𝑑𝑑𝑣𝑣 . In practice, people often choose 𝑑𝑑𝑘𝑘=𝑑𝑑𝑣𝑣=𝑚𝑚 for simplicity. Chapter 16 555 To illustrate the multi-head self-attention stack in code, first consider how we created the single query projection matrix in the previous subsection, Parameterizing", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 496, "start_word": 158720, "end_word": 159120, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000497": {"text": "required dimen - sion-matching in the matrix multiplications, both 𝑼𝑼𝒒𝒒𝑗𝑗 and 𝑼𝑼𝒌𝒌𝑗𝑗 have the shape 𝑑𝑑𝑘𝑘×𝑑𝑑 , and 𝑼𝑼𝑣𝑣𝑗𝑗 has the shape 𝑑𝑑𝑣𝑣×𝑑𝑑 . As a result, both resulting sequences, query and key, have length 𝑑𝑑𝑘𝑘 , and the resulting value sequence has length 𝑑𝑑𝑣𝑣 . In practice, people often choose 𝑑𝑑𝑘𝑘=𝑑𝑑𝑣𝑣=𝑚𝑚 for simplicity. Chapter 16 555 To illustrate the multi-head self-attention stack in code, first consider how we created the single query projection matrix in the previous subsection, Parameterizing the self-attention mechanism: scaled dot-product attention: >>> torch.manual_seed( 123) >>> d = embedded_sentence.shape[ 1] >>> one_U_query = torch.rand(d, d) Now, assume we have eight attention heads similar to the original transformer, that is, ℎ=8 : >>> h = 8 >>> multihead_U_query = torch.rand(h, d, d) >>> multihead_U_key = torch.rand(h, d, d) >>> multihead_U_value = torch.rand(h, d, d) As we can see in the code, multiple attention heads can be added by simply adding an additional dimension. After initializing the projection matrices, we can compute the projected sequences similar to how it’s done in scaled dot-product attention. Now, instead of computing one set of query, key, and value sequences, we need to compute h sets of them. More formally, for example, the computation involving the query projection for the ith data point in the jth head can be written as follows: 𝒒𝒒𝑗𝑗(𝑖𝑖)=𝑼𝑼𝒒𝒒𝑗𝑗𝒙𝒙(𝑖𝑖) We then repeat this computation for all heads 𝑗𝑗𝑗𝑗𝑗𝑗𝑗𝑗𝑗𝑗𝑗𝑗𝑗 . In code, this looks like the following for the second input word as the query: >>> multihead_query_2 = multihead_U_query.matmul(x_2) >>> multihead_query_2.shape torch.Size([8, 16]) The multihead_query_2 matrix has eight rows, where each row corresponds to the jth attention head.Splitting data across multiple attention heads In practice, rather than having a separate matrix for each attention head, transformer implementations use a single matrix for all attention heads. The attention heads are then organized into logically separate regions in this matrix, which can be accessed via Boolean masks. This makes it possible to implement multi-head attention more efficiently because multiple matrix multiplications can be implemented as a single matrix multiplication instead. However, for simplicity, we are omitting this implementation detail in this section. Transformers – Improving Natural Language Processing with Attention Mechanisms 556 Similarly, we can compute key and value sequences for each head: >>> multihead_key_2 = multihead_U_key.matmul(x_2) >>> multihead_value_2 = multihead_U_value.matmul(x_2) >>> multihead_key_2[ 2] tensor([-1.9619, -0.7701, -0.7280, -1.6840, -1.0801, -1.6778, 0.6763, 0.6547, 1.4445, -2.7016, -1.1364, -1.1204, -2.4430, -0.5982, -0.8292, -1.4401]) The", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 497, "start_word": 159040, "end_word": 159440, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000498": {"text": "to implement multi-head attention more efficiently because multiple matrix multiplications can be implemented as a single matrix multiplication instead. However, for simplicity, we are omitting this implementation detail in this section. Transformers – Improving Natural Language Processing with Attention Mechanisms 556 Similarly, we can compute key and value sequences for each head: >>> multihead_key_2 = multihead_U_key.matmul(x_2) >>> multihead_value_2 = multihead_U_value.matmul(x_2) >>> multihead_key_2[ 2] tensor([-1.9619, -0.7701, -0.7280, -1.6840, -1.0801, -1.6778, 0.6763, 0.6547, 1.4445, -2.7016, -1.1364, -1.1204, -2.4430, -0.5982, -0.8292, -1.4401]) The code output shows the key vector of the second input element via the third attention head. However, remember that we need to repeat the key and value computations for all input sequence elements, not just x_2—we need this to compute self-attention later. A simple and illustrative way to do this is by expanding the input sequence embeddings to size 8 as the first dimension, which is the number of attention heads. We use the .repeat() method for this: >>> stacked_inputs = embedded_sentence.T.repeat( 8, 1, 1) >>> stacked_inputs.shape torch.Size([8, 16, 8]) Then, we can have a batch matrix multiplication, via torch.bmm() , with the attention heads to com- pute all keys: >>> multihead_keys = torch.bmm(multihead_U_key, stacked_inputs) >>> multihead_keys.shape torch.Size([8, 16, 8]) In this code, we now have a tensor that refers to the eight attention heads in its first dimension. The second and third dimensions refer to the embedding size and the number of words, respectively. Let us swap the second and third dimensions so that the keys have a more intuitive representation, that is, the same dimensionality as the original input sequence embedded_sentence : >>> multihead_keys = multihead_keys.permute( 0, 2, 1) >>> multihead_keys.shape torch.Size([8, 8, 16]) After rearranging, we can access the second key value in the second attention head as follows: >>> multihead_keys[ 2, 1] tensor([-1.9619, -0.7701, -0.7280, -1.6840, -1.0801, -1.6778, 0.6763, 0.6547, 1.4445, -2.7016, -1.1364, -1.1204, -2.4430, -0.5982, -0.8292, -1.4401]) We can see that this is the same key value that we got via multihead_key_2[2] earlier, which indicates that our complex matrix manipulations and computations are correct. So, let’s repeat it for the value sequences: >>> multihead_values = torch.matmul( multihead_U_value, stacked_inputs) >>> multihead_values = multihead_values.permute( 0, 2, 1) Chapter 16 557 We follow the steps of the single head attention calculation to calculate the context vectors as de - scribed in the Parameterizing the self-attention mechanism: scaled dot-product attention section. We will skip the intermediate steps for brevity", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 498, "start_word": 159360, "end_word": 159760, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000499": {"text": "key value that we got via multihead_key_2[2] earlier, which indicates that our complex matrix manipulations and computations are correct. So, let’s repeat it for the value sequences: >>> multihead_values = torch.matmul( multihead_U_value, stacked_inputs) >>> multihead_values = multihead_values.permute( 0, 2, 1) Chapter 16 557 We follow the steps of the single head attention calculation to calculate the context vectors as de - scribed in the Parameterizing the self-attention mechanism: scaled dot-product attention section. We will skip the intermediate steps for brevity and assume that we have computed the context vectors for the second input element as the query and the eight different attention heads, which we represent as multihead_z_2 via random data: >>> multihead_z_2 = torch.rand( 8, 16) Note that the first dimension indexes over the eight attention heads, and the context vectors, similar to the input sentences, are 16-dimensional vectors. If this appears complicated, think of multihead_z_2 as eight copies of the 𝑧𝑧(2) shown in Figure 16.5; that is, we have one 𝑧𝑧(2) for each of the eight attention heads. Then, we concatenate these vectors into one long vector of length 𝑑𝑑𝑣𝑣×ℎ and use a linear projection (via a fully connected layer) to map it back to a vector of length 𝑑𝑑𝑣𝑣 . This process is illustrated in Figure 16.7: Figure 16.7: Concatenating the scaled dot-product attention vectors into one vector and passing it through a linear projection In code, we can implement the concatenation and squashing as follows: >>> linear = torch.nn.Linear( 8*16, 16) >>> context_vector_2 = linear(multihead_z_2.flatten()) >>> context_vector_2.shape torch.Size([16]) Transformers – Improving Natural Language Processing with Attention Mechanisms 558 To summarize, multi-head self-attention is repeating the scaled dot-product attention computation multiple times in parallel and combining the results. It works very well in practice because the multiple heads help the model to capture information from different parts of the input, which is very similar to how the multiple kernels produce multiple channels in a convolutional network, where each channel can capture different feature information. Lastly, while multi-head attention sounds computationally expensive, note that the computation can all be done in parallel because there are no dependencies between the multiple heads. Learning a language model: decoder and masked multi-head attention Similar to the encoder, the decoder also contains several repeated layers. Besides the two sublayers that we have already introduced in the previous encoder section (the multi-head self-attention layer and fully connected layer), each repeated layer also contains", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 499, "start_word": 159680, "end_word": 160080, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000500": {"text": "each channel can capture different feature information. Lastly, while multi-head attention sounds computationally expensive, note that the computation can all be done in parallel because there are no dependencies between the multiple heads. Learning a language model: decoder and masked multi-head attention Similar to the encoder, the decoder also contains several repeated layers. Besides the two sublayers that we have already introduced in the previous encoder section (the multi-head self-attention layer and fully connected layer), each repeated layer also contains a masked multi-head attention sublayer. Masked attention is a variation of the original attention mechanism, where masked attention only passes a limited input sequence into the model by “masking” out a certain number of words. For example, if we are building a language translation model with a labeled dataset, at sequence position i during the training procedure, we only feed in the correct output words from positions 1,…,i-1. All other words (for instance, those that come after the current position) are hidden from the model to prevent the model from “cheating.” This is also consistent with the nature of text generation: although the true translated words are known during training, we know nothing about the ground truth in practice. Thus, we can only feed the model the solutions to what it has already generated, at position i. Figure 16.8 illustrates how the layers are arranged in the decoder block: Figure 16.8: Layer arrangement in the decoder part First, the previous output words (output embeddings) are passed into the masked multi-head atten- tion layer. Then, the second layer receives both the encoded inputs from the encoder block and the output of the masked multi-head attention layer into a multi-head attention layer. Finally, we pass the multi-head attention outputs into a fully connected layer that generates the overall model output: a probability vector corresponding to the output words. Chapter 16 559 Note that we can use an argmax function to obtain the predicted words from these word probabili- ties similar to the overall approach we took in the recurrent neural network in Chapter 15, Modeling Sequential Data Using Recurrent Neural Networks. Comparing the decoder with the encoder block, the main difference is the range of sequence elements that the model can attend to. In the encoder, for each given word, the attention is calculated across all the words in a sentence, which can be considered as a form of bidirectional input parsing.", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 500, "start_word": 160000, "end_word": 160400, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000501": {"text": "predicted words from these word probabili- ties similar to the overall approach we took in the recurrent neural network in Chapter 15, Modeling Sequential Data Using Recurrent Neural Networks. Comparing the decoder with the encoder block, the main difference is the range of sequence elements that the model can attend to. In the encoder, for each given word, the attention is calculated across all the words in a sentence, which can be considered as a form of bidirectional input parsing. The decoder also receives the bidirectionally parsed inputs from the encoder. However, when it comes to the output sequence, the decoder only considers those elements that are preceding the current input position, which can be interpreted as a form of unidirectional input parsing. Implementation details: positional encodings and layer normalization In this subsection, we will discuss some of the implementation details of transformers that we have glanced over so far but are worth mentioning. First, let’s consider the positional encodings that were part of the original transformer architecture from Figure 16.6. Positional encodings help with capturing information about the input sequence ordering and are a crucial part of transformers because both scaled dot-product attention layers and fully connected layers are permutation-invariant. This means, without positional encoding, the order of words is ignored and does not make any difference to the attention-based encodings. However, we know that word order is essential for understanding a sentence. For example, consider the following two sentences: 1. Mary gives John a flower 2. John gives Mary a flower The words occurring in the two sentences are exactly the same; the meanings, however, are very different. Transformers enable the same words at different positions to have slightly different encodings by adding a vector of small values to the input embeddings at the beginning of the encoder and decoder blocks. In particular, the original transformer architecture uses a so-called sinusoidal encoding: 𝑃𝑃𝑃𝑃 (𝑖𝑖𝑖𝑖𝑖𝑖 )=sin(𝑝𝑝𝑝𝑝𝑝𝑝/10000𝑖𝑖𝑖/𝑘𝑘 model ) 𝑃𝑃𝑃𝑃 (𝑖𝑖𝑖𝑖𝑖𝑖𝑖𝑖 )= cos (𝑝𝑝𝑝𝑝𝑝𝑝/10000𝑖𝑖𝑖/ 𝑘𝑘model ) Here 𝑖𝑖 is the position of the word and k denotes the length of the encoding vector, where we choose k to have the same dimension as the input word embeddings so that the positional encoding and word embeddings can be added together. Sinusoidal functions are used to prevent positional encodings from becoming too large. For instance, if we used absolute position 1,2,3…, n to be positional encodings, they would dominate the word encoding", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 501, "start_word": 160320, "end_word": 160720, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000502": {"text": "(𝑖𝑖𝑖𝑖𝑖𝑖𝑖𝑖 )= cos (𝑝𝑝𝑝𝑝𝑝𝑝/10000𝑖𝑖𝑖/ 𝑘𝑘model ) Here 𝑖𝑖 is the position of the word and k denotes the length of the encoding vector, where we choose k to have the same dimension as the input word embeddings so that the positional encoding and word embeddings can be added together. Sinusoidal functions are used to prevent positional encodings from becoming too large. For instance, if we used absolute position 1,2,3…, n to be positional encodings, they would dominate the word encoding and make the word embedding values negligible. Transformers – Improving Natural Language Processing with Attention Mechanisms 560 In general, there are two types of positional encodings, an absolute one (as shown in the previous formula) and a relative one. The former will record absolute positions of words and is sensitive to word shifts in a sentence. That is to say, absolute positional encodings are fixed vectors for each given position. On the other hand, relative encodings only maintain the relative position of words and are invariant to sentence shift. Next, let’s look at the layer normalization mechanism, which was first introduced by J. Ba, J.R. Kiros, and G.E. Hinton in 2016 in the same-named paper Layer Normalization (URL: https://arxiv.org/ abs/1607.06450 ). While batch normalization, which we will discuss in more detail in Chapter 17, Gen- erative Adversarial Networks for Synthesizing New Data, is a popular choice in computer vision contexts, layer normalization is the preferred choice in NLP contexts, where sentence lengths can vary. Figure 16.9 illustrates the main differences of layer and batch normalization side by side: Figure 16.9: A comparison of batch and layer normalization While layer normalization is traditionally performed across all elements in a given feature for each feature independently, the layer normalization used in transformers extends this concept and com- putes the normalization statistics across all feature values independently for each training example. Since layer normalization computes mean and standard deviation for each training example, it relaxes minibatch size constraints or dependencies. In contrast to batch normalization, layer normalization is thus capable of learning from data with small minibatch sizes and varying lengths. However, note that the original transformer architecture does not have varying-length inputs (sentences are padded when needed), and unlike RNNs, there is no recurrence in the model. So, how can we then justify the use of layer normalization over batch normalization? Transformers are usually trained on very large text corpora, which requires", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 502, "start_word": 160640, "end_word": 161040, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000503": {"text": "it relaxes minibatch size constraints or dependencies. In contrast to batch normalization, layer normalization is thus capable of learning from data with small minibatch sizes and varying lengths. However, note that the original transformer architecture does not have varying-length inputs (sentences are padded when needed), and unlike RNNs, there is no recurrence in the model. So, how can we then justify the use of layer normalization over batch normalization? Transformers are usually trained on very large text corpora, which requires parallel computation; this can be challenging to achieve with batch normalization, which has a dependency between training examples. Layer normalization has no such dependency and is thus a more natural choice for transformers. Chapter 16 561 Building large-scale language models by leveraging unlabeled data In this section, we will discuss popular large-scale transformer models that emerged from the original transformer. One common theme among these transformers is that they are pre-trained on very large, unlabeled datasets and then fine-tuned for their respective target tasks. First, we will introduce the common training procedure of transformer-based models and explain how it is different from the original transformer. Then, we will focus on popular large-scale language models including Generative Pre-trained Transformer (GPT ), Bidirectional Encoder Representations from Transformers (BERT ), and Bidirectional and Auto-Regressive Transformers (BART ). Pre-training and fine-tuning transformer models In an earlier section, Attention is all we need: introducing the original transformer architecture, we dis- cussed how the original transformer architecture can be used for language translation. Language translation is a supervised task and requires a labeled dataset, which can be very expensive to obtain. The lack of large, labeled datasets is a long-lasting problem in deep learning, especially for models like the transformer, which are even more data hungry than other deep learning architectures. How - ever, given that large amounts of text (books, websites, and social media posts) are generated every day, an interesting question is how we can use such unlabeled data for improving the model training. The answer to whether we can leverage unlabeled data in transformers is yes, and the trick is a process called self-supervised learning: we can generate “labels” from supervised learning from plain text itself. For example, given a large, unlabeled text corpus, we train the model to perform next-word prediction, which enables the model to learn the probability distribution of words and can form a strong basis for becoming a powerful", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 503, "start_word": 160960, "end_word": 161360, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000504": {"text": "can use such unlabeled data for improving the model training. The answer to whether we can leverage unlabeled data in transformers is yes, and the trick is a process called self-supervised learning: we can generate “labels” from supervised learning from plain text itself. For example, given a large, unlabeled text corpus, we train the model to perform next-word prediction, which enables the model to learn the probability distribution of words and can form a strong basis for becoming a powerful language model. Self-supervised learning is traditionally also referred to as unsupervised pre-training and is essential for the success of modern transformer-based models. The “unsupervised” in unsupervised pre-training supposedly refers to the fact that we use unlabeled data; however, since we use the structure of the data to generate labels (for example, the next-word prediction task mentioned previously), it is still a supervised learning process. To elaborate a bit further on how unsupervised pre-training and next-word prediction works, if we have a sentence containing n words, the pre-training procedure can be decomposed into the following three steps: 1. At time step 1, feed in the ground-truth words 1, …, i-1. 2. Ask the model to predict the word at position i and compare it with the ground-truth word i. 3. Update the model and time step, i:= i+1. Go back to step 1 and repeat until all words are pro - cessed. We should note that in the next iteration, we always feed the model the ground-truth (correct) words instead of what the model has generated in the previous round. Transformers – Improving Natural Language Processing with Attention Mechanisms 562 The main idea of pre-training is to make use of plain text and then transfer and fine-tune the model to perform some specific tasks for which a (smaller) labeled dataset is available. Now, there are many different types of pre-training techniques. For example, the previously mentioned next-word prediction task can be considered as a unidirectional pre-training approach. Later, we will introduce additional pre-training techniques that are utilized in different language models to achieve various functionalities. A complete training procedure of a transformer-based model consists of two parts: (1) pre-training on a large, unlabeled dataset and (2) training (that is, fine-tuning) the model for specific downstream tasks using a labeled dataset. In the first step, the pre-trained model is not designed for any specific task but rather trained as a “general” language", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 504, "start_word": 161280, "end_word": 161680, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000505": {"text": "considered as a unidirectional pre-training approach. Later, we will introduce additional pre-training techniques that are utilized in different language models to achieve various functionalities. A complete training procedure of a transformer-based model consists of two parts: (1) pre-training on a large, unlabeled dataset and (2) training (that is, fine-tuning) the model for specific downstream tasks using a labeled dataset. In the first step, the pre-trained model is not designed for any specific task but rather trained as a “general” language model. Afterward, via the second step, it can be gen- eralized to any customized task via regular supervised learning on a labeled dataset. With the representations that can be obtained from the pre-trained model, there are mainly two strat- egies for transferring and adopting a model to a specific task: (1) a feature-based approach and (2) a fine-tuning approach. (Here, we can think of these representations as the hidden layer activations of the last layers of a model.) The feature-based approach uses the pre-trained representations as additional features to a labeled dataset. This requires us to learn how to extract sentence features from the pre-trained model. An early model that is well-known for this feature extraction approach is ELMo (Embeddings from Language Models) proposed by Peters and colleagues in 2018 in the paper Deep Contextualized Word Representa- tions (URL: https://arxiv.org/abs/1802.05365 ). ELMo is a pre-trained bidirectional language model that masks words at a certain rate. In particular, it randomly masks 15 percent of the input words during pre-training, and the modeling task is to fill in these blanks, that is, predicting the missing (masked) words. This is different from the unidirectional approach we introduced previously, which hides all the future words at time step i. Bidirectional masking enables a model to learn from both ends and can thus capture more holistic information about a sentence. The pre-trained ELMo model can generate high-quality sentence representations that, later on, serve as input features for specific tasks. In other words, we can think of the feature-based approach as a model-based feature extraction technique similar to principal component analysis, which we covered in Chapter 5, Compressing Data via Dimensionality Reduction. The fine-tuning approach, on the other hand, updates the pre-trained model parameters in a regular supervised fashion via backpropagation. Unlike the feature-based method, we usually also add another fully connected layer to the pre-trained model, to accomplish certain tasks such as classification, and then", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 505, "start_word": 161600, "end_word": 162000, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000506": {"text": "features for specific tasks. In other words, we can think of the feature-based approach as a model-based feature extraction technique similar to principal component analysis, which we covered in Chapter 5, Compressing Data via Dimensionality Reduction. The fine-tuning approach, on the other hand, updates the pre-trained model parameters in a regular supervised fashion via backpropagation. Unlike the feature-based method, we usually also add another fully connected layer to the pre-trained model, to accomplish certain tasks such as classification, and then update the whole model based on the prediction performance on the labeled training set. One popular model that follows this approach is BERT, a large-scale transformer model pre-trained as a bidirectional language model. We will discuss BERT in more detail in the following subsections. In addition, in the last section of this chapter, we will see a code example showing how to fine-tune a pre-trained BERT model for sentiment classification using the movie review dataset we worked with in Chapter 8, Applying Machine Learning to Sentiment Analysis, and Chapter 15, Modeling Sequential Data Using Recurrent Neural Networks. Chapter 16 563 Before we move on to the next section and start our discussion of popular transformer-based language models, the following figure summarizes the two stages of training transformer models and illustrates the difference between the feature-based and fine-tuning approaches: Figure 16.10: The two main ways to adopt a pre-trained transformer for downstream tasks Leveraging unlabeled data with GPT The Generative Pre-trained Transformer ( GPT ) is a popular series of large-scale language models for generating text developed by OpenAI. The most recent model, GPT-3, which was released in May 2020 (Language Models are Few-Shot Learners), is producing astonishing results. The quality of the text generated by GPT-3 is very hard to distinguish from human-generated texts. In this section, we are going to discuss how the GPT model works on a high level, and how it has evolved over the years. As listed in Table 16.1, one obvious evolution within the GPT model series is the number of parameters: Model Release yearNumber of parametersTitle Paper link GPT-1 2018 110 million Improving Language Understanding by Generative Pre-Traininghttps://www.cs.ubc. ca/~amuham01/LING530/papers/ radford2018improving.pdf GPT-2 2019 1.5 billion Language Models are Unsupervised Multitask Learnershttps://www.semanticscholar. org/paper/Language-Models-are- Unsupervised-Multitask-Learners- Radford-Wu/9405cc0d6169988371b2 755e573cc28650d14dfe GPT-3 2020 175 billion Language Models are Few-Shot Learnershttps://arxiv.org/ pdf/2005.14165.pdf Table 16.1: Overview of the GPT models Transformers – Improving Natural Language Processing with Attention Mechanisms 564 But let’s not", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 506, "start_word": 161920, "end_word": 162320, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000507": {"text": "listed in Table 16.1, one obvious evolution within the GPT model series is the number of parameters: Model Release yearNumber of parametersTitle Paper link GPT-1 2018 110 million Improving Language Understanding by Generative Pre-Traininghttps://www.cs.ubc. ca/~amuham01/LING530/papers/ radford2018improving.pdf GPT-2 2019 1.5 billion Language Models are Unsupervised Multitask Learnershttps://www.semanticscholar. org/paper/Language-Models-are- Unsupervised-Multitask-Learners- Radford-Wu/9405cc0d6169988371b2 755e573cc28650d14dfe GPT-3 2020 175 billion Language Models are Few-Shot Learnershttps://arxiv.org/ pdf/2005.14165.pdf Table 16.1: Overview of the GPT models Transformers – Improving Natural Language Processing with Attention Mechanisms 564 But let’s not get ahead of ourselves, and take a closer look at the GPT-1 model first, which was released in 2018. Its training procedure can be decomposed into two stages: 1. Pre-training on a large amount of unlabeled plain text 2. Supervised fine-tuning As Figure 16.11 (adapted from the GPT-1 paper) illustrates, we can consider GPT-1 as a transformer consisting of (1) a decoder (and without an encoder block) and (2) an additional layer that is added later for the supervised fine-tuning to accomplish specific tasks: Figure 16.11: The GPT-1 transformer In the figure, note that if our task is Text Prediction (predicting the next word), then the model is ready after the pre-training step. Otherwise, for example, if our task is related to classification or regression, then supervised fine-tuning is required. During pre-training, GPT-1 utilizes a transformer decoder structure, where, at a given word position, the model only relies on preceding words to predict the next word. GPT-1 utilizes a unidirectional self-attention mechanism, as opposed to a bidirectional one as in BERT (which we will cover later in this chapter), because GPT-1 is focused on text generation rather than classification. During text gen- eration, it produces words one by one with a natural left-to-right direction. There is one other aspect worth highlighting here: during the training procedure, for each position, we always feed the correct words from the previous positions to the model. However, during inference, we just feed the model whatever words it has generated to be able to generate new texts. Chapter 16 565 After obtaining the pre-trained model (the block in the previous figure labeled as Transformer), we then insert it between the input pre-processing block and a linear layer, where the linear layer serves as an output layer (similar to previous deep neural network models we discussed earlier in this book). For classification tasks, fine-tuning is as simple as first tokenizing the input and then feeding it", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 507, "start_word": 162240, "end_word": 162640, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000508": {"text": "whatever words it has generated to be able to generate new texts. Chapter 16 565 After obtaining the pre-trained model (the block in the previous figure labeled as Transformer), we then insert it between the input pre-processing block and a linear layer, where the linear layer serves as an output layer (similar to previous deep neural network models we discussed earlier in this book). For classification tasks, fine-tuning is as simple as first tokenizing the input and then feeding it into the pre-trained model and the newly added linear layer, which is followed by a softmax activation function. However, for more complicated tasks such as question answering, inputs are organized in a certain format that is not necessarily matching the pre-trained model, which requires an extra processing step customized for each task. Readers who are interested in specific modifications are encouraged to read the GPT-1 paper for additional details (the link is provided in the previous table). GPT-1 also performs surprisingly well on zero-shot tasks, which proves its ability to be a general lan- guage model that can be customized for different types of tasks with minimal task-specific fine-tuning. Zero-shot learning generally describes a special circumstance in machine learning where during testing and inference, the model is required to classify samples from classes that were not observed during training. In the context of GPT, the zero-shot setting refers to unseen tasks. GPT’s adaptability inspired researchers to get rid of the task-specific input and model setup, which led to the development of GPT-2. Unlike its predecessor, GPT-2 does not require any additional mod- ification during the input or fine-tuning stages anymore. Instead of rearranging sequences to match the required format, GPT-2 can distinguish between different types of inputs and perform the corre - sponding downstream tasks with minor hints, the so-called “contexts.” This is achieved by modeling output probabilities conditioned on both input and task type, 𝑝𝑝(𝑜𝑜𝑜𝑜𝑜𝑜𝑝𝑝𝑜𝑜𝑜𝑜|𝑖𝑖𝑖𝑖𝑝𝑝𝑜𝑜𝑜𝑜𝑖𝑜𝑜𝑖𝑖𝑖𝑖𝑖𝑖) , instead of only conditioning on the input. For example, the model is expected to recognize a translation task if the context includes translate to French, English text, French text . This sounds much more “artificially intelligent” than GPT and is indeed the most noticeable improve - ment besides the model size. Just as the title of its corresponding paper indicates (Language Models are Unsupervised Multitask Learners), an unsupervised language model may be key to zero-shot learning, and GPT-2 makes full use of zero-shot", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 508, "start_word": 162560, "end_word": 162960, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000509": {"text": "conditioning on the input. For example, the model is expected to recognize a translation task if the context includes translate to French, English text, French text . This sounds much more “artificially intelligent” than GPT and is indeed the most noticeable improve - ment besides the model size. Just as the title of its corresponding paper indicates (Language Models are Unsupervised Multitask Learners), an unsupervised language model may be key to zero-shot learning, and GPT-2 makes full use of zero-shot task transfer to build this multi-task learner. Compared with GPT-2, GPT-3 is less “ambitious” in the sense that it shifts the focus from zero- to one- shot and few-shot learning via in-context learning. While providing no task-specific training examples seems to be too strict, few-shot learning is not only more realistic but also more human-like: humans usually need to see a few examples to be able to learn a new task. Just as its name suggests, few-shot learning means that the model sees a few examples of the task while one-shot learning is restricted to exactly one example. Transformers – Improving Natural Language Processing with Attention Mechanisms 566 Figure 16.12 illustrates the difference between zero-shot, one-shot, few-shot, and fine-tuning proce - dures: Figure 16.12: A comparison of zero-shot, one-shot, and few-shot learning The model architecture of GPT-3 is pretty much the same as GPT-2 except for the 100-fold parameter size increase and the use of a sparse transformer. In the original (dense) attention mechanism we discussed earlier, each element attends to all other elements in the input, which scales with 𝑂𝑂(𝑛𝑛2) complexity. Sparse attention improves the efficiency by only attending to a subset of elements with limited size, normally proportional to 𝑛𝑛1/𝑝𝑝 . Interested readers can learn more about the specific subset selection by visiting the sparse transformer paper: Generating Long Sequences with Sparse Transformers by Rewon Child et al. 2019 (URL: https://arxiv.org/abs/1904.10509 ). Using GPT-2 to generate new text Before we move on to the next transformer architecture, let us take a look at how we can use the latest GPT models to generate new text. Note that GPT-3 is still relatively new and is currently only available as a beta version via the OpenAI API at https://openai.com/blog/openai-api/ . However, an implementation of GPT-2 has been made available by Hugging Face (a popular NLP and machine learning company; http://huggingface.co ), which we will use. Chapter 16 567 We will", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 509, "start_word": 162880, "end_word": 163280, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000510": {"text": "Before we move on to the next transformer architecture, let us take a look at how we can use the latest GPT models to generate new text. Note that GPT-3 is still relatively new and is currently only available as a beta version via the OpenAI API at https://openai.com/blog/openai-api/ . However, an implementation of GPT-2 has been made available by Hugging Face (a popular NLP and machine learning company; http://huggingface.co ), which we will use. Chapter 16 567 We will be accessing GPT-2 via transformers , which is a very comprehensive Python library created by Hugging Face that provides various transformer-based models for pre-training and fine-tuning. Users can also discuss and share their customized models on the forum. Feel free to check out and engage with the community if you are interested: https://discuss.huggingface.co . Once we have installed the transformers library, we can run the following code to import a pre-trained GPT model that can generate new text: >>> from transformers import pipeline, set_seed >>> generator = pipeline( 'text-generation' , model= 'gpt2') Then, we can prompt the model with a text snippet and ask it to generate new text based on that input snippet: >>> set_seed( 123) >>> generator( \"Hey readers, today is\" , ... max_length= 20, ... num_return_sequences= 3) [{'generated_text': \"Hey readers, today is not the last time we'll be seeing one of our favorite indie rock bands\"}, {'generated_text': 'Hey readers, today is Christmas. This is not Christmas, because Christmas is so long and I hope'}, {'generated_text': \"Hey readers, today is CTA Day!\\n\\nWe're proud to be hosting a special event\"}] As we can see from the output, the model generated three reasonable sentences based on our text snippet. If you want to explore more examples, please feel free to change the random seed and the maximum sequence length.Installing transformers version 4.9.1 Because this package is evolving rapidly, you may not be able to replicate the results in the following subsections. For reference, this tutorial uses version 4.9.1 released in June 2021. To install the version we used in this book, you can execute the following command in your terminal to install it from PyPI: pip install transformers==4.9.1 We also recommend checking the latest instructions on the official installation page: https://huggingface.co/transformers/installation.html Transformers – Improving Natural Language Processing with Attention Mechanisms 568 Also, as previously illustrated in Figure 16.10, we can use a transformer model to generate features for training other", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 510, "start_word": 163200, "end_word": 163600, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000511": {"text": "subsections. For reference, this tutorial uses version 4.9.1 released in June 2021. To install the version we used in this book, you can execute the following command in your terminal to install it from PyPI: pip install transformers==4.9.1 We also recommend checking the latest instructions on the official installation page: https://huggingface.co/transformers/installation.html Transformers – Improving Natural Language Processing with Attention Mechanisms 568 Also, as previously illustrated in Figure 16.10, we can use a transformer model to generate features for training other models. The following code illustrates how we can use GPT-2 to generate features based on an input text: >>> from transformers import GPT2Tokenizer >>> tokenizer = GPT2Tokenizer.from_pretrained( 'gpt2') >>> text = \"Let us encode this sentence\" >>> encoded_input = tokenizer(text, return_tensors= 'pt') >>> encoded_input {'input_ids': tensor([[ 5756, 514, 37773, 428, 6827]]), 'attention_mask': tensor([[1, 1, 1, 1, 1]])} This code encoded the input sentence text into a tokenized format for the GPT-2 model. As we can see, it mapped the strings to an integer representation, and it set the attention mask to all 1s, which means that all words will be processed when we pass the encoded input to the model, as shown here: >>> from transformers import GPT2Model >>> model = GPT2Model.from_pretrained( 'gpt2') >>> output = model(**encoded_input) The output variable stores the last hidden state, that is, our GPT-2-based feature encoding of the input sentence: >>> output[ 'last_hidden_state' ].shape torch.Size([1, 5, 768]) To suppress the verbose output, we only showed the shape of the tensor. Its first dimension is the batch size (we only have one input text), which is followed by the sentence length and size of the feature encoding. Here, each of the five words is encoded as a 768-dimensional vector. Now, we could apply this feature encoding to a given dataset and train a downstream classifier based on the GPT-2-based feature representation instead of using a bag-of-words model as discussed in Chapter 8, Applying Machine Learning to Sentiment Analysis. Moreover, an alternative approach to using large pre-trained language models is fine-tuning, as we discussed earlier. We will be seeing a fine-tuning example later in this chapter. If you are interested in additional details on using GPT-2, we recommend the following documenta - tion pages: • https://huggingface.co/gpt2 • https://huggingface.co/docs/transformers/model_doc/gpt2 Chapter 16 569 Bidirectional pre-training with BERT BERT , its full name being Bidirectional Encoder Representations from Transformers, was created by a Google research team in 2018 (BERT: Pre-training", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 511, "start_word": 163520, "end_word": 163920, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000512": {"text": "Sentiment Analysis. Moreover, an alternative approach to using large pre-trained language models is fine-tuning, as we discussed earlier. We will be seeing a fine-tuning example later in this chapter. If you are interested in additional details on using GPT-2, we recommend the following documenta - tion pages: • https://huggingface.co/gpt2 • https://huggingface.co/docs/transformers/model_doc/gpt2 Chapter 16 569 Bidirectional pre-training with BERT BERT , its full name being Bidirectional Encoder Representations from Transformers, was created by a Google research team in 2018 (BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding by J. Devlin, M. Chang, K. Lee, and K. Toutanova, https://arxiv.org/abs/1810.04805 ). For reference, even though we cannot compare GPT and BERT directly as they are different architec- tures, BERT has 345 million parameters (which makes it only slightly larger than GPT-1, and its size is only 1/5 of GPT-2). As its name suggests, BERT has a transformer-encoder-based model structure that utilizes a bidirection - al training procedure. (Or, more accurately, we can think of BERT as using “nondirectional” training because it reads in all input elements all at once.) Under this setting, the encoding of a certain word depends on both the preceding and the succeeding words. Recall that in GPT, input elements are read in with a natural left-to-right order, which helps to form a powerful generative language model. Bidirectional training disables BERT’s ability to generate a sentence word by word but provides input encodings of higher quality for other tasks, such as classification, since the model can now process information in both directions. Recall that in a transformer’s encoder, token encoding is a summation of positional encodings and token embeddings. In the BERT encoder, there is an additional segment embedding indicating which segment this token belongs to. This means that each token representation contains three ingredients, as Figure 16.13 illustrates: Figure 16.13: Preparing the inputs for the BERT encoder Why do we need this additional segment information in BERT? The need for this segment information originated from the special pre-training task of BERT called next-sentence prediction. In this pre-training task, each training example includes two sentences and thus requires special segment notation to denote whether it belongs to the first or second sentence. Transformers – Improving Natural Language Processing with Attention Mechanisms 570 Now, let us look at BERT’s pre-training tasks in more detail. Similar to all other transformer-based language models, BERT has two training stages: pre-training and fine-tuning. And", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 512, "start_word": 163840, "end_word": 164240, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000513": {"text": "need for this segment information originated from the special pre-training task of BERT called next-sentence prediction. In this pre-training task, each training example includes two sentences and thus requires special segment notation to denote whether it belongs to the first or second sentence. Transformers – Improving Natural Language Processing with Attention Mechanisms 570 Now, let us look at BERT’s pre-training tasks in more detail. Similar to all other transformer-based language models, BERT has two training stages: pre-training and fine-tuning. And pre-training includes two unsupervised tasks: masked language modeling and next-sentence prediction. In the masked language model ( MLM ), tokens are randomly replaced by so-called mask tokens, [MASK] , and the model is required to predict these hidden words. Compared with the next-word prediction in GPT, MLM in BERT is more akin to “filling in the blanks” because the model can attend to all tokens in the sentence (except the masked ones). However, simply masking words out can result in inconsis- tencies between pre-training and fine-tuning since [MASK] tokens do not appear in regular texts. To alleviate this, there are further modifications to the words that are selected for masking. For instance, 15 percent of the words in BERT are marked for masking. These 15 percent of randomly selected words are then further treated as follows: 1. Keep the word unchanged 10 percent of the time 2. Replace the original word token with a random word 10 percent of the time 3. Replace the original word token with a mask token, [MASK] , 80 percent of the time Besides avoiding the aforementioned inconsistency between pre-training and fine-tuning when in- troducing [MASK] tokens into the training procedure, these modifications also have other benefits. Firstly, unchanged words include the possibility of maintaining the information of the original token; otherwise, the model can only learn from the context and nothing from the masked words. Secondly, the 10 percent random words prevent the model from becoming lazy, for instance, learning nothing but returning what it is being given. The probabilities for masking, randomizing, and leaving words unchanged were chosen by an ablation study (see the GPT-2 paper); for instance, authors tested dif- ferent settings and found that this combination worked best. Figure 16.14 illustrates an example where the word fox is masked and, with a certain probability, re - mains unchanged or is replaced by [MASK] or coffee. The model is then required to", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 513, "start_word": 164160, "end_word": 164560, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000514": {"text": "from becoming lazy, for instance, learning nothing but returning what it is being given. The probabilities for masking, randomizing, and leaving words unchanged were chosen by an ablation study (see the GPT-2 paper); for instance, authors tested dif- ferent settings and found that this combination worked best. Figure 16.14 illustrates an example where the word fox is masked and, with a certain probability, re - mains unchanged or is replaced by [MASK] or coffee. The model is then required to predict what the masked (highlighted) word is as illustrated in Figure 16.14: Figure 16.14: An example of MLM Next-sentence prediction is a natural modification of the next-word prediction task considering the bidirectional encoding of BERT. In fact, many important NLP tasks, such as question answering, depend on the relationship of two sentences in the document. This kind of relationship is hard to capture via regular language models because next-word prediction training usually occurs on a single-sentence level due to input length constraints. Chapter 16 571 In the next-sentence prediction task, the model is given two sentences, A and B, in the following format: [CLS] A [SEP] B [SEP] [CLS] is a classification token, which serves as a placeholder for the predicted label in the decoder output, as well as a token denoting the beginning of the sentences. The [SEP] token, on the other hand, is attached to denote the end of each sentence. The model is then required to classify whether B is the next sentence (“IsNext”) of A or not. To provide the model with a balanced dataset, 50 percent of the samples are labeled as “IsNext” while the remaining samples are labeled as “NotNext.” BERT is pre-trained on these two tasks, masked sentences and next-sentence prediction, at the same time. Here, the training objective of BERT is to minimize the combined loss function of both tasks. Starting from the pre-trained model, specific modifications are required for different downstream tasks in the fine-tuning stage. Each input example needs to match a certain format; for example, it should begin with a [CLS] token and be separated using [SEP] tokens if it consists of more than one sentence. Roughly speaking, BERT can be fine-tuned on four categories of tasks: (a) sentence pair classification; (b) single-sentence classification; (c) question answering; (d) single-sentence tagging. Among them, (a) and (b) are sequence-level classification tasks, which only require an additional softmax layer to be added", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 514, "start_word": 164480, "end_word": 164880, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000515": {"text": "tasks in the fine-tuning stage. Each input example needs to match a certain format; for example, it should begin with a [CLS] token and be separated using [SEP] tokens if it consists of more than one sentence. Roughly speaking, BERT can be fine-tuned on four categories of tasks: (a) sentence pair classification; (b) single-sentence classification; (c) question answering; (d) single-sentence tagging. Among them, (a) and (b) are sequence-level classification tasks, which only require an additional softmax layer to be added to the output representation of the [CLS] token. (c) and (d), on the other hand, are token-level classification tasks. This means that the model passes output representations of all related tokens to the softmax layer to predict a class label for each individual token. Question answering Task (c), question answering, appears to be less often discussed compared to other popular classification tasks such as sentiment classification or speech tagging. In question answer - ing, each input example can be split into two parts, the question and the paragraph that helps to answer the question. The model is required to point out both the start and end token in the paragraph that forms a proper answer to the question. This means that the model needs to generate a tag for every single token in the paragraph, indicating whether this token is a start or end token, or neither. As a side note, it is worth mentioning that the output may contain an end token that appears before the start token, which will lead to a conflict when generating the answer. This kind of output will be recognized as “No Answer” to the question. Transformers – Improving Natural Language Processing with Attention Mechanisms 572 As Figure 16.15 indicates, the model fine-tuning setup has a very simple structure: an input encoder is attached to a pre-trained BERT, and a softmax layer is added for classification. Once the model structure is set up, all the parameters will be adjusted along the learning process. Figure 16.15: Using BERT to fine-tune different language tasks The best of both worlds: BART The Bidirectional and Auto-Regressive Transformer , abbreviated as BART , was developed by re - searchers at Facebook AI Research in 2019: BART: Denoising Sequence-to-Sequence Pre-training for Nat- ural Language Generation, Translation, and Comprehension, Lewis and colleagues, https://arxiv.org/ abs/1910.13461 . Recall that in previous sections we argued that GPT utilizes a transformer’s decoder structure, whereas BERT", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 515, "start_word": 164800, "end_word": 165200, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000516": {"text": "the parameters will be adjusted along the learning process. Figure 16.15: Using BERT to fine-tune different language tasks The best of both worlds: BART The Bidirectional and Auto-Regressive Transformer , abbreviated as BART , was developed by re - searchers at Facebook AI Research in 2019: BART: Denoising Sequence-to-Sequence Pre-training for Nat- ural Language Generation, Translation, and Comprehension, Lewis and colleagues, https://arxiv.org/ abs/1910.13461 . Recall that in previous sections we argued that GPT utilizes a transformer’s decoder structure, whereas BERT utilizes a transformer’s encoder structure. Those two models are thus capable of performing different tasks well: GPT’s specialty is generating text, whereas BERT performs better on classification tasks. BART can be viewed as a generalization of both GPT and BERT. As the title of this section suggests, BART is able to accomplish both tasks, generating and classifying text. The reason why it can handle both tasks well is that the model comes with a bidirectional encoder as well as a left-to-right autoregressive decoder. Chapter 16 573 You may wonder how this is different from the original transformer. There are a few changes to the model size along with some minor changes such as activation function choices. However, one of the more interesting changes is that BART works with different model inputs. The original transformer model was designed for language translation so there are two inputs: the text to be translated (source sequence) for the encoder and the translation (target sequence) for the decoder. Additionally, the decoder also receives the encoded source sequence, as illustrated earlier in Figure 16.6. However, in BART, the input format was generalized such that it only uses the source sequence as input. BART can perform a wider range of tasks including language translation, where a target sequence is still required to compute the loss and fine-tune the model, but it is not necessary to feed it directly into the decoder. Now let us take a closer look at the BART’s model structure. As previously mentioned, BART is com- posed of a bidirectional encoder and an autoregressive decoder. Upon receiving a training example as plain text, the input will first be “corrupted” and then encoded by the encoder. These input encodings will then be passed to the decoder, along with the generated tokens. The cross-entropy loss between encoder output and the original text will be calculated and then optimized through the learning pro - cess. Think of", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 516, "start_word": 165120, "end_word": 165520, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000517": {"text": "look at the BART’s model structure. As previously mentioned, BART is com- posed of a bidirectional encoder and an autoregressive decoder. Upon receiving a training example as plain text, the input will first be “corrupted” and then encoded by the encoder. These input encodings will then be passed to the decoder, along with the generated tokens. The cross-entropy loss between encoder output and the original text will be calculated and then optimized through the learning pro - cess. Think of a transformer where we have two texts in different languages as input to the decoder: the initial text to be translated (source text) and the generated text in the target language. BART can be understood as replacing the former with corrupted text and the latter with the input text itself. Figure 16.16: BART’s model structure To explain the corruption step in a bit more detail, recall that BERT and GPT are pre-trained by recon- structing masked words: BERT is “filling in the blanks” and GPT is “predicting the next word.” These pre-training tasks can also be recognized as reconstructing corrupted sentences because masking words is one way of corrupting a sentence. BART provides the following corruption methods that can be applied to the clean text: • Token masking • Token deletion • Text infilling • Sentence permutation • Document rotation One or more of the techniques listed above can be applied to the same sentence; in the worst scenario, where all the information is contaminated and corrupted, the text becomes useless. Hence, the encod - er has limited utility, and with only the decoder module working properly, the model will essentially become more similar to a unidirectional language. Transformers – Improving Natural Language Processing with Attention Mechanisms 574 BART can be fine-tuned on a wide range of downstream tasks including (a) sequence classification, (b) token classification, (c) sequence generation, and (d) machine translation. As with BERT, small changes to the inputs need to be made in order to perform different tasks. In the sequence classification task, an additional token needs to be attached to the input to serve as the generated label token, which is similar to the [CLS] token in BERT. Also, instead of disturbing the input, uncorrupted input is fed into both the encoder and decoder so that the model can make full use of the input. For token classification, additional tokens become unnecessary, and the model can", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 517, "start_word": 165440, "end_word": 165840, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000518": {"text": "inputs need to be made in order to perform different tasks. In the sequence classification task, an additional token needs to be attached to the input to serve as the generated label token, which is similar to the [CLS] token in BERT. Also, instead of disturbing the input, uncorrupted input is fed into both the encoder and decoder so that the model can make full use of the input. For token classification, additional tokens become unnecessary, and the model can directly use the generated representation for each token for classification. Sequence generation in BART differs a bit from GPT because of the existence of the encoder. Instead of generating text from the ground up, sequence generation tasks via BART are more comparable to summarization, where the model is given a corpus of contexts and asked to generate a summary or an abstractive answer to certain questions. To this end, whole input sequences are fed into the encoder while the decoder generates output autoregressively. Finally, it’s natural for BART to perform machine translation considering the similarity between BART and the original transformer. However, instead of following the exact same procedure as for training the original transformer, researchers considered the possibility of incorporating the entire BART model as a pre-trained decoder. To complete the translation model, a new set of randomly initialized parameters is added as a new, additional encoder. Then, the fine-tuning stage can be accomplished in two steps: 1. First, freeze all the parameters except the encoder 2. Then, update all parameters in the model BART was evaluated on several benchmark datasets for various tasks, and it obtained very competi- tive results compared to other famous language models such as BERT. In particular, for generation tasks including abstractive question answering, dialogue response, and summarization tasks, BART achieved state-of-the-art results. Fine-tuning a BERT model in PyTorch Now that we have introduced and discussed all the necessary concepts and the theory behind the original transformer and popular transformer-based models, it’s time to take a look at the more prac- tical part! In this section, you will learn how to fine-tune a BERT model for sentiment classification in PyTorch. Note that although there are many other transformer-based models to choose from, BERT provides a nice balance between model popularity and having a manageable model size so that it can be fine- tuned on a single GPU. Note also that pre-training a BERT from", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 518, "start_word": 165760, "end_word": 166160, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000519": {"text": "the original transformer and popular transformer-based models, it’s time to take a look at the more prac- tical part! In this section, you will learn how to fine-tune a BERT model for sentiment classification in PyTorch. Note that although there are many other transformer-based models to choose from, BERT provides a nice balance between model popularity and having a manageable model size so that it can be fine- tuned on a single GPU. Note also that pre-training a BERT from scratch is painful and quite unnecessary considering the availability of the transformers Python package provided by Hugging Face, which includes a bunch of pre-trained models that are ready for fine-tuning. Chapter 16 575 In the following sections, you’ll see how to prepare and tokenize the IMDb movie review dataset and fine-tune the distilled BERT model to perform sentiment classification. We deliberately chose sentiment classification as a simple but classic example, though there are many other fascinating applications of language models. Also, by using the familiar IMDb movie review dataset, we can get a good idea of the predictive performance of the BERT model by comparing it to the logistic regression model in Chapter 8, Applying Machine Learning to Sentiment Analysis, and the RNN in Chapter 15, Modeling Sequential Data Using Recurrent Neural Networks. Loading the IMDb movie review dataset In this subsection, we will begin by loading the required packages and the dataset, split into train, validation, and test sets. For the BERT-related parts of this tutorial, we will mainly use the open-source transformers library (https://huggingface.co/transformers/ ) created by Hugging Face, which we installed in the pre - vious section, Using GPT-2 to generate new text. The DistilBERT model we are using in this chapter is a lightweight transformer model created by distill - ing a pre-trained BERT base model. The original uncased BERT base model contains over 110 million parameters while DistilBERT has 40 percent fewer parameters. Also, DistilBERT runs 60 percent faster and still preserves 95 percent of BERT’s performance on the GLUE language understanding benchmark. The following code imports all the packages we will be using in this chapter to prepare the data and fine-tune the DistilBERT model: >>> import gzip >>> import shutil >>> import time >>> import pandas as pd >>> import requests >>> import torch >>> import torch.nn.functional as F >>> import torchtext >>> import transformers >>> from transformers import DistilBertTokenizerFast >>> from transformers", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 519, "start_word": 166080, "end_word": 166480, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000520": {"text": "runs 60 percent faster and still preserves 95 percent of BERT’s performance on the GLUE language understanding benchmark. The following code imports all the packages we will be using in this chapter to prepare the data and fine-tune the DistilBERT model: >>> import gzip >>> import shutil >>> import time >>> import pandas as pd >>> import requests >>> import torch >>> import torch.nn.functional as F >>> import torchtext >>> import transformers >>> from transformers import DistilBertTokenizerFast >>> from transformers import DistilBertForSequenceClassification Next, we specify some general settings, including the number of epochs we train the network on, the device specification, and the random seed. To reproduce the results, make sure to set a specific random seed such as 123: >>> torch.backends.cudnn.deterministic = True >>> RANDOM_SEED = 123 >>> torch.manual_seed(RANDOM_SEED) Transformers – Improving Natural Language Processing with Attention Mechanisms 576 >>> DEVICE = torch.device( 'cuda' if torch.cuda.is_available() else 'cpu') >>> NUM_EPOCHS = 3 We will be working on the IMDb movie review dataset, which you have already seen in Chapters 8 and 15. The following code fetches the compressed dataset and unzips it: >>> url = ( \"https://github.com/rasbt/\" ... \"machine-learning-book/raw/\" ... \"main/ch08/movie_data.csv.gz\" ) >>> filename = url.split( \"/\")[-1] >>> with open(filename, \"wb\") as f: ... r = requests.get(url) ... f.write(r.content) >>> with gzip.open('movie_data.csv.gz' , 'rb') as f_in: ... with open('movie_data.csv' , 'wb') as f_out: ... shutil.copyfileobj(f_in, f_out) If you have the movie_data.csv file from Chapter 8 still on your hard drive, you can skip this download and unzip procedure. Next, we load the data into a pandas DataFrame and make sure it looks all right: >>> df = pd.read_csv( 'movie_data.csv' ) >>> df.head( 3) Figure 16.17: The first three rows of the IMDb movie review dataset The next step is to split the dataset into separate training, validation, and test sets. Here, we use 70 percent of the reviews for the training set, 10 percent for the validation set, and the remaining 20 percent for testing: >>> train_texts = df.iloc[: 35000]['review' ].values >>> train_labels = df.iloc[: 35000]['sentiment' ].values >>> valid_texts = df.iloc[ 35000:40000]['review' ].values Chapter 16 577 >>> valid_labels = df.iloc[ 35000:40000]['sentiment' ].values >>> test_texts = df.iloc[ 40000:]['review' ].values >>> test_labels = df.iloc[ 40000:]['sentiment' ].values Tokenizing the dataset So far, we have obtained the texts and labels for the training, validation, and test sets. Now, we are going to tokenize the texts into individual word tokens using the tokenizer implementation", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 520, "start_word": 166400, "end_word": 166800, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000521": {"text": "the remaining 20 percent for testing: >>> train_texts = df.iloc[: 35000]['review' ].values >>> train_labels = df.iloc[: 35000]['sentiment' ].values >>> valid_texts = df.iloc[ 35000:40000]['review' ].values Chapter 16 577 >>> valid_labels = df.iloc[ 35000:40000]['sentiment' ].values >>> test_texts = df.iloc[ 40000:]['review' ].values >>> test_labels = df.iloc[ 40000:]['sentiment' ].values Tokenizing the dataset So far, we have obtained the texts and labels for the training, validation, and test sets. Now, we are going to tokenize the texts into individual word tokens using the tokenizer implementation inherited from the pre-trained model class: >>> tokenizer = DistilBertTokenizerFast.from_pretrained( ... 'distilbert-base-uncased' ... ) >>> train_encodings = tokenizer(list(train_texts), truncation=True, padding=True) >>> valid_encodings = tokenizer(list(valid_texts), truncation=True, padding=True) >>> test_encodings = tokenizer(list(test_texts), truncation=True, padding=True) Finally, let’s pack everything into a class called IMDbDataset and create the corresponding data loaders. Such a self-defined dataset class lets us customize all the related features and functions for our custom movie review dataset in DataFrame format: >>> class IMDbDataset (torch.utils.data.Dataset): ... def __init__ (self, encodings, labels): ... self.encodings = encodings ... self.labels = labels >>> def __getitem__ (self, idx): ... item = {key: torch.tensor(val[idx]) ... for key, val in self.encodings.items()} ... item[ 'labels' ] = torch.tensor(self.labels[idx])Choosing different tokenizers If you are interested in applying different types of tokenizers, feel free to explore the tokenizers package (https://huggingface.co/docs/tokenizers/python/latest/ ), which is also built and maintained by Hugging Face. However, inherited tokenizers main- tain the consistency between the pre-trained model and the dataset, which saves us the extra effort of finding the specific tokenizer corresponding to the model. In other words, using an inherited tokenizer is the recommended approach if you want to fine-tune a pre-trained model. Transformers – Improving Natural Language Processing with Attention Mechanisms 578 ... return item >>> def __len__ (self): ... return len(self.labels) >>> train_dataset = IMDbDataset(train_encodings, train_labels) >>> valid_dataset = IMDbDataset(valid_encodings, valid_labels) >>> test_dataset = IMDbDataset(test_encodings, test_labels) >>> train_loader = torch.utils.data.DataLoader( ... train_dataset, batch_size= 16, shuffle= True) >>> valid_loader = torch.utils.data.DataLoader( ... valid_dataset, batch_size= 16, shuffle= False) >>> test_loader = torch.utils.data.DataLoader( ... test_dataset, batch_size= 16, shuffle= False) While the overall data loader setup should be familiar from previous chapters, one noteworthy detail is the item variable in the __getitem__ method. The encodings we produced previously store a lot of information about the tokenized texts. Via the dictionary comprehension that we use to assign the dictionary to the item variable, we are only extracting the most relevant information. For instance, the resulting dictionary entries include", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 521, "start_word": 166720, "end_word": 167120, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000522": {"text": "16, shuffle= False) >>> test_loader = torch.utils.data.DataLoader( ... test_dataset, batch_size= 16, shuffle= False) While the overall data loader setup should be familiar from previous chapters, one noteworthy detail is the item variable in the __getitem__ method. The encodings we produced previously store a lot of information about the tokenized texts. Via the dictionary comprehension that we use to assign the dictionary to the item variable, we are only extracting the most relevant information. For instance, the resulting dictionary entries include input_ids (unique integers from the vocabulary correspond- ing to the tokens), labels (the class labels), and attention_mask . Here, attention_mask is a tensor with binary values (0s and 1s) that denotes which tokens the model should attend to. In particular, 0s correspond to tokens used for padding the sequence to equal lengths and are ignored by the model; the 1s correspond to the actual text tokens. Loading and fine-tuning a pre-trained BERT model Having taken care of the data preparation, in this subsection, you will see how to load the pre-trained DistilBERT model and fine-tune it using the dataset we just created. The code for loading the pre- trained model is as follows: >>> model = DistilBertForSequenceClassification.from_pretrained( ... 'distilbert-base-uncased' ) >>> model.to(DEVICE) >>> model.train() >>> optim = torch.optim.Adam(model.parameters(), lr= 5e-5) DistilBertForSequenceClassification specifies the downstream task we want to fine-tune the model on, which is sequence classification in this case. As mentioned before, 'distilbert-base-uncased' is a lightweight version of a BERT uncased base model with manageable size and good performance. Note that “uncased” means that the model does not distinguish between upper- and lower-case letters. Chapter 16 579 Now, it’s time to train the model. We can break this up into two parts. First, we need to define an accuracy function to evaluate the model performance. Note that this accuracy function computes the conventional classification accuracy. Why is it so verbose? Here, we are loading the dataset batch by batch to work around RAM or GPU memory (VRAM) limitations when working with a large deep learning model: >>> def compute_accuracy (model, data_loader, device): ... with torch.no_grad(): ... correct_pred, num_examples = 0, 0 ... for batch_idx, batch in enumerate (data_loader): ... ### Prepare data ... input_ids = batch[ 'input_ids' ].to(device) ... attention_mask = \\ ... batch[ 'attention_mask' ].to(device) ... labels = batch[ 'labels' ].to(device) ... outputs = model(input_ids, ... attention_mask=attention_mask) ... logits = outputs[ 'logits' ] ... predicted_labels = torch.argmax(logits, 1) ...", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 522, "start_word": 167040, "end_word": 167440, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000523": {"text": "work around RAM or GPU memory (VRAM) limitations when working with a large deep learning model: >>> def compute_accuracy (model, data_loader, device): ... with torch.no_grad(): ... correct_pred, num_examples = 0, 0 ... for batch_idx, batch in enumerate (data_loader): ... ### Prepare data ... input_ids = batch[ 'input_ids' ].to(device) ... attention_mask = \\ ... batch[ 'attention_mask' ].to(device) ... labels = batch[ 'labels' ].to(device) ... outputs = model(input_ids, ... attention_mask=attention_mask) ... logits = outputs[ 'logits' ] ... predicted_labels = torch.argmax(logits, 1) ... num_examples += labels.size( 0) ... correct_pred += \\ ... (predicted_labels == labels). sum() ... return correct_pred. float()/num_examples * 100 In the compute_accuracy function, we load a given batch and then obtain the predicted labels from the outputs. While doing this, we keep track of the total number of examples via num_examples . Similarly, we keep track of the number of correct predictions via the correct_pred variable. Finally, after we iterate over the complete dataset, we compute the accuracy as the proportion of correctly predicted labels. Overall, via the compute_accuracy function, you can already get a glimpse at how we can use the transformer model to obtain the class labels. That is, we feed the model the input_ids along with the attention_mask information that, here, denotes whether a token is an actual text token or a token for padding the sequences to equal length. The model call then returns the outputs, which is a transformer library-specific SequenceClassifierOutput object. From this object, we then obtain the logits that we convert into class labels via the argmax function as we have done in previous chapters.Using other pre-trained transformers The transformers package also provides many other pre-trained models and various downstream tasks for fine-tuning. Check them out at https://huggingface.co/ transformers/ . Transformers – Improving Natural Language Processing with Attention Mechanisms 580 Finally, let us get to the main part: the training (or rather, fine-tuning) loop. As you will notice, fine-tun - ing a model from the transformers library is very similar to training a model in pure PyTorch from scratch: >>> start_time = time.time() >>> for epoch in range (NUM_EPOCHS): ... model.train() ... for batch_idx, batch in enumerate (train_loader): ... ### Prepare data ... input_ids = batch[ 'input_ids' ].to(DEVICE) ... attention_mask = batch[ 'attention_mask' ].to(DEVICE) ... labels = batch[ 'labels' ].to(DEVICE) ... ### Forward pass ... outputs = model(input_ids, ... attention_mask=attention_mask, ... labels=labels) ... loss, logits = outputs[ 'loss'], outputs[ 'logits' ] ... ###", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 523, "start_word": 167360, "end_word": 167760, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000524": {"text": "from the transformers library is very similar to training a model in pure PyTorch from scratch: >>> start_time = time.time() >>> for epoch in range (NUM_EPOCHS): ... model.train() ... for batch_idx, batch in enumerate (train_loader): ... ### Prepare data ... input_ids = batch[ 'input_ids' ].to(DEVICE) ... attention_mask = batch[ 'attention_mask' ].to(DEVICE) ... labels = batch[ 'labels' ].to(DEVICE) ... ### Forward pass ... outputs = model(input_ids, ... attention_mask=attention_mask, ... labels=labels) ... loss, logits = outputs[ 'loss'], outputs[ 'logits' ] ... ### Backward pass ... optim.zero_grad() ... loss.backward() ... optim.step() ... ### Logging ... if not batch_idx % 250: ... print(f'Epoch: {epoch+1:04d}/{NUM_EPOCHS:04d} ' ... f' | Batch' ... f'{batch_idx:04d} /' ... f'{len(train_loader):04d} | ' ... f'Loss: {loss:.4f}') ... model. eval() ... with torch.set_grad_enabled( False): ... print(f'Training accuracy: ' ... f'{compute_accuracy(model, train_loader, DEVICE): .2f}%' Chapter 16 581 ... f'\\nValid accuracy: ' ... f'{compute_accuracy(model, valid_loader, DEVICE): .2f}%') ... print(f'Time elapsed: {(time.time() - start_time)/ 60:.2f} min' ) ... print(f'Total Training Time: {(time.time() - start_time)/ 60:.2f} min' ) ... print(f'Test accuracy: {compute_accuracy(model, test_loader, DEVICE):.2f}%') The output produced by the preceding code is as follows (note that the code is not fully deterministic, which is why the results you are getting may be slightly different): Epoch: 0001/0003 | Batch 0000/2188 | Loss: 0.6771 Epoch: 0001/0003 | Batch 0250/2188 | Loss: 0.3006 Epoch: 0001/0003 | Batch 0500/2188 | Loss: 0.3678 Epoch: 0001/0003 | Batch 0750/2188 | Loss: 0.1487 Epoch: 0001/0003 | Batch 1000/2188 | Loss: 0.6674 Epoch: 0001/0003 | Batch 1250/2188 | Loss: 0.3264 Epoch: 0001/0003 | Batch 1500/2188 | Loss: 0.4358 Epoch: 0001/0003 | Batch 1750/2188 | Loss: 0.2579 Epoch: 0001/0003 | Batch 2000/2188 | Loss: 0.2474 Training accuracy: 96.32% Valid accuracy: 92.34% Time elapsed: 20.67 min Epoch: 0002/0003 | Batch 0000/2188 | Loss: 0.0850 Epoch: 0002/0003 | Batch 0250/2188 | Loss: 0.3433 Epoch: 0002/0003 | Batch 0500/2188 | Loss: 0.0793 Epoch: 0002/0003 | Batch 0750/2188 | Loss: 0.0061 Epoch: 0002/0003 | Batch 1000/2188 | Loss: 0.1536 Epoch: 0002/0003 | Batch 1250/2188 | Loss: 0.0816 Epoch: 0002/0003 | Batch 1500/2188 | Loss: 0.0786 Epoch: 0002/0003 | Batch 1750/2188 | Loss: 0.1395 Epoch: 0002/0003 | Batch 2000/2188 | Loss: 0.0344 Training accuracy: 98.35% Valid accuracy: 92.46% Time elapsed: 41.41 min Epoch: 0003/0003 | Batch 0000/2188 | Loss: 0.0403 Epoch: 0003/0003 | Batch 0250/2188 | Loss: 0.0036 Epoch: 0003/0003 | Batch 0500/2188 | Loss: 0.0156 Epoch: 0003/0003 | Batch 0750/2188 | Loss: 0.0114 Epoch: 0003/0003 | Batch 1000/2188 |", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 524, "start_word": 167680, "end_word": 168080, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000525": {"text": "Epoch: 0002/0003 | Batch 1250/2188 | Loss: 0.0816 Epoch: 0002/0003 | Batch 1500/2188 | Loss: 0.0786 Epoch: 0002/0003 | Batch 1750/2188 | Loss: 0.1395 Epoch: 0002/0003 | Batch 2000/2188 | Loss: 0.0344 Training accuracy: 98.35% Valid accuracy: 92.46% Time elapsed: 41.41 min Epoch: 0003/0003 | Batch 0000/2188 | Loss: 0.0403 Epoch: 0003/0003 | Batch 0250/2188 | Loss: 0.0036 Epoch: 0003/0003 | Batch 0500/2188 | Loss: 0.0156 Epoch: 0003/0003 | Batch 0750/2188 | Loss: 0.0114 Epoch: 0003/0003 | Batch 1000/2188 | Loss: 0.1227 Epoch: 0003/0003 | Batch 1250/2188 | Loss: 0.0125 Transformers – Improving Natural Language Processing with Attention Mechanisms 582 Epoch: 0003/0003 | Batch 1500/2188 | Loss: 0.0074 Epoch: 0003/0003 | Batch 1750/2188 | Loss: 0.0202 Epoch: 0003/0003 | Batch 2000/2188 | Loss: 0.0746 Training accuracy: 99.08% Valid accuracy: 91.84% Time elapsed: 62.15 min Total Training Time: 62.15 min Test accuracy: 92.50% In this code, we iterate over multiple epochs. In each epoch we perform the following steps: 1. Load the input into the device we are working on (GPU or CPU) 2. Compute the model output and loss 3. Adjust the weight parameters by backpropagating the loss 4. Evaluate the model performance on both the training and validation set Note that the training time may vary on different devices. After three epochs, accuracy on the test dataset reaches around 93 percent, which is a substantial improvement compared to the 85 percent test accuracy that the RNN achieved in Chapter 15. Fine-tuning a transformer more conveniently using the Trainer API In the previous subsection, we implemented the training loop in PyTorch manually to illustrate that fine-tuning a transformer model is really not that much different from training an RNN or CNN model from scratch. However, note that the transformers library contains several nice extra features for additional convenience, like the Trainer API, which we will introduce in this subsection. The Trainer API provided by Hugging Face is optimized for transformer models with a wide range of training options and various built-in features. When using the Trainer API, we can skip the effort of writing training loops on our own, and training or fine-tuning a transformer model is as simple as a function (or method) call. Let’s see how this works in practice. After loading the pre-trained model via >>> model = DistilBertForSequenceClassification.from_pretrained( ... 'distilbert-base-uncased' ) >>> model.to(DEVICE) >>> model.train(); The training loop from the previous section can then be replaced", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 525, "start_word": 168000, "end_word": 168400, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000526": {"text": "models with a wide range of training options and various built-in features. When using the Trainer API, we can skip the effort of writing training loops on our own, and training or fine-tuning a transformer model is as simple as a function (or method) call. Let’s see how this works in practice. After loading the pre-trained model via >>> model = DistilBertForSequenceClassification.from_pretrained( ... 'distilbert-base-uncased' ) >>> model.to(DEVICE) >>> model.train(); The training loop from the previous section can then be replaced by the following code: >>> optim = torch.optim.Adam(model.parameters(), lr= 5e-5) >>> from transformers import Trainer, TrainingArguments Chapter 16 583 >>> training_args = TrainingArguments( ... output_dir= './results' , ... num_train_epochs= 3, ... per_device_train_batch_size= 16, ... per_device_eval_batch_size=16, ... logging_dir= './logs' , ... logging_steps= 10, ... ) >>> trainer = Trainer( ... model=model, ... args=training_args, ... train_dataset=train_dataset, ... optimizers=(optim, None) # optim and learning rate scheduler ... ) In the preceding code snippets, we first defined the training arguments, which are relatively self-ex - planatory settings regarding the input and output locations, number of epochs, and batch sizes. We tried to keep the settings as simple as possible; however, there are many additional settings available, and we recommend consulting the TrainingArguments documentation page for additional details: https://huggingface.co/transformers/main_classes/trainer.html#trainingarguments . We then passed these TrainingArguments settings to the Trainer class to instantiate a new trainer object. After initiating the trainer with the settings, the model to be fine-tuned, and the training and evaluation sets, we can train the model by calling the trainer.train() method (we will use this method further shortly). That’s it, using the Trainer API is as simple as shown in the preceding code, and no further boilerplate code is required. However, you may have noticed that the test dataset was not involved in these code snippets, and we haven’t specified any evaluation metrics in this subsection. This is because the Trainer API only shows the training loss and does not provide model evaluation along the training process by default. There are two ways to display the final model performance, which we will illustrate next. The first method for evaluating the final model is to define an evaluation function as the compute_ metrics argument for another Trainer instance. The compute_metrics function operates on the models’ test predictions as logits (which is the default output of the model) and the test labels. To instantiate this function, we recommend installing Hugging Face’s datasets library via", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 526, "start_word": 168320, "end_word": 168720, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000527": {"text": "evaluation along the training process by default. There are two ways to display the final model performance, which we will illustrate next. The first method for evaluating the final model is to define an evaluation function as the compute_ metrics argument for another Trainer instance. The compute_metrics function operates on the models’ test predictions as logits (which is the default output of the model) and the test labels. To instantiate this function, we recommend installing Hugging Face’s datasets library via pip install datasets and use it as follows: >>> from datasets import load_metric >>> import numpy as np >>> metric = load_metric( \"accuracy\" ) >>> def compute_metrics (eval_pred): Transformers – Improving Natural Language Processing with Attention Mechanisms 584 ... logits, labels = eval_pred ... # note: logits are a numpy array, not a pytorch tensor ... predictions = np.argmax(logits, axis=- 1) ... return metric.compute( ... predictions=predictions, references=labels) The updated Trainer instantiation (now including compute_metrics ) is then as follows: >>> trainer=Trainer( ... model=model, ... args=training_args, ... train_dataset=train_dataset, ... eval_dataset=test_dataset, ... compute_metrics=compute_metrics, ... optimizers=(optim, None) # optim and learning rate scheduler ... ) Now, let’s train the model (again, note that the code is not fully deterministic, which is why you might be getting slightly different results): >>> start_time = time.time() >>> trainer.train() ***** Running training ***** Num examples = 35000 Num Epochs = 3 Instantaneous batch size per device = 16 Total train batch size (w. parallel, distributed & accumulation) = 16 Gradient Accumulation steps = 1 Total optimization steps = 6564 Step Training Loss 10 0.705800 20 0.684100 30 0.681500 40 0.591600 50 0.328600 60 0.478300 ... >>> print(f'Total Training Time: ' ... f' {(time.time() - start_time)/ 60:.2f} min') Total Training Time: 45.36 min Chapter 16 585 After the training has completed, which can take up to an hour depending on your GPU, we can call trainer.evaluate() to obtain the model performance on the test set: >>> print(trainer.evaluate()) ***** Running Evaluation ***** Num examples = 10000 Batch size = 16 100%|█████████████████████████████████████████| 625/625 [10:59<00:00, 1.06s/ it] {'eval_loss': 0.30534815788269043, 'eval_accuracy': 0.9327, 'eval_runtime': 87.1161, 'eval_samples_per_second': 114.789, 'eval_steps_per_second': 7.174, 'epoch': 3.0} As we can see, the evaluation accuracy is around 94 percent, similar to our own previously used Py - Torch training loop. (Note that we have skipped the training step, because the model is already fine- tuned after the previous trainer.train() call.) There is a small discrepancy between our manual training approach", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 527, "start_word": 168640, "end_word": 169040, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000528": {"text": "Running Evaluation ***** Num examples = 10000 Batch size = 16 100%|█████████████████████████████████████████| 625/625 [10:59<00:00, 1.06s/ it] {'eval_loss': 0.30534815788269043, 'eval_accuracy': 0.9327, 'eval_runtime': 87.1161, 'eval_samples_per_second': 114.789, 'eval_steps_per_second': 7.174, 'epoch': 3.0} As we can see, the evaluation accuracy is around 94 percent, similar to our own previously used Py - Torch training loop. (Note that we have skipped the training step, because the model is already fine- tuned after the previous trainer.train() call.) There is a small discrepancy between our manual training approach and using the Trainer class, because the Trainer class uses some different and some additional settings. The second method we could employ to compute the final test set accuracy is re-using our compute_ accuracy function that we defined in the previous section. We can directly evaluate the performance of the fine-tuned model on the test dataset by running the following code: >>> model.eval() >>> model.to(DEVICE) >>> print(f'Test accuracy: {compute_accuracy(model, test_loader, DEVICE): .2f}%') Test accuracy: 93.27% In fact, if you want to check the model’s performance regularly during training, you can require the trainer to print the model evaluation after each epoch by defining the training arguments as follows: >>> from transformers import TrainingArguments >>> training_args = TrainingArguments( \"test_trainer\" , ... evaluation_strategy= \"epoch\", ...) Transformers – Improving Natural Language Processing with Attention Mechanisms 586 However, if you are planning to change or optimize hyperparameters and repeat the fine-tuning pro - cedure several times, we recommend using the validation set for this purpose, in order to keep the test set independent. We can achieve this by instantiating the Trainer using valid_dataset : >>> trainer=Trainer( ... model=model, ... args=training_args, ... train_dataset=train_dataset, ... eval_dataset=valid_dataset, ... compute_metrics=compute_metrics, ... ) In this section, we saw how we can fine-tune a BERT model for classification. This is different from using other deep learning architectures like RNNs, which we usually train from scratch. However, un- less we are doing research and are trying to develop new transformer architectures—a very expensive endeavor—pre-training transformer models is not necessary. Since transformer models are trained on general, unlabeled dataset resources, pre-training them ourselves may not be a good use of our time and resources; fine-tuning is the way to go. Summary In this chapter, we introduced a whole new model architecture for natural language processing, the transformer architecture. The transformer architecture is built on a concept called self-attention, and we started introducing this concept step by step. First, we looked at an", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 528, "start_word": 168960, "end_word": 169360, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000529": {"text": "very expensive endeavor—pre-training transformer models is not necessary. Since transformer models are trained on general, unlabeled dataset resources, pre-training them ourselves may not be a good use of our time and resources; fine-tuning is the way to go. Summary In this chapter, we introduced a whole new model architecture for natural language processing, the transformer architecture. The transformer architecture is built on a concept called self-attention, and we started introducing this concept step by step. First, we looked at an RNN outfitted with attention in order to improve its translation capabilities for long sentences. Then, we gently introduced the concept of self-attention and explained how it is used in the multi-head attention module within the transformer. Many different derivatives of the transformer architecture have emerged and evolved since the origi- nal transformer was published in 2017. In this chapter, we focused on a selection of some of the most popular ones: the GPT model family, BERT, and BART. GPT is a unidirectional model that is partic- ularly good at generating new text. BERT takes a bidirectional approach, which is better suited for other types of tasks, for example, classification. Lastly, BART combines both the bidirectional encoder from BERT and the unidirectional decoder from GPT. Interested readers can find out about additional transformer-based architectures via the following two survey articles: 1. Pre-trained Models for Natural Language Processing: A Survey by Qiu and colleagues, 2020. Avail- able at https://arxiv.org/abs/2003.08271 2. AMMUS : A Survey of Transformer-based Pretrained Models in Natural Language Processing by Kayan and colleagues, 2021. Available at https://arxiv.org/abs/2108.05542 Transformer models are generally more data hungry than RNNs and require large amounts of data for pre-training. The pre-training leverages large amounts of unlabeled data to build a general language model that can then be specialized to specific tasks by fine-tuning it on smaller labeled datasets. Chapter 16 587 To see how this works in practice, we downloaded a pre-trained BERT model from the Hugging Face transformers library and fine-tuned it for sentiment classification on the IMDb movie review dataset. In the next chapter, we will discuss generative adversarial networks. As the name suggests, generative adversarial networks are models that can be used for generating new data, similar to the GPT models we discussed in this chapter. However, we are now leaving the natural language modeling topic behind us and will look at generative adversarial networks in the context of computer vision", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 529, "start_word": 169280, "end_word": 169680, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000530": {"text": "from the Hugging Face transformers library and fine-tuned it for sentiment classification on the IMDb movie review dataset. In the next chapter, we will discuss generative adversarial networks. As the name suggests, generative adversarial networks are models that can be used for generating new data, similar to the GPT models we discussed in this chapter. However, we are now leaving the natural language modeling topic behind us and will look at generative adversarial networks in the context of computer vision and generating new images, the task that these networks were originally designed for. Join our book’s Discord space Join the book’s Discord workspace for a monthly Ask me Anything session with the authors: https://packt.link/MLwPyTorch 17 Generative Adversarial Networks for Synthesizing New Data In the previous chapter, we focused on recurrent neural networks for modeling sequences. In this chapter, we will explore generative adversarial networks (GANs ) and see their application in synthe - sizing new data samples. GANs are considered to be one of the most important breakthroughs in deep learning, allowing computers to generate new data (such as new images). In this chapter, we will cover the following topics: • Introducing generative models for synthesizing new data • Autoencoders, variational autoencoders, and their relationship to GANs • Understanding the building blocks of GANs • Implementing a simple GAN model to generate handwritten digits • Understanding transposed convolution and batch normalization • Improving GANs: deep convolutional GANs and GANs using the Wasserstein distance Introducing generative adversarial networks Let’s first look at the foundations of GAN models. The overall objective of a GAN is to synthesize new data that has the same distribution as its training dataset. Therefore, GANs, in their original form, are considered to be in the unsupervised learning category of machine learning tasks, since no labeled data is required. It is worth noting, however, that extensions made to the original GAN can lie in both the semi-supervised and supervised domains. The general GAN concept was first proposed in 2014 by Ian Goodfellow and his colleagues as a meth- od for synthesizing new images using deep neural networks ( NNs ) (Generative Adversarial Nets , in Advances in Neural Information Processing Systems by I. Goodfellow, J. Pouget-Abadie, M. Mirza, B. Xu , D. Warde-Farley, S. Ozair, A. Courville, and Y. Bengio, pp. 2672-2680, 2014). While the initial GAN archi- tecture proposed in this paper was based on fully connected", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 530, "start_word": 169600, "end_word": 170000, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000531": {"text": "supervised domains. The general GAN concept was first proposed in 2014 by Ian Goodfellow and his colleagues as a meth- od for synthesizing new images using deep neural networks ( NNs ) (Generative Adversarial Nets , in Advances in Neural Information Processing Systems by I. Goodfellow, J. Pouget-Abadie, M. Mirza, B. Xu , D. Warde-Farley, S. Ozair, A. Courville, and Y. Bengio, pp. 2672-2680, 2014). While the initial GAN archi- tecture proposed in this paper was based on fully connected layers, similar to multilayer perceptron architectures, and trained to generate low-resolution MNIST-like handwritten digits, it served more as a proof of concept to demonstrate the feasibility of this new approach. Generative Adversarial Networks for Synthesizing New Data 590 However, since its introduction, the original authors, as well as many other researchers, have proposed numerous improvements and various applications in different fields of engineering and science; for example, in computer vision, GANs are used for image-to-image translation (learning how to map an input image to an output image), image super-resolution (making a high-resolution image from a low-resolution version), image inpainting (learning how to reconstruct the missing parts of an image), and many more applications. For instance, recent advances in GAN research have led to models that are able to generate new, high-resolution face images. Examples of such high-resolution images can be found on https://www.thispersondoesnotexist.com/ , which showcases synthetic face images generated by a GAN. Starting with autoencoders Before we discuss how GANs work, we will first start with autoencoders, which can compress and decompress training data. While standard autoencoders cannot generate new data, understanding their function will help you to navigate GANs in the next section. Autoencoders are composed of two networks concatenated together: an encoder network and a de - coder network. The encoder network receives a d-dimensional input feature vector associated with example x (that is, 𝒙𝒙𝒙𝒙𝒙𝑑𝑑 ) and encodes it into a p -dimensional vector, z (that is, 𝒛𝒛𝒛𝒛𝒛𝑝𝑝 ). In other words, the role of the encoder is to learn how to model the function z = f(x). The encoded vector, z, is also called the latent vector, or the latent feature representation. Typically, the dimensionality of the latent vector is less than that of the input examples; in other words, p < d. Hence, we can say that the encoder acts as a data compression function. Then, the decoder decompresses 𝒙𝒙̂ from the low - er-dimensional", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 531, "start_word": 169920, "end_word": 170320, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000532": {"text": "𝒛𝒛𝒛𝒛𝒛𝑝𝑝 ). In other words, the role of the encoder is to learn how to model the function z = f(x). The encoded vector, z, is also called the latent vector, or the latent feature representation. Typically, the dimensionality of the latent vector is less than that of the input examples; in other words, p < d. Hence, we can say that the encoder acts as a data compression function. Then, the decoder decompresses 𝒙𝒙̂ from the low - er-dimensional latent vector, z, where we can think of the decoder as a function, 𝒙𝒙̂=𝑔𝑔(𝒛𝒛) . A simple autoencoder architecture is shown in Figure 17.1, where the encoder and decoder parts consist of only one fully connected layer each: Figure 17.1: The architecture of an autoencoder Chapter 17 591 While Figure 17.1 depicts an autoencoder without hidden layers within the encoder and decoder, we can, of course, add multiple hidden layers with nonlinearities (as in a multilayer NN) to construct a deep autoencoder that can learn more effective data compression and reconstruction functions. Also, note that the autoencoder mentioned in this section uses fully connected layers. When we work with images, however, we can replace the fully connected layers with convolutional layers, as you learned in Chapter 14, Classifying Images with Deep Convolutional Neural Networks.The connection between autoencoders and dimensionality reduction In Chapter 5, Compressing Data via Dimensionality Reduction, you learned about dimen - sionality reduction techniques, such as principal component analysis (PCA ) and linear discriminant analysis ( LDA ). Autoencoders can be used as a dimensionality reduction technique as well. In fact, when there is no nonlinearity in either of the two subnetworks (encoder and decoder), then the autoencoder approach is almost identical to PCA. In this case, if we assume the weights of a single-layer encoder (no hidden layer and no nonlinear activation function) are denoted by the matrix U , then the encoder models z = UTx. Similarly, a single-layer linear decoder models 𝒙𝒙̂=𝑼𝑼𝑼𝑼 . Putting these two compo - nents together, we have 𝒙𝒙̂= 𝑼𝑼𝑼𝑼𝑇𝑇𝒙𝒙 . This is exactly what PCA does, with the exception that PCA has an additional orthonormal constraint: UUT = I n×n. Other types of autoencoders based on the size of latent space As previously mentioned, the dimensionality of an autoencoder’s latent space is typically lower than the dimensionality of the inputs (p < d), which makes autoencoders suitable for dimensionality reduction.", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 532, "start_word": 170240, "end_word": 170640, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000533": {"text": "Similarly, a single-layer linear decoder models 𝒙𝒙̂=𝑼𝑼𝑼𝑼 . Putting these two compo - nents together, we have 𝒙𝒙̂= 𝑼𝑼𝑼𝑼𝑇𝑇𝒙𝒙 . This is exactly what PCA does, with the exception that PCA has an additional orthonormal constraint: UUT = I n×n. Other types of autoencoders based on the size of latent space As previously mentioned, the dimensionality of an autoencoder’s latent space is typically lower than the dimensionality of the inputs (p < d), which makes autoencoders suitable for dimensionality reduction. For this reason, the latent vector is also often referred to as the “bottleneck,” and this particular configuration of an autoencoder is also called under - complete. However, there is a different category of autoencoders, called overcomplete, where the dimensionality of the latent vector, z , is, in fact, greater than the dimensionality of the input examples (p > d). When training an overcomplete autoencoder, there is a trivial solution where the encoder and the decoder can simply learn to copy (memorize) the input features to their output layer. Obviously, this solution is not very useful. However, with some modifications to the training procedure, overcomplete autoencoders can be used for noise reduction. In this case, during training, random noise, 𝝐𝝐 , is added to the input examples and the network learns to reconstruct the clean example, x, from the noisy signal, 𝒙𝒙𝒙𝒙𝒙 . Then, at evaluation time, we provide the new examples that are naturally noisy (that is, noise is already present such that no additional artificial noise, 𝝐𝝐 , is added) in order to remove the existing noise from these examples. This particular autoencoder architecture and training method is referred to as a denoising autoencoder. If you are interested, you can learn more about it in the research article Stacked denoising autoencoders: Learning useful representations in a deep network with a local denoising criterion by Pascal Vincent and colleagues, 2010 (http://www.jmlr.org/papers/v11/vincent10a. html ). Generative Adversarial Networks for Synthesizing New Data 592 Generative models for synthesizing new data Autoencoders are deterministic models, which means that after an autoencoder is trained, given an input, x, it will be able to reconstruct the input from its compressed version in a lower-dimensional space. Therefore, it cannot generate new data beyond reconstructing its input through the transfor - mation of the compressed representation. A generative model, on the other hand, can generate a new example, 𝒙𝒙̃ , from a random vector, z (cor -", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 533, "start_word": 170560, "end_word": 170960, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000534": {"text": "Data 592 Generative models for synthesizing new data Autoencoders are deterministic models, which means that after an autoencoder is trained, given an input, x, it will be able to reconstruct the input from its compressed version in a lower-dimensional space. Therefore, it cannot generate new data beyond reconstructing its input through the transfor - mation of the compressed representation. A generative model, on the other hand, can generate a new example, 𝒙𝒙̃ , from a random vector, z (cor - responding to the latent representation). A schematic representation of a generative model is shown in the following figure. The random vector, z , comes from a distribution with fully known characteristics, so we can easily sample from such a distribution. For example, each element of z may come from the uniform distribution in the range [–1, 1] (for which we write 𝑧𝑧𝑖𝑖~Uniform(−1,1) ) or from a standard normal distribution (in which case, we write 𝑧𝑧𝑖𝑖~Normal(𝜇𝜇 𝜇 𝜇𝜇𝜇𝜇2𝜇1) ): Figure 17.2: A generative model As we have shifted our attention from autoencoders to generative models, you may have noticed that the decoder component of an autoencoder has some similarities with a generative model. In particular, they both receive a latent vector, z , as input and return an output in the same space as x . (For the auto - encoder, 𝒙𝒙̂ is the reconstruction of an input, x , and for the generative model, 𝒙𝒙̃ is a synthesized sample.) However, the major difference between the two is that we do not know the distribution of z in the autoen - coder, while in a generative model, the distribution of z is fully characterizable. It is possible to generalize an autoencoder into a generative model, though. One approach is the variational autoencoder ( VA E ). In a V AE receiving an input example, x, the encoder network is modified in such a way that it com- putes two moments of the distribution of the latent vector: the mean, 𝝁𝝁 , and variance, 𝝈𝝈2 . During the training of a V AE, the network is forced to match these moments with those of a standard normal distribution (that is, zero mean and unit variance). Then, after the V AE model is trained, the encoder is discarded, and we can use the decoder network to generate new examples, 𝒙𝒙̃ , by feeding random z vectors from the “learned” Gaussian distribution. Chapter 17", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 534, "start_word": 170880, "end_word": 171280, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000535": {"text": "the distribution of the latent vector: the mean, 𝝁𝝁 , and variance, 𝝈𝝈2 . During the training of a V AE, the network is forced to match these moments with those of a standard normal distribution (that is, zero mean and unit variance). Then, after the V AE model is trained, the encoder is discarded, and we can use the decoder network to generate new examples, 𝒙𝒙̃ , by feeding random z vectors from the “learned” Gaussian distribution. Chapter 17 593 Besides V AEs, there are other types of generative models, for example, autoregressive models and nor- malizing flow models. However, in this chapter, we are only going to focus on GAN models, which are among the most recent and most popular types of generative models in deep learning. Generating new samples with GANs To understand what GANs do in a nutshell, let’s first assume we have a network that receives a random vector, z, sampled from a known distribution, and generates an output image, x . We will call this network generator (G) and use the notation 𝒙𝒙̃=𝐺𝐺(𝒛𝒛) to refer to the generated output. Assume our goal is to generate some images, for example, face images, images of buildings, images of animals, or even handwritten digits such as MNIST. As always, we will initialize this network with random weights. Therefore, the first output images, before these weights are adjusted, will look like white noise. Now, imagine there is a function that can assess the quality of images (let’s call it an assessor function). If such a function exists, we can use the feedback from that function to tell our generator network how to adjust its weights to improve the quality of the generated images. This way, we can train the generator based on the feedback from that assessor function, such that the generator learns to improve its output toward producing realistic-looking images. While an assessor function, as described in the previous paragraph, would make the image generation task very easy, the question is whether such a universal function to assess the quality of images exists and, if so, how it is defined. Obviously, as humans, we can easily assess the quality of output images when we observe the outputs of the network; although, we cannot (yet) backpropagate the result from our brain to the network. Now, if our brain can assess the quality of synthesized images, can we design", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 535, "start_word": 171200, "end_word": 171600, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000536": {"text": "the previous paragraph, would make the image generation task very easy, the question is whether such a universal function to assess the quality of images exists and, if so, how it is defined. Obviously, as humans, we can easily assess the quality of output images when we observe the outputs of the network; although, we cannot (yet) backpropagate the result from our brain to the network. Now, if our brain can assess the quality of synthesized images, can we design an NN model to do the same thing? In fact, that’s the general idea of a GAN. What is a generative model? Note that generative models are traditionally defined as algorithms that model data input distributions, p(x), or the joint distributions of the input data and associated targets, p (x, y). By definition, these models are also capable of sampling from some feature, x i, conditioned on another feature, x j, which is known as conditional inference. In the context of deep learning, however, the term generative model is typically used to refer to models that generate realistic-looking data. This means that we can sample from input distributions, p(x), but we are not necessarily able to perform conditional inference. Generative Adversarial Networks for Synthesizing New Data 594 As shown in Figure 17.3, a GAN model consists of an additional NN called discriminator (D), which is a classifier that learns to detect a synthesized image, 𝒙𝒙̃ , from a real image, x: Figure 17.3: The discriminator distinguishes between the real image and the one created by the generator In a GAN model, the two networks, generator and discriminator, are trained together. At first, after initializing the model weights, the generator creates images that do not look realistic. Similarly, the discriminator does a poor job of distinguishing between real images and images synthesized by the generator. But over time (that is, through training), both networks become better as they interact with each other. In fact, the two networks play an adversarial game, where the generator learns to improve its output to be able to fool the discriminator. At the same time, the discriminator becomes better at detecting the synthesized images. Understanding the loss functions of the generator and discriminator networks in a GAN model The objective function of GANs, as described in the original paper Generative Adversarial Nets by I. Goodfellow and colleagues ( https://papers.nips.cc/paper/5423-generative-adversarial-nets. pdf), is as follows: 𝑉𝑉𝑉𝑉𝑉(𝐷𝐷),𝑉𝑉(𝐺𝐺))=𝐸𝐸𝒙𝒙𝒙𝒙𝒙𝑑𝑑𝑑𝑑𝑑𝑑𝑑𝑑(𝒙𝒙)[log𝐷𝐷(𝒙𝒙)]+𝐸𝐸𝒛𝒛𝒙𝒙𝒙𝒛𝒛(𝒛𝒛)[log(1−𝐷𝐷 𝑉𝐷𝐷(𝒛𝒛)))] Here,", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 536, "start_word": 171520, "end_word": 171920, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000537": {"text": "other. In fact, the two networks play an adversarial game, where the generator learns to improve its output to be able to fool the discriminator. At the same time, the discriminator becomes better at detecting the synthesized images. Understanding the loss functions of the generator and discriminator networks in a GAN model The objective function of GANs, as described in the original paper Generative Adversarial Nets by I. Goodfellow and colleagues ( https://papers.nips.cc/paper/5423-generative-adversarial-nets. pdf), is as follows: 𝑉𝑉𝑉𝑉𝑉(𝐷𝐷),𝑉𝑉(𝐺𝐺))=𝐸𝐸𝒙𝒙𝒙𝒙𝒙𝑑𝑑𝑑𝑑𝑑𝑑𝑑𝑑(𝒙𝒙)[log𝐷𝐷(𝒙𝒙)]+𝐸𝐸𝒛𝒛𝒙𝒙𝒙𝒛𝒛(𝒛𝒛)[log(1−𝐷𝐷 𝑉𝐷𝐷(𝒛𝒛)))] Here, 𝑉𝑉𝑉𝑉𝑉(𝐷𝐷),𝑉𝑉(𝐺𝐺)) is called the value function, which can be interpreted as a payoff: we want to max - imize its value with respect to the discriminator (D), while minimizing its value with respect to the generator (G), that is, min 𝐺𝐺max 𝐷𝐷𝑉𝑉𝑉𝑉𝑉(𝐷𝐷),𝑉𝑉(𝐺𝐺)) . D(x) is the probability that indicates whether the input example, x, is real or fake (that is, generated). The expression 𝐸𝐸𝒙𝒙𝒙𝒙𝒙𝑑𝑑𝑑𝑑𝑑𝑑𝑑𝑑(𝒙𝒙)[log𝐷𝐷(𝒙𝒙)] refers to the expected value of the quantity in brackets with respect to the examples from the data distribution (distribution of the real examples); 𝐸𝐸𝒛𝒛𝒛𝒛𝒛𝒛𝒛(𝒛𝒛)[log(1−𝐷𝐷𝐷𝐷𝐷 (𝒛𝒛)))] refers to the expected value of the quantity with respect to the distribution of the input, z, vectors. Chapter 17 595 One training step of a GAN model with such a value function requires two optimization steps: (1) maximizing the payoff for the discriminator and (2) minimizing the payoff for the generator. A prac- tical way of training GANs is to alternate between these two optimization steps: (1) fix (freeze) the parameters of one network and optimize the weights of the other one, and (2) fix the second network and optimize the first one. This process should be repeated at each training iteration. Let’s assume that the generator network is fixed, and we want to optimize the discriminator. Both terms in the value function 𝑉𝑉𝑉𝑉𝑉(𝐷𝐷),𝑉𝑉(𝐺𝐺)) contribute to optimizing the discriminator, where the first term corresponds to the loss associated with the real examples, and the second term is the loss for the fake examples. Therefore, when G is fixed, our objective is to maximize 𝑉𝑉𝑉𝑉𝑉(𝐷𝐷),𝑉𝑉(𝐺𝐺)) , which means making the dis- criminator better at distinguishing between real and generated images. After optimizing the discriminator using the loss terms for real and fake samples, we then fix the dis- criminator and optimize the generator. In this case, only the second term in 𝑉𝑉𝑉𝑉𝑉(𝐷𝐷),𝑉𝑉(𝐺𝐺)) contributes to the gradients of the generator. As a result, when D is fixed, our objective is to", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 537, "start_word": 171840, "end_word": 172240, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000538": {"text": "for the fake examples. Therefore, when G is fixed, our objective is to maximize 𝑉𝑉𝑉𝑉𝑉(𝐷𝐷),𝑉𝑉(𝐺𝐺)) , which means making the dis- criminator better at distinguishing between real and generated images. After optimizing the discriminator using the loss terms for real and fake samples, we then fix the dis- criminator and optimize the generator. In this case, only the second term in 𝑉𝑉𝑉𝑉𝑉(𝐷𝐷),𝑉𝑉(𝐺𝐺)) contributes to the gradients of the generator. As a result, when D is fixed, our objective is to minimize 𝑉𝑉𝑉𝑉𝑉(𝐷𝐷),𝑉𝑉(𝐺𝐺)) , which can be written as min 𝐺𝐺𝐸𝐸𝒛𝒛𝒛𝒛𝒛𝒛𝒛(𝒛𝒛)[log(1−𝐷𝐷𝐷𝐷𝐷 (𝒛𝒛)))] . As was mentioned in the original GAN paper by Goodfellow and colleagues, this function, log(1−𝐷𝐷𝐷𝐷𝐷 (𝒛𝒛))) , suffers from vanishing gradients in the early training stages. The reason for this is that the outputs, G(z), early in the learning process, look nothing like real examples, and therefore D(G(z)) will be close to zero with high confidence. This phenomenon is called saturation. To resolve this issue, we can reformulate the minimization objective, min 𝐺𝐺𝐸𝐸𝒛𝒛𝒛𝒛𝒛𝒛𝒛(𝒛𝒛)[log(1−𝐷𝐷𝐷𝐷𝐷 (𝒛𝒛)))] , by rewriting it as max 𝐺𝐺𝐸𝐸𝒛𝒛𝒛𝒛𝒛𝒛𝒛(𝒛𝒛)[log(𝐷𝐷𝐷𝐷𝐷 (𝒛𝒛)))] . This replacement means that for training the generator, we can swap the labels of real and fake examples and carry out a regular function minimization. In other words, even though the examples synthesized by the generator are fake and are therefore labeled 0, we can flip the labels by assigning label 1 to these examples and minimize the binary cross-entropy loss with these new labels instead of maximizing max 𝐺𝐺𝐸𝐸𝒛𝒛𝒛𝒛𝒛𝒛𝒛(𝒛𝒛)[log(𝐷𝐷𝐷𝐷𝐷 (𝒛𝒛)))] . Now that we have covered the general optimization procedure for training GAN models, let’s explore the various data labels that we can use when training GANs. Given that the discriminator is a binary classifier (the class labels are 0 and 1 for fake and real images, respectively), we can use the binary cross-entropy loss function. Therefore, we can determine the ground truth labels for the discriminator loss as follows: Ground truth labels for the discriminator= { 1: for real images, i.e., 𝒙𝒙 0: for outputs of 𝐺𝐺, i.e., 𝐺𝐺(𝒛𝒛) What about the labels to train the generator? As we want the generator to synthesize realistic images, we want to penalize the generator when its outputs are not classified as real by the discriminator. This means that we will assume the ground truth labels for the outputs of the generator to be 1 when computing the loss function for the generator. Generative Adversarial Networks", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 538, "start_word": 172160, "end_word": 172560, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000539": {"text": "the discriminator= { 1: for real images, i.e., 𝒙𝒙 0: for outputs of 𝐺𝐺, i.e., 𝐺𝐺(𝒛𝒛) What about the labels to train the generator? As we want the generator to synthesize realistic images, we want to penalize the generator when its outputs are not classified as real by the discriminator. This means that we will assume the ground truth labels for the outputs of the generator to be 1 when computing the loss function for the generator. Generative Adversarial Networks for Synthesizing New Data 596 Putting all of this together, the following figure displays the individual steps in a simple GAN model: Figure 17.4: The steps in building a GAN model In the following section, we will implement a GAN from scratch to generate new handwritten digits. Implementing a GAN from scratch In this section, we will cover how to implement and train a GAN model to generate new images such as MNIST digits. Since the training on a normal central processing unit (CPU ) may take a long time, in the following subsection, we will cover how to set up the Google Colab environment, which will allow us to run the computations on graphics processing units (GPUs ). Training GAN models on Google Colab Some of the code examples in this chapter may require extensive computational resources that go beyond a conventional laptop or a workstation without a GPU. If you already have an NVIDIA GPU-en- abled computing machine available, with CUDA and cuDNN libraries installed, you can use that to speed up the computations. Chapter 17 597 However, since many of us do not have access to high-performance computing resources, we will use the Google Colaboratory environment (often referred to as Google Colab), which is a free cloud computing service (available in most countries). Google Colab provides Jupyter Notebook instances that run on the cloud; the notebooks can be saved on Google Drive or GitHub. While the platform provides various different computing resources, such as CPUs, GPUs, and even tensor processing units ( TPUs ), it is important to highlight that the execution time is currently limited to 12 hours. Therefore, any notebook running longer than 12 hours will be interrupted. The code blocks in this chapter will need a maximum computing time of two to three hours, so this will not be an issue. However, if you decide to use Google Colab for other projects that take", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 539, "start_word": 172480, "end_word": 172880, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000540": {"text": "provides various different computing resources, such as CPUs, GPUs, and even tensor processing units ( TPUs ), it is important to highlight that the execution time is currently limited to 12 hours. Therefore, any notebook running longer than 12 hours will be interrupted. The code blocks in this chapter will need a maximum computing time of two to three hours, so this will not be an issue. However, if you decide to use Google Colab for other projects that take longer than 12 hours, be sure to use checkpointing and save intermediate checkpoints. Accessing Google Colab is very straightforward. You can visit https://colab.research.google.com , which automatically takes you to a prompt window where you can see your existing Jupyter notebooks. From this prompt window, click the Google Drive tab, as shown in Figure 17.5. This is where you will save the notebook on your Google Drive.Jupyter Notebook Jupyter Notebook is a graphical user interface (GUI) for running code interactively and interleaving it with text documentation and figures. Due to its versatility and ease of use, it has become one of the most popular tools in data science. For more information about the general Jupyter Notebook GUI, please view the official documentation at https://jupyter-notebook.readthedocs.io/en/stable/ . All the code in this book is also available in the form of Jupyter notebooks, and a short introduc- tion can be found in the code directory of the first chapter. Lastly, we highly recommend Adam Rule et al.’s article Ten simple rules for writing and sharing computational analyses in Jupyter Notebooks on using Jupyter Notebook effectively in scientific research projects, which is freely available at https://journals.plos.org/ ploscompbiol/article?id=10.1371/journal.pcbi.1007007 . Generative Adversarial Networks for Synthesizing New Data 598 Then, to create a new notebook, click on the New notebook link at the bottom of the prompt window: Figure 17.5: Creating a new Python notebook in Google Colab This will create and open a new notebook for you. All the code examples you write in this notebook will be automatically saved, and you can later access the notebook from your Google Drive in a direc- tory called Colab Notebooks . In the next step, we want to utilize GPUs to run the code examples in this notebook. To do this, from the Runtime option in the menu bar of this notebook, click on Change runtime type and select GPU , as shown in Figure 17.6: Figure 17.6: Utilizing", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 540, "start_word": 172800, "end_word": 173200, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000541": {"text": "All the code examples you write in this notebook will be automatically saved, and you can later access the notebook from your Google Drive in a direc- tory called Colab Notebooks . In the next step, we want to utilize GPUs to run the code examples in this notebook. To do this, from the Runtime option in the menu bar of this notebook, click on Change runtime type and select GPU , as shown in Figure 17.6: Figure 17.6: Utilizing GPUs in Google Colab Chapter 17 599 In the last step, we just need to install the Python packages that we will need for this chapter. The Colab Notebooks environment already comes with certain packages, such as NumPy, SciPy, and the latest stable version of PyTorch. At the time of writing, the latest stable version on Google Colab is PyTorch 1.9. Now, we can test the installation and verify that the GPU is available using the following code: >>> import torch >>> print(torch.__version__) 1.9.0+cu111 >>> print(\"GPU Available:\" , torch.cuda.is_available()) GPU Available: True >>> if torch.cuda.is_available(): ... device = torch.device( \"cuda:0\" ) ... else: ... device = \"cpu\" >>> print(device) cuda:0 Furthermore, if you want to save the model to your personal Google Drive, or transfer or upload other files, you need to mount Google Drive. To do this, execute the following in a new cell of the notebook: >>> from google.colab import drive >>> drive.mount( '/content/drive/' ) This will provide a link to authenticate the Colab Notebook accessing your Google Drive. After following the instructions for authentication, it will provide an authentication code that you need to copy and paste into the designated input field below the cell you have just executed. Then, your Google Drive will be mounted and available at /content/drive/My Drive . Alternatively, you can mount it via the GUI interface as highlighted in Figure 17.7: Figure 17.7: Mounting your Google Drive Generative Adversarial Networks for Synthesizing New Data 600 Implementing the generator and the discriminator networks We will start the implementation of our first GAN model with a generator and a discriminator as two fully connected networks with one or more hidden layers, as shown in Figure 17.8: Figure 17.8: A GAN model with a generator and discriminator as two fully connected networks Figure 17.8 depicts the original GAN based on fully connected layers, which we will refer to as a vanilla GAN . In this", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 541, "start_word": 173120, "end_word": 173520, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000542": {"text": "New Data 600 Implementing the generator and the discriminator networks We will start the implementation of our first GAN model with a generator and a discriminator as two fully connected networks with one or more hidden layers, as shown in Figure 17.8: Figure 17.8: A GAN model with a generator and discriminator as two fully connected networks Figure 17.8 depicts the original GAN based on fully connected layers, which we will refer to as a vanilla GAN . In this model, for each hidden layer, we will apply the leaky ReLU activation function. The use of ReLU results in sparse gradients, which may not be suitable when we want to have the gradients for the full range of input values. In the discriminator network, each hidden layer is also followed by a dropout layer. Furthermore, the output layer in the generator uses the hyperbolic tangent (tanh) activation function. (Using tanh activation is recommended for the generator network since it helps with the learning.) Chapter 17 601 The output layer in the discriminator has no activation function (that is, linear activation) to get the logits. Alternatively, we can use the sigmoid activation function to get probabilities as output. Leaky rectified linear unit (ReLU) activation function In Chapter 12, Parallelizing Neural Network Training with PyTorch, we covered different nonlinear activation functions that can be used in an NN model. If you recall, the ReLU activation function was defined as 𝜎𝜎(𝑧𝑧)= max(0,𝑧𝑧) , which suppresses the negative (pre - activation) inputs; that is, negative inputs are set to zero. Consequently, using the ReLU activation function may result in sparse gradients during backpropagation. Sparse gradi- ents are not always detrimental and can even benefit models for classification. However, in certain applications, such as GANs, it can be beneficial to obtain the gradients for the full range of input values, which we can achieve by making a slight modification to the ReLU function such that it outputs small values for negative inputs. This modified version of the ReLU function is also known as leaky ReLU. In short, the leaky ReLU activation function permits non-zero gradients for negative inputs as well, and as a result, it makes the networks more expressive overall. The leaky ReLU activation function is defined as follows: Figure 17.9: The leaky ReLU activation function Here, 𝛼𝛼 determines the slope for the negative (preactivation) inputs. Generative Adversarial Networks for Synthesizing New Data 602", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 542, "start_word": 173440, "end_word": 173840, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000543": {"text": "it outputs small values for negative inputs. This modified version of the ReLU function is also known as leaky ReLU. In short, the leaky ReLU activation function permits non-zero gradients for negative inputs as well, and as a result, it makes the networks more expressive overall. The leaky ReLU activation function is defined as follows: Figure 17.9: The leaky ReLU activation function Here, 𝛼𝛼 determines the slope for the negative (preactivation) inputs. Generative Adversarial Networks for Synthesizing New Data 602 We will define two helper functions for each of the two networks, instantiate a model from the PyTorch nn.Sequential class, and add the layers as described. The code is as follows: >>> import torch.nn as nn >>> import numpy as np >>> import matplotlib.pyplot as plt >>> ## define a function for the generator: >>> def make_generator_network ( ... input_size= 20, ... num_hidden_layers= 1, ... num_hidden_units= 100, ... num_output_units= 784): ... model = nn.Sequential() ... for i in range (num_hidden_layers): ... model.add_module( f'fc_g{i}', ... nn.Linear(input_size, num_hidden_units)) ... model.add_module( f'relu_g {i}', nn.LeakyReLU()) ... input_size = num_hidden_units ... model.add_module( f'fc_g{num_hidden_layers} ', ... nn.Linear(input_size, num_output_units)) ... model.add_module( 'tanh_g' , nn.Tanh()) ... return model >>> >>> ## define a function for the discriminator: >>> def make_discriminator_network ( ... input_size, ... num_hidden_layers= 1, ... num_hidden_units= 100, ... num_output_units= 1): ... model = nn.Sequential() ... for i in range (num_hidden_layers): ... model.add_module( ... f'fc_d{i}', ... nn.Linear(input_size, num_hidden_units, bias= False) ... ) ... model.add_module( f'relu_d {i}', nn.LeakyReLU()) ... model.add_module( 'dropout' , nn.Dropout(p= 0.5)) ... input_size = num_hidden_units ... model.add_module( f'fc_d{num_hidden_layers} ', ... nn.Linear(input_size, num_output_units)) ... model.add_module( 'sigmoid' , nn.Sigmoid()) ... return model Chapter 17 603 Next, we will specify the training settings for the model. As you will remember from previous chapters, the image size in the MNIST dataset is 28×28 pixels. (That is only one color channel because MNIST contains only grayscale images.) We will further specify the size of the input vector, z, to be 20. Since we are implementing a very simple GAN model for illustration purposes only and using fully connected layers, we will only use a single hidden layer with 100 units in each network. In the following code, we will specify and initialize the two networks, and print their summary information: >>> image_size = ( 28, 28) >>> z_size = 20 >>> gen_hidden_layers = 1 >>> gen_hidden_size = 100 >>> disc_hidden_layers = 1 >>> disc_hidden_size = 100 >>> torch.manual_seed( 1) >>>", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 543, "start_word": 173760, "end_word": 174160, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000544": {"text": "20. Since we are implementing a very simple GAN model for illustration purposes only and using fully connected layers, we will only use a single hidden layer with 100 units in each network. In the following code, we will specify and initialize the two networks, and print their summary information: >>> image_size = ( 28, 28) >>> z_size = 20 >>> gen_hidden_layers = 1 >>> gen_hidden_size = 100 >>> disc_hidden_layers = 1 >>> disc_hidden_size = 100 >>> torch.manual_seed( 1) >>> gen_model = make_generator_network( ... input_size=z_size, ... num_hidden_layers=gen_hidden_layers, ... num_hidden_units=gen_hidden_size, ... num_output_units=np.prod(image_size) ... ) >>> print(gen_model) Sequential( (fc_g0): Linear(in_features=20, out_features=100, bias=False) (relu_g0): LeakyReLU(negative_slope=0.01) (fc_g1): Linear(in_features=100, out_features=784, bias=True) (tanh_g): Tanh() ) >>> disc_model = make_discriminator_network( ... input_size=np.prod(image_size), ... num_hidden_layers=disc_hidden_layers, ... num_hidden_units=disc_hidden_size ... ) >>> print(disc_model) Sequential( (fc_d0): Linear(in_features=784, out_features=100, bias=False) (relu_d0): LeakyReLU(negative_slope=0.01) (dropout): Dropout(p=0.5, inplace=False) (fc_d1): Linear(in_features=100, out_features=1, bias=True) (sigmoid): Sigmoid() ) Generative Adversarial Networks for Synthesizing New Data 604 Defining the training dataset In the next step, we will load the MNIST dataset from PyTorch and apply the necessary preprocessing steps. Since the output layer of the generator is using the tanh activation function, the pixel values of the synthesized images will be in the range (–1, 1). However, the input pixels of the MNIST images are within the range [0, 255] (with a data type PIL.Image.Image ). Thus, in the preprocessing steps, we will use the torchvision.transforms.ToTensor function to convert the input image tensors to a tensor. As a result, besides changing the data type, calling this function will also change the range of input pixel intensities to [0, 1]. Then, we can shift them by –0.5 and scale them by a factor of 0.5 such that the pixel intensities will be rescaled to be in the range [–1, 1], which can improve gradient descent-based learning: >>> import torchvision >>> from torchvision import transforms >>> image_path = './' >>> transform = transforms.Compose([ ... transforms.ToTensor(), ... transforms.Normalize(mean=( 0.5), std=( 0.5)), ... ]) >>> mnist_dataset = torchvision.datasets.MNIST( ... root=image_path, train= True, ... transform=transform, download= False ... ) >>> example, label = next(iter(mnist_dataset)) >>> print(f'Min: {example. min()} Max: {example. max()}') >>> print(example.shape) Min: -1.0 Max: 1.0 torch.Size([1, 28, 28]) Furthermore, we will also create a random vector, z, based on the desired random distribution (in this code example, uniform or normal, which are the most common choices): >>> def create_noise (batch_size, z_size, mode_z): ... if mode_z == 'uniform' : ... input_z = torch.rand(batch_size,", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 544, "start_word": 174080, "end_word": 174480, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000545": {"text": "]) >>> mnist_dataset = torchvision.datasets.MNIST( ... root=image_path, train= True, ... transform=transform, download= False ... ) >>> example, label = next(iter(mnist_dataset)) >>> print(f'Min: {example. min()} Max: {example. max()}') >>> print(example.shape) Min: -1.0 Max: 1.0 torch.Size([1, 28, 28]) Furthermore, we will also create a random vector, z, based on the desired random distribution (in this code example, uniform or normal, which are the most common choices): >>> def create_noise (batch_size, z_size, mode_z): ... if mode_z == 'uniform' : ... input_z = torch.rand(batch_size, z_size)* 2 - 1 ... elif mode_z == 'normal' : ... input_z = torch.randn(batch_size, z_size) ... return input_z Let’s inspect the dataset object that we created. In the following code, we will take one batch of exam- ples and print the array shapes of this sample of input vectors and images. Furthermore, in order to understand the overall data flow of our GAN model, in the following code, we will process a forward pass for our generator and discriminator. Chapter 17 605 First, we will feed the batch of input, z, vectors to the generator and get its output, g_output . This will be a batch of fake examples, which will be fed to the discriminator model to get the probabilities for the batch of fake examples, d_proba_fake . Furthermore, the processed images that we get from the dataset object will be fed to the discriminator model, which will result in the probabilities for the real examples, d_proba_real . The code is as follows: >>> from torch.utils.data import DataLoader >>> batch_size = 32 >>> dataloader = DataLoader(mnist_dataset, batch_size, shuffle= False) >>> input_real, label = next(iter(dataloader)) >>> input_real = input_real.view(batch_size, - 1) >>> torch.manual_seed( 1) >>> mode_z = 'uniform' # 'uniform' vs. 'normal' >>> input_z = create_noise(batch_size, z_size, mode_z) >>> print('input-z -- shape:' , input_z.shape) >>> print('input-real -- shape:' , input_real.shape) input-z -- shape: torch.Size([32, 20]) input-real -- shape: torch.Size([32, 784]) >>> g_output = gen_model(input_z) >>> print('Output of G -- shape:' , g_output.shape) Output of G -- shape: torch.Size([32, 784]) >>> d_proba_real = disc_model(input_real) >>> d_proba_fake = disc_model(g_output) >>> print('Disc. (real) -- shape:' , d_proba_real.shape) >>> print('Disc. (fake) -- shape:' , d_proba_fake.shape) Disc. (real) -- shape: torch.Size([32, 1]) Disc. (fake) -- shape: torch.Size([32, 1]) The two probabilities, d_proba_fake and d_proba_real , will be used to compute the loss functions for training the model. Training the GAN model As the next step, we will create an instance of nn.BCELoss as our loss", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 545, "start_word": 174400, "end_word": 174800, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000546": {"text": ", g_output.shape) Output of G -- shape: torch.Size([32, 784]) >>> d_proba_real = disc_model(input_real) >>> d_proba_fake = disc_model(g_output) >>> print('Disc. (real) -- shape:' , d_proba_real.shape) >>> print('Disc. (fake) -- shape:' , d_proba_fake.shape) Disc. (real) -- shape: torch.Size([32, 1]) Disc. (fake) -- shape: torch.Size([32, 1]) The two probabilities, d_proba_fake and d_proba_real , will be used to compute the loss functions for training the model. Training the GAN model As the next step, we will create an instance of nn.BCELoss as our loss function and use that to calculate the binary cross-entropy loss for the generator and discriminator associated with the batches that we just processed. To do this, we also need the ground truth labels for each output. For the generator, we will create a vector of 1s with the same shape as the vector containing the predicted probabilities for the generated images, d_proba_fake . For the discriminator loss, we have two terms: the loss for detecting the fake examples involving d_proba_fake and the loss for detecting the real examples based on d_proba_real . Generative Adversarial Networks for Synthesizing New Data 606 The ground truth labels for the fake term will be a vector of 0s that we can generate via the torch. zeros() (or torch.zeros_like() ) function. Similarly, we can generate the ground truth values for the real images via the torch.ones() (or torch.ones_like() ) function, which creates a vector of 1s: >>> loss_fn = nn.BCELoss() >>> ## Loss for the Generator >>> g_labels_real = torch.ones_like(d_proba_fake) >>> g_loss = loss_fn(d_proba_fake, g_labels_real) >>> print(f'Generator Loss: {g_loss: .4f}') Generator Loss: 0.6863 >>> ## Loss for the Discriminator >>> d_labels_real = torch.ones_like(d_proba_real) >>> d_labels_fake = torch.zeros_like(d_proba_fake) >>> d_loss_real = loss_fn(d_proba_real, d_labels_real) >>> d_loss_fake = loss_fn(d_proba_fake, d_labels_fake) >>> print(f'Discriminator Losses: Real {d_loss_real: .4f} Fake {d_loss_ fake:.4f}') Discriminator Losses: Real 0.6226 Fake 0.7007 The previous code example shows the step-by-step calculation of the different loss terms for the purpose of understanding the overall concept behind training a GAN model. The following code will set up the GAN model and implement the training loop, where we will include these calculations in a for loop. We will start with setting up the data loader for the real dataset, the generator and discriminator model, as well as a separate Adam optimizer for each of the two models: >>> batch_size = 64 >>> torch.manual_seed( 1) >>> np.random.seed( 1) >>> mnist_dl = DataLoader(mnist_dataset, batch_size=batch_size, ... shuffle= True, drop_last= True) >>> gen_model", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 546, "start_word": 174720, "end_word": 175120, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000547": {"text": "a GAN model. The following code will set up the GAN model and implement the training loop, where we will include these calculations in a for loop. We will start with setting up the data loader for the real dataset, the generator and discriminator model, as well as a separate Adam optimizer for each of the two models: >>> batch_size = 64 >>> torch.manual_seed( 1) >>> np.random.seed( 1) >>> mnist_dl = DataLoader(mnist_dataset, batch_size=batch_size, ... shuffle= True, drop_last= True) >>> gen_model = make_generator_network( ... input_size=z_size, ... num_hidden_layers=gen_hidden_layers, ... num_hidden_units=gen_hidden_size, ... num_output_units=np.prod(image_size) ... ).to(device) >>> disc_model = make_discriminator_network( ... input_size=np.prod(image_size), ... num_hidden_layers=disc_hidden_layers, ... num_hidden_units=disc_hidden_size ... ).to(device) Chapter 17 607 >>> loss_fn = nn.BCELoss() >>> g_optimizer = torch.optim.Adam(gen_model.parameters()) >>> d_optimizer = torch.optim.Adam(disc_model.parameters()) In addition, we will compute the loss gradients with respect to the model weights and optimize the parameters of the generator and discriminator using two separate Adam optimizers. We will write two utility functions for training the discriminator and the generator as follows: >>> ## Train the discriminator >>> def d_train (x): ... disc_model.zero_grad() ... # Train discriminator with a real batch ... batch_size = x.size( 0) ... x = x.view(batch_size, - 1).to(device) ... d_labels_real = torch.ones(batch_size, 1, device=device) ... d_proba_real = disc_model(x) ... d_loss_real = loss_fn(d_proba_real, d_labels_real) ... # Train discriminator on a fake batch ... input_z = create_noise(batch_size, z_size, mode_z).to(device) ... g_output = gen_model(input_z) ... d_proba_fake = disc_model(g_output) ... d_labels_fake = torch.zeros(batch_size, 1, device=device) ... d_loss_fake = loss_fn(d_proba_fake, d_labels_fake) ... # gradient backprop & optimize ONLY D's parameters ... d_loss = d_loss_real + d_loss_fake ... d_loss.backward() ... d_optimizer.step() ... return d_loss.data.item(), d_proba_real.detach(), \\ ... d_proba_fake.detach() >>> >>> ## Train the generator >>> def g_train (x): ... gen_model.zero_grad() ... batch_size = x.size( 0) ... input_z = create_noise(batch_size, z_size, mode_z).to(device) ... g_labels_real = torch.ones(batch_size, 1, device=device) ... ... g_output = gen_model(input_z) ... d_proba_fake = disc_model(g_output) ... g_loss = loss_fn(d_proba_fake, g_labels_real) Generative Adversarial Networks for Synthesizing New Data 608 ... # gradient backprop & optimize ONLY G's parameters ... g_loss.backward() ... g_optimizer.step() ... return g_loss.data.item() Next, we will alternate between the training of the generator and the discriminator for 100 epochs. For each epoch, we will record the loss for the generator, the loss for the discriminator, and the loss for the real data and fake data respectively. Furthermore, after each epoch, we will generate some examples from a fixed noise input using the current generator model by calling the create_samples() function.", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 547, "start_word": 175040, "end_word": 175440, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000548": {"text": "backprop & optimize ONLY G's parameters ... g_loss.backward() ... g_optimizer.step() ... return g_loss.data.item() Next, we will alternate between the training of the generator and the discriminator for 100 epochs. For each epoch, we will record the loss for the generator, the loss for the discriminator, and the loss for the real data and fake data respectively. Furthermore, after each epoch, we will generate some examples from a fixed noise input using the current generator model by calling the create_samples() function. We will store the synthesized images in a Python list. The code is as follows: >>> fixed_z = create_noise(batch_size, z_size, mode_z).to(device) >>> def create_samples (g_model, input_z): ... g_output = g_model(input_z) ... images = torch.reshape(g_output, (batch_size, *image_size)) ... return (images+ 1)/2.0 >>> >>> epoch_samples = [] >>> all_d_losses = [] >>> all_g_losses = [] >>> all_d_real = [] >>> all_d_fake = [] >>> num_epochs = 100 >>> >>> for epoch in range (1, num_epochs+ 1): ... d_losses, g_losses = [], [] ... d_vals_real, d_vals_fake = [], [] ... for i, (x, _) in enumerate (mnist_dl): ... d_loss, d_proba_real, d_proba_fake = d_train(x) ... d_losses.append(d_loss) ... g_losses.append(g_train(x)) ... d_vals_real.append(d_proba_real.mean().cpu()) ... d_vals_fake.append(d_proba_fake.mean().cpu()) ... ... all_d_losses.append(torch.tensor(d_losses).mean()) ... all_g_losses.append(torch.tensor(g_losses).mean()) ... all_d_real.append(torch.tensor(d_vals_real).mean()) ... all_d_fake.append(torch.tensor(d_vals_fake).mean()) ... print(f'Epoch {epoch:03d} | Avg Losses >>' ... f' G/D {all_g_losses[- 1]:.4f}/{all_d_losses[- 1]:.4f}' ... f' [D-Real: {all_d_real[- 1]:.4f}' ... f' D-Fake: {all_d_fake[- 1]:.4f}]') Chapter 17 609 ... epoch_samples.append( ... create_samples(gen_model, fixed_z).detach().cpu().numpy() ... ) Epoch 001 | Avg Losses >> G/D 0.9546/0.8957 [D-Real: 0.8074 D-Fake: 0.4687] Epoch 002 | Avg Losses >> G/D 0.9571/1.0841 [D-Real: 0.6346 D-Fake: 0.4155] Epoch ... Epoch 100 | Avg Losses >> G/D 0.8622/1.2878 [D-Real: 0.5488 D-Fake: 0.4518] Using a GPU on Google Colab, the training process that we implemented in the previous code block should be completed in less than an hour. (It may even be faster on your personal computer if you have a recent and capable CPU and a GPU.) After the model training has completed, it is often helpful to plot the discriminator and generator losses to analyze the behavior of both subnetworks and assess whether they converged. It is also helpful to plot the average probabilities of the batches of real and fake examples as computed by the discriminator in each iteration. We expect these probabilities to be around 0.5, which means that the discriminator is not able to confidently distinguish between real and fake images: >>> import itertools >>> fig = plt.figure(figsize=( 16, 6))", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 548, "start_word": 175360, "end_word": 175760, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000549": {"text": "is often helpful to plot the discriminator and generator losses to analyze the behavior of both subnetworks and assess whether they converged. It is also helpful to plot the average probabilities of the batches of real and fake examples as computed by the discriminator in each iteration. We expect these probabilities to be around 0.5, which means that the discriminator is not able to confidently distinguish between real and fake images: >>> import itertools >>> fig = plt.figure(figsize=( 16, 6)) >>> ## Plotting the losses >>> ax = fig.add_subplot( 1, 2, 1) >>> plt.plot(all_g_losses, label= 'Generator loss' ) >>> half_d_losses = [all_d_loss/ 2 for all_d_loss in all_d_losses] >>> plt.plot(half_d_losses, label= 'Discriminator loss' ) >>> plt.legend(fontsize= 20) >>> ax.set_xlabel( 'Iteration' , size=15) >>> ax.set_ylabel( 'Loss', size=15) >>> >>> ## Plotting the outputs of the discriminator >>> ax = fig.add_subplot( 1, 2, 2) >>> plt.plot(all_d_real, label= r'Real: $D(\\mathbf{x})$' ) >>> plt.plot(all_d_fake, label= r'Fake: $D(G(\\mathbf{z}))$' ) >>> plt.legend(fontsize= 20) >>> ax.set_xlabel( 'Iteration' , size=15) >>> ax.set_ylabel( 'Discriminator output' , size=15) >>> plt.show() Generative Adversarial Networks for Synthesizing New Data 610 Figure 17.10 shows the results: Figure 17.10: The discriminator performance As you can see from the discriminator outputs in the previous figure, during the early stages of the training, the discriminator was able to quickly learn to distinguish quite accurately between the real and fake examples; that is, the fake examples had probabilities close to 0, and the real examples had probabilities close to 1. The reason for that was that the fake examples were nothing like the real ones; therefore, distinguishing between real and fake was rather easy. As the training proceeds further, the generator will become better at synthesizing realistic images, which will result in probabilities of both real and fake examples that are close to 0.5. Furthermore, we can also see how the outputs of the generator, that is, the synthesized images, change during training. In the following code, we will visualize some of the images produced by the generator for a selection of epochs: >>> selected_epochs = [ 1, 2, 4, 10, 50, 100 ] >>> fig = plt.figure(figsize=( 10, 14)) >>> for i,e in enumerate (selected_epochs): ... for j in range (5): ... ax = fig.add_subplot( 6, 5, i* 5+j+1) ... ax.set_xticks([]) ... ax.set_yticks([]) ... if j == 0: ... ax.text( ... - 0.06, 0.5, f'Epoch {e}', ... rotation= 90, size= 18, color= 'red', ... horizontalalignment= 'right', ...", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 549, "start_word": 175680, "end_word": 176080, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000550": {"text": "will visualize some of the images produced by the generator for a selection of epochs: >>> selected_epochs = [ 1, 2, 4, 10, 50, 100 ] >>> fig = plt.figure(figsize=( 10, 14)) >>> for i,e in enumerate (selected_epochs): ... for j in range (5): ... ax = fig.add_subplot( 6, 5, i* 5+j+1) ... ax.set_xticks([]) ... ax.set_yticks([]) ... if j == 0: ... ax.text( ... - 0.06, 0.5, f'Epoch {e}', ... rotation= 90, size= 18, color= 'red', ... horizontalalignment= 'right', ... verticalalignment= 'center' , ... transform=ax.transAxes ... ) Chapter 17 611 ... ... image = epoch_samples[e- 1][j] ... ax.imshow(image, cmap= 'gray_r' ) ... >>> plt.show() Figure 17.11 shows the produced images: Figure 17.11: Images produced by the generator As you can see from Figure 17.11, the generator network produced more and more realistic images as the training progressed. However, even after 100 epochs, the produced images still look very different from the handwritten digits contained in the MNIST dataset. In this section, we designed a very simple GAN model with only a single fully connected hidden layer for both the generator and discriminator. After training the GAN model on the MNIST dataset, we were able to achieve promising, although not yet satisfactory, results with the new handwritten digits. Generative Adversarial Networks for Synthesizing New Data 612 As we learned in Chapter 14, Classifying Images with Deep Convolutional Neural Networks, NN architec- tures with convolutional layers have several advantages over fully connected layers when it comes to image classification. In a similar sense, adding convolutional layers to our GAN model to work with image data might improve the outcome. In the next section, we will implement a deep convolutional GAN (DCGAN ), which uses convolutional layers for both the generator and the discriminator networks. Improving the quality of synthesized images using a convolutional and Wasserstein GAN In this section, we will implement a DCGAN, which will enable us to improve the performance we saw in the previous GAN example. Additionally, we will briefly talk about an extra key technique, Wasserstein GAN (WGAN ). The techniques that we will cover in this section will include the following: • Transposed convolution • Batch normalization (BatchNorm) • WGAN The DCGAN was proposed in 2016 by A. Radford, L. Metz, and S. Chintala in their article Unsupervised representation learning with deep convolutional generative adversarial networks, which is freely available at https://arxiv.org/pdf/1511.06434.pdf . In this article, the", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 550, "start_word": 176000, "end_word": 176400, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000551": {"text": "we saw in the previous GAN example. Additionally, we will briefly talk about an extra key technique, Wasserstein GAN (WGAN ). The techniques that we will cover in this section will include the following: • Transposed convolution • Batch normalization (BatchNorm) • WGAN The DCGAN was proposed in 2016 by A. Radford, L. Metz, and S. Chintala in their article Unsupervised representation learning with deep convolutional generative adversarial networks, which is freely available at https://arxiv.org/pdf/1511.06434.pdf . In this article, the researchers proposed using convolu- tional layers for both the generator and discriminator networks. Starting from a random vector, z, the DCGAN first uses a fully connected layer to project z into a new vector with a proper size so that it can be reshaped into a spatial convolution representation (h ×w×c), which is smaller than the output image size. Then, a series of convolutional layers, known as transposed convolution, are used to upsample the feature maps to the desired output image size. Transposed convolution In Chapter 14, you learned about the convolution operation in one- and two-dimensional spaces. In particular, we looked at how the choices for the padding and strides change the output feature maps. While a convolution operation is usually used to downsample the feature space (for example, by set- ting the stride to 2, or by adding a pooling layer after a convolutional layer), a transposed convolution operation is usually used for upsampling the feature space. To understand the transposed convolution operation, let’s go through a simple thought experiment. Assume that we have an input feature map of size n ×n. Then, we apply a 2D convolution operation with certain padding and stride parameters to this n×n input, resulting in an output feature map of size m×m. Now, the question is, how we can apply another convolution operation to obtain a feature map with the initial dimension n×n from this m×m output feature map while maintaining the connectivity patterns between the input and output? Note that only the shape of the n×n input matrix is recovered and not the actual matrix values. Chapter 17 613 This is what transposed convolution does, as shown in Figure 17.12: Figure 17.12: Transposed convolution Upsampling feature maps using transposed convolution works by inserting 0s between the elements of the input feature maps. Figure 17.13 shows an example of applying transposed convolution to an input of size 4×4, with a stride of", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 551, "start_word": 176320, "end_word": 176720, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000552": {"text": "connectivity patterns between the input and output? Note that only the shape of the n×n input matrix is recovered and not the actual matrix values. Chapter 17 613 This is what transposed convolution does, as shown in Figure 17.12: Figure 17.12: Transposed convolution Upsampling feature maps using transposed convolution works by inserting 0s between the elements of the input feature maps. Figure 17.13 shows an example of applying transposed convolution to an input of size 4×4, with a stride of 2×2 and kernel size of 2×2. The matrix of size 9×9 in the center shows the results after inserting such 0s into the input feature map. Then, performing a normal convolution using the 2×2 kernel with a stride of 1 results in an output of size 8×8. We can verify the backward direction by performing a regular convolution on the output with a stride of 2, which results in an output feature map of size 4×4, which is the same as the original input size: Figure 17.13: Applying transposed convolution to a 4×4 inputTransposed convolution versus deconvolution Transposed convolution is also called fractionally strided convolution. In deep learning literature, another common term that is used to refer to transposed convolution is decon- volution. However, note that deconvolution was originally defined as the inverse of a convo - lution operation, f, on a feature map, x, with weight parameters, w, producing feature map x′, fw(x) = x′. A deconvolution function, f–1, can then be defined as 𝑓𝑓𝒘𝒘−1(𝑓𝑓(𝒙𝒙))=𝒙𝒙 . However, note that the transposed convolution is merely focused on recovering the dimensionality of the feature space and not the actual values. Generative Adversarial Networks for Synthesizing New Data 614 Figure 17.13 shows how transposed convolution works in general. There are various cases in which input size, kernel size, strides, and padding variations can change the output. If you want to learn more about all these different cases, refer to the tutorial A Guide to Convolution Arithmetic for Deep Learning by Vincent Dumoulin and Francesco Visin, 2018 ( https://arxiv.org/pdf/1603.07285.pdf .) Batch normalization BatchNorm was introduced in 2015 by Sergey Ioffe and Christian Szegedy in the article Batch Normal- ization: Accelerating Deep Network Training by Reducing Internal Covariate Shift, which you can access via arXiv at https://arxiv.org/pdf/1502.03167.pdf . One of the main ideas behind BatchNorm is normalizing the layer inputs and preventing changes in their distribution during training, which enables faster and better convergence.", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 552, "start_word": 176640, "end_word": 177040, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000553": {"text": "Guide to Convolution Arithmetic for Deep Learning by Vincent Dumoulin and Francesco Visin, 2018 ( https://arxiv.org/pdf/1603.07285.pdf .) Batch normalization BatchNorm was introduced in 2015 by Sergey Ioffe and Christian Szegedy in the article Batch Normal- ization: Accelerating Deep Network Training by Reducing Internal Covariate Shift, which you can access via arXiv at https://arxiv.org/pdf/1502.03167.pdf . One of the main ideas behind BatchNorm is normalizing the layer inputs and preventing changes in their distribution during training, which enables faster and better convergence. BatchNorm transforms a mini-batch of features based on its computed statistics. Assume that we have the net preactivation feature maps obtained after a convolutional layer in a four-dimensional tensor, Z, with the shape [m×c×h×w], where m is the number of examples in the batch (i.e., batch size), h×w is the spatial dimension of the feature maps, and c is the number of channels. BatchNorm can be summarized in three steps, as follows: 1. Compute the mean and standard deviation of the net inputs for each mini-batch: 𝝁𝝁𝐵𝐵=1 𝑚𝑚𝑚𝑚𝑚𝑚𝑚∑𝒁𝒁[𝑖𝑖𝑖𝑖𝑖𝑖𝑖𝑖] 𝑖𝑖𝑖𝑖𝑖𝑖𝑖𝑖 𝝈𝝈𝐵𝐵2=1 𝑚𝑚𝑚𝑚𝑚𝑚𝑚∑(𝒁𝒁[𝑖𝑖𝑖𝑖𝑖𝑖𝑖𝑖]−𝝁𝝁𝐵𝐵)2 𝑖𝑖𝑖𝑖𝑖𝑖𝑖𝑖 where 𝝁𝝁𝐵𝐵 and 𝝈𝝈𝐵𝐵2 both have size c. 2. Standardize the net inputs for all examples in the batch: 𝒁𝒁std[𝑖𝑖]=𝒁𝒁[𝑖𝑖]−𝝁𝝁𝐵𝐵 𝝈𝝈𝐵𝐵+𝜖𝜖 where 𝜖𝜖 is a small number for numerical stability (that is, to avoid division by zero). 3. Scale and shift the normalized net inputs using two learnable parameter vectors, 𝜸𝜸 and 𝜷𝜷 , of size c (number of channels): 𝑨𝑨pre[𝑖𝑖]= 𝜸𝜸𝜸𝜸std[𝑖𝑖]+𝜷𝜷 Chapter 17 615 Figure 17.14 illustrates the process: Figure 17.14: The process of batch normalization In the first step of BatchNorm, the mean, 𝝁𝝁𝐵𝐵 , and standard deviation, 𝝈𝝈𝐵𝐵 , of the mini-batch are com- puted. Both 𝝁𝝁𝐵𝐵 and 𝝈𝝈𝐵𝐵 are vectors of size c (where c is the number of channels). Then, these statistics are used in step 2 to scale the examples in each mini-batch via z-score normalization (standardization), resulting in standardized net inputs, 𝒁𝒁std[𝑖𝑖] . As a consequence, these net inputs are mean-centered and have unit variance, which is generally a useful property for gradient descent-based optimization. On the other hand, always normalizing the net inputs such that they have the same properties across the different mini-batches, which can be diverse, can severely impact the representational capacity of NNs. This can be understood by considering a feature, 𝑥𝑥𝑥𝑥𝑥(0,1) , which, after sigmoid activation to 𝜎𝜎(𝑥𝑥) , results in a linear region for values close to 0. Therefore, in step 3, the learnable parameters,", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 553, "start_word": 176960, "end_word": 177360, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000554": {"text": "and have unit variance, which is generally a useful property for gradient descent-based optimization. On the other hand, always normalizing the net inputs such that they have the same properties across the different mini-batches, which can be diverse, can severely impact the representational capacity of NNs. This can be understood by considering a feature, 𝑥𝑥𝑥𝑥𝑥(0,1) , which, after sigmoid activation to 𝜎𝜎(𝑥𝑥) , results in a linear region for values close to 0. Therefore, in step 3, the learnable parameters, 𝜷𝜷 and 𝜸𝜸 , which are vectors of size c (number of channels), allow BatchNorm to control the shift and spread of the normalized features. During training, the running averages, 𝝁𝝁𝐵𝐵 , and running variance, 𝝈𝝈𝐵𝐵2 , are computed, which are used along with the tuned parameters, 𝜷𝜷 and 𝜸𝜸 , to normalize the test example(s) at evaluation. Generative Adversarial Networks for Synthesizing New Data 616 The PyTorch API provides a class, nn.BatchNorm2d() (nn.BatchNorm1d() for 1D input), that we can use as a layer when defining our models; it will perform all of the steps that we described for Batch- Norm. Note that the behavior for updating the learnable parameters, 𝜸𝜸 and 𝜷𝜷 , depends on whether the model is a training model not. These parameters are learned only during training and are then used for normalization during evaluation. Implementing the generator and discriminator At this point, we have covered the main components of a DCGAN model, which we will now implement. The architectures of the generator and discriminator networks are summarized in the following two figures. The generator takes a vector, z, of size 100 as input. Then, a series of transposed convolutions using nn.ConvTranspose2d() upsamples the feature maps until the spatial dimension of the resulting feature maps reaches 28×28. The number of channels is reduced by half after each transposed convolutional layer, except the last one, which uses only one output filter to generate a grayscale image. Each trans- posed convolutional layer is followed by BatchNorm and leaky ReLU activation functions, except the last one, which uses tanh activation (without BatchNorm).Why does BatchNorm help optimization? Initially, BatchNorm was developed to reduce the so-called internal covariance shift, which is defined as the changes that occur in the distribution of a layer’s activations due to the updated network parameters during training. To explain this with a simple example, consider a fixed batch that passes through the network at epoch 1.", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 554, "start_word": 177280, "end_word": 177680, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000555": {"text": "trans- posed convolutional layer is followed by BatchNorm and leaky ReLU activation functions, except the last one, which uses tanh activation (without BatchNorm).Why does BatchNorm help optimization? Initially, BatchNorm was developed to reduce the so-called internal covariance shift, which is defined as the changes that occur in the distribution of a layer’s activations due to the updated network parameters during training. To explain this with a simple example, consider a fixed batch that passes through the network at epoch 1. We record the activations of each layer for this batch. After iterating through the whole training dataset and updating the model parameters, we start the second epoch, where the previously fixed batch passes through the network. Then, we compare the layer activations from the first and second epochs. Since the network parameters have changed, we observe that the activations have also changed. This phenomenon is called the internal covariance shift, which was believed to decelerate NN training. However, in 2018, S. Santurkar, D. Tsipras, A. Ilyas, and A. Madry further investigated what makes BatchNorm so effective. In their study, the researchers observed that the effect of BatchNorm on the internal covariance shift is marginal. Based on the outcome of their experiments, they hypothesized that the effectiveness of BatchNorm is, instead, based on a smoother surface of the loss function, which makes the non-convex optimization more robust. If you are interested in learning more about these results, read through the original paper, How Does Batch Normalization Help Optimization?, which is freely available at http://papers. nips.cc/paper/7515-how-does-batch-normalization-help-optimization.pdf. Chapter 17 617 The architecture for the generator (the feature maps after each layer) is shown in Figure 17.15: Figure 17.15: The generator network The discriminator receives images of size 1×28×28, which are passed through four convolutional layers. The first three convolutional layers reduce the spatial dimensionality by 4 while increasing the number of channels of the feature maps. Each convolutional layer is also followed by BatchNorm and leaky ReLU activation. The last convolutional layer uses kernels of size 7×7 and a single filter to reduce the spatial dimensionality of the output to 1×1×1. Finally, the convolutional output is followed by a sigmoid function and squeezed to one dimension: Figure 17.16: The discriminator network Generative Adversarial Networks for Synthesizing New Data 618 The code for the helper function to make the generator and the discriminator network class is as follows: >>> def make_generator_network (input_size, n_filters): ...", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 555, "start_word": 177600, "end_word": 178000, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000556": {"text": "BatchNorm and leaky ReLU activation. The last convolutional layer uses kernels of size 7×7 and a single filter to reduce the spatial dimensionality of the output to 1×1×1. Finally, the convolutional output is followed by a sigmoid function and squeezed to one dimension: Figure 17.16: The discriminator network Generative Adversarial Networks for Synthesizing New Data 618 The code for the helper function to make the generator and the discriminator network class is as follows: >>> def make_generator_network (input_size, n_filters): ... model = nn.Sequential( ... nn.ConvTranspose2d(input_size, n_filters* 4, 4, ... 1, 0, bias= False), ... nn.BatchNorm2d(n_filters* 4), ... nn.LeakyReLU( 0.2), ... nn.ConvTranspose2d(n_filters* 4, n_filters* 2, ... 3, 2, 1, bias= False), ... nn.BatchNorm2d(n_filters* 2), ... nn.LeakyReLU( 0.2), ... nn.ConvTranspose2d(n_filters* 2, n_filters, ... 4, 2, 1, bias= False), ... nn.BatchNorm2d(n_filters), ... nn.LeakyReLU( 0.2), ... nn.ConvTranspose2d(n_filters, 1, 4, 2, 1, ... bias= False), ... nn.Tanh() ... ) ... return model >>> >>> class Discriminator (nn.Module): ... def __init__(self, n_filters): ... super().__init__() ... self.network = nn.Sequential( ... nn.Conv2d( 1, n_filters, 4, 2, 1, bias= False),Architecture design considerations for convolutional GANs Notice that the number of feature maps follows different trends between the generator and the discriminator. In the generator, we start with a large number of feature maps and decrease them as we progress toward the last layer. On the other hand, in the discriminator, we start with a small number of channels and increase it toward the last layer. This is an important point for designing CNNs with the number of feature maps and the spatial size of the feature maps in reverse order. When the spatial size of the feature maps increases, the number of feature maps decreases and vice versa. In addition, note that it’s usually not recommended to use bias units in the layer that follows a BatchNorm layer. Using bias units would be redundant in this case, since BatchNorm already has a shift parameter, 𝜷𝜷 . You can omit the bias units for a given layer by setting bias=False in nn.ConvTranspose2d or nn.Conv2d . Chapter 17 619 ... nn.LeakyReLU( 0.2), ... nn.Conv2d(n_filters, n_filters* 2, ... 4, 2, 1, bias= False), ... nn.BatchNorm2d(n_filters * 2), ... nn.LeakyReLU( 0.2), ... nn.Conv2d(n_filters* 2, n_filters* 4, ... 3, 2, 1, bias= False), ... nn.BatchNorm2d(n_filters* 4), ... nn.LeakyReLU( 0.2), ... nn.Conv2d(n_filters* 4, 1, 4, 1, 0, bias= False), ... nn.Sigmoid() ... ) ... ... def forward (self, input): ... output = self.network( input) ...", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 556, "start_word": 177920, "end_word": 178320, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000557": {"text": "the bias units for a given layer by setting bias=False in nn.ConvTranspose2d or nn.Conv2d . Chapter 17 619 ... nn.LeakyReLU( 0.2), ... nn.Conv2d(n_filters, n_filters* 2, ... 4, 2, 1, bias= False), ... nn.BatchNorm2d(n_filters * 2), ... nn.LeakyReLU( 0.2), ... nn.Conv2d(n_filters* 2, n_filters* 4, ... 3, 2, 1, bias= False), ... nn.BatchNorm2d(n_filters* 4), ... nn.LeakyReLU( 0.2), ... nn.Conv2d(n_filters* 4, 1, 4, 1, 0, bias= False), ... nn.Sigmoid() ... ) ... ... def forward (self, input): ... output = self.network( input) ... return output.view(- 1, 1).squeeze( 0) With the helper function and class, you can build a DCGAN model and train it by using the same MNIST dataset object we initialized in the previous section when we implemented the simple, fully connected GAN. We can create the generator networks using the helper function and print its archi- tecture as follows: >>> z_size = 100 >>> image_size = ( 28, 28) >>> n_filters = 32 >>> gen_model = make_generator_network(z_size, n_filters).to(device) >>> print(gen_model) Sequential( (0): ConvTranspose2d(100, 128, kernel_size=(4, 4), stride=(1, 1), bias=False) (1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_ stats=True) (2): LeakyReLU(negative_slope=0.2) (3): ConvTranspose2d(128, 64, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False) (4): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_ stats=True) (5): LeakyReLU(negative_slope=0.2) (6): ConvTranspose2d(64, 32, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1), bias=False) (7): BatchNorm2d(32, eps=1e-05, momentum=0.1, affine=True, track_running_ stats=True) Generative Adversarial Networks for Synthesizing New Data 620 (8): LeakyReLU(negative_slope=0.2) (9): ConvTranspose2d(32, 1, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1), bias=False) (10): Tanh() ) Similarly, we can generate the discriminator network and see its architecture: >>> disc_model = Discriminator(n_filters).to(device) >>> print(disc_model) Discriminator( (network): Sequential( (0): Conv2d(1, 32, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1), bias=False) (1): LeakyReLU(negative_slope=0.2) (2): Conv2d(32, 64, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1), bias=False) (3): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_ stats=True) (4): LeakyReLU(negative_slope=0.2) (5): Conv2d(64, 128, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False) (6): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_ stats=True) (7): LeakyReLU(negative_slope=0.2) (8): Conv2d(128, 1, kernel_size=(4, 4), stride=(1, 1), bias=False) (9): Sigmoid() ) ) Also, we can use the same loss functions and optimizers as we did in the Training the GAN model subsection: >>> loss_fn = nn.BCELoss() >>> g_optimizer = torch.optim.Adam(gen_model.parameters(), 0.0003) >>> d_optimizer = torch.optim.Adam(disc_model.parameters(), 0.0002) Chapter 17 621 We will be making a few small modifications to the training procedure. The create_noise() function for generating random input must change to output a tensor of four dimensions instead of a vector: >>> def create_noise (batch_size, z_size, mode_z): ... if mode_z == 'uniform' : ...", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 557, "start_word": 178240, "end_word": 178640, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000558": {"text": "can use the same loss functions and optimizers as we did in the Training the GAN model subsection: >>> loss_fn = nn.BCELoss() >>> g_optimizer = torch.optim.Adam(gen_model.parameters(), 0.0003) >>> d_optimizer = torch.optim.Adam(disc_model.parameters(), 0.0002) Chapter 17 621 We will be making a few small modifications to the training procedure. The create_noise() function for generating random input must change to output a tensor of four dimensions instead of a vector: >>> def create_noise (batch_size, z_size, mode_z): ... if mode_z == 'uniform' : ... input_z = torch.rand(batch_size, z_size, 1, 1)*2 - 1 ... elif mode_z == 'normal' : ... input_z = torch.randn(batch_size, z_size, 1, 1) ... return input_z The d_train() function for training the discriminator doesn’t need to reshape the input image: >>> def d_train (x): ... disc_model.zero_grad() ... # Train discriminator with a real batch ... batch_size = x.size( 0) ... x = x.to(device) ... d_labels_real = torch.ones(batch_size, 1, device=device) ... d_proba_real = disc_model(x) ... d_loss_real = loss_fn(d_proba_real, d_labels_real) ... # Train discriminator on a fake batch ... input_z = create_noise(batch_size, z_size, mode_z).to(device) ... g_output = gen_model(input_z) ... d_proba_fake = disc_model(g_output) ... d_labels_fake = torch.zeros(batch_size, 1, device=device) ... d_loss_fake = loss_fn(d_proba_fake, d_labels_fake) ... # gradient backprop & optimize ONLY D's parameters ... d_loss = d_loss_real + d_loss_fake ... d_loss.backward() ... d_optimizer.step() ... return d_loss.data.item(), d_proba_real.detach(), \\ ... d_proba_fake.detach() Generative Adversarial Networks for Synthesizing New Data 622 Next, we will alternate between the training of the generator and the discriminator for 100 epochs. After each epoch, we will generate some examples from a fixed noise input using the current generator model by calling the create_samples() function. The code is as follows: >>> fixed_z = create_noise(batch_size, z_size, mode_z).to(device) >>> epoch_samples = [] >>> torch.manual_seed( 1) >>> for epoch in range (1, num_epochs+ 1): ... gen_model.train() ... for i, (x, _) in enumerate (mnist_dl): ... d_loss, d_proba_real, d_proba_fake = d_train(x) ... d_losses.append(d_loss) ... g_losses.append(g_train(x)) ... print(f'Epoch {epoch:03d} | Avg Losses >>' ... f' G/D {torch.FloatTensor(g_losses).mean(): .4f}' ... f'/{torch.FloatTensor(d_losses).mean(): .4f}') ... gen_model. eval() ... epoch_samples.append( ... create_samples( ... gen_model, fixed_z ... ).detach().cpu().numpy() ... ) Epoch 001 | Avg Losses >> G/D 4.7016/0.1035 Epoch 002 | Avg Losses >> G/D 5.9341/0.0438 ... Epoch 099 | Avg Losses >> G/D 4.3753/0.1360 Epoch 100 | Avg Losses >> G/D 4.4914/0.1120 Finally, let’s visualize the saved examples at some epochs to see how the model is learning and how the quality of synthesized examples changes over the course of learning: >>>", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 558, "start_word": 178560, "end_word": 178960, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000559": {"text": "... f'/{torch.FloatTensor(d_losses).mean(): .4f}') ... gen_model. eval() ... epoch_samples.append( ... create_samples( ... gen_model, fixed_z ... ).detach().cpu().numpy() ... ) Epoch 001 | Avg Losses >> G/D 4.7016/0.1035 Epoch 002 | Avg Losses >> G/D 5.9341/0.0438 ... Epoch 099 | Avg Losses >> G/D 4.3753/0.1360 Epoch 100 | Avg Losses >> G/D 4.4914/0.1120 Finally, let’s visualize the saved examples at some epochs to see how the model is learning and how the quality of synthesized examples changes over the course of learning: >>> selected_epochs = [ 1, 2, 4, 10, 50, 100 ] >>> fig = plt.figure(figsize=( 10, 14)) >>> for i,e in enumerate (selected_epochs): ... for j in range (5): ... ax = fig.add_subplot( 6, 5, i* 5+j+1) ... ax.set_xticks([]) ... ax.set_yticks([]) ... if j == 0: ... ax.text(- 0.06, 0.5, f'Epoch {e}', ... rotation= 90, size= 18, color= 'red', ... horizontalalignment= 'right', ... verticalalignment= 'center' , Chapter 17 623 ... transform=ax.transAxes) ... ... image = epoch_samples[e- 1][j] ... ax.imshow(image, cmap= 'gray_r' ) >>> plt.show() Figure 17.17 shows the results: Figure 17.17: Generated images from the DCGAN We used the same code to visualize the results as in the section on vanilla GAN. Comparing the new examples shows that DCGAN can generate images of a much higher quality. You may wonder how we can evaluate the results of GAN generators. The simplest approach is visual assessment, which involves evaluating the quality of the synthesized images in the context of the target domain and the project objective. Furthermore, there have been several more sophisticated evaluation methods proposed that are less subjective and less limited by domain knowledge. For a detailed survey, see Pros and Cons of GAN Evaluation Measures: New Developments ( https://arxiv.org/abs/2103.09396 ). The paper summarizes generator evaluation into qualitative and quantitative measures. Generative Adversarial Networks for Synthesizing New Data 624 There is a theoretical argument that training the generator should seek to minimize the dissimilar - ity between the distribution observed in the real data and the distribution observed in synthesized examples. Hence our current architecture would not perform very well when using cross-entropy as a loss function. In the next subsection, we will cover WGAN, which uses a modified loss function based on the so- called Wasserstein-1 (or earth mover’s) distance between the distributions of real and fake images for improving the training performance. Dissimilarity measures between two distributions We will first see different measures for computing the divergence between", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 559, "start_word": 178880, "end_word": 179280, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000560": {"text": "in the real data and the distribution observed in synthesized examples. Hence our current architecture would not perform very well when using cross-entropy as a loss function. In the next subsection, we will cover WGAN, which uses a modified loss function based on the so- called Wasserstein-1 (or earth mover’s) distance between the distributions of real and fake images for improving the training performance. Dissimilarity measures between two distributions We will first see different measures for computing the divergence between two distributions. Then, we will see which one of these measures is already embedded in the original GAN model. Finally, switching this measure in GANs will lead us to the implementation of a WGAN. As mentioned at the beginning of this chapter, the goal of a generative model is to learn how to syn- thesize new samples that have the same distribution as the distribution of the training dataset. Let P(x) and Q(x) represent the distribution of a random variable, x, as shown in the following figure. First, let’s look at some ways, shown in Figure 17.18 , that we can use to measure the dissimilarity between two distributions, P and Q: Figure 17.18: Methods to measure the dissimilarity between distributions P and Q The function supremum, sup(S), used in the total variation (TV) measure, refers to the smallest value that is greater than all elements of S. In other words, sup(S) is the least upper bound for S. Vice versa, the infimum function, inf(S), which is used in EM distance, refers to the largest value that is smaller than all elements of S (the greatest lower bound). Chapter 17 625 Let’s gain an understanding of these measures by briefly stating what they are trying to accomplish in simple words: • The first one, TV distance, measures the largest difference between the two distributions at each point. • The EM distance can be interpreted as the minimal amount of work needed to transform one distribution into the other. The infimum function in the EM distance is taken over Π(𝑃𝑃𝑃𝑃𝑃) , which is the collection of all joint distributions whose marginals are P or Q. Then, 𝛾𝛾(𝑢𝑢𝑢𝑢𝑢) is a transfer plan, which indicates how we redistribute the earth from location u to v, subject to some constraints for maintaining valid distributions after such transfers. Computing EM distance is an optimization problem by itself, which is to find the optimal transfer plan,", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 560, "start_word": 179200, "end_word": 179600, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000561": {"text": "needed to transform one distribution into the other. The infimum function in the EM distance is taken over Π(𝑃𝑃𝑃𝑃𝑃) , which is the collection of all joint distributions whose marginals are P or Q. Then, 𝛾𝛾(𝑢𝑢𝑢𝑢𝑢) is a transfer plan, which indicates how we redistribute the earth from location u to v, subject to some constraints for maintaining valid distributions after such transfers. Computing EM distance is an optimization problem by itself, which is to find the optimal transfer plan, 𝛾𝛾(𝑢𝑢𝑢𝑢𝑢) . • The Kullback-Leibler ( KL) and Jensen-Shannon ( JS) divergence measures come from the field of information theory. Note that KL divergence is not symmetric, that is, 𝐾𝐾𝐾𝐾(𝑃𝑃‖𝑄𝑄)≠𝐾𝐾𝐾𝐾(𝑄𝑄‖𝑃𝑃) in contrast to JS divergence. The dissimilarity equations provided in Figure 17.18 correspond to continuous distributions but can be extended for discrete cases. An example of calculating these different dissimilarity measures with two simple discrete distributions is illustrated in Figure 17.19: Figure 17.19: An example of calculating the different dissimilarity measures Note that, in the case of the EM distance, for this simple example, we can see that Q(x) at x = 2 has the excess value of 0.5−1 3= 0.166 , while the value of Q at the other two x’s is below 1/3. Therefore, the minimal amount of work is when we transfer the extra value at x = 2 to x = 1 and x = 3, as shown in Figure 17.19. For this simple example, it’s easy to see that these transfers will result in the minimal amount of work out of all possible transfers. However, this may be infeasible to do for more complex cases. Generative Adversarial Networks for Synthesizing New Data 626 Now, going back to our discussion of GANs, let’s see how these different distance measures are related to the loss function for GANs. It can be mathematically shown that the loss function in the original GAN indeed minimizes the JS divergence between the distribution of real and fake examples. But, as discussed in an article by Martin Arjovsky and colleagues (Wasserstein Generative Adversarial Networks, http:// proceedings.mlr.press/v70/arjovsky17a/arjovsky17a.pdf ), JS divergence has problems training a GAN model, and therefore, in order to improve the training, the researchers proposed using the EM distance as a measure of dissimilarity between the distribution of real and fake examples.The relationship between KL divergence and cross-entropy KL divergence, 𝐾𝐾𝐾𝐾(𝑃𝑃‖𝑄𝑄) , measures the relative entropy of the distribution, P, with", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 561, "start_word": 179520, "end_word": 179920, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000562": {"text": "the distribution of real and fake examples. But, as discussed in an article by Martin Arjovsky and colleagues (Wasserstein Generative Adversarial Networks, http:// proceedings.mlr.press/v70/arjovsky17a/arjovsky17a.pdf ), JS divergence has problems training a GAN model, and therefore, in order to improve the training, the researchers proposed using the EM distance as a measure of dissimilarity between the distribution of real and fake examples.The relationship between KL divergence and cross-entropy KL divergence, 𝐾𝐾𝐾𝐾(𝑃𝑃‖𝑄𝑄) , measures the relative entropy of the distribution, P, with respect to a reference distribution, Q. The formulation for KL divergence can be extended as: 𝐾𝐾𝐾𝐾(𝑃𝑃‖𝑄𝑄)=−∫𝑃𝑃(𝑥𝑥)log(𝑄𝑄(𝑥𝑥))𝑑𝑑𝑥𝑥−(−∫𝑃𝑃 (𝑥𝑥)log(𝑃𝑃(𝑥𝑥))) Moreover, for discrete distributions, KL divergence can be written as: 𝐾𝐾𝐾𝐾(𝑃𝑃‖𝑄𝑄)=−∑𝑃𝑃 (𝑥𝑥𝑖𝑖)𝑃𝑃(𝑥𝑥𝑖𝑖) 𝑄𝑄(𝑥𝑥𝑖𝑖) 𝑖𝑖 which can be similarly extended as: 𝐾𝐾𝐾𝐾(𝑃𝑃‖𝑄𝑄)=−∑𝑃𝑃 (𝑥𝑥𝑖𝑖)log(𝑄𝑄(𝑥𝑥𝑖𝑖)) 𝑖𝑖−(−∑𝑃𝑃(𝑥𝑥𝑖𝑖)log(𝑃𝑃(𝑥𝑥𝑖𝑖)) 𝑖𝑖) Based on the extended formulation (either discrete or continuous), KL divergence is viewed as the cross-entropy between P and Q (the first term in the preceding equation) subtracted by the (self-) entropy of P (second term), that is, 𝐾𝐾𝐾𝐾(𝑃𝑃‖𝑄𝑄)=𝐻𝐻(𝑃𝑃𝑃𝑄𝑄)−𝐻𝐻(𝑃𝑃) . What is the advantage of using EM distance? To answer this question, we can consider an example that was given in the previously mentioned article by Martin Arjovsky and colleagues. To put it in simple words, assume we have two distributions, P and Q, which are two parallel lines. One line is fixed at x = 0 and the other line can move across the x-axis but is initially located at 𝑥𝑥𝑥𝑥𝑥 , where 𝜃𝜃𝜃𝜃 . It can be shown that the KL, TV , and JS dissimilarity measures are 𝐾𝐾𝐾𝐾(𝑃𝑃‖𝑄𝑄)= +∞ , 𝑇𝑇𝑇𝑇(𝑃𝑃𝑃𝑃𝑃)=1 , and 𝐽𝐽𝐽𝐽(𝑃𝑃𝑃𝑃𝑃)=1 2log2 . None of these dissimilarity measures are a function of the parameter 𝜃𝜃 , and therefore, they cannot be differentiated with respect to 𝜃𝜃 toward making the distributions, P and Q , become similar to each other. On the other hand, the EM distance is 𝐸𝐸𝐸𝐸(𝑃𝑃𝑃𝑃𝑃)=|𝜃𝜃| , whose gradient with respect to 𝜃𝜃 exists and can push Q toward P . Chapter 17 627 Now, let’s focus our attention on how EM distance can be used to train a GAN model. Let’s assume P r is the distribution of the real examples and P g denotes the distributions of fake (generated) examples. Pr and P g replace P and Q in the EM distance equation. As was mentioned earlier, computing the EM distance is an optimization problem by itself; therefore, this becomes computationally intractable, especially if we want to repeat this", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 562, "start_word": 179840, "end_word": 180240, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000563": {"text": "Chapter 17 627 Now, let’s focus our attention on how EM distance can be used to train a GAN model. Let’s assume P r is the distribution of the real examples and P g denotes the distributions of fake (generated) examples. Pr and P g replace P and Q in the EM distance equation. As was mentioned earlier, computing the EM distance is an optimization problem by itself; therefore, this becomes computationally intractable, especially if we want to repeat this computation in each iteration of the GAN training loop. Fortunately, though, the computation of the EM distance can be simplified using a theorem called Kantorovich-Ru - binstein duality, as follows: 𝑊𝑊𝑊𝑊𝑊𝑟𝑟,𝑊𝑊𝑔𝑔) = 𝑠𝑠𝑠𝑠𝑠𝑠 ‖𝑓𝑓‖𝐿𝐿≤1𝐸𝐸𝑢𝑢𝑢𝑢𝑢𝑟𝑟[𝑓𝑓(𝑠𝑠)]−𝐸𝐸𝑣𝑣𝑢𝑢𝑢𝑔𝑔[𝑓𝑓(𝑣𝑣)] Here, the supremum is taken over all the 1-Lipschitz continuous functions denoted by ‖𝑓𝑓‖𝐿𝐿≤1 . Using EM distance in practice for GANs Now, the question is, how do we find such a 1-Lipschitz continuous function to compute the Wasserstein distance between the distribution of real (P r) and fake (P g) outputs for a GAN? While the theoretical concepts behind the WGAN approach may seem complicated at first, the answer to this question is simpler than it may appear. Recall that we consider deep NNs to be universal function approximators. This means that we can simply train an NN model to approximate the Wasserstein distance function. As you saw in the previous section, the simple GAN uses a discriminator in the form of a classifier. For WGAN, the discriminator can be changed to behave as a critic, which returns a scalar score instead of a probability value. We can interpret this score as how realistic the input images are (like an art critic giving scores to artworks in a gallery). To train a GAN using the Wasserstein distance, the losses for the discriminator, D, and generator, G, are defined as follows. The critic (that is, the discriminator network) returns its outputs for the batch of real image examples and the batch of synthesized examples. We use the notations D(x) and D(G(z)), respectively.Lipschitz continuity Based on 1-Lipschitz continuity, the function, f, must satisfy the following property: |𝑓𝑓(𝑥𝑥1)−𝑓𝑓(𝑥𝑥2)|≤|𝑥𝑥1−𝑥𝑥2| Furthermore, a real function, f:R→R, that satisfies the property |𝑓𝑓(𝑥𝑥1)−𝑓𝑓(𝑥𝑥2)|≤𝐾𝐾|𝑥𝑥1−𝑥𝑥2| is called K-Lipschitz continuous. Generative Adversarial Networks for Synthesizing New Data 628 Then, the following loss terms can be defined: • The real component of the discriminator’s loss: 𝐿𝐿real𝐷𝐷=−1 𝑁𝑁∑𝐷𝐷(𝒙𝒙𝑖𝑖) 𝑖𝑖 • The fake component of the discriminator’s loss: 𝐿𝐿fake𝐷𝐷=1", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 563, "start_word": 180160, "end_word": 180560, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000564": {"text": "image examples and the batch of synthesized examples. We use the notations D(x) and D(G(z)), respectively.Lipschitz continuity Based on 1-Lipschitz continuity, the function, f, must satisfy the following property: |𝑓𝑓(𝑥𝑥1)−𝑓𝑓(𝑥𝑥2)|≤|𝑥𝑥1−𝑥𝑥2| Furthermore, a real function, f:R→R, that satisfies the property |𝑓𝑓(𝑥𝑥1)−𝑓𝑓(𝑥𝑥2)|≤𝐾𝐾|𝑥𝑥1−𝑥𝑥2| is called K-Lipschitz continuous. Generative Adversarial Networks for Synthesizing New Data 628 Then, the following loss terms can be defined: • The real component of the discriminator’s loss: 𝐿𝐿real𝐷𝐷=−1 𝑁𝑁∑𝐷𝐷(𝒙𝒙𝑖𝑖) 𝑖𝑖 • The fake component of the discriminator’s loss: 𝐿𝐿fake𝐷𝐷=1 𝑁𝑁∑𝐷𝐷𝐷𝐷𝐷(𝒛𝒛𝑖𝑖)) 𝑖𝑖 • The loss for the generator: 𝐿𝐿𝐺𝐺=−1 𝑁𝑁∑𝐷𝐷𝐷𝐷𝐷(𝒛𝒛𝑖𝑖)) 𝑖𝑖 That will be all for the WGAN, except that we need to ensure that the 1-Lipschitz property of the crit- ic function is preserved during training. For this purpose, the WGAN paper proposes clamping the weights to a small region, for example, [–0.01, 0.01]. Gradient penalty In the paper by Arjovsky and colleagues, weight clipping is suggested for the 1-Lipschitz property of the discriminator (or critic). However, in another paper titled Improved Training of Wasserstein GANs by Ishaan Gulrajani and colleagues, 2017, which is freely available at https://arxiv.org/pdf/1704.00028. pdf, Ishaan Gulrajani and colleagues showed that clipping the weights can lead to exploding and vanishing gradients. Furthermore, weight clipping can also lead to capacity underuse, which means that the critic network is limited to learning only some simple functions, as opposed to more complex functions. Therefore, rather than clipping the weights, Ishaan Gulrajani and colleagues proposed gra - dient penalty ( GP) as an alternative solution. The result is the WGAN with gradient penalty ( WGAN-GP ). The procedure for the GP that is added in each iteration can be summarized by the following sequence of steps: 1. For each pair of real and fake examples (𝒙𝒙[𝑖𝑖],𝒙𝒙̃[𝑖𝑖]) in a given batch, choose a random number, 𝛼𝛼[𝑖𝑖] , sampled from a uniform distribution, that is, 𝛼𝛼[𝑖𝑖]∈𝑈𝑈(0,1) . 2. Calculate an interpolation between the real and fake examples: 𝒙𝒙̌[𝑖𝑖]=𝛼𝛼𝒙𝒙[𝑖𝑖]+(1−𝛼𝛼)𝒙𝒙̃[𝑖𝑖] , re- sulting in a batch of interpolated examples. 3. Compute the discriminator (critic) output for all the interpolated examples, 𝐷𝐷𝐷𝐷𝐷̌[𝑖𝑖]) . 4. Calculate the gradients of the critic’s output with respect to each interpolated example, that is, ∇𝒙𝒙̌[𝑖𝑖]𝐷𝐷𝐷𝒙𝒙̌[𝑖𝑖]) . 5. Compute the GP as: 𝐿𝐿𝑔𝑔𝑔𝑔𝐷𝐷=1 𝑁𝑁∑(‖∇𝒙𝒙̌[𝑖𝑖]𝐷𝐷𝐷𝒙𝒙̌[𝑖𝑖])‖2−1)2 𝑖𝑖 Chapter 17 629 The total loss for the discriminator is then as follows: 𝐿𝐿total𝐷𝐷=𝐿𝐿real𝐷𝐷+𝐿𝐿fake𝐷𝐷+𝜆𝜆𝐿𝐿𝑔𝑔𝑔𝑔𝐷𝐷 Here, 𝜆𝜆 is a tunable hyperparameter. Implementing WGAN-GP to train the DCGAN model We have already defined the helper function and", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 564, "start_word": 180480, "end_word": 180880, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000565": {"text": "in a batch of interpolated examples. 3. Compute the discriminator (critic) output for all the interpolated examples, 𝐷𝐷𝐷𝐷𝐷̌[𝑖𝑖]) . 4. Calculate the gradients of the critic’s output with respect to each interpolated example, that is, ∇𝒙𝒙̌[𝑖𝑖]𝐷𝐷𝐷𝒙𝒙̌[𝑖𝑖]) . 5. Compute the GP as: 𝐿𝐿𝑔𝑔𝑔𝑔𝐷𝐷=1 𝑁𝑁∑(‖∇𝒙𝒙̌[𝑖𝑖]𝐷𝐷𝐷𝒙𝒙̌[𝑖𝑖])‖2−1)2 𝑖𝑖 Chapter 17 629 The total loss for the discriminator is then as follows: 𝐿𝐿total𝐷𝐷=𝐿𝐿real𝐷𝐷+𝐿𝐿fake𝐷𝐷+𝜆𝜆𝐿𝐿𝑔𝑔𝑔𝑔𝐷𝐷 Here, 𝜆𝜆 is a tunable hyperparameter. Implementing WGAN-GP to train the DCGAN model We have already defined the helper function and class that create the generator and discriminator networks for DCGAN ( make_generator_network() and Discriminator() ). It is recommended to use layer normalization in WGAN instead of batch normalization. Layer normalization normalizes the inputs across features instead of across the batch dimension in batch normalization. The code to build the WGAN model is as follows: >>> def make_generator_network_wgan (input_size, n_filters): ... model = nn.Sequential( ... nn.ConvTranspose2d(input_size, n_filters* 4, 4, ... 1, 0, bias= False), ... nn.InstanceNorm2d(n_filters* 4), ... nn.LeakyReLU( 0.2), ... ... nn.ConvTranspose2d(n_filters* 4, n_filters* 2, ... 3, 2, 1, bias= False), ... nn.InstanceNorm2d(n_filters* 2), ... nn.LeakyReLU( 0.2), ... ... nn.ConvTranspose2d(n_filters* 2, n_filters, 4, ... 2, 1, bias= False), ... nn.InstanceNorm2d(n_filters), ... nn.LeakyReLU( 0.2), ... ... nn.ConvTranspose2d(n_filters, 1, 4, 2, 1, bias= False), ... nn.Tanh() ... ) ... return model >>> >>> class DiscriminatorWGAN (nn.Module): ... def __init__(self, n_filters): ... super().__init__() ... self.network = nn.Sequential( ... nn.Conv2d( 1, n_filters, 4, 2, 1, bias= False), ... nn.LeakyReLU( 0.2), ... Generative Adversarial Networks for Synthesizing New Data 630 ... nn.Conv2d(n_filters, n_filters* 2, 4, 2, 1, ... bias= False), ... nn.InstanceNorm2d(n_filters * 2), ... nn.LeakyReLU( 0.2), ... ... nn.Conv2d(n_filters* 2, n_filters* 4, 3, 2, 1, ... bias= False), ... nn.InstanceNorm2d(n_filters* 4), ... nn.LeakyReLU( 0.2), ... ... nn.Conv2d(n_filters* 4, 1, 4, 1, 0, bias= False), ... nn.Sigmoid() ... ) ... ... def forward (self, input): ... output = self.network( input) ... return output.view(- 1, 1).squeeze( 0) Now we can initiate the networks and their optimizers as follows: >>> gen_model = make_generator_network_wgan( ... z_size, n_filters ... ).to(device) >>> disc_model = DiscriminatorWGAN(n_filters).to(device) >>> g_optimizer = torch.optim.Adam(gen_model.parameters(), 0.0002) >>> d_optimizer = torch.optim.Adam(disc_model.parameters(), 0.0002) Next, we will define the function to compute the GP component as follows: >>> from torch.autograd import grad as torch_grad >>> def gradient_penalty (real_data, generated_data): ... batch_size = real_data.size( 0) ... ... # Calculate interpolation ... alpha = torch.rand(real_data.shape[ 0], 1, 1, 1, ... requires_grad= True, device=device) ... interpolated = alpha * real_data + \\", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 565, "start_word": 180800, "end_word": 181200, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000566": {"text": "as follows: >>> gen_model = make_generator_network_wgan( ... z_size, n_filters ... ).to(device) >>> disc_model = DiscriminatorWGAN(n_filters).to(device) >>> g_optimizer = torch.optim.Adam(gen_model.parameters(), 0.0002) >>> d_optimizer = torch.optim.Adam(disc_model.parameters(), 0.0002) Next, we will define the function to compute the GP component as follows: >>> from torch.autograd import grad as torch_grad >>> def gradient_penalty (real_data, generated_data): ... batch_size = real_data.size( 0) ... ... # Calculate interpolation ... alpha = torch.rand(real_data.shape[ 0], 1, 1, 1, ... requires_grad= True, device=device) ... interpolated = alpha * real_data + \\ ... ( 1 - alpha) * generated_data ... ... # Calculate probability of interpolated examples ... proba_interpolated = disc_model(interpolated) ... Chapter 17 631 ... # Calculate gradients of probabilities ... gradients = torch_grad( ... outputs=proba_interpolated, inputs=interpolated, ... grad_outputs=torch.ones(proba_interpolated.size(), ... device=device), ... create_graph= True, retain_graph= True ... )[0] ... ... gradients = gradients.view(batch_size, - 1) ... gradients_norm = gradients.norm( 2, dim=1) ... return lambda_gp * ((gradients_norm - 1)**2).mean() The WGAN version of discriminator and generator training functions are as follows: >>> def d_train_wgan (x): ... disc_model.zero_grad() ... ... batch_size = x.size( 0) ... x = x.to(device) ... ... # Calculate probabilities on real and generated data ... d_real = disc_model(x) ... input_z = create_noise(batch_size, z_size, mode_z).to(device) ... g_output = gen_model(input_z) ... d_generated = disc_model(g_output) ... d_loss = d_generated.mean() - d_real.mean() + \\ ... gradient_penalty(x.data, g_output.data) ... d_loss.backward() ... d_optimizer.step() ... return d_loss.data.item() >>> >>> def g_train_wgan (x): ... gen_model.zero_grad() ... ... batch_size = x.size( 0) ... input_z = create_noise(batch_size, z_size, mode_z).to(device) ... g_output = gen_model(input_z) ... ... d_generated = disc_model(g_output) ... g_loss = -d_generated.mean() ... Generative Adversarial Networks for Synthesizing New Data 632 ... # gradient backprop & optimize ONLY G's parameters ... g_loss.backward() ... g_optimizer.step() ... return g_loss.data.item() Then we will train the model for 100 epochs and record the generator output of a fixed noise input: >>> epoch_samples_wgan = [] >>> lambda_gp = 10.0 >>> num_epochs = 100 >>> torch.manual_seed( 1) >>> critic_iterations = 5 >>> for epoch in range (1, num_epochs+ 1): ... gen_model.train() ... d_losses, g_losses = [], [] ... for i, (x, _) in enumerate (mnist_dl): ... for _ in range (critic_iterations): ... d_loss = d_train_wgan(x) ... d_losses.append(d_loss) ... g_losses.append(g_train_wgan(x)) ... ... print(f'Epoch {epoch:03d} | D Loss >>' ... f' {torch.FloatTensor(d_losses).mean(): .4f}') ... gen_model. eval() ... epoch_samples_wgan.append( ... create_samples( ... gen_model, fixed_z ... ).detach().cpu().numpy() ... ) Finally, let’s visualize the saved examples at some epochs to see how the WGAN model is learning and how the", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 566, "start_word": 181120, "end_word": 181520, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000567": {"text": "range (1, num_epochs+ 1): ... gen_model.train() ... d_losses, g_losses = [], [] ... for i, (x, _) in enumerate (mnist_dl): ... for _ in range (critic_iterations): ... d_loss = d_train_wgan(x) ... d_losses.append(d_loss) ... g_losses.append(g_train_wgan(x)) ... ... print(f'Epoch {epoch:03d} | D Loss >>' ... f' {torch.FloatTensor(d_losses).mean(): .4f}') ... gen_model. eval() ... epoch_samples_wgan.append( ... create_samples( ... gen_model, fixed_z ... ).detach().cpu().numpy() ... ) Finally, let’s visualize the saved examples at some epochs to see how the WGAN model is learning and how the quality of synthesized examples changes over the course of learning. The following fig- ure shows the results, which demonstrate slightly better image quality than what the DCGAN model generated: Chapter 17 633 Figure 17.20: Generated images using WGAN Mode collapse Due to the adversarial nature of GAN models, it is notoriously hard to train them. One common cause of failure in training GANs is when the generator gets stuck in a small subspace and learns to generate similar samples. This is called mode collapse, and an example is shown in Figure 17.21. The synthesized examples in this figure are not cherry-picked. This shows that the generator has failed to learn the entire data distribution, and instead, has taken a lazy approach focusing on a subspace: Generative Adversarial Networks for Synthesizing New Data 634 Figure 17.21: An example of mode collapse Besides the vanishing and exploding gradient problems that we saw previously, there are some further aspects that can also make training GAN models difficult (indeed, it is an art). Here are a few suggested tricks from GAN artists. One approach is called mini-batch discrimination, which is based on the fact that batches consisting of only real or fake examples are fed separately to the discriminator. In mini-batch discrimination, we let the discriminator compare examples across these batches to see whether a batch is real or fake. The diversity of a batch consisting of only real examples is most likely higher than the diversity of a fake batch if a model suffers from mode collapse. Another technique that is commonly used for stabilizing GAN training is feature matching. In feature matching, we make a slight modification to the objective function of the generator by adding an extra term that minimizes the difference between the original and synthesized images based on interme - diate representations (feature maps) of the discriminator. We encourage you to read more about this technique in the original", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 567, "start_word": 181440, "end_word": 181840, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000568": {"text": "than the diversity of a fake batch if a model suffers from mode collapse. Another technique that is commonly used for stabilizing GAN training is feature matching. In feature matching, we make a slight modification to the objective function of the generator by adding an extra term that minimizes the difference between the original and synthesized images based on interme - diate representations (feature maps) of the discriminator. We encourage you to read more about this technique in the original article by Ting-Chun Wang and colleagues, titled High Resolution Image Syn- thesis and Semantic Manipulation with Conditional GANs, which is freely available at https://arxiv. org/pdf/1711.11585.pdf . During the training, a GAN model can also get stuck in several modes and just hop between them. To avoid this behavior, you can store some old examples and feed them to the discriminator to prevent the generator from revisiting previous modes. This technique is referred to as experience replay. Fur - thermore, you can train multiple GANs with different random seeds so that the combination of all of them covers a larger part of the data distribution than any single one of them. Chapter 17 635 Other GAN applications In this chapter, we mainly focused on generating examples using GANs and looked at a few tricks and techniques to improve the quality of synthesized outputs. The applications of GANs are expanding rapidly, including in computer vision, machine learning, and even other domains of science and en- gineering. A nice list of different GAN models and application areas can be found at https://github. com/hindupuravinash/the-gan-zoo . It is worth mentioning that we covered GANs in an unsupervised fashion; that is, no class label in- formation was used in the models that were covered in this chapter. However, the GAN approach can be generalized to semi-supervised and supervised tasks, as well. For example, the conditional GAN (cGAN ) proposed by Mehdi Mirza and Simon Osindero in the paper Conditional Generative Adversarial Nets, 2014 ( https://arxiv.org/pdf/1411.1784.pdf ) uses the class label information and learns to synthesize new images conditioned on the provided label, that is, 𝒙𝒙̃=𝐺𝐺(𝒛𝒛|𝑦𝑦) —applied to MNIST. This allows us to generate different digits in the range 0-9 selectively. Furthermore, conditional GANs allow us to do image-to-image translation, which is to learn how to convert a given image from a specific domain to another. In this context, one interesting work is the Pix2Pix algorithm, published", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 568, "start_word": 181760, "end_word": 182160, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000569": {"text": "the paper Conditional Generative Adversarial Nets, 2014 ( https://arxiv.org/pdf/1411.1784.pdf ) uses the class label information and learns to synthesize new images conditioned on the provided label, that is, 𝒙𝒙̃=𝐺𝐺(𝒛𝒛|𝑦𝑦) —applied to MNIST. This allows us to generate different digits in the range 0-9 selectively. Furthermore, conditional GANs allow us to do image-to-image translation, which is to learn how to convert a given image from a specific domain to another. In this context, one interesting work is the Pix2Pix algorithm, published in the paper Image-to-Image Translation with Conditional Adversarial Networks by Philip Isola and colleagues, 2018 (https://arxiv.org/pdf/1611.07004.pdf ). It is worth mentioning that in the Pix2Pix algorithm, the discriminator provides the real/fake predictions for multiple patches across the image as opposed to a single prediction for an entire image. CycleGAN is another interesting GAN model built on top of the cGAN, also for image-to-image trans- lation. However, note that in CycleGAN, the training examples from the two domains are unpaired, meaning that there is no one-to-one correspondence between inputs and outputs. For example, using a CycleGAN, we could change the season of a picture taken in summer to winter. In the paper Unpaired Image-to-Image Translation Using Cycle-Consistent Adversarial Networks by Jun-Yan Zhu and colleagues, 2020 (https://arxiv.org/pdf/1703.10593.pdf ), an impressive example shows horses converted into zebras. Summary In this chapter, you first learned about generative models in deep learning and their overall objective: synthesizing new data. We then covered how GAN models use a generator network and a discrimina - tor network, which compete with each other in an adversarial training setting to improve each other. Next, we implemented a simple GAN model using only fully connected layers for both the generator and the discriminator. We also covered how GAN models can be improved. First, you saw a DCGAN, which uses deep convo - lutional networks for both the generator and the discriminator. Along the way, you also learned about two new concepts: transposed convolution (for upsampling the spatial dimensionality of feature maps) and BatchNorm (for improving convergence during training). We then looked at a WGAN, which uses the EM distance to measure the distance between the distribu- tions of real and fake samples. Finally, we talked about the WGAN with GP to maintain the 1-Lipschitz property instead of clipping the weights. Generative Adversarial Networks for Synthesizing New Data 636 In the next chapter, we will look at graph neural networks. Previously,", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 569, "start_word": 182080, "end_word": 182480, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000570": {"text": "concepts: transposed convolution (for upsampling the spatial dimensionality of feature maps) and BatchNorm (for improving convergence during training). We then looked at a WGAN, which uses the EM distance to measure the distance between the distribu- tions of real and fake samples. Finally, we talked about the WGAN with GP to maintain the 1-Lipschitz property instead of clipping the weights. Generative Adversarial Networks for Synthesizing New Data 636 In the next chapter, we will look at graph neural networks. Previously, we have been focused on tab - ular and image datasets. In contrast, graph neural networks are designed for graph-structured data, which allows us to work with datasets that are ubiquitous in social sciences, engineering, and biology. Popular examples of graph-structure data include social network graphs and molecules consisting of atoms connected by covalent bonds. Join our book’s Discord space Join the book’s Discord workspace for a monthly Ask me Anything session with the authors: https://packt.link/MLwPyTorch 18 Graph Neural Networks for Capturing Dependencies in Graph Structured Data In this chapter, we will introduce a class of deep learning models that operates on graph data, namely, graph neural networks (GNNs ). GNNs have been an area of rapid development in recent years. Ac- cording to the State of AI report from 2021 ( https://www.stateof.ai/2021-report-launch.html ), GNNs have evolved “from niche to one of the hottest fields of AI research.” GNNs have been applied in a variety of areas, including the following: • Text classification ( https://arxiv.org/abs/1710.10903 ) • Recommender systems ( https://arxiv.org/abs/1704.06803 ) • Traffic forecasting ( https://arxiv.org/abs/1707.01926 ) • Drug discovery ( https://arxiv.org/abs/1806.02473 ) While we can’t cover every new idea in this rapidly developing space, we’ll provide a basis to under - stand how GNNs function and how they can be implemented. In addition, we’ll introduce the PyTorch Geometric library, which provides resources for managing graph data for deep learning as well as implementations of many different kinds of graph layers that you can use in your deep learning models. The topics that will be covered in this chapter are as follows: • An introduction to graph data and how it can be represented for use in deep neural networks • An explanation of graph convolutions, a major building block of common GNNs • A tutorial showing how to implement GNNs for molecular property prediction using PyTorch Geometric • An overview of methods at the cutting edge of the", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 570, "start_word": 182400, "end_word": 182800, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000571": {"text": "graph layers that you can use in your deep learning models. The topics that will be covered in this chapter are as follows: • An introduction to graph data and how it can be represented for use in deep neural networks • An explanation of graph convolutions, a major building block of common GNNs • A tutorial showing how to implement GNNs for molecular property prediction using PyTorch Geometric • An overview of methods at the cutting edge of the GNN field Graph Neural Networks for Capturing Dependencies in Graph Structured Data 638 Introduction to graph data Broadly speaking, graphs represent a certain way we describe and capture relationships in data. Graphs are a particular kind of data structure that is nonlinear and abstract. And since graphs are abstract objects, a concrete representation needs to be defined so the graphs can be operated on. Furthermore, graphs can be defined to have certain properties that may require different representations. Figure 18.1 summarizes the common types of graphs, which we will discuss in more detail in the following subsections: Figure 18.1: Common types of graphs Undirected graphs An undirected graph consists of nodes (in graph theory also often called vertices) that are connected via edges where the order of the nodes and their connection does not matter. Figure 18.2 sketches two typical examples of undirected graphs, a friend graph, and a graph of a chemical molecule consisting of atoms connected through chemical bonds (we will be discussing such molecular graphs in much more detail in later sections): Chapter 18 639 Figure 18.2: Two examples of undirected graphs Other common examples of data that can be represented as undirected graphs include images, pro - tein-protein interaction networks, and point clouds. Mathematically, an undirected graph G is a pair (V, E), where V is a set of the graph’s nodes, and E is the set of edges making up the paired nodes. The graph can then be encoded as a |V|×|V| adjacency matrix A. Each element x ij in matrix A is either a 1 or a 0, with 1 denoting an edge between nodes i and j (vice versa, 0 denotes the absence of an edge). Since the graph is undirected, an additional property of A is that x ij = x ji. Directed graphs Directed graphs, in contrast to undirected graphs discussed in the previous section, connect nodes via directed edges. Mathematically", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 571, "start_word": 182720, "end_word": 183120, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000572": {"text": "can then be encoded as a |V|×|V| adjacency matrix A. Each element x ij in matrix A is either a 1 or a 0, with 1 denoting an edge between nodes i and j (vice versa, 0 denotes the absence of an edge). Since the graph is undirected, an additional property of A is that x ij = x ji. Directed graphs Directed graphs, in contrast to undirected graphs discussed in the previous section, connect nodes via directed edges. Mathematically they are defined in the same way as an undirected graph, except that E, the set of edges, is a set of ordered pairs. Therefore, element x ij of A does need not equal x ji. Graph Neural Networks for Capturing Dependencies in Graph Structured Data 640 An example of a directed graph is a citation network, where nodes are publications and edges from a node are directed toward the nodes of papers that a given paper cited. Figure 18.3: An example of a directed graph Labeled graphs Many graphs we are interested in working with have additional information associated with each of their nodes and edges. For example, if you consider the caffeine molecule shown earlier, molecules can be represented as graphs where each node is a chemical element (for example, O, C, N, or H atoms) and each edge is the type of bond (for example, single or double bond) between its two nodes. These node and edge features need to be encoded in some capacity. Given graph G, defined by the node set and edge set tuple (V, E), we define a |V|×f V node feature matrix X, where f V is the length of the label vector of each node. For edge labels, we define an |E|×f E edge feature matrix X E, where f E is the length of the label vector of each edge. Molecules are an excellent example of data that can be represented as a labeled graph, and we will be working with molecular data throughout the chapter. As such, we will take this opportunity to cover their representation in detail in the next section. Representing molecules as graphs As a chemical overview, molecules can be thought of as groups of atoms held together by chemical bonds. There are different atoms corresponding to different chemical elements, for example, common elements include carbon (C), oxygen (O), nitrogen (N), and hydrogen (H). Also, there", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 572, "start_word": 183040, "end_word": 183440, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000573": {"text": "represented as a labeled graph, and we will be working with molecular data throughout the chapter. As such, we will take this opportunity to cover their representation in detail in the next section. Representing molecules as graphs As a chemical overview, molecules can be thought of as groups of atoms held together by chemical bonds. There are different atoms corresponding to different chemical elements, for example, common elements include carbon (C), oxygen (O), nitrogen (N), and hydrogen (H). Also, there are different kinds of bonds that form the connection between atoms, for example, single or double bonds. We can represent a molecule as an undirected graph with a node label matrix, where each row is a one-hot encoding of the associated node’s atom type. Additionally, there is an edge label matrix where each row is a one-hot encoding of the associated edge’s bond type. To simplify this representation, hydrogen atoms are sometimes made implicit since their location can be inferred with basic chemical rules. Considering the caffeine molecule we saw earlier, an example of a graph representation with implicit hydrogen atoms is shown in Figure 18.4: Chapter 18 641 Figure 18.4: Graph representation of a caffeine molecule Understanding graph convolutions The previous section showed how graph data can be represented. The next logical step is to discuss what tools we have that can effectively utilize those representations. In the following subsections, we will introduce graph convolutions, which are the key component for building GNNs. In this section, we’ll see why we want to use convolutions on graphs and discuss what attributes we want those convolutions to have. We’ll then introduce graph convolutions through an implementation example. The motivation behind using graph convolutions To help explain graph convolutions, let’s briefly recap how convolutions are utilized in convolutional neural networks (CNNs), which we discussed in Chapter 14, Classifying Images with Deep Convolutional Neural Networks. In the context of images, we can think of a convolution as the process of sliding a convolutional filter over an image, where, at each step, a weighted sum is computed between the filter and the receptive field (the part of the image it is currently on top of). Graph Neural Networks for Capturing Dependencies in Graph Structured Data 642 As discussed in the CNN chapter, the filter can be viewed as a detector for a specific feature. This ap - proach to feature detection is well-suited for", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 573, "start_word": 183360, "end_word": 183760, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000574": {"text": "of a convolution as the process of sliding a convolutional filter over an image, where, at each step, a weighted sum is computed between the filter and the receptive field (the part of the image it is currently on top of). Graph Neural Networks for Capturing Dependencies in Graph Structured Data 642 As discussed in the CNN chapter, the filter can be viewed as a detector for a specific feature. This ap - proach to feature detection is well-suited for images for several reasons, for instance, the following priors we can place on image data: 1. Shift-invariance: We can still recognize a feature in an image regardless of where it is located (for example, after translation). A cat can be recognized as a cat whether it is in the top left, bottom right, or another part of an image. 2. Locality: Nearby pixels are closely related. 3. Hierarchy: Larger parts of an image can often be broken down into combinations of associated smaller parts. A cat has a head and legs; the head has eyes and a nose; the eyes have pupils and irises. Interested readers can find a more formal description of these priors, and priors assumed by GNNs, in the 2019 article Understanding the Representation Power of Graph Neural Networks in Learning Graph Topology, by N. Dehmamy, A.-L. Barabasi, and R. Yu ( https://arxiv.org/abs/1907.05008 ). Another reason convolutions are well-suited for processing images is that the number of trainable parameters does not depend on the dimensionality of the input. You could train a series of 3×3 con- volutional filters on, for example, a 256×256 or a 9×9 image. (However, if the same image is presented in different resolutions, the receptive fields and, therefore, the extracted features will differ. And for higher-resolution images, we may want to choose larger kernels or add additional layers to extract useful features effectively.) Like images, graphs also have natural priors that justify a convolutional approach. Both kinds of data, images and graphs, share the locality prior. However, how we define locality differs. In images, the prior is on locality in 2D space, while with graphs, it is structural locality. Intuitively, this means that a node that is one edge away is more likely to be related than a node five edges away. For example, in a citation graph, a directly cited publication, which would be one edge away, is more likely to have", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 574, "start_word": 183680, "end_word": 184080, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000575": {"text": "convolutional approach. Both kinds of data, images and graphs, share the locality prior. However, how we define locality differs. In images, the prior is on locality in 2D space, while with graphs, it is structural locality. Intuitively, this means that a node that is one edge away is more likely to be related than a node five edges away. For example, in a citation graph, a directly cited publication, which would be one edge away, is more likely to have similar subject matter than a publication with multiple degrees of separation. A strict prior for graph data is permutation invariance, which means that the ordering of the nodes does not affect the output. This is illustrated in Figure 18.5, where changing the ordering of a graph’s nodes does not change the graph’s structure: Chapter 18 643 Figure 18.5: Different adjacency matrices representing the same graph Since the same graph can be represented by multiple adjacency matrices, as illustrated in Figure 18.5, consequently, any graph convolution needs to be permutation invariant. A convolutional approach is also desirable for graphs because it can function with a fixed parame - ter set for graphs of different sizes. This property is arguably even more important for graphs than images. For instance, there are many image datasets with a fixed resolution where a fully connected approach (for example, using a multilayer perceptron) could be possible, as we have seen in Chapter 11, Implementing a Multilayer Artificial Neural Network from Scratch. In contrast, most graph datasets contain graphs of varying sizes. While image convolutional operators are standardized, there are many different kinds of graph con- volutions, and the development of new graph convolutions is a very active area of research. Our focus is on providing general ideas so that readers can rationalize about the GNNs they wish to utilize. To this end, the following subsection will show how to implement a basic graph convolution in PyTorch. Then, in the next section, we will construct a simple GNN in PyTorch from the ground up. Graph Neural Networks for Capturing Dependencies in Graph Structured Data 644 Implementing a basic graph convolution In this subsection, we will introduce a basic graph convolution function and see what happens when it is applied to a graph. Consider the following graph and its representation: Figure 18.6: A representation of a graph Figure 18.6 depicts an undirected graph with node labels specified by", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 575, "start_word": 184000, "end_word": 184400, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000576": {"text": "Then, in the next section, we will construct a simple GNN in PyTorch from the ground up. Graph Neural Networks for Capturing Dependencies in Graph Structured Data 644 Implementing a basic graph convolution In this subsection, we will introduce a basic graph convolution function and see what happens when it is applied to a graph. Consider the following graph and its representation: Figure 18.6: A representation of a graph Figure 18.6 depicts an undirected graph with node labels specified by an n×n adjacency matrix A and n×f in node feature matrix X, where the only feature is a one-hot representation of each node’s color— green (G), blue (B), or orange (O). One of the most versatile libraries for graph manipulation and visualization is NetworkX, which we will be using to illustrate how to construct graphs from a label matrix X and a node matrix A. Using NetworkX, we can construct the graph shown in Figure 18.6 as follows: >>> import numpy as np >>> import networkx as nxInstalling NetworkX NetworkX is a handy Python library for manipulating and visualizing graphs. It can be installed via pip : pip install networkx We used version 2.6.2 to create the graph visualizations in this chapter. For more infor - mation, please visit the official website at https://networkx.org . Chapter 18 645 >>> G = nx.Graph() ... # Hex codes for colors if we draw graph >>> blue, orange, green = \"#1f77b4\" , \"#ff7f0e\" , \"#2ca02c\" >>> G.add_nodes_from([ ... (1, {\"color\": blue}), ... (2, {\"color\": orange}), ... (3, {\"color\": blue}), ... (4, {\"color\": green}) ... ]) >>> G.add_edges_from([( 1,2), (2,3), (1,3), (3,4)]) >>> A = np.asarray(nx.adjacency_matrix(G).todense()) >>> print(A) [[0 1 1 0] [1 0 1 0] [1 1 0 1] [0 0 1 0]] >>> def build_graph_color_label_representation (G, mapping_dict): ... one_hot_idxs = np.array([mapping_dict[v] for v in ... nx.get_node_attributes(G, 'color').values()]) >>> one_hot_encoding = np.zeros( ... (one_hot_idxs.size, len(mapping_dict))) >>> one_hot_encoding[ ... np.arange(one_hot_idxs.size), one_hot_idxs] = 1 >>> return one_hot_encoding >>> X = build_graph_color_label_representation( ... G, {green: 0, blue: 1, orange: 2}) >>> print(X) [[0., 1., 0.], [0., 0., 1.], [0., 1., 0.], [1., 0., 0.]] To draw the graph constructed in the preceding code, we can then use the following code: >>> color_map = nx.get_node_attributes(G, 'color').values() >>> nx.draw(G,with_labels= True, node_color=color_map) In the preceding code example, we first initiated a new Graph object from NetworkX. We then added nodes 1 to 4 together with color specifications for visualization.", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 576, "start_word": 184320, "end_word": 184720, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000577": {"text": "return one_hot_encoding >>> X = build_graph_color_label_representation( ... G, {green: 0, blue: 1, orange: 2}) >>> print(X) [[0., 1., 0.], [0., 0., 1.], [0., 1., 0.], [1., 0., 0.]] To draw the graph constructed in the preceding code, we can then use the following code: >>> color_map = nx.get_node_attributes(G, 'color').values() >>> nx.draw(G,with_labels= True, node_color=color_map) In the preceding code example, we first initiated a new Graph object from NetworkX. We then added nodes 1 to 4 together with color specifications for visualization. After adding the nodes, we specified their connections (edges). Using the adjacency_matrix constructor from NetworkX, we create the adjacency matrix A, and our custom build_graph_color_label_representation function creates the node label matrix X from the information we added to the Graph object earlier. Graph Neural Networks for Capturing Dependencies in Graph Structured Data 646 With graph convolutions, we can interpret each row of X as being an embedding of the information that is stored at the node corresponding to that row. Graph convolutions update the embeddings at each node based on the embeddings of their neighbors and themselves. For our example implementation, the graph convolution will take the following form: 𝒙𝒙𝑖𝑖′=𝒙𝒙𝑖𝑖𝑾𝑾1+∑𝒙𝒙 𝑗𝑗𝑾𝑾2+𝑏𝑏 𝑗𝑗𝑗𝑗𝑗(𝑖𝑖) Here, 𝒙𝒙𝑖𝑖′ is the updated embedding for node i; W1 and W 2 are f in×fout matrices of learnable filter weights; and b is a learnable bias vector of length f out. The two weight matrices W 1 and W 2 can be considered filter banks, where each column is an individual filter. Note that this filter design is most effective when the locality prior on graph data holds. If a value at a node is highly correlated with the value at another node many edges away, a single convolution will not capture that relationship. Stacking convolutions will capture more distant relationships, as illustrated in Figure 18.7 (we set the bias to zero for simplicity): Figure 18.7: Capturing relationships from a graph Chapter 18 647 The design of the graph convolution illustrated in Figure 18.7 fits our priors on graph data, but it may not be clear how to implement the sum over neighbors in matrix form. This is where we utilize the adjacency matrix A. The matrix form of this convolution is XW 1 + AXW 2. Here, the adjacency matrix, consisting of 1s and 0s, acts as a mask to select nodes and compute the desired sums. In NumPy, ini- tializing this layer and computing a", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 577, "start_word": 184640, "end_word": 185040, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000578": {"text": "the graph convolution illustrated in Figure 18.7 fits our priors on graph data, but it may not be clear how to implement the sum over neighbors in matrix form. This is where we utilize the adjacency matrix A. The matrix form of this convolution is XW 1 + AXW 2. Here, the adjacency matrix, consisting of 1s and 0s, acts as a mask to select nodes and compute the desired sums. In NumPy, ini- tializing this layer and computing a forward pass on the previous graph could be written as follows: >>> f_in, f_out = X.shape[ 1], 6 >>> W_1 = np.random.rand(f_in, f_out) >>> W_2 = np.random.rand(f_in, f_out) >>> h = np.dot(X, W_1)+ np.dot(np.dot(A,X), W_2) Computing a forward pass of a graph convolution is that easy. Ultimately, we want a graph convolutional layer to update the representation of the node information encoded in X by utilizing the structural (connectivity) information provided by A. There are many potential ways to do this, and this plays out in the numerous kinds of graph convolutions that have been developed. To talk about different graph convolutions, generally, it would be nice for them to have a unifying framework. Thankfully, such a framework was presented in Neural Message Passing for Quantum Chem - istry by Justin Gilmer and colleagues, 2017, https://arxiv.org/abs/1704.01212 . In this message-passing framework, each node in the graph has an associated hidden state ℎ𝑖𝑖(𝑡𝑡) , where i is the node’s index at time step t . The initial value ℎ𝑖𝑖(0) is defined as X i, which is the row of X associated with node i. Each graph convolution can be split into a message-passing phase and a node update phase. Let N(i) be the neighbors of node i. For undirected graphs, N(i) is the set of nodes that share an edge with node i. For directed graphs, N(i) is the set of nodes that have an edge whose endpoint is node i. The message-passing phase can be formulated as follows: 𝑚𝑚𝑖𝑖=∑𝑀𝑀 𝑡𝑡(ℎ𝑖𝑖(𝑡𝑡),ℎ𝑗𝑗(𝑡𝑡),𝑒𝑒𝑖𝑖𝑗𝑗) 𝑗𝑗𝑗𝑗𝑗(𝑖𝑖) Here, Mt is a message function. In our example layer, we define this message function as 𝑀𝑀𝑡𝑡=ℎ𝑗𝑗(𝑡𝑡)𝑊𝑊2 . The node update phase with the update function Ut is ℎ𝑖𝑖(𝑡𝑡𝑡𝑡)=𝑈𝑈𝑡𝑡(ℎ𝑖𝑖(𝑡𝑡),𝑚𝑚𝑖𝑖) . In our example layer, this update is ℎ𝑖𝑖(𝑡𝑡𝑡𝑡)=ℎ𝑖𝑖(𝑡𝑡)𝑊𝑊𝑡+𝑚𝑚𝑖𝑖+𝑏𝑏 . Graph Neural Networks for Capturing Dependencies in Graph Structured Data 648 Figure 18.8 visualizes the message-passing idea and summarizes the convolution we have implemented: Figure 18.8: The convolutions implemented on", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 578, "start_word": 184960, "end_word": 185360, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000579": {"text": "The message-passing phase can be formulated as follows: 𝑚𝑚𝑖𝑖=∑𝑀𝑀 𝑡𝑡(ℎ𝑖𝑖(𝑡𝑡),ℎ𝑗𝑗(𝑡𝑡),𝑒𝑒𝑖𝑖𝑗𝑗) 𝑗𝑗𝑗𝑗𝑗(𝑖𝑖) Here, Mt is a message function. In our example layer, we define this message function as 𝑀𝑀𝑡𝑡=ℎ𝑗𝑗(𝑡𝑡)𝑊𝑊2 . The node update phase with the update function Ut is ℎ𝑖𝑖(𝑡𝑡𝑡𝑡)=𝑈𝑈𝑡𝑡(ℎ𝑖𝑖(𝑡𝑡),𝑚𝑚𝑖𝑖) . In our example layer, this update is ℎ𝑖𝑖(𝑡𝑡𝑡𝑡)=ℎ𝑖𝑖(𝑡𝑡)𝑊𝑊𝑡+𝑚𝑚𝑖𝑖+𝑏𝑏 . Graph Neural Networks for Capturing Dependencies in Graph Structured Data 648 Figure 18.8 visualizes the message-passing idea and summarizes the convolution we have implemented: Figure 18.8: The convolutions implemented on the graph and the message form In the next section, we’ll incorporate this graph convolution layer into a GNN model implemented in PyTorch. Implementing a GNN in PyTorch from scratch The previous section focused on understanding and implementing a graph convolution operation. In this section, we’ll walk you through a basic implementation of a graph neural network to illustrate how to apply these methods to graphs if you start from scratch. If this approach appears complicated, don’t worry; GNNs are relatively complex models to implement. Thus, we’ll introduce PyTorch Geometric in a later section, which provides tools to ease the implementation of, and the data management for, graph neural networks. Chapter 18 649 Defining the NodeNetwork model We will start this section by showing a PyTorch from-scratch implementation of a GNN. We will take a top-down approach, starting with the main neural network model, which we call NodeNetwork , and then we will fill in the individual details: import networkx as nx import torch from torch.nn.parameter import Parameter import numpy as np import math import torch.nn.functional as F class NodeNetwork (torch.nn.Module): def __init__ (self, input_features): super().__init__() self.conv_1 = BasicGraphConvolutionLayer ( input_features, 32) self.conv_2 = BasicGraphConvolutionLayer( 32, 32) self.fc_1 = torch.nn.Linear( 32, 16) self.out_layer = torch.nn.Linear( 16, 2) def forward (self, X, A, batch_mat): x = F.relu(self.conv_1(X, A)) x = F.relu(self.conv_2(x, A)) output = global_sum_pool(x, batch_mat) output = self.fc_1(output) output = self.out_layer(output) return F.softmax(output, dim= 1) The NodeNetwork model we just defined can be summarized as follows: 1. Perform two graph convolutions ( self.conv_1 and self.conv_2 ) 2. Pool all the node embeddings via global_sum_pool , which we will define later 3. Run the pooled embeddings through two fully connected layers ( self.fc_1 and self.out_ layer ) 4. Output a class-membership probability via softmax Graph Neural Networks for Capturing Dependencies in Graph Structured Data 650 The structure of the network along with a visualization of what each layer is doing is", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 579, "start_word": 185280, "end_word": 185680, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000580": {"text": "defined can be summarized as follows: 1. Perform two graph convolutions ( self.conv_1 and self.conv_2 ) 2. Pool all the node embeddings via global_sum_pool , which we will define later 3. Run the pooled embeddings through two fully connected layers ( self.fc_1 and self.out_ layer ) 4. Output a class-membership probability via softmax Graph Neural Networks for Capturing Dependencies in Graph Structured Data 650 The structure of the network along with a visualization of what each layer is doing is summarized in Figure 18.9: Figure 18.9: A visualization of each neural network layer The individual aspects, such as the graph convolution layers and global pooling, will be discussed in the next subsections. Coding the NodeNetwork’s graph convolution layer Now, let’s define the graph convolution operation ( BasicGraphConvolutionLayer ) that was used inside the previous NodeNetwork class: class BasicGraphConvolutionLayer (torch.nn.Module): def __init__ (self, in_channels, out_channels): super().__init__() self.in_channels = in_channels Chapter 18 651 self.out_channels = out_channels self.W2 = Parameter(torch.rand( (in_channels, out_channels), dtype=torch.float32)) self.W1 = Parameter(torch.rand( (in_channels, out_channels), dtype=torch.float32)) self.bias = Parameter(torch.zeros( out_channels, dtype=torch.float32)) def forward (self, X, A): potential_msgs = torch.mm(X, self.W2) propagated_msgs = torch.mm(A, potential_msgs) root_update = torch.mm(X, self.W1) output = propagated_msgs + root_update + self.bias return output As with fully connected layers and image convolutional layers, we add a bias term so that the intercept of the linear combination of the layer outputs (prior to the application of a nonlinearity like ReLU) can vary. The forward() method implements the matrix form of the forward pass, which we discussed in the previous subsection, with the addition of a bias term. To try out the BasicGraphConvolutionLayer , let’s apply it to the graph and adjacency matrix that we defined in the section Implementing a basic graph convolution previously: >>> print('X.shape:' , X.shape) X.shape: ( 4, 3) >>> print('A.shape:' , A.shape) A.shape: (4, 4) >>> basiclayer = BasicGraphConvolutionLayer( 3, 8) >>> out = basiclayer( ... X=torch.tensor(X, dtype=torch.float32), ... A=torch.tensor(A, dtype=torch.float32) ... ) >>> print('Output shape:' , out.shape) Output shape: torch.Size([4, 8]) Based on the code example above, we can see that our BasicGraphConvolutionLayer converted the four-node graph consisting of three features into a representation with eight features. Graph Neural Networks for Capturing Dependencies in Graph Structured Data 652 Adding a global pooling layer to deal with varying graph sizes Next, we define the global_sum_pool() function that was used in the NodeNetwork class, where global_sum_pool() implements a global pooling layer. Global pooling layers aggregate", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 580, "start_word": 185600, "end_word": 186000, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000581": {"text": "print('Output shape:' , out.shape) Output shape: torch.Size([4, 8]) Based on the code example above, we can see that our BasicGraphConvolutionLayer converted the four-node graph consisting of three features into a representation with eight features. Graph Neural Networks for Capturing Dependencies in Graph Structured Data 652 Adding a global pooling layer to deal with varying graph sizes Next, we define the global_sum_pool() function that was used in the NodeNetwork class, where global_sum_pool() implements a global pooling layer. Global pooling layers aggregate all of a graph’s node embeddings into a fixed-sized output. As shown in Figure 18.9, global_sum_pool() sums all the node embeddings of a graph. We note that this global pooling is relatively similar to the global average pooling used in CNNs, which is used before the data is run through fully connected layers, as we have seen in Chapter 14, Classifying Images with Deep Convolutional Neural Networks. Summing all the node embeddings results in a loss of information, so reshaping the data would be preferable, but since graphs can have different sizes, this is not feasible. Global pooling can be done with any permutation invariant function, for example, sum, max, and mean . Here is the implementation of global_sum_pool() : def global_sum_pool (X, batch_mat): if batch_mat is None or batch_mat.dim() == 1: return torch.sum(X, dim= 0).unsqueeze( 0) else: return torch.mm(batch_mat, X) If data is not batched or the batch size is one, this function just sums over the current node embed- dings. Otherwise, the embeddings are multiplied with batch_mat , which has a structure based on how graph data is batched. When all data in a dataset has the same dimensionality, batching the data is as straightforward as adding a dimension by stacking the data. (Side note: the function called in the default batching func- tion in PyTorch is literally called stack .) Since graph sizes vary, this approach is not feasible with graph data unless padding is used. However, padding can be inefficient in cases where graph sizes can vary substantially. Usually, the better way to deal with varying graph sizes is to treat each batch as a single graph where each graph in the batch is a subgraph that is disconnected from the rest. This is illustrated in Figure 18.10: Chapter 18 653 Figure 18.10: How to deal with varying graph sizes To describe Figure 18.10 more formally, suppose we are given graphs G 1, ..., Gk of", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 581, "start_word": 185920, "end_word": 186320, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000582": {"text": "padding can be inefficient in cases where graph sizes can vary substantially. Usually, the better way to deal with varying graph sizes is to treat each batch as a single graph where each graph in the batch is a subgraph that is disconnected from the rest. This is illustrated in Figure 18.10: Chapter 18 653 Figure 18.10: How to deal with varying graph sizes To describe Figure 18.10 more formally, suppose we are given graphs G 1, ..., Gk of sizes n 1, ..., nk with f features per node. In addition, we are given the corresponding adjacency matrices A 1, ..., Ak and feature matrices X 1, ..., Xk. Let N be the total number of nodes, 𝑁𝑁𝑁∑𝑛𝑛𝑖𝑖𝑘𝑘 𝑖𝑖𝑖𝑖 , s1 = 0, and s i = s i–1 + n i–1 for 1<𝑖𝑖𝑖𝑖𝑖 . As shown in the figure, we define a graph G B with N×N adjacency matrix A B and N×f feature matrix XB. Using Python index notation, A B[si:si + n i, si + n i] = A i, and all other elements of A B outside these index sets are 0. Additionally, X B[si:si + n i, :] = X i. By design, disconnected nodes will never be in the same receptive field of a graph convolution. As a result, when backpropagating gradients of G B through graph convolutions, the gradients attached to each graph in the batch will be independent. This means that if we treat a set of graph convolutions as a function f , if h B = f(XB, AB) and h i = f(Xi, Ai), then h B[si:si + n, :] = h i. If the sum global pooling extracts the sums of each hi from hB as separate vectors, passing that stack of vectors through fully connected layers would keep the gradients of each item in the batch separate throughout the entire backpropagation. Graph Neural Networks for Capturing Dependencies in Graph Structured Data 654 This is the purpose of batch_mat in global_sum_pool() —to serve as a graph selection mask that keeps the graphs in the batch separate. We can generate this mask for graphs of sizes n 1, ..., nk with the following code: def get_batch_tensor (graph_sizes): starts = [ sum(graph_sizes[:idx]) for idx in range (len(graph_sizes))] stops = [starts[idx] + graph_sizes[idx] for idx in range (len(graph_sizes))] tot_len = sum(graph_sizes) batch_size = len(graph_sizes) batch_mat = torch.zeros([batch_size, tot_len]). float() for idx,", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 582, "start_word": 186240, "end_word": 186640, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000583": {"text": "in Graph Structured Data 654 This is the purpose of batch_mat in global_sum_pool() —to serve as a graph selection mask that keeps the graphs in the batch separate. We can generate this mask for graphs of sizes n 1, ..., nk with the following code: def get_batch_tensor (graph_sizes): starts = [ sum(graph_sizes[:idx]) for idx in range (len(graph_sizes))] stops = [starts[idx] + graph_sizes[idx] for idx in range (len(graph_sizes))] tot_len = sum(graph_sizes) batch_size = len(graph_sizes) batch_mat = torch.zeros([batch_size, tot_len]). float() for idx, starts_and_stops in enumerate (zip(starts, stops)): start = starts_and_stops[ 0] stop = starts_and_stops[ 1] batch_mat[idx,start:stop] = 1 return batch_mat Thus, given a batch size, b, batch_mat is a b×N matrix where batch_mat[i–1, si:si + n i] = 1 for 1≤𝑖𝑖≤𝑖𝑖 and where elements outside these index sets are 0. The following is a collate function for constructing a representation of some G B and a corresponding batch matrix: # batch is a list of dictionaries each containing # the representation and label of a graph def collate_graphs (batch): adj_mats = [graph[ 'A'] for graph in batch] sizes = [A.size( 0) for A in adj_mats] tot_size = sum(sizes) # create batch matrix batch_mat = get_batch_tensor(sizes) # combine feature matrices feat_mats = torch.cat([graph[ 'X'] for graph in batch], dim= 0) # combine labels labels = torch.cat([graph[ 'y'] for graph in batch], dim= 0) # combine adjacency matrices batch_adj = torch.zeros([tot_size, tot_size], dtype=torch.float32) accum = 0 for adj in adj_mats: g_size = adj.shape[ 0] batch_adj[accum:accum+g_size,accum:accum+g_size] = adj accum = accum + g_size repr_and_label = { 'A': batch_adj, Chapter 18 655 'X': feat_mats, 'y': labels, 'batch': batch_mat} return repr_and_label Preparing the DataLoader In this section, we will see how the code from the previous subsections all comes together. First, we will generate some graphs and put them into a PyTorch Dataset . Then, we will use our collate function in a DataLoader for our GNN. But before we define the graphs, let’s implement a function that builds a dictionary representation that we will use later: def get_graph_dict (G, mapping_dict): # Function builds dictionary representation of graph G A = torch.from_numpy( np.asarray(nx.adjacency_matrix(G).todense())). float() # build_graph_color_label_representation() # was introduced with the first example graph X = torch.from_numpy( build_graph_color_label_representation( G, mapping_dict)). float() # kludge since there is not specific task for this example y = torch.tensor([[ 1,0]]).float() return {'A': A, 'X': X, 'y': y, 'batch': None} This function takes a NetworkX graph and returns a dictionary containing its", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 583, "start_word": 186560, "end_word": 186960, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000584": {"text": "that builds a dictionary representation that we will use later: def get_graph_dict (G, mapping_dict): # Function builds dictionary representation of graph G A = torch.from_numpy( np.asarray(nx.adjacency_matrix(G).todense())). float() # build_graph_color_label_representation() # was introduced with the first example graph X = torch.from_numpy( build_graph_color_label_representation( G, mapping_dict)). float() # kludge since there is not specific task for this example y = torch.tensor([[ 1,0]]).float() return {'A': A, 'X': X, 'y': y, 'batch': None} This function takes a NetworkX graph and returns a dictionary containing its adjacency matrix A, its node feature matrix X, and a binary label y. Since we won’t actually be training this model on a real-world task, we just set the labels arbitrarily. Then, nx.adjacency_matrix() takes a NetworkX graph and returns a sparse representation that we convert to a dense np.array form using todense() . We’ll now construct graphs and use the get_graph_dict function to convert NetworkX graphs to a format our network can handle: >>> # building 4 graphs to treat as a dataset >>> blue, orange, green = \"#1f77b4\" , \"#ff7f0e\" ,\"#2ca02c\" >>> mapping_dict= {green: 0, blue: 1, orange: 2} >>> G1 = nx.Graph() >>> G1.add_nodes_from([ ... (1,{\"color\" : blue}), ... (2,{\"color\" : orange}), ... (3,{\"color\" : blue}), ... (4,{\"color\" : green}) ... ]) Graph Neural Networks for Capturing Dependencies in Graph Structured Data 656 >>> G1.add_edges_from([( 1, 2), ( 2, 3), ( 1, 3), ( 3, 4)]) >>> G2 = nx.Graph() >>> G2.add_nodes_from([ ... (1,{\"color\" : green}), ... (2,{\"color\" : green}), ... (3,{\"color\" : orange}), ... (4,{\"color\" : orange}), ... (5,{\"color\" : blue}) ... ]) >>> G2.add_edges_from([( 2, 3),(3, 4),(3, 1),(5, 1)]) >>> G3 = nx.Graph() >>> G3.add_nodes_from([ ... (1,{\"color\" : orange}), ... (2,{\"color\" : orange}), ... (3,{\"color\" : green}), ... (4,{\"color\" : green}), ... (5,{\"color\" : blue}), ... (6,{\"color\" :orange}) ... ]) >>> G3.add_edges_from([( 2,3), (3,4), (3,1), (5,1), (2,5), (6,1)]) >>> G4 = nx.Graph() >>> G4.add_nodes_from([ ... (1,{\"color\" : blue}), ... (2,{\"color\" : blue}), ... (3,{\"color\" : green}) ... ]) >>> G4.add_edges_from([( 1, 2), ( 2, 3)]) >>> graph_list = [get_graph_dict(graph, mapping_dict) for graph in ... [G1, G2, G3, G4]] Chapter 18 657 The graphs this code generates are visualized in Figure 18.11: Figure 18.11: Four generated graphs This code block constructs four NetworkX graphs and stores them in a list. Here, the constructor of nx.Graph() initializes an empty graph, and add_nodes_from() adds nodes to the empty graph from a list of tuples. The first item in each", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 584, "start_word": 186880, "end_word": 187280, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000585": {"text": "... ]) >>> G4.add_edges_from([( 1, 2), ( 2, 3)]) >>> graph_list = [get_graph_dict(graph, mapping_dict) for graph in ... [G1, G2, G3, G4]] Chapter 18 657 The graphs this code generates are visualized in Figure 18.11: Figure 18.11: Four generated graphs This code block constructs four NetworkX graphs and stores them in a list. Here, the constructor of nx.Graph() initializes an empty graph, and add_nodes_from() adds nodes to the empty graph from a list of tuples. The first item in each tuple is the node’s name, and the second item is a dictionary of that node’s attributes. Graph Neural Networks for Capturing Dependencies in Graph Structured Data 658 The add_edges_from() method of a graph takes a list of tuples where each tuple defines an edge be - tween its elements (nodes). Now, we can construct a PyTorch Dataset for these graphs: from torch.utils.data import Dataset class ExampleDataset (Dataset ): # Simple PyTorch dataset that will use our list of graphs def __init__ (self, graph_list): self.graphs = graph_list def __len__ (self): return len(self.graphs) def __getitem__ (self,idx): mol_rep = self.graphs[idx] return mol_rep While using a custom Dataset may seem like unnecessary effort, it allows us to exhibit how collate_ graphs() can be used in a DataLoader : >>> from torch.utils.data import DataLoader >>> dset = ExampleDataset(graph_list) >>> # Note how we use our custom collate function >>> loader = DataLoader( ... dset, batch_size= 2, shuffle= False, ... collate_fn=collate_graphs) Using the NodeNetwork to make predictions After we have defined all the necessary functions and set up the DataLoader , we now initialize a new NodeNetwork and apply it to our graph data: >>> node_features = 3 >>> net = NodeNetwork(node_features) >>> batch_results = [] >>> for b in loader: ... batch_results.append( ... net(b[ 'X'], b['A'], b['batch']).detach()) Note that for brevity, we didn’t include a training loop; however, the GNN model could be trained in a regular fashion by computing the loss between predicted and true class labels, backpropagating the loss via .backward() , and updating the model weights via a gradient descent-based optimizer. We leave this as an optional exercise for the reader. In the next section, we will show how to do that with a GNN implementation from PyTorch Geometric, which implements more sophisticated GNN code. Chapter 18 659 To continue with our previous code, let’s now provide a single input graph to the model directly with- out the DataLoader : >>> G1_rep", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 585, "start_word": 187200, "end_word": 187600, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000586": {"text": "true class labels, backpropagating the loss via .backward() , and updating the model weights via a gradient descent-based optimizer. We leave this as an optional exercise for the reader. In the next section, we will show how to do that with a GNN implementation from PyTorch Geometric, which implements more sophisticated GNN code. Chapter 18 659 To continue with our previous code, let’s now provide a single input graph to the model directly with- out the DataLoader : >>> G1_rep = dset[ 1] >>> G1_single = net( ... G1_rep[ 'X'], G1_rep[ 'A'], G1_rep[ 'batch']).detach() We can now compare the results from applying the GNN to a single graph ( G1_single ) and to the first graph from the DataLoader (also the first graph, G1, which we guaranteed, since we set shuffle=False ) to double-check that the batch loader works correctly. As we can see by using torch.isclose() (to account for rounding errors), the results are equivalent, as we would have hoped: >>> G1_batch = batch_results[ 0][1] >>> torch.all(torch.isclose(G1_single, G1_batch)) tensor(True) Congrats! You now understand how to construct, set up, and run a basic GNN. However, from this introduction, you probably realize that managing and manipulating graph data can be somewhat laborious. Also, we didn’t even build a graph convolution that uses edge labels, which would compli- cate matters further. Thankfully, there is PyTorch Geometric, a package that makes this much easier by providing implementations of many GNN layers. We’ll introduce this library with an end-to-end example of implementing and training a more complex GNN on molecule data in the next subsection. Implementing a GNN using the PyTorch Geometric library In this section, we will implement a GNN using the PyTorch Geometric library, which simplifies the process of training GNNs. We apply the GNN to QM9, a dataset consisting of small molecules, to pre - dict isotropic polarizability, which is a measure of a molecule’s tendency to have its charge distorted by an electric field. Installing PyTorch Geometric PyTorch Geometric can be installed via conda or pip. We recommend you visit the official documentation website at https://pytorch-geometric.readthedocs.io/en/latest/ notes/installation.html to select the installation command recommended for your operating system. For this chapter, we used pip to install version 2.0.2 along with its torch-scatter and torch-sparse dependencies: pip install torch-scatter==2.0.9 pip install torch-sparse==0.6.12 pip install torch-geometric==2.0.2 Graph Neural Networks for Capturing Dependencies in Graph Structured Data 660 Let’s start by loading a dataset", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 586, "start_word": 187520, "end_word": 187920, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000587": {"text": "by an electric field. Installing PyTorch Geometric PyTorch Geometric can be installed via conda or pip. We recommend you visit the official documentation website at https://pytorch-geometric.readthedocs.io/en/latest/ notes/installation.html to select the installation command recommended for your operating system. For this chapter, we used pip to install version 2.0.2 along with its torch-scatter and torch-sparse dependencies: pip install torch-scatter==2.0.9 pip install torch-sparse==0.6.12 pip install torch-geometric==2.0.2 Graph Neural Networks for Capturing Dependencies in Graph Structured Data 660 Let’s start by loading a dataset of small molecules and look at how PyTorch Geometric stores the data: >>> # For all examples in this section we use the following imports. >>> # Note that we are using torch_geometric's DataLoader. >>> import torch >>> from torch_geometric.datasets import QM9 >>> from torch_geometric.loader import DataLoader >>> from torch_geometric.nn import NNConv, global_add_pool >>> import torch.nn.functional as F >>> import torch.nn as nn >>> import numpy as np >>> # let's load the QM9 small molecule dataset >>> dset = QM9( '.') >>> len(dset) 130831 >>> # Here's how torch geometric wraps data >>> data = dset[ 0] >>> data Data(edge_attr=[8, 4], edge_index=[2, 8], idx=[1], name=\"gdb_1\", pos=[5, 3], x=[5, 11], y=[1, 19], z=[5]) >>> # can access attributes directly >>> data.z tensor([6, 1, 1, 1, 1]) >>> # the atomic number of each atom can add attributes >>> data.new_attribute = torch.tensor([ 1, 2, 3]) >>> data Data(edge_attr=[8, 4], edge_index=[2, 8], idx=[1], name=\"gdb_1\", new_ attribute=[3], pos=[5, 3], x=[5, 11], y=[1, 19], z=[5]) >>> # can move all attributes between devices >>> device = torch.device( ... \"cuda:0\" if torch.cuda.is_available() else \"cpu\" ... ) >>> data.to(device) >>> data.new_attribute.is_cuda True The Data object is a convenient, flexible wrapper for graph data. Note that many PyTorch Geometric objects require certain keywords in data objects to process them correctly. Specifically, x should contain node features, edge_attr should contain edge features, edge_index should include an edge list, and y should contain labels. The QM9 data contains some additional attributes of note: pos, the position of each of the molecules’ atoms in a 3D grid, and z, the atomic number of each atom in the molecule. The labels in the QM9 are a bunch of physical properties of the molecules, such as dipole moment, free energy, enthalpy, or isotropic polarization. We are going to implement a GNN and train it on QM9 to predict isotropic polarization. Chapter 18 661 The bond types of molecules are important; that is,", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 587, "start_word": 187840, "end_word": 188240, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000588": {"text": "additional attributes of note: pos, the position of each of the molecules’ atoms in a 3D grid, and z, the atomic number of each atom in the molecule. The labels in the QM9 are a bunch of physical properties of the molecules, such as dipole moment, free energy, enthalpy, or isotropic polarization. We are going to implement a GNN and train it on QM9 to predict isotropic polarization. Chapter 18 661 The bond types of molecules are important; that is, which atoms are connected via a certain bond type, for example, single or double bonds, matters. Hence, we’ll want to use a graph convolution that can utilize edge features. For this, we’ll use the torch_geometric.nn.NNConv layer. (If you are interested in the implementation details, its source code be found at https://pytorch-geometric.readthedocs. io/en/latest/_modules/torch_geometric/nn/conv/nn_conv.html#NNConv .) This convolution in the NNConv layer takes the following form: 𝑿𝑿𝑖𝑖(𝑡𝑡)= 𝑾𝑾𝑿𝑿𝑖𝑖(𝑡𝑡𝑡𝑡)+∑𝑿𝑿𝑗𝑗(𝑡𝑡𝑡𝑡) 𝑗𝑗𝑗𝑗𝑗(𝑖𝑖).ℎΘ(𝑒𝑒𝑖𝑖𝑖𝑗𝑗) Here, h is a neural network parameterized by a set of weights Θ , and W is a weight matrix for the node labels. This graph convolution is very similar to the one we implemented previously from scratch: 𝑿𝑿𝑖𝑖(𝑡𝑡)=𝑾𝑾1𝑿𝑿𝑖𝑖(𝑡𝑡𝑡1)+∑𝑿𝑿𝑗𝑗(𝑡𝑡𝑡1)𝑾𝑾2 𝑗𝑗𝑗𝑗𝑗(𝑖𝑖) The only real difference is that the W 2 equivalent, the neural network h, is parametrized based on the edge labels, which allows the weights to vary for different edge labels. Via the following code, we implement a GNN utilizing two such graph convolutional layers ( NNConv ): class ExampleNet (torch.nn.Module): def __init__ (self, num_node_features, num_edge_features): super().__init__() conv1_net = nn.Sequential( nn.Linear(num_edge_features, 32), nn.ReLU(), nn.Linear( 32, num_node_features* 32)) conv2_net = nn.Sequential( nn.Linear(num_edge_features, 32), nn.ReLU(), nn.Linear( 32, 32*16)) self.conv1 = NNConv(num_node_features, 32, conv1_net) self.conv2 = NNConv( 32,16, conv2_net)The QM9 dataset The QM9 dataset contains 133,885 small organic molecules labeled with several geomet- ric, energetic, electronic, and thermodynamic properties. QM9 is a common benchmark dataset for developing methods for predicting chemical structure-property relationships and hybrid quantum mechanic/machine learning methods. More information about the dataset can be found at http://quantum-machine.org/datasets/ . Graph Neural Networks for Capturing Dependencies in Graph Structured Data 662 self.fc_1 = nn.Linear( 16, 32) self.out = nn.Linear( 32, 1) def forward (self, data): batch, x, edge_index, edge_attr = ( data.batch, data.x, data.edge_index, data.edge_attr) # First graph conv layer x = F.relu(self.conv1(x, edge_index, edge_attr)) # Second graph conv layer x = F.relu(self.conv2(x, edge_index, edge_attr)) x = global_add_pool(x,batch) x = F.relu(self.fc_1(x)) output = self.out(x) return output We’ll train this GNN to predict a molecule’s isotropic polarizability, a", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 588, "start_word": 188160, "end_word": 188560, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000589": {"text": "at http://quantum-machine.org/datasets/ . Graph Neural Networks for Capturing Dependencies in Graph Structured Data 662 self.fc_1 = nn.Linear( 16, 32) self.out = nn.Linear( 32, 1) def forward (self, data): batch, x, edge_index, edge_attr = ( data.batch, data.x, data.edge_index, data.edge_attr) # First graph conv layer x = F.relu(self.conv1(x, edge_index, edge_attr)) # Second graph conv layer x = F.relu(self.conv2(x, edge_index, edge_attr)) x = global_add_pool(x,batch) x = F.relu(self.fc_1(x)) output = self.out(x) return output We’ll train this GNN to predict a molecule’s isotropic polarizability, a measure of the relative tendency of a molecule’s charge distribution to be distorted by an external electric field. We’ll split the QM9 dataset into training, validation, and test sets, and use PyTorch Geometric DataLoader . Note that these do not require a special collate function, but require a Data object with appropriately named attributes. Next, let’s split the dataset: >>> from torch.utils.data import random_split >>> train_set, valid_set, test_set = random_split( ... dset,[ 110000, 10831, 10000]) >>> trainloader = DataLoader(train_set, batch_size= 32, shuffle= True) >>> validloader = DataLoader(valid_set, batch_size= 32, shuffle= True) >>> testloader = DataLoader(test_set, batch_size= 32, shuffle= True) The following code will initialize and train a network on a GPU (if available): >>> # initialize a network >>> qm9_node_feats, qm9_edge_feats = 11, 4 >>> net = ExampleNet(qm9_node_feats, qm9_edge_feats) >>> # initialize an optimizer with some reasonable parameters >>> optimizer = torch.optim.Adam( ... net.parameters(), lr= 0.01) >>> epochs = 4 >>> target_idx = 1 # index position of the polarizability label >>> device = torch.device( \"cuda:0\" if ... torch.cuda.is_available() else \"cpu\") >>> net.to(device) Chapter 18 663 The training loop, shown in the following code, follows the familiar pattern we have encountered in previous PyTorch chapters, so we can skip the explanation details. However, one detail that is worth highlighting is that here we are computing the mean squared error (MSE) loss instead of the cross-en- tropy, since polarizability is a continuous target and not a class label: >>> for total_epochs in range (epochs): ... epoch_loss = 0 ... total_graphs = 0 ... net.train() ... for batch in trainloader: ... batch.to(device) ... optimizer.zero_grad() ... output = net(batch) ... loss = F.mse_loss( ... output,batch.y[:, target_idx].unsqueeze( 1)) ... loss.backward() ... epoch_loss += loss.item() ... total_graphs += batch.num_graphs ... optimizer.step() ... train_avg_loss = epoch_loss / total_graphs ... val_loss = 0 ... total_graphs = 0 ... net. eval() ... for batch in validloader: ... batch.to(device) ... output = net(batch) ... loss = F.mse_loss( ... output,batch.y[:,", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 589, "start_word": 188480, "end_word": 188880, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000590": {"text": "in range (epochs): ... epoch_loss = 0 ... total_graphs = 0 ... net.train() ... for batch in trainloader: ... batch.to(device) ... optimizer.zero_grad() ... output = net(batch) ... loss = F.mse_loss( ... output,batch.y[:, target_idx].unsqueeze( 1)) ... loss.backward() ... epoch_loss += loss.item() ... total_graphs += batch.num_graphs ... optimizer.step() ... train_avg_loss = epoch_loss / total_graphs ... val_loss = 0 ... total_graphs = 0 ... net. eval() ... for batch in validloader: ... batch.to(device) ... output = net(batch) ... loss = F.mse_loss( ... output,batch.y[:, target_idx].unsqueeze( 1)) ... val_loss += loss.item() ... total_graphs += batch.num_graphs ... val_avg_loss = val_loss / total_graphs ... print(f\"Epochs: {total_epochs} | \" ... f\"epoch avg. loss: {train_avg_loss: .2f} | \" ... f\"validation avg. loss: {val_avg_loss: .2f}\") Epochs: 0 | epoch avg. loss: 0.30 | validation avg. loss: 0.10 Epochs: 1 | epoch avg. loss: 0.12 | validation avg. loss: 0.07 Epochs: 2 | epoch avg. loss: 0.10 | validation avg. loss: 0.05 Epochs: 3 | epoch avg. loss: 0.09 | validation avg. loss: 0.07 Graph Neural Networks for Capturing Dependencies in Graph Structured Data 664 Over the first four training epochs, both training and validation loss are decreasing. The dataset is large and may take a little while to train on a CPU, so we stop training after four epochs. However, if we train the model further, the loss will continue to improve. You can train the model for additional epochs to see how that changes the performance. The following code predicts the values on the test data and collects the true labels: >>> net.eval() >>> predictions = [] >>> real = [] >>> for batch in testloader: ... output = net(batch.to(device)) ... predictions.append(output.detach().cpu().numpy()) ... real.append( ... batch.y[:,target_idx] .detach().cpu().numpy()) >>> real = np.concatenate(real) >>> predictions = np.concatenate(predictions) Now we can make a scatterplot with a subset of the test data. Since the test dataset is relatively large (10,000 molecules), the results can be a bit cluttered, and for simplicity, we only plot the first 500 predictions and targets: >>> import matplotlib.pyplot as plt >>> plt.scatter(real[: 500], predictions[: 500]) >>> plt.xlabel( 'Isotropic polarizability' ) >>> plt.ylabel( 'Predicted isotropic polarizability' ) The resulting figure is shown here: Figure 18.12: Predicted isotropic polarizability plotted against the actual isotropic polarizability Chapter 18 665 Based on the plot, given that the points lie relatively near the diagonal, our simple GNN appears to have done a decent job with predicting isotropic polarization values, even without hyperparameter tuning.", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 590, "start_word": 188800, "end_word": 189200, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000591": {"text": "plot the first 500 predictions and targets: >>> import matplotlib.pyplot as plt >>> plt.scatter(real[: 500], predictions[: 500]) >>> plt.xlabel( 'Isotropic polarizability' ) >>> plt.ylabel( 'Predicted isotropic polarizability' ) The resulting figure is shown here: Figure 18.12: Predicted isotropic polarizability plotted against the actual isotropic polarizability Chapter 18 665 Based on the plot, given that the points lie relatively near the diagonal, our simple GNN appears to have done a decent job with predicting isotropic polarization values, even without hyperparameter tuning. Other GNN layers and recent developments This section will introduce a selection of additional layers that you can utilize in your GNNs, in addition to providing a high-level overview of some recent developments in the field. While we will provide background on the intuition behind these layers and their implementations, these concepts can become a little complicated mathematically speaking, but don’t get discouraged. These are optional topics, and it is not necessary to grasp the minutiae of all these implementations. Understanding the general ideas behind the layers will be sufficient to experiment with the PyTorch Geometric imple - mentations that we reference. The following subsections will introduce spectral graph convolution layers, graph pooling layers, and normalization layers for graphs. Lastly, the final subsection will provide a bird’s eye view of some more advanced kinds of graph neural networks. Spectral graph convolutions The graph convolutions we have utilized up to this point have all been spatial in nature. This means that they aggregate information based on the topological space associated with the graph, which is just a fancy way of saying that spatial convolutions operate on local neighborhoods of nodes. As a consequence of this, if a GNN that utilizes spatial convolutions needs to capture complex global pat- terns in graph data, then the network will need to stack multiple spatial convolutions. In situations where these global patterns are important, but network depth needs to be limited, spectral graph convolutions are an alternative kind of convolution to consider. Spectral graph convolutions operate differently than spatial graph convolutions. Spectral graph con- volutions operate by utilizing the graph’s spectrum—its set of eigenvalues—by computing the eigende - composition of a normalized version of the graph’s adjacency matrix called the graph Laplacian. That last sentence may seem like a doozy, so let’s break it down and go over it step by step. For an undirected graph, the Laplacian matrix of a graph is defined as", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 591, "start_word": 189120, "end_word": 189520, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000592": {"text": "an alternative kind of convolution to consider. Spectral graph convolutions operate differently than spatial graph convolutions. Spectral graph con- volutions operate by utilizing the graph’s spectrum—its set of eigenvalues—by computing the eigende - composition of a normalized version of the graph’s adjacency matrix called the graph Laplacian. That last sentence may seem like a doozy, so let’s break it down and go over it step by step. For an undirected graph, the Laplacian matrix of a graph is defined as L = D – A, where A is the ad- jacency matrix of the graph and D is the degree matrix. A degree matrix is a diagonal matrix where the element on the diagonal in the row with index i is the number of edges in and out of the node associated with the ith row of the adjacency matrix. TorchDrug – A PyTorch-based library for drug discovery PyTorch Geometric is a comprehensive general-purpose library for working with graphs, including molecules, as you have seen in this section. If you are interested in more in- depth molecule work and drug discovery, we also recommend considering the recently developed TorchDrug library, which offers many convenient utilities for working with molecules. You can find out more about TorchDrug here: https://torchdrug.ai/ . Graph Neural Networks for Capturing Dependencies in Graph Structured Data 666 L is a real-valued symmetric matrix, and it has been proven that real-valued symmetric matrices can be decomposed as 𝑳𝑳 𝑳 𝑳𝑳𝑳𝑳𝑳𝑳𝑻𝑻 , where Q is an orthogonal matrix whose columns are the eigenvectors of L, and 𝚲𝚲 is a diagonal matrix whose elements are the eigenvalues of L. You can think of Q as pro - viding an underlying representation of the graph’s structure. Unlike spatial convolutions, which use local neighborhoods of the graph that are defined by A, spectral convolutions utilize the alternative representation of the structure from Q to update the node embeddings. The following example of a spectral convolution utilizes the eigendecomposition of the symmetric normalized graph Laplacian, which is defined for a graph as follows: 𝑳𝑳𝑠𝑠𝑠𝑠𝑠𝑠=𝑰𝑰𝑰𝑰𝑰−1 2𝑨𝑨𝑰𝑰−1 2 Here, I is the identity matrix. This is used because the normalization of the graph Laplacian can help stabilize the gradient-based training procedure similar to feature standardization. Given that 𝑸𝑸𝑸𝑸𝑸𝑸𝑻𝑻 is the eigendecomposition of L sym, the graph convolution is defined as follows: 𝑿𝑿′=𝑸𝑸(𝑸𝑸𝑇𝑇𝑿𝑿𝑿𝑸𝑸𝑇𝑇𝑾𝑾) Here, W is a trainable weight matrix. The inside of the parentheses essentially", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 592, "start_word": 189440, "end_word": 189840, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000593": {"text": "a spectral convolution utilizes the eigendecomposition of the symmetric normalized graph Laplacian, which is defined for a graph as follows: 𝑳𝑳𝑠𝑠𝑠𝑠𝑠𝑠=𝑰𝑰𝑰𝑰𝑰−1 2𝑨𝑨𝑰𝑰−1 2 Here, I is the identity matrix. This is used because the normalization of the graph Laplacian can help stabilize the gradient-based training procedure similar to feature standardization. Given that 𝑸𝑸𝑸𝑸𝑸𝑸𝑻𝑻 is the eigendecomposition of L sym, the graph convolution is defined as follows: 𝑿𝑿′=𝑸𝑸(𝑸𝑸𝑇𝑇𝑿𝑿𝑿𝑸𝑸𝑇𝑇𝑾𝑾) Here, W is a trainable weight matrix. The inside of the parentheses essentially multiplies X and W by a matrix that encodes structural relationships in the graph. The ⊙ operator here denotes element-wise multiplication of the inner terms, while the outside Q maps the result back into the original basis. This convolution has a few undesirable properties, since computing a graph’s eigendecomposition has a computational complexity of O(n3). This means that it is slow, and as it is structured, W is dependent on the size of the graph. Consequently, the spectral convolution can only be applied to graphs of the same size. Furthermore, the receptive field of this convolution is the whole graph, and this cannot be tuned in the current formulation. However, various techniques and convolutions have been developed to address these issues. For example, Bruna and colleagues ( https://arxiv.org/abs/1312.6203 ) introduced a smoothing method that addresses the size dependence of W by approximating it with a set of functions, each multiplied by their own scalar parameter, 𝛼𝛼 . That is, given the set of functions f 1, ..., fn, 𝑾𝑾𝑾∑𝛼𝛼𝑖𝑖𝑓𝑓𝑖𝑖 . The set of functions is such that the dimensionality can be varied. However, since 𝛼𝛼 remains scalar, the convolutions parameter space can be independent of the graph size. Other spectral convolutions worth mentioning include the Chebyshev graph convolution ( https:// arxiv.org/abs/1606.09375 ), which can approximate the original spectral convolution at a lower time complexity and can have receptive fields with varying sizes. Kipf and Welling ( https://arxiv. org/abs/1609.02907 ) introduce a convolution with properties similar to the Chebyshev convolutions, but with a reduced parameter burden. Implementations of both of these are available in PyTorch Geometric as torch_geometric.nn.ChebConv and torch_geometric.nn.GCNConv and are reasonable places to start if you want to play around with spectral convolutions. Chapter 18 667 Pooling We will briefly discuss some examples of pooling layers that have been developed for graphs. While the downsampling provided by pooling layers has been beneficial in CNN architectures, the benefit of downsampling", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 593, "start_word": 189760, "end_word": 190160, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000594": {"text": "a convolution with properties similar to the Chebyshev convolutions, but with a reduced parameter burden. Implementations of both of these are available in PyTorch Geometric as torch_geometric.nn.ChebConv and torch_geometric.nn.GCNConv and are reasonable places to start if you want to play around with spectral convolutions. Chapter 18 667 Pooling We will briefly discuss some examples of pooling layers that have been developed for graphs. While the downsampling provided by pooling layers has been beneficial in CNN architectures, the benefit of downsampling in GNNs has not been realized as clearly. Pooling layers for image data (ab)use spatial locality, which graphs do not have. If a clustering of the nodes in a graph is provided, we can define how a graph pooling layer should pool nodes. However, it is unclear how to define optimal clustering, and different clustering approaches may be favored for different contexts. Even after clustering is determined, if nodes are downsampled, it is unclear how the remaining nodes should be connected. While these are still open research questions, we’ll look at a few graph pooling layers and point out their approaches to the aforementioned issues. As with CNNs, there are mean and max pooling layers that can be applied to GNNs. As shown in Figure 18.13, given a clustering of nodes, each cluster becomes a node in a new graph: Figure 18.13: Applying max pooling to a graph Graph Neural Networks for Capturing Dependencies in Graph Structured Data 668 Each cluster’s embedding is equal to the mean or max of the embeddings of the nodes in the cluster. To address connectivity, the cluster is assigned the union of all edge indices in the cluster. For example, if nodes i, j, k are assigned to cluster c 1, any node, or cluster containing a node, that shared an edge with i, j, or k will share an edge with c 1. A more complex pooling layer, DiffPool ( https://arxiv.org/abs/1806.08804 ), tries to address both clustering and downsampling simultaneously. This layer learns a soft cluster assignment matrix 𝑺𝑺𝑺𝑺𝑛𝑛𝑛𝑛𝑛 , which distributes n node embeddings into c clusters. (For a refresher on soft versus hard clustering, refer to the section Hard versus soft clustering in Chapter 10, Working with Unlabeled Data – Clustering Analysis.) With this, X is updated as X′ = STX and A as A′ = STATS. Notably, A′ no longer con- tains discrete values and can instead be viewed as", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 594, "start_word": 190080, "end_word": 190480, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000595": {"text": "to address both clustering and downsampling simultaneously. This layer learns a soft cluster assignment matrix 𝑺𝑺𝑺𝑺𝑛𝑛𝑛𝑛𝑛 , which distributes n node embeddings into c clusters. (For a refresher on soft versus hard clustering, refer to the section Hard versus soft clustering in Chapter 10, Working with Unlabeled Data – Clustering Analysis.) With this, X is updated as X′ = STX and A as A′ = STATS. Notably, A′ no longer con- tains discrete values and can instead be viewed as a matrix of edge weightings. Over time, DiffPool converges to an almost hard clustering assignment with interpretable structure. Another pooling method, top-k pooling, drops nodes from the graph instead of aggregating them, which circumvents clustering and connectivity issues. While this seemingly comes with a loss of the information in the dropped nodes, in the context of a network, as long as a convolution occurs before pooling, the network can learn to avoid this. The dropped nodes are selected using a projection score against a learnable vector p. The actual formulation to compute (X′, A′), as stated in Towards Sparse Hierarchical Graph Classifiers ( https://arxiv.org/abs/1811.01287 ), is: 𝑦𝑦𝑦𝑋𝑋𝑝𝑝 ‖𝑝𝑝‖, 𝑖𝑖 𝑦top-k (𝒚𝒚,𝒚𝒚), 𝑿𝑿′𝑦(𝑿𝑿 𝑿 𝑿𝑿𝑿𝑿 (𝒚𝒚))𝑖𝑖, 𝑨𝑨′𝑦𝐴𝐴 𝑖𝑖𝑖𝑖 Here, top-k selects the indexes of y , with the top k values and the index vector i being used to drop rows of X and A . Top- k pooling is implemented in PyTorch Geometric as torch_geometric.nn.TopKPooling . Additionally, max and mean pooling are implemented as torch_geometric.nn.max_pool_x and torch_ geometric.nn.avg_pool_x , respectively. Normalization Normalization techniques are utilized in many kinds of neural networks to help stabilize and/or speed up the training process. Many approaches, such as batch normalization (discussed in Chapter 17, Generative Adversarial Networks for Synthesizing New Data), can be readily applied in GNNs with appropriate bookkeeping. In this section, we will briefly describe some of the normalization layers that have been designed specifically for graph data. As a quick review of normalization, we mean that given a set of feature values x 1, ..., xn, we update the values with 𝑥𝑥𝑖𝑖−𝜇𝜇 𝜎𝜎 , where 𝜇𝜇 is the mean and 𝜎𝜎 the standard deviation of the set of values. Typically, most neural network normalization methods take the general form 𝛾𝛾𝑥𝑥𝑖𝑖−𝜇𝜇 𝜎𝜎+𝛽𝛽 , where 𝛾𝛾 and 𝛽𝛽 are learnable parameters, and the difference between methods has to do with the set of features the normalization is applied over. GraphNorm: A Principled Approach", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 595, "start_word": 190400, "end_word": 190800, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000596": {"text": "of normalization, we mean that given a set of feature values x 1, ..., xn, we update the values with 𝑥𝑥𝑖𝑖−𝜇𝜇 𝜎𝜎 , where 𝜇𝜇 is the mean and 𝜎𝜎 the standard deviation of the set of values. Typically, most neural network normalization methods take the general form 𝛾𝛾𝑥𝑥𝑖𝑖−𝜇𝜇 𝜎𝜎+𝛽𝛽 , where 𝛾𝛾 and 𝛽𝛽 are learnable parameters, and the difference between methods has to do with the set of features the normalization is applied over. GraphNorm: A Principled Approach to Accelerating Graph Neural Network Training by Tianle Cai and col- leagues, 2020 (https://arxiv.org/abs/2009.03294 ), showed that the mean statistic after aggregation in a graph convolution can contain meaningful information, so discarding it completely may not be desirable. To address this, they introduced GraphNorm. Chapter 18 669 Borrowing notation from the original manuscript, let h be the matrix of node embeddings. Let hi, j be the jth feature value of node v i, where i = 1, ..., n, and j = 1, ..., d. GraphNorm takes the following form: 𝛾𝛾𝑗𝑗ℎ𝑖𝑖𝑖𝑗𝑗−𝛼𝛼𝑗𝑗⋅𝜇𝜇𝑗𝑗 𝜎𝜎𝜎𝑗𝑗+𝛽𝛽𝑗𝑗 Here, 𝜇𝜇𝑗𝑗=∑ℎ𝑖𝑖𝑖𝑖𝑖𝑛𝑛 𝑖𝑖𝑖𝑖 𝑛𝑛 and 𝜎𝜎𝜎𝑗𝑗=∑(ℎ𝑖𝑖𝑖𝑖𝑖−𝛼𝛼𝑖𝑖𝜇𝜇𝑖𝑖)2 𝑛𝑛 𝑖𝑖𝑖𝑖 𝑛𝑛 . The key addition is the learnable parameter, 𝛼𝛼 , which can control how much of the mean statistic, 𝜇𝜇𝑗𝑗 , to discard. Another graph normalization technique is MsgNorm, which was described by Guohao Li and col - leagues in the manuscript DeeperGCN: All You Need to Train Deeper GCNs in 2020 ( https://arxiv.org/ abs/2006.07739 ). MsgNorm corresponds to the message-passing formulation of graph convolutions mentioned earlier in the chapter. Using message-passing network nomenclature (defined at the end of the subsection Implementing a basic graph convolution), after a graph convolution has summed over Mt and produced m i but before updating the nodes embedding with U t, MsgNorm normalizes m i with the following formula: 𝑚𝑚𝑖𝑖′=𝑠𝑠𝑠‖ℎ𝑖𝑖‖2𝑠𝑚𝑚𝑖𝑖 ‖𝑚𝑚𝑖𝑖‖2 Here, s is a learnable scaling factor and the intuition behind this approach is to normalize the features of the aggregated messages in a graph convolution. While there is no theory to support this normal- ization approach, it has worked well in practice. The normalization layers we’ve discussed are all implemented and available via PyTorch Geomet - ric as BatchNorm , GroupNorm , and MessageNorm . For more information, please visit the PyTorch Geometric documentation at https://pytorch-geometric.readthedocs.io/en/latest/modules/ nn.html#normalization-layers . Unlike graph pooling layers, which may require an additional clustering setup, graph normalization layers can be more readily plugged into an existing GNN", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 596, "start_word": 190720, "end_word": 191120, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000597": {"text": "in a graph convolution. While there is no theory to support this normal- ization approach, it has worked well in practice. The normalization layers we’ve discussed are all implemented and available via PyTorch Geomet - ric as BatchNorm , GroupNorm , and MessageNorm . For more information, please visit the PyTorch Geometric documentation at https://pytorch-geometric.readthedocs.io/en/latest/modules/ nn.html#normalization-layers . Unlike graph pooling layers, which may require an additional clustering setup, graph normalization layers can be more readily plugged into an existing GNN model. Testing a variety of normalization methods during model development and optimization is a reasonable and recommended approach. Pointers to advanced graph neural network literature The field of deep learning focused on graphs is developing rapidly, and there are many methods that we can’t cover in reasonable detail in this introductory chapter. So, before we conclude this chapter, we want to provide interested readers with a selection of pointers to noteworthy literature for more in-depth studies of this topic. As you might remember from Chapter 16, Transformers – Improving Natural Language Processing with Attention Mechanisms, attention mechanisms can improve the capabilities of models by providing additional contexts. In this regard, a variety of attention methods for GNNs have been developed. Examples of GNNs augmented with attention include Graph Attention Networks, by Petar Veličković and colleagues, 2017 ( https://arxiv.org/abs/1710.10903 ) and Relational Graph Attention Networks by Dan Busbridge and colleagues, 2019 ( https://arxiv.org/abs/1904.05811 ). Graph Neural Networks for Capturing Dependencies in Graph Structured Data 670 Recently, these attention mechanisms have also been utilized in graph transformers proposed by Seongjun Yun and colleagues, 2020 ( https://arxiv.org/abs/1911.06455 ) and Heterogeneous Graph Transformer by Ziniu Hu and colleagues, 2020 ( https://arxiv.org/abs/2003.01332 ). Next to the aforementioned graph transformers, other deep generative models have been developed specifically for graphs. There are graph variational autoencoders such as those introduced in Variation - al Graph Auto-Encoders by Kipf and Welling, 2016 ( https://arxiv.org/abs/1611.07308 ), Constrained Graph Variational Autoencoders for Molecule Design by Qi Liu and colleagues, 2018 (https://arxiv.org/ abs/1805.09076 ), and GraphVAE: Towards Generation of Small Graphs Using Variational Autoencoders by Simonovsky and Komodakis, 2018 ( https://arxiv.org/abs/1802.03480 ). Another notable graph variational autoencoder that has been applied to molecule generation is the Junction Tree Variational Autoencoder for Molecular Graph Generation by Wengong Jin and colleagues, 2019 ( https://arxiv.org/ abs/1802.04364 ). Some GANs have been designed to generate graph data, though, as of this writing, the performance of", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 597, "start_word": 191040, "end_word": 191440, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000598": {"text": "Autoencoders for Molecule Design by Qi Liu and colleagues, 2018 (https://arxiv.org/ abs/1805.09076 ), and GraphVAE: Towards Generation of Small Graphs Using Variational Autoencoders by Simonovsky and Komodakis, 2018 ( https://arxiv.org/abs/1802.03480 ). Another notable graph variational autoencoder that has been applied to molecule generation is the Junction Tree Variational Autoencoder for Molecular Graph Generation by Wengong Jin and colleagues, 2019 ( https://arxiv.org/ abs/1802.04364 ). Some GANs have been designed to generate graph data, though, as of this writing, the performance of GANs on graphs is much less convincing than in the image domain. Examples include GraphGAN: Graph Representation Learning with Generative Adversarial Nets by Hongwei Wang and colleagues, 2017 (https://arxiv.org/abs/1711.08267 ) and MolGAN: An Implicit Generative Model for Small Molecular Graphs by Cao and Kipf, 2018 ( https://arxiv.org/abs/1805.11973 ). GNNs have also been incorporated into deep reinforcement learning models—you will learn more about reinforcement learning in the next chapter. Examples include Graph Convolutional Policy Network for Goal-Directed Molecular Graph Generation by Jiaxuan You and colleagues, 2018 ( https://arxiv.org/ abs/1806.02473 ) and a deep Q-network proposed in Optimization of Molecules via Deep Reinforcement Learning by Zhenpeng Zhou and colleagues, 2018 ( https://arxiv.org/abs/1810.08678 ), which utilizes a GNN that was applied to molecule generation tasks. Lastly, while not technically graph data, 3D point clouds are sometimes represented as such using distance cutoffs to create edges. Applications of graph networks in this space include Point-GNN: Graph Neural Network for 3D Object Detection in a Point Cloud by Weijing Shi and colleagues, 2020 ( https:// arxiv.org/abs/2003.01251 ), which detects 3D objects in LiDAR point clouds. In addition, GAPNet: Graph Attention based Point Neural Network for Exploiting Local Feature of Point Cloud by Can Chen and colleagues, 2019 ( https://arxiv.org/abs/1905.08705 ) was designed to detect local features in point cloud data, which had been challenging for other deep architectures. Chapter 18 671 Summary As the amount of data we have access to continues to increase, so too will our need to understand in- terrelations within the data. While this will be done in numerous ways, graphs function as a distilled representation of these relationships, so the amount of graph data available will only increase. In this chapter, we explained graph neural networks from the ground up by implementing a graph convolution layer and a GNN from scratch. We saw that implementing GNNs, due to the nature of graph data, is actually quite complex. Thus, to apply", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 598, "start_word": 191360, "end_word": 191760, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000599": {"text": "too will our need to understand in- terrelations within the data. While this will be done in numerous ways, graphs function as a distilled representation of these relationships, so the amount of graph data available will only increase. In this chapter, we explained graph neural networks from the ground up by implementing a graph convolution layer and a GNN from scratch. We saw that implementing GNNs, due to the nature of graph data, is actually quite complex. Thus, to apply GNNs to a real-world example, such as predict- ing molecular polarization, we learned how to utilize the PyTorch Geometric library, which provides implementations of many of the building blocks we need. Lastly, we went over some of the notable literature for diving into the GNN literature more deeply. Hopefully, this chapter provided an introduction to how deep learning can be leveraged to learn on graphs. Methods in this space are currently a hot area of research, and many of the ones we have mentioned were published in the last couple of years. With this text as a starting point, maybe the next advancement in the space can be made by you. In the next chapter, we will look at reinforcement learning, which is a completely different category of machine learning compared to what we have covered so far in this book. Join our book’s Discord space Join the book’s Discord workspace for a monthly Ask me Anything session with the authors: https://packt.link/MLwPyTorch 19 Reinforcement Learning for Decision Making in Complex Environments In the previous chapters, we focused on supervised and unsupervised machine learning. We also learned how to leverage artificial neural networks and deep learning to tackle problems encountered with these types of machine learning. As you’ll recall, supervised learning focuses on predicting a category label or continuous value from a given input feature vector. Unsupervised learning focuses on extracting patterns from data, making it useful for data compression (Chapter 5, Compressing Data via Dimensionality Reduction), clustering (Chapter 10, Working with Unlabeled Data – Clustering Analysis), or approximating the training set distribution for generating new data (Chapter 17, Generative Adversarial Networks for Synthesizing New Data). In this chapter, we turn our attention to a separate category of machine learning, reinforcement learning (RL), which is different from the previous categories as it is focused on learning a series of actions for optimizing an overall reward—for example, winning at a game of", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 599, "start_word": 191680, "end_word": 192080, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000600": {"text": "5, Compressing Data via Dimensionality Reduction), clustering (Chapter 10, Working with Unlabeled Data – Clustering Analysis), or approximating the training set distribution for generating new data (Chapter 17, Generative Adversarial Networks for Synthesizing New Data). In this chapter, we turn our attention to a separate category of machine learning, reinforcement learning (RL), which is different from the previous categories as it is focused on learning a series of actions for optimizing an overall reward—for example, winning at a game of chess. In summary, this chapter will cover the following topics: • Learning the basics of RL, getting familiar with agent/environment interactions, and under - standing how the reward process works, in order to help make decisions in complex environ- ments • Introducing different categories of RL problems, model-based and model-free learning tasks, Monte Carlo, and temporal difference learning algorithms • Implementing a Q-learning algorithm in a tabular format • Understanding function approximation for solving RL problems, and combining RL with deep learning by implementing a deep Q-learning algorithm Reinforcement Learning for Decision Making in Complex Environments 674 RL is a complex and vast area of research, and this chapter focuses on the fundamentals. As this chapter serves as an introduction, and to keep our attention on the important methods and algorithms, we will work mainly with basic examples that illustrate the main concepts. However, toward the end of this chapter, we will go over a more challenging example and utilize deep learning architectures for a particular RL approach known as deep Q-learning. Introduction – learning from experience In this section, we will first introduce the concept of RL as a branch of machine learning and see its major differences compared with other tasks of machine learning. After that, we will cover the fun- damental components of an RL system. Then, we will see the RL mathematical formulation based on the Markov decision process. Understanding reinforcement learning Until this point, this book has primarily focused on supervised and unsupervised learning. Recall that in supervised learning, we rely on labeled training examples, which are provided by a supervisor or a human expert, and the goal is to train a model that can generalize well to unseen, unlabeled test examples. This means that the supervised learning model should learn to assign the same labels or values to a given input example as the supervisor human expert. On the other hand, in unsupervised learning,", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 600, "start_word": 192000, "end_word": 192400, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000601": {"text": "book has primarily focused on supervised and unsupervised learning. Recall that in supervised learning, we rely on labeled training examples, which are provided by a supervisor or a human expert, and the goal is to train a model that can generalize well to unseen, unlabeled test examples. This means that the supervised learning model should learn to assign the same labels or values to a given input example as the supervisor human expert. On the other hand, in unsupervised learning, the goal is to learn or capture the underlying structure of a dataset, such as in clustering and dimensionality reduction methods; or learning how to generate new, synthetic training examples with a similar underlying distribution. RL is substantially different from supervised and unsupervised learning, and so RL is often regarded as the “third category of machine learning.” The key element that distinguishes RL from other subtasks of machine learning, such as supervised and unsupervised learning, is that RL is centered around the concept of learning by interaction. This means that in RL, the model learns from interactions with an environment to maximize a reward function. While maximizing a reward function is related to the concept of minimizing the loss function in su- pervised learning, the correct labels for learning a series of actions are not known or defined upfront in RL—instead, they need to be learned through interactions with the environment to achieve a cer - tain desired outcome—such as winning at a game. With RL, the model (also called an agent ) interacts with its environment, and by doing so generates a sequence of interactions that are together called an episode. Through these interactions, the agent collects a series of rewards determined by the en- vironment. These rewards can be positive or negative, and sometimes they are not disclosed to the agent until the end of an episode. For example, imagine that we want to teach a computer to play the game of chess and win against human players. The labels (rewards) for each individual chess move made by the computer are not known until the end of the game, because during the game itself, we don’t know whether a particular move will result in winning or losing that game. Only right at the end of the game is the feedback determined. That feedback would likely be a positive reward given if the computer won the game because the", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 601, "start_word": 192320, "end_word": 192720, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000602": {"text": "play the game of chess and win against human players. The labels (rewards) for each individual chess move made by the computer are not known until the end of the game, because during the game itself, we don’t know whether a particular move will result in winning or losing that game. Only right at the end of the game is the feedback determined. That feedback would likely be a positive reward given if the computer won the game because the agent had achieved the overall desired outcome; and vice versa, a negative reward would likely be given if the computer had lost the game. Chapter 19 675 Furthermore, considering the example of playing chess, the input is the current configuration, for instance, the arrangement of the individual chess pieces on the board. Given the large number of pos- sible inputs (the states of the system), it is impossible to label each configuration or state as positive or negative. Therefore, to define a learning process, we provide rewards (or penalties) at the end of each game, when we know whether we reached the desired outcome—whether we won the game or not. This is the essence of RL. In RL, we cannot or do not teach an agent, computer, or robot how to do things; we can only specify what we want the agent to achieve. Then, based on the outcome of a par - ticular trial, we can determine rewards depending on the agent’s success or failure. This makes RL very attractive for decision making in complex environments, especially when the problem-solving task requires a series of steps, which are unknown, or hard to explain, or hard to define. Besides applications in games and robotics, examples of RL can also be found in nature. For example, training a dog involves RL—we hand out rewards (treats) to the dog when it performs certain desirable actions. Or consider a medical dog that is trained to warn its partner of an oncoming seizure. In this case, we do not know the exact mechanism by which the dog is able to detect an oncoming seizure, and we certainly wouldn’t be able to define a series of steps to learn seizure detection, even if we had precise knowledge of this mechanism. However, we can reward the dog with a treat if it successfully detects a seizure to reinforce this behavior! While RL provides a powerful framework", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 602, "start_word": 192640, "end_word": 193040, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000603": {"text": "trained to warn its partner of an oncoming seizure. In this case, we do not know the exact mechanism by which the dog is able to detect an oncoming seizure, and we certainly wouldn’t be able to define a series of steps to learn seizure detection, even if we had precise knowledge of this mechanism. However, we can reward the dog with a treat if it successfully detects a seizure to reinforce this behavior! While RL provides a powerful framework for learning an arbitrary series of actions to achieve a certain goal, please do keep in mind that RL is still a relatively young and active area of research with many unresolved challenges. One aspect that makes training RL models particularly challenging is that the consequent model inputs depend on actions taken previously. This can lead to all sorts of problems, and usually results in unstable learning behavior. Also, this sequence-dependence in RL creates a so- called delayed effect, which means that the action taken at a time step t may result in a future reward appearing some arbitrary number of steps later. Defining the agent-environment interface of a reinforcement learning system In all examples of RL, we can find two distinct entities: an agent and an environment. Formally, an agent is defined as an entity that learns how to make decisions and interacts with its surrounding environment by taking an action. In return, as a consequence of taking an action, the agent receives observations and a reward signal as governed by the environment. The environment is anything that falls outside the agent. The environment communicates with the agent and determines the reward signal for the agent’s action as well as its observations. The reward signal is the feedback that the agent receives from interacting with the environment, which is usually provided in the form of a scalar value and can be either positive or negative. The purpose of the reward is to tell the agent how well it has performed. The frequency at which the agent receives the reward depends on the given task or problem. For example, in the game of chess, the reward would be determined after a full game based on the outcome of all the moves: a win or a loss. On the other hand, we could define a maze such that the reward is determined after each time step. In such a maze, the", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 603, "start_word": 192960, "end_word": 193360, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000604": {"text": "reward is to tell the agent how well it has performed. The frequency at which the agent receives the reward depends on the given task or problem. For example, in the game of chess, the reward would be determined after a full game based on the outcome of all the moves: a win or a loss. On the other hand, we could define a maze such that the reward is determined after each time step. In such a maze, the agent then tries to maximize its accumulated rewards over its lifetime—where lifetime describes the duration of an episode. Reinforcement Learning for Decision Making in Complex Environments 676 Figure 19.1 illustrates the interactions and communication between the agent and the environment: Figure 19.1: The interaction between the agent and its environment The state of the agent, as illustrated in Figure 19.1, is the set of all of its variables (1). For example, in the case of a robot drone, these variables could include the drone’s current position (longitude, latitude, and altitude), the drone’s remaining battery life, the speed of each fan, and so forth. At each time step, the agent interacts with the environment through a set of available actions A t (2). Based on the action taken by the agent denoted by A t, while it is at state S t, the agent will receive a reward signal R t+1 (3), and its state will become S t+1 (4). During the learning process, the agent must try different actions (exploration) so that it can progres- sively learn which actions to prefer and perform more often (exploitation) in order to maximize the total, cumulative reward. To understand this concept, let’s consider a very simple example where a new computer science graduate with a focus on software engineering is wondering whether to start working at a company (exploitation) or to pursue a master’s or Ph.D. degree to learn more about data science and machine learning (exploration). In general, exploitation will result in choosing actions with a greater short-term reward, whereas exploration can potentially result in greater total rewards in the long run. The tradeoff between exploration and exploitation has been studied extensively, and yet, there is no universal answer to this decision-making dilemma. The theoretical foundations of RL Before we jump into some practical examples and start training an RL model, which we will be doing later in this chapter, let’s first", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 604, "start_word": 193280, "end_word": 193680, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000605": {"text": "and machine learning (exploration). In general, exploitation will result in choosing actions with a greater short-term reward, whereas exploration can potentially result in greater total rewards in the long run. The tradeoff between exploration and exploitation has been studied extensively, and yet, there is no universal answer to this decision-making dilemma. The theoretical foundations of RL Before we jump into some practical examples and start training an RL model, which we will be doing later in this chapter, let’s first understand some of the theoretical foundations of RL. The following sections will begin by first examining the mathematical formulation of Markov decision processes, episodic versus continuing tasks, some key RL terminology, and dynamic programming using the Bellman equation. Let’s start with Markov decision processes. Chapter 19 677 Markov decision processes In general, the type of problems that RL deals with are typically formulated as Markov decision pro - cesses (MDPs ). The standard approach for solving MDP problems is by using dynamic programming, but RL offers some key advantages over dynamic programming. Dynamic programming is not a feasible approach, however, when the size of states (that is, the number of possible configurations) is relatively large. In such cases, RL is considered a much more efficient and practical alternative approach for solving MDPs. The mathematical formulation of Markov decision processes The types of problems that require learning an interactive and sequential decision-making process, where the decision at time step t affects the subsequent situations, are mathematically formalized as MDPs. In the case of the agent/environment interactions in RL, if we denote the agent’s starting state as S 0, the interactions between the agent and the environment result in a sequence as follows: {S0, A 0, R 1}, {S1, A 1, R 2}, {S2, A 2, R 3}, ... Note that the braces serve only as a visual aid. Here, S t and A t stand for the state and the action taken at time step t. Rt+1 denotes the reward received from the environment after performing action A t. Note that St, Rt+1, and A t are time-dependent random variables that take values from predefined finite sets denoted by 𝑠𝑠𝑠𝑠𝑠̂ , 𝑟𝑟𝑟𝑟𝑟̂ , and 𝑎𝑎𝑎𝑎𝑎̂ , respectively. In an MDP, these time-dependent random variables, St and R t+1, have probability distributions that only depend on their values at the preceding time step, t – 1. The probability distribution for S t+1", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 605, "start_word": 193600, "end_word": 194000, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000606": {"text": "taken at time step t. Rt+1 denotes the reward received from the environment after performing action A t. Note that St, Rt+1, and A t are time-dependent random variables that take values from predefined finite sets denoted by 𝑠𝑠𝑠𝑠𝑠̂ , 𝑟𝑟𝑟𝑟𝑟̂ , and 𝑎𝑎𝑎𝑎𝑎̂ , respectively. In an MDP, these time-dependent random variables, St and R t+1, have probability distributions that only depend on their values at the preceding time step, t – 1. The probability distribution for S t+1 = s′ and R t+1 = r can be written as a conditional probability over the preceding state (S t) and taken action (A t) as follows: 𝑝𝑝(𝑠𝑠′,𝑟𝑟|𝑠𝑠,𝑠𝑠)≝𝑃𝑃(𝑆𝑆𝑡𝑡𝑡𝑡=𝑠𝑠′,𝑅𝑅𝑡𝑡𝑡𝑡=𝑟𝑟|𝑆𝑆𝑡𝑡= 𝑠𝑠,𝑠𝑠𝑡𝑡=𝑠𝑠) Dynamic programming Dynamic programming refers to a set of computer algorithms and programming methods that was developed by Richard Bellman in the 1950s. In a sense, dynamic programming is about recursive problem solving—solving relatively complicated problems by breaking them down into smaller subproblems. The key difference between recursion and dynamic programming is that dynamic program - ming stores the results of subproblems (usually as a dictionary or other form of lookup table) so that they can be accessed in constant time (instead of recalculating them) if they are encountered again in future. Examples of some famous problems in computer science that are solved by dynamic programming include sequence alignment and computing the shortest path from point A to point B. Reinforcement Learning for Decision Making in Complex Environments 678 This probability distribution completely defines the dynamics of the environment (or model of the environment) because, based on this distribution, all transition probabilities of the environment can be computed. Therefore, the environment dynamics are a central criterion for categorizing different RL methods. The types of RL methods that require a model of the environment or try to learn a model of the environment (that is, the environment dynamics) are called model-based methods, as opposed to model-free methods. The environment dynamics can be considered deterministic if particular actions for given states are always or never taken, that is, 𝑝𝑝(𝑠𝑠′,𝑟𝑟|𝑠𝑠,𝑠𝑠)∈{0,1} . Otherwise, in the more general case, the environ- ment would have stochastic behavior. To make sense of this stochastic behavior, let’s consider the probability of observing the future state St+1 = s′ conditioned on the current state S t = s and the performed action A t = a. This is denoted by: 𝑝𝑝(𝑠𝑠′|𝑠𝑠𝑠𝑠𝑠)≝𝑃𝑃(𝑆𝑆𝑡𝑡𝑡𝑡=𝑠𝑠′|𝑆𝑆𝑡𝑡=𝑠𝑠𝑠𝑠𝑠𝑡𝑡=𝑠𝑠) Model-free and model-based RL When the probability 𝑝𝑝(𝑠𝑠′,𝑟𝑟|𝑠𝑠,𝑠𝑠) is", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 606, "start_word": 193920, "end_word": 194320, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000607": {"text": "considered deterministic if particular actions for given states are always or never taken, that is, 𝑝𝑝(𝑠𝑠′,𝑟𝑟|𝑠𝑠,𝑠𝑠)∈{0,1} . Otherwise, in the more general case, the environ- ment would have stochastic behavior. To make sense of this stochastic behavior, let’s consider the probability of observing the future state St+1 = s′ conditioned on the current state S t = s and the performed action A t = a. This is denoted by: 𝑝𝑝(𝑠𝑠′|𝑠𝑠𝑠𝑠𝑠)≝𝑃𝑃(𝑆𝑆𝑡𝑡𝑡𝑡=𝑠𝑠′|𝑆𝑆𝑡𝑡=𝑠𝑠𝑠𝑠𝑠𝑡𝑡=𝑠𝑠) Model-free and model-based RL When the probability 𝑝𝑝(𝑠𝑠′,𝑟𝑟|𝑠𝑠,𝑠𝑠) is known, then the learning task can be solved with dynamic programming. But when the dynamics of the environment are not known, as is the case in many real-world problems, then we would need to acquire a large number of samples by interacting with the environment to compensate for the unknown environ- ment dynamics. Two main approaches for dealing with this problem are the model-free Monte Carlo (MC ) and temporal difference (TD) methods. The following chart displays the two main categories and the branches of each method: Figure 19.2: The different models to use based on the environment dynamics We will cover these different approaches and their branches from theory to practical algorithms in this chapter. Chapter 19 679 It can be computed as a marginal probability by taking the sum over all possible rewards: 𝑝𝑝(𝑠𝑠′|𝑠𝑠𝑠𝑠𝑠)≝∑𝑝𝑝(𝑠𝑠′𝑠𝑟𝑟|𝑠𝑠𝑠𝑠𝑠) 𝑟𝑟𝑟𝑟𝑟̂ This probability is called state-transition probability. Based on the state-transition probability, if the environment dynamics are deterministic, then it means that when the agent takes action A t = a at state S t = s, the transition to the next state, S t+1 = s′, will be 100 percent certain, that is, 𝑝𝑝(𝑠𝑠′|𝑠𝑠𝑠𝑠𝑠)=1 . Visualization of a Markov process A Markov process can be represented as a directed cyclic graph in which the nodes in the graph repre - sent the different states of the environment. The edges of the graph (that is, the connections between the nodes) represent the transition probabilities between the states. For example, let’s consider a student deciding between three different situations: (A) studying for an exam at home, (B) playing video games at home, or (C) studying at the library. Furthermore, there is a terminal state (T) for going to sleep. The decisions are made every hour, and after making a decision, the student will remain in a chosen situation for that particular hour. Then, assume that when staying at home (state A), there is a 50", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 607, "start_word": 194240, "end_word": 194640, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000608": {"text": "between the states. For example, let’s consider a student deciding between three different situations: (A) studying for an exam at home, (B) playing video games at home, or (C) studying at the library. Furthermore, there is a terminal state (T) for going to sleep. The decisions are made every hour, and after making a decision, the student will remain in a chosen situation for that particular hour. Then, assume that when staying at home (state A), there is a 50 percent likelihood that the student switches the activity to playing video games. On the other hand, when the student is at state B (playing video games), there is a relatively high chance (80 percent) that the student will continue playing video games in the subsequent hours. The dynamics of the student’s behavior is shown as a Markov process in Figure 19.3, which includes a cyclic graph and a transition table: Figure 19.3: The Markov process of the student The values on the edges of the graph represent the transition probabilities of the student’s behavior, and their values are also shown in the table to the right. When considering the rows in the table, please note that the transition probabilities coming out of each state (node) always sum to 1. Episodic versus continuing tasks As the agent interacts with the environment, the sequence of observations or states forms a trajectory. There are two types of trajectories. If an agent’s trajectory can be divided into subparts such that each starts at time t = 0 and ends in a terminal state S T (at t = T), the task is called an episodic task. Reinforcement Learning for Decision Making in Complex Environments 680 On the other hand, if the trajectory is infinitely continuous without a terminal state, the task is called a continuing task. The task related to a learning agent for the game of chess is an episodic task, whereas a cleaning robot that is keeping a house tidy is typically performing a continuing task. In this chapter, we only consider episodic tasks. In episodic tasks, an episode is a sequence or trajectory that an agent takes from a starting state, S 0, to a terminal state, S T: S0, A 0, R 1, S 1, A 1, R 2, ..., St, A t, R t+1, ..., St–1, A t–1, R t, S t For the Markov process shown in Figure", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 608, "start_word": 194560, "end_word": 194960, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000609": {"text": "cleaning robot that is keeping a house tidy is typically performing a continuing task. In this chapter, we only consider episodic tasks. In episodic tasks, an episode is a sequence or trajectory that an agent takes from a starting state, S 0, to a terminal state, S T: S0, A 0, R 1, S 1, A 1, R 2, ..., St, A t, R t+1, ..., St–1, A t–1, R t, S t For the Markov process shown in Figure 19.3, which depicts the task of a student studying for an exam, we may encounter episodes like the following three examples: Episode 1: 𝐵𝐵𝐵𝐵𝐵𝐵𝐵𝐵𝐵𝐵𝐵𝐵𝐵𝐵𝐵𝐵𝐵𝐵 𝐵 p𝐵ss(fin𝐵l rew𝐵 rd = +1 ) Episode 2: 𝐵𝐵𝐵𝐵𝐵𝐵𝐵𝐵𝐵𝐵𝐵𝐵𝐵𝐵𝐵𝐵𝐵𝐵𝐵𝐵𝐵𝐵𝐵𝐵 𝐵 f𝐵il (fin𝐵l rew𝐵 rd = −1 ) Episode 3: 𝐵𝐵𝐵𝐵𝐵𝐵𝐵𝐵𝐵𝐵𝐵𝐵𝐵𝐵 𝐵 p𝐵ss(fin𝐵l rew𝐵 rd = +1 ) RL terminology: return, policy, and value function Next, let’s define some additional RL-specific terminology that we will need for the remainder of this chapter. The return The so-called return at time t is the cumulated reward obtained from the entire duration of an episode. Recall that R t+1 = r is the immediate reward obtained after performing an action, A t, at time t; the sub - sequent rewards are R t+2, R t+3, and so forth. The return at time t can then be calculated from the immediate reward as well as the subsequent ones, as follows: 𝐺𝐺𝑡𝑡≝𝑅𝑅𝑡𝑡𝑡𝑡+𝛾𝛾𝑅𝑅𝑡𝑡𝑡𝑡+𝛾𝛾𝑡𝑅𝑅𝑡𝑡𝑡𝑡+⋯=∑𝛾𝛾𝑘𝑘𝑅𝑅𝑡𝑡𝑡𝑘𝑘𝑡𝑡 𝑘𝑘𝑘𝑘 Here, 𝛾𝛾 is the discount factor in range [0, 1]. The parameter 𝛾𝛾 indicates how much the future rewards are “worth” at the current moment (time t). Note that by setting 𝛾𝛾𝛾𝛾 , we would imply that we do not care about future rewards. In this case, the return will be equal to the immediate reward, ignoring the subsequent rewards after t + 1, and the agent will be short-sighted. On the other hand, if 𝛾𝛾𝛾𝛾 , the return will be the unweighted sum of all subsequent rewards. Moreover, note that the equation for the return can be expressed in a simpler way by using recursion as follows: 𝐺𝐺𝑡𝑡=𝑅𝑅𝑡𝑡𝑡𝑡+𝛾𝛾𝐺𝐺𝑡𝑡𝑡𝑡=𝑟𝑟+𝛾𝛾𝐺𝐺𝑡𝑡𝑡𝑡 Chapter 19 681 This means that the return at time t is equal to the immediate reward r plus the discounted future return at time t + 1. This is a very important property, which facilitates the computations of the return. Let’s compute the return at different time steps for the episodes in our previous student example. Assume 𝛾𝛾", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 609, "start_word": 194880, "end_word": 195280, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000610": {"text": "Moreover, note that the equation for the return can be expressed in a simpler way by using recursion as follows: 𝐺𝐺𝑡𝑡=𝑅𝑅𝑡𝑡𝑡𝑡+𝛾𝛾𝐺𝐺𝑡𝑡𝑡𝑡=𝑟𝑟+𝛾𝛾𝐺𝐺𝑡𝑡𝑡𝑡 Chapter 19 681 This means that the return at time t is equal to the immediate reward r plus the discounted future return at time t + 1. This is a very important property, which facilitates the computations of the return. Let’s compute the return at different time steps for the episodes in our previous student example. Assume 𝛾𝛾 𝛾 𝛾𝛾𝛾 and that the only reward given is based on the result of the exam (+1 for passing the exam, and –1 for failing it). The rewards for intermediate time steps are 0. Episode 1: 𝐵𝐵𝐵𝐵𝐵𝐵𝐵𝐵𝐵𝐵𝐵𝐵𝐵𝐵𝐵𝐵𝐵𝐵 𝐵 p𝐵ss(fin𝐵l rew𝐵 rd = +1 ) : • 𝑡𝑡𝑡𝑡 𝑡 𝑡𝑡 0𝑡𝑅𝑅1+𝛾𝛾𝑅𝑅2+𝛾𝛾2𝑅𝑅3+⋯+𝛾𝛾6𝑅𝑅7 → 𝐺𝐺0=0+0×𝛾𝛾 +𝛾+𝛾×𝛾𝛾6= 0.96≈ 0. 53𝛾 • 𝑡𝑡𝑡𝑡 𝑡 𝑡𝑡 1𝑡𝑡×𝛾𝛾5𝑡0.590 • 𝑡𝑡𝑡𝑡 𝑡 𝑡𝑡 2𝑡1×𝛾𝛾4𝑡0.656 • ... • 𝑡𝑡𝑡𝑡 𝑡 𝑡𝑡 6𝑡1×𝛾𝛾𝑡𝛾𝛾𝛾 • 𝑡𝑡𝑡𝑡 𝑡 𝑡𝑡 7𝑡1𝑡1 Intuition behind the discount factor To get an understanding of the discount factor, consider Figure 19.4, showing the value of earning a $100 bill today compared to earning it in a year from now. Under certain economic situations, like inflation, earning this $100 bill right now could be worth more than earning it in the future: Figure 19.4: An example of a discount factor based on the value of a $100 bill over time Therefore, we say that if this bill is worth $100 right now, then it would be worth $90 in a year with a discount factor 𝛾𝛾 𝛾 𝛾𝛾𝛾 . Reinforcement Learning for Decision Making in Complex Environments 682 Episode 2: 𝐴𝐴𝐴𝐴𝐴𝐴𝐴𝐴𝐴𝐴𝐴𝐴𝐴𝐴𝐴𝐴𝐴𝐴𝐴𝐴𝐴𝐴𝐴𝐴 𝐴 𝐴𝐴 i𝐴(𝐴in𝐴𝐴 rew𝐴 rd = −1 ) : • 𝑡𝑡𝑡𝑡 𝑡 𝑡𝑡 0𝑡−1×𝛾𝛾8𝑡−𝑡.43𝑡 • 𝑡𝑡𝑡𝑡 𝑡 𝑡𝑡 0𝑡−𝑡×𝛾𝛾7𝑡−0.478 • ... • 𝑡𝑡𝑡𝑡 𝑡 𝑡𝑡 0𝑡−1×𝛾𝛾𝑡 −𝛾𝛾𝛾 • 𝑡𝑡𝑡𝑡 𝑡 𝑡𝑡 10𝑡−1 We leave the computation of the returns for the third episode as an exercise for the reader. Policy A policy typically denoted by 𝜋𝜋(𝑎𝑎|𝑠𝑠) is a function that determines the next action to take, which can be either deterministic or stochastic (that is, the probability for taking the next action). A stochastic policy then has a probability distribution over actions that an agent can take at a given state: 𝜋𝜋(𝑎𝑎|𝑠𝑠)≝𝑃𝑃[𝐴𝐴𝑡𝑡=𝑎𝑎|𝑆𝑆𝑡𝑡=𝑠𝑠] During the learning process, the policy may change as the agent gains more experience. For example, the agent may start from a random policy, where", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 610, "start_word": 195200, "end_word": 195600, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000611": {"text": "the reader. Policy A policy typically denoted by 𝜋𝜋(𝑎𝑎|𝑠𝑠) is a function that determines the next action to take, which can be either deterministic or stochastic (that is, the probability for taking the next action). A stochastic policy then has a probability distribution over actions that an agent can take at a given state: 𝜋𝜋(𝑎𝑎|𝑠𝑠)≝𝑃𝑃[𝐴𝐴𝑡𝑡=𝑎𝑎|𝑆𝑆𝑡𝑡=𝑠𝑠] During the learning process, the policy may change as the agent gains more experience. For example, the agent may start from a random policy, where the probability of all actions is uniform; meanwhile, the agent will hopefully learn to optimize its policy toward reaching the optimal policy. The optimal policy 𝜋𝜋∗(𝑎𝑎|𝑠𝑠) is the policy that yields the highest return. Value function The value function, also referred to as the state-value function, measures the goodness of each state—in other words, how good or bad it is to be in a particular state. Note that the criterion for goodness is based on the return. Now, based on the return G t, we define the value function of state s as the expected return (the average return over all possible episodes) after following policy 𝜋𝜋 : 𝑣𝑣𝜋𝜋(𝑠𝑠)≝𝐸𝐸𝜋𝜋[𝐺𝐺𝑡𝑡|𝑆𝑆𝑡𝑡=𝑠𝑠]=𝐸𝐸𝜋𝜋[∑𝛾𝛾𝑘𝑘𝑘𝑘𝑅𝑅𝑡𝑡𝑘𝑘𝑘𝑘𝑘 𝑘𝑘𝑘𝑘|𝑆𝑆𝑡𝑡= 𝑠𝑠𝑠 In an actual implementation, we usually estimate the value function using lookup tables, so we do not have to recompute it multiple times. (This is the dynamic programming aspect.) For example, in practice, when we estimate the value function using such tabular methods, we store all the state values in a table denoted by V(s). In a Python implementation, this could be a list or a NumPy array whose indices refer to different states; or, it could be a Python dictionary, where the dictionary keys map the states to the respective values. Moreover, we can also define a value for each state-action pair, which is called the action-value function and is denoted by 𝑞𝑞𝜋𝜋(𝑠𝑠𝑠𝑠𝑠) . The action-value function refers to the expected return G t when the agent is at state S t = s and takes action A t = a. Chapter 19 683 Extending the definition of the state-value function to state-action pairs, we get the following: 𝑞𝑞𝜋𝜋(𝑠𝑠𝑠𝑠𝑠)≝𝐸𝐸𝜋𝜋[𝐺𝐺𝑡𝑡|𝑆𝑆𝑡𝑡= 𝑠𝑠𝑠𝑠𝑠𝑡𝑡=𝑠𝑠]=𝐸𝐸𝜋𝜋[∑𝛾𝛾𝑘𝑘𝑘𝑘𝑅𝑅𝑡𝑡𝑘𝑘𝑘𝑘𝑘 𝑘𝑘𝑘𝑘|𝑆𝑆𝑡𝑡=𝑠𝑠𝑠𝑠𝑠𝑡𝑡=𝑠𝑠𝑎 This is similar to referring to the optimal policy as 𝜋𝜋∗(𝑎𝑎|𝑠𝑠) , 𝑣𝑣∗(𝑠𝑠) , and 𝑞𝑞∗(𝑠𝑠𝑠𝑠𝑠) also denote the optimal state-value and action-value functions. Estimating the value function is an essential component of RL methods. We will cover different ways of calculating and estimating the state-value function", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 611, "start_word": 195520, "end_word": 195920, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000612": {"text": "at state S t = s and takes action A t = a. Chapter 19 683 Extending the definition of the state-value function to state-action pairs, we get the following: 𝑞𝑞𝜋𝜋(𝑠𝑠𝑠𝑠𝑠)≝𝐸𝐸𝜋𝜋[𝐺𝐺𝑡𝑡|𝑆𝑆𝑡𝑡= 𝑠𝑠𝑠𝑠𝑠𝑡𝑡=𝑠𝑠]=𝐸𝐸𝜋𝜋[∑𝛾𝛾𝑘𝑘𝑘𝑘𝑅𝑅𝑡𝑡𝑘𝑘𝑘𝑘𝑘 𝑘𝑘𝑘𝑘|𝑆𝑆𝑡𝑡=𝑠𝑠𝑠𝑠𝑠𝑡𝑡=𝑠𝑠𝑎 This is similar to referring to the optimal policy as 𝜋𝜋∗(𝑎𝑎|𝑠𝑠) , 𝑣𝑣∗(𝑠𝑠) , and 𝑞𝑞∗(𝑠𝑠𝑠𝑠𝑠) also denote the optimal state-value and action-value functions. Estimating the value function is an essential component of RL methods. We will cover different ways of calculating and estimating the state-value function and action-value function later in this chapter. Before we move directly ahead into some RL algorithms, let’s briefly go over the derivation for the Bellman equation, which we can use to implement the policy evaluation.The difference between the reward, return, and value function The reward is a consequence of the agent taking an action given the current state of the environment. In other words, the reward is a signal that the agent receives when per - forming an action to transition from one state to the next. However, remember that not every action yields a positive or negative reward—think back to our chess example, where a positive reward is only received upon winning the game, and the reward for all inter - mediate actions is zero. A state itself has a certain value, which we assign to it, to measure how good or bad this state is—this is where the value function comes into play. Typically, the states with a “high” or “good” value are those states that have a high expected return and will likely yield a high reward given a particular policy. For example, let’s consider a chess-playing computer once more. A positive reward may only be given at the end of the game if the computer wins the game. There is no (positive) reward if the computer loses the game. Now, imagine the computer performs a particular chess move that captures the opponent’s queen without any negative consequences for the computer. Since the computer only receives a reward for winning the game, it does not get an immediate reward by making this move that captures the opponent’s queen. However, the new state (the state of the board after capturing the queen) may have a high value, which may yield a reward (if the game is won afterward). Intuitively, we can say that the high value associated with capturing the opponent’s queen is associated with the fact that", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 612, "start_word": 195840, "end_word": 196240, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000613": {"text": "consequences for the computer. Since the computer only receives a reward for winning the game, it does not get an immediate reward by making this move that captures the opponent’s queen. However, the new state (the state of the board after capturing the queen) may have a high value, which may yield a reward (if the game is won afterward). Intuitively, we can say that the high value associated with capturing the opponent’s queen is associated with the fact that capturing the queen often results in winning the game—and thus the high expected return, or value. However, note that capturing the opponent’s queen does not always lead to winning the game; hence, the agent is likely to receive a positive reward, but it is not guaranteed. In short, the return is the weighted sum of rewards for an entire episode, which would be equal to the discounted final reward in our chess example (since there is only one reward). The value function is the expectation over all possible episodes, which basically computes how “valuable” it is, on average, to make a certain move. Reinforcement Learning for Decision Making in Complex Environments 684 Dynamic programming using the Bellman equation The Bellman equation is one of the central elements of many RL algorithms. The Bellman equation simplifies the computation of the value function, such that rather than summing over multiple time steps, it uses a recursion that is similar to the recursion for computing the return. Based on the recursive equation for the total return 𝐺𝐺𝑡𝑡=𝑟𝑟𝑟𝑟𝑟𝐺𝐺 𝑡𝑡𝑡𝑡 , we can rewrite the value function as follows: 𝑣𝑣𝜋𝜋(𝑠𝑠)≝𝐸𝐸 𝜋𝜋[𝐺𝐺𝑡𝑡|𝑆𝑆𝑡𝑡=𝑠𝑠] =𝐸𝐸 𝜋𝜋[𝑟𝑟 𝑟 𝑟𝑟𝐺𝐺 𝑡𝑡𝑡𝑡|𝑆𝑆𝑡𝑡=𝑠𝑠] = 𝑟𝑟𝑟𝑟𝑟𝐸𝐸 𝜋𝜋[𝐺𝐺𝑡𝑡𝑡𝑡|𝑆𝑆𝑡𝑡=𝑠𝑠] Notice that the immediate reward r is taken out of the expectation since it is a constant and known quantity at time t. Similarly, for the action-value function, we could write: 𝑞𝑞𝜋𝜋(𝑠𝑠𝑠 𝑠𝑠)≝𝐸𝐸 𝜋𝜋[𝐺𝐺𝑡𝑡|𝑆𝑆𝑡𝑡= 𝑠𝑠𝑠 𝑠𝑠 𝑡𝑡=𝑠𝑠] =𝐸𝐸 𝜋𝜋[𝑟𝑟 𝑟 𝑟𝑟𝐺𝐺 𝑡𝑡𝑡𝑡|𝑆𝑆𝑡𝑡= 𝑠𝑠𝑠 𝑠𝑠 𝑡𝑡=𝑠𝑠] = 𝑟𝑟𝑟𝑟𝑟𝐸𝐸 𝜋𝜋[𝐺𝐺𝑡𝑡𝑡𝑡|𝑆𝑆𝑡𝑡= 𝑠𝑠𝑠 𝑠𝑠 𝑡𝑡=𝑠𝑠] We can use the environment dynamics to compute the expectation by summing all the probabilities of the next state s′ and the corresponding rewards r: 𝑣𝑣𝜋𝜋(𝑠𝑠)=∑𝜋𝜋(𝑎𝑎|𝑠𝑠) 𝑎𝑎𝑎𝑎𝑎̂∑𝑝𝑝(𝑠𝑠′,𝑟𝑟|𝑠𝑠,𝑎𝑎)[𝑟𝑟𝑟𝑟𝑟𝑟𝑟 𝜋𝜋[𝐺𝐺𝑡𝑡𝑡𝑡|𝑆𝑆𝑡𝑡𝑡𝑡=𝑠𝑠′]] 𝑠𝑠′𝑎𝑆𝑆̂,𝑟𝑟𝑎𝑟𝑟̂ Now, we can see that expectation of the return, 𝐸𝐸𝜋𝜋[𝐺𝐺𝑡𝑡𝑡𝑡|𝑆𝑆𝑡𝑡=𝑠𝑠′] , is essentially the state-value function 𝑣𝑣𝜋𝜋(𝑠𝑠′) . So, we can write 𝑣𝑣𝜋𝜋(𝑠𝑠) as a function of 𝑣𝑣𝜋𝜋(𝑠𝑠′) : 𝑣𝑣𝜋𝜋(𝑠𝑠)=∑𝜋𝜋(𝑎𝑎|𝑠𝑠) 𝑎𝑎𝑎𝑎𝑎̂∑𝑝𝑝(𝑠𝑠′,𝑟𝑟|𝑠𝑠,𝑎𝑎)[𝑟𝑟𝑟𝑟𝑟𝑣𝑣 𝜋𝜋(𝑠𝑠′)] 𝑠𝑠′𝑎𝑆𝑆̂,𝑟𝑟𝑎𝑟𝑟̂ This is called the Bellman equation, which relates the value function for a", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 613, "start_word": 196160, "end_word": 196560, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000614": {"text": "𝑟𝑟𝑟𝑟𝑟𝐸𝐸 𝜋𝜋[𝐺𝐺𝑡𝑡𝑡𝑡|𝑆𝑆𝑡𝑡= 𝑠𝑠𝑠 𝑠𝑠 𝑡𝑡=𝑠𝑠] We can use the environment dynamics to compute the expectation by summing all the probabilities of the next state s′ and the corresponding rewards r: 𝑣𝑣𝜋𝜋(𝑠𝑠)=∑𝜋𝜋(𝑎𝑎|𝑠𝑠) 𝑎𝑎𝑎𝑎𝑎̂∑𝑝𝑝(𝑠𝑠′,𝑟𝑟|𝑠𝑠,𝑎𝑎)[𝑟𝑟𝑟𝑟𝑟𝑟𝑟 𝜋𝜋[𝐺𝐺𝑡𝑡𝑡𝑡|𝑆𝑆𝑡𝑡𝑡𝑡=𝑠𝑠′]] 𝑠𝑠′𝑎𝑆𝑆̂,𝑟𝑟𝑎𝑟𝑟̂ Now, we can see that expectation of the return, 𝐸𝐸𝜋𝜋[𝐺𝐺𝑡𝑡𝑡𝑡|𝑆𝑆𝑡𝑡=𝑠𝑠′] , is essentially the state-value function 𝑣𝑣𝜋𝜋(𝑠𝑠′) . So, we can write 𝑣𝑣𝜋𝜋(𝑠𝑠) as a function of 𝑣𝑣𝜋𝜋(𝑠𝑠′) : 𝑣𝑣𝜋𝜋(𝑠𝑠)=∑𝜋𝜋(𝑎𝑎|𝑠𝑠) 𝑎𝑎𝑎𝑎𝑎̂∑𝑝𝑝(𝑠𝑠′,𝑟𝑟|𝑠𝑠,𝑎𝑎)[𝑟𝑟𝑟𝑟𝑟𝑣𝑣 𝜋𝜋(𝑠𝑠′)] 𝑠𝑠′𝑎𝑆𝑆̂,𝑟𝑟𝑎𝑟𝑟̂ This is called the Bellman equation, which relates the value function for a state, s, to the value func- tion of its subsequent state, s′. This greatly simplifies the computation of the value function because it eliminates the iterative loop along the time axis. Reinforcement learning algorithms In this section, we will cover a series of learning algorithms. We will start with dynamic programming, which assumes that the transition dynamics—or the environment dynamics, that is, 𝑝𝑝(𝑠𝑠′,𝑟𝑟|𝑠𝑠,𝑠𝑠) —are known. However, in most RL problems, this is not the case. To work around the unknown environ- ment dynamics, RL techniques were developed that learn through interacting with the environment. These techniques include Monte Carlo (MC ), temporal difference (TD) learning, and the increasingly popular Q-learning and deep Q-learning approaches. Chapter 19 685 Figure 19.5 describes the course of advancing RL algorithms, from dynamic programming to Q-learning: Figure 19.5: Different types of RL algorithms In the following sections of this chapter, we will step through each of these RL algorithms. We will start with dynamic programming, before moving on to MC, and finally on to TD and its branches of on-policy SARSA (state–action–reward–state–action) and off-policy Q-learning. We will also move into deep Q-learning while we build some practical models. Dynamic programming In this section, we will focus on solving RL problems under the following assumptions: • We have full knowledge of the environment dynamics; that is, all transition probabilities 𝑝𝑝(𝑠𝑠′,𝑟𝑟|𝑠𝑠,𝑠𝑠) —are known. • The agent’s state has the Markov property, which means that the next action and reward depend only on the current state and the choice of action we make at this moment or current time step. The mathematical formulation for RL problems using a Markov decision process ( MDP ) was introduced earlier in this chapter. If you need a refresher, please refer to the section entitled The mathematical for- mulation of Markov decision processes, which introduced the formal definition of the value function 𝑣𝑣𝜋𝜋(𝑠𝑠) following the policy 𝜋𝜋 , and the Bellman equation,", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 614, "start_word": 196480, "end_word": 196880, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000615": {"text": "and reward depend only on the current state and the choice of action we make at this moment or current time step. The mathematical formulation for RL problems using a Markov decision process ( MDP ) was introduced earlier in this chapter. If you need a refresher, please refer to the section entitled The mathematical for- mulation of Markov decision processes, which introduced the formal definition of the value function 𝑣𝑣𝜋𝜋(𝑠𝑠) following the policy 𝜋𝜋 , and the Bellman equation, which was derived using the environment dynamics. We should emphasize that dynamic programming is not a practical approach for solving RL problems. The problem with using dynamic programming is that it assumes full knowledge of the environment dynamics, which is usually unreasonable or impractical for most real-world applications. However, from an educational standpoint, dynamic programming helps with introducing RL in a simple fashion and motivates the use of more advanced and complicated RL algorithms. There are two main objectives via the tasks described in the following subsections: 1. Obtain the true state-value function, 𝑣𝑣𝜋𝜋(𝑠𝑠) ; this task is also known as the prediction task and is accomplished with policy evaluation. 2. Find the optimal value function, 𝑣𝑣∗(𝑠𝑠) , which is accomplished via generalized policy iteration. Reinforcement Learning for Decision Making in Complex Environments 686 Policy evaluation – predicting the value function with dynamic programming Based on the Bellman equation, we can compute the value function for an arbitrary policy 𝜋𝜋 with dynamic programming when the environment dynamics are known. For computing this value func- tion, we can adapt an iterative solution, where we start from 𝑣𝑣〈0〉(𝑠𝑠) , which is initialized to zero values for each state. Then, at each iteration i + 1, we update the values for each state based on the Bellman equation, which, in turn, is based on the values of states from a previous iteration, i, as follows: 𝑣𝑣〈𝑖𝑖𝑖𝑖〉(𝑠𝑠)=∑𝜋𝜋(𝑎𝑎|𝑠𝑠) 𝑎𝑎∑𝑝𝑝(𝑠𝑠′,𝑟𝑟|𝑠𝑠,𝑎𝑎)[𝑟𝑟𝑟𝑟𝑟𝑣𝑣〈𝑖𝑖〉(𝑠𝑠′)] 𝑠𝑠′∈𝑆𝑆̂,𝑟𝑟∈𝑟𝑟̂ It can be shown that as the iterations increase to infinity, 𝑣𝑣〈𝑖𝑖〉(𝑠𝑠) converges to the true state-value function, 𝑣𝑣𝜋𝜋(𝑠𝑠) . Also, notice here that we do not need to interact with the environment. The reason for this is that we already know the environment dynamics accurately. As a result, we can leverage this information and estimate the value function easily. After computing the value function, an obvious question is how that value function can be useful for us if our policy is still a random", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 615, "start_word": 196800, "end_word": 197200, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000616": {"text": "as the iterations increase to infinity, 𝑣𝑣〈𝑖𝑖〉(𝑠𝑠) converges to the true state-value function, 𝑣𝑣𝜋𝜋(𝑠𝑠) . Also, notice here that we do not need to interact with the environment. The reason for this is that we already know the environment dynamics accurately. As a result, we can leverage this information and estimate the value function easily. After computing the value function, an obvious question is how that value function can be useful for us if our policy is still a random policy. The answer is that we can actually use this computed 𝑣𝑣𝜋𝜋(𝑠𝑠) to improve our policy, as we will see next. Improving the policy using the estimated value function Now that we have computed the value function 𝑣𝑣𝜋𝜋(𝑠𝑠) by following the existing policy, 𝜋𝜋 , we want to use 𝑣𝑣𝜋𝜋(𝑠𝑠) and improve the existing policy, 𝜋𝜋 . This means that we want to find a new policy, 𝜋𝜋′ , that, for each state, s, following 𝜋𝜋′ , would yield higher or at least equal value than using the current policy, 𝜋𝜋 . In mathematical terms, we can express this objective for the improved policy, 𝜋𝜋′ , as: 𝑣𝑣𝜋𝜋′(𝑠𝑠)≥𝑣𝑣 𝜋𝜋(𝑠𝑠) ∀𝑠𝑠 𝑠 𝑠𝑠 ̂ First, recall that a policy, 𝜋𝜋 , determines the probability of choosing each action, a , while the agent is at state s. Now, in order to find 𝜋𝜋′ that always has a better or equal value for each state, we first compute the action-value function, 𝑞𝑞𝜋𝜋(𝑠𝑠𝑠𝑠𝑠) , for each state, s, and action, a, based on the computed state value using the value function 𝑣𝑣𝜋𝜋(𝑠𝑠) . We iterate through all the states, and for each state, s, we compare the value of the next state, s′, that would occur if action a was selected. After we have obtained the highest state value by evaluating all state-action pairs via 𝑞𝑞𝜋𝜋(𝑠𝑠𝑠𝑠𝑠) , we can compare the corresponding action with the action selected by the current policy. If the action suggested by the current policy (that is, arg max 𝑎𝑎𝜋𝜋(𝑎𝑎|𝑠𝑠) ) is different than the action suggested by the action-value function ( that is, arg max 𝑎𝑎𝑞𝑞𝜋𝜋(𝑠𝑠𝑠 𝑠𝑠) ), then we can update the policy by reassigning the probabilities of actions to match the action that gives the highest action value, 𝑞𝑞𝜋𝜋(𝑠𝑠𝑠𝑠𝑠) . This is called the policy improvement algorithm. Chapter 19 687 Policy iteration Using the policy improvement algorithm described in the previous subsection, it can be shown", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 616, "start_word": 197120, "end_word": 197520, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000617": {"text": "action suggested by the current policy (that is, arg max 𝑎𝑎𝜋𝜋(𝑎𝑎|𝑠𝑠) ) is different than the action suggested by the action-value function ( that is, arg max 𝑎𝑎𝑞𝑞𝜋𝜋(𝑠𝑠𝑠 𝑠𝑠) ), then we can update the policy by reassigning the probabilities of actions to match the action that gives the highest action value, 𝑞𝑞𝜋𝜋(𝑠𝑠𝑠𝑠𝑠) . This is called the policy improvement algorithm. Chapter 19 687 Policy iteration Using the policy improvement algorithm described in the previous subsection, it can be shown that the policy improvement will strictly yield a better policy, unless the current policy is already optimal (which means 𝑣𝑣𝜋𝜋(𝑠𝑠)=𝑣𝑣𝜋𝜋′(𝑠𝑠)=𝑣𝑣∗(𝑠𝑠) for each 𝑠𝑠𝑠𝑠𝑠̂ ). Therefore, if we iteratively perform policy evalu- ation followed by policy improvement, we are guaranteed to find the optimal policy. Value iteration We saw that by repeating the policy evaluation (compute 𝑣𝑣𝜋𝜋(𝑠𝑠) and 𝑞𝑞𝜋𝜋(𝑠𝑠𝑠𝑠𝑠) ) and policy improvement (finding 𝜋𝜋′ such that 𝑣𝑣𝜋𝜋′(𝑠𝑠)≥𝑣𝑣 𝜋𝜋(𝑠𝑠) ∀𝑠𝑠 𝑠 𝑠𝑠 ̂ ), we can reach the optimal policy. However, it can be more efficient if we combine the two tasks of policy evaluation and policy improvement into a single step. The following equation updates the value function for iteration i + 1 (denoted by 𝑣𝑣〈𝑖𝑖𝑖𝑖〉 ) based on the action that maximizes the weighted sum of the next state value and its immediate reward ( 𝑟𝑟𝑟𝑟𝑟𝑟𝑟〈𝑖𝑖〉(𝑠𝑠′) ): 𝑣𝑣〈𝑖𝑖𝑖𝑖〉(𝑠𝑠)= max 𝑎𝑎∑𝑝𝑝(𝑠𝑠′,𝑟𝑟|𝑠𝑠,𝑠𝑠)[𝑟𝑟 𝑟𝑟𝑟𝑣𝑣〈𝑖𝑖〉(𝑠𝑠′)] 𝑠𝑠′,𝑟𝑟 In this case, the updated value for 𝑣𝑣〈𝑖𝑖𝑖𝑖〉(𝑠𝑠) is maximized by choosing the best action out of all possible actions, whereas in policy evaluation, the updated value was using the weighted sum over all actions. Reinforcement learning with Monte Carlo As we saw in the previous section, dynamic programming relies on a simplistic assumption that the environment’s dynamics are fully known. Moving away from the dynamic programming approach, we now assume that we do not have any knowledge about the environment dynamics. That is, we do not know the state-transition probabilities of the environment, and instead, we want the agent to learn through interacting with the environment. Using MC methods, the learning process is based on the so-called simulated experience.Note that this technique is referred to as generalized policy iteration ( GPI), which is common among many RL methods. We will use the GPI in later sections of this chapter for the MC and TD learning methods. Notation for tabular estimates of the state-value and action-value functions In most RL literature and textbooks, the lowercase 𝑣𝑣𝜋𝜋 and", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 617, "start_word": 197440, "end_word": 197840, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000618": {"text": "want the agent to learn through interacting with the environment. Using MC methods, the learning process is based on the so-called simulated experience.Note that this technique is referred to as generalized policy iteration ( GPI), which is common among many RL methods. We will use the GPI in later sections of this chapter for the MC and TD learning methods. Notation for tabular estimates of the state-value and action-value functions In most RL literature and textbooks, the lowercase 𝑣𝑣𝜋𝜋 and 𝑞𝑞𝜋𝜋 are used to refer to the true state-value and true action-value functions, respectively, as mathematical functions. Meanwhile, for practical implementations, these value functions are defined as lookup tables. The tabular estimates of these value functions are denoted by 𝑉𝑉(𝑆𝑆𝑡𝑡=𝑠𝑠)≈𝑣𝑣𝜋𝜋(𝑠𝑠) and 𝑄𝑄𝜋𝜋(𝑆𝑆𝑡𝑡= 𝑠𝑠𝑠𝑠𝑠𝑡𝑡=𝑎𝑎)≈𝑞𝑞𝜋𝜋(𝑠𝑠𝑠𝑎𝑎) . We will also use this notation in this chapter. Reinforcement Learning for Decision Making in Complex Environments 688 For MC-based RL, we define an agent class that follows a probabilistic policy, 𝜋𝜋 , and based on this policy, our agent takes an action at each step. This results in a simulated episode. Earlier, we defined the state-value function, such that the value of a state indicates the expected return from that state. In dynamic programming, this computation relied on the knowledge of the environ- ment dynamics, that is, 𝑝𝑝(𝑠𝑠′,𝑟𝑟|𝑠𝑠,𝑠𝑠) . However, from now on, we will develop algorithms that do not require the environment dynamics. MC-based methods solve this problem by generating simulated episodes where an agent interacts with the environment. From these simulated episodes, we will be able to compute the average return for each state visited in that simulated episode. State-value function estimation using MC After generating a set of episodes, for each state, s, the set of episodes that all pass through state s is considered for calculating the value of state s. Let’s assume that a lookup table is used for obtaining the value corresponding to the value function, 𝑉𝑉(𝑆𝑆𝑡𝑡=𝑠𝑠) . MC updates for estimating the value function are based on the total return obtained in that episode starting from the first time that state s is visited. This algorithm is called first-visit Monte Carlo value prediction. Action-value function estimation using MC When the environment dynamics are known, we can easily infer the action-value function from a state-value function by looking one step ahead to find the action that gives the maximum value, as was shown in the Dynamic programming section. However,", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 618, "start_word": 197760, "end_word": 198160, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000619": {"text": "updates for estimating the value function are based on the total return obtained in that episode starting from the first time that state s is visited. This algorithm is called first-visit Monte Carlo value prediction. Action-value function estimation using MC When the environment dynamics are known, we can easily infer the action-value function from a state-value function by looking one step ahead to find the action that gives the maximum value, as was shown in the Dynamic programming section. However, this is not feasible if the environment dynamics are unknown. To solve this issue, we can extend the algorithm for estimating the first-visit MC state-value prediction. For instance, we can compute the estimated return for each state-action pair using the action-value function. To obtain this estimated return, we consider visits to each state-action pair (s , a), which refers to visiting state s and taking action a. However, a problem arises since some actions may never be selected, resulting in insufficient explo - ration. There are a few ways to resolve this. The simplest approach is called exploratory start, which assumes that every state-action pair has a non-zero probability at the beginning of the episode. Another approach for dealing with this lack-of-exploration issue is called the 𝜖𝜖 -greedy policy, which will be discussed in the next section on policy improvement. Finding an optimal policy using MC control MC control refers to the optimization procedure for improving a policy. Similar to the policy iteration approach in the previous section (Dynamic programming), we can repeatedly alternate between policy evaluation and policy improvement until we reach the optimal policy. So, starting from a random policy, 𝜋𝜋0 , the process of alternating between policy evaluation and policy improvement can be illus- trated as follows: 𝜋𝜋0𝐸𝐸𝐸𝐸𝐸𝐸𝐸𝐸𝐸→ 𝑞𝑞𝜋𝜋0𝐼𝐼𝐼𝐼𝐼𝐼𝐼𝐼𝐼𝐼𝐸𝐸𝐼𝐼→ 𝜋𝜋1𝐸𝐸𝐸𝐸𝐸𝐸𝐸𝐸𝐸→ 𝑞𝑞𝜋𝜋1𝐼𝐼𝐼𝐼𝐼𝐼𝐼𝐼𝐼𝐼𝐸𝐸𝐼𝐼→ 𝜋𝜋2 … 𝐸𝐸𝐸𝐸𝐸𝐸𝐸𝐸𝐸→ 𝑞𝑞∗𝐼𝐼𝐼𝐼𝐼𝐼𝐼𝐼𝐼𝐼𝐸𝐸𝐼𝐼→ 𝜋𝜋∗ Chapter 19 689 Policy improvement – computing the greedy policy from the action- value function Given an action-value function, q(s, a), we can generate a greedy (deterministic) policy as follows: 𝜋𝜋(𝑠𝑠)≝ arg max 𝑎𝑎𝑞𝑞(𝑠𝑠𝑠 𝑠𝑠) To avoid the lack-of-exploration problem, and to consider the non-visited state-action pairs as discussed earlier, we can let the non-optimal actions have a small chance ( 𝜖𝜖 ) to be chosen. This is called the 𝜖𝜖 -greedy policy, according to which, all non-optimal actions at state s have a minimal 𝜖𝜖 |𝐴𝐴(𝑠𝑠)| probability of being selected (instead of 0), and the optimal action has a probability", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 619, "start_word": 198080, "end_word": 198480, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000620": {"text": "we can generate a greedy (deterministic) policy as follows: 𝜋𝜋(𝑠𝑠)≝ arg max 𝑎𝑎𝑞𝑞(𝑠𝑠𝑠 𝑠𝑠) To avoid the lack-of-exploration problem, and to consider the non-visited state-action pairs as discussed earlier, we can let the non-optimal actions have a small chance ( 𝜖𝜖 ) to be chosen. This is called the 𝜖𝜖 -greedy policy, according to which, all non-optimal actions at state s have a minimal 𝜖𝜖 |𝐴𝐴(𝑠𝑠)| probability of being selected (instead of 0), and the optimal action has a probability of 1−(|𝐴𝐴(𝑠𝑠)|−1)×𝜖𝜖 |𝐴𝐴(𝑠𝑠)| (instead of 1). Temporal difference learning So far, we have seen two fundamental RL techniques—dynamic programming and MC-based learning. Recall that dynamic programming relies on the complete and accurate knowledge of the environment dynamics. The MC-based method, on the other hand, learns by simulated experience. In this section, we will now introduce a third RL method called TD learning, which can be considered as an improve - ment or extension of the MC-based RL approach. Similar to the MC technique, TD learning is also based on learning by experience and, therefore, does not require any knowledge of environment dynamics and transition probabilities. The main difference between the TD and MC techniques is that in MC, we have to wait until the end of the episode to be able to calculate the total return. However, in TD learning, we can leverage some of the learned properties to update the estimated values before reaching the end of the episode. This is called bootstrapping (in the context of RL, the term bootstrapping is not to be confused with the bootstrap estimates we used in Chapter 7, Combining Different Models for Ensemble Learning). Similar to the dynamic programming approach and MC-based learning, we will consider two tasks: estimating the value function (which is also called value prediction) and improving the policy (which is also called the control task). TD prediction Let’s first revisit the value prediction by MC. At the end of each episode, we are able to estimate the return, Gt, for each time step t . Therefore, we can update our estimates for the visited states as follows: 𝑉𝑉(𝑆𝑆𝑡𝑡)←𝑉𝑉(𝑆𝑆𝑡𝑡)+𝛼𝛼(𝐺𝐺𝑡𝑡−𝑉𝑉(𝑆𝑆𝑡𝑡)) Here, Gt is used as the target return to update the estimated values, and (G t – V(S t)) is a correction term added to our current estimate of the value V (St). The value 𝛼𝛼 is a hyperparameter denoting the learning rate, which is kept constant during learning. Reinforcement", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 620, "start_word": 198400, "end_word": 198800, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000621": {"text": "of each episode, we are able to estimate the return, Gt, for each time step t . Therefore, we can update our estimates for the visited states as follows: 𝑉𝑉(𝑆𝑆𝑡𝑡)←𝑉𝑉(𝑆𝑆𝑡𝑡)+𝛼𝛼(𝐺𝐺𝑡𝑡−𝑉𝑉(𝑆𝑆𝑡𝑡)) Here, Gt is used as the target return to update the estimated values, and (G t – V(S t)) is a correction term added to our current estimate of the value V (St). The value 𝛼𝛼 is a hyperparameter denoting the learning rate, which is kept constant during learning. Reinforcement Learning for Decision Making in Complex Environments 690 Notice that in MC, the correction term uses the actual return, G t, which is not known until the end of the episode. To clarify this, we can rename the actual return, G t, to G t:T, where the subscript t:T indicates that this is the return obtained at time step t while considering all the events that occurred from time step t until the final time step, T. In TD learning, we replace the actual return, Gt:T, with a new target return, G t:t+1, which significantly simplifies the updates for the value function, V(S t). The update formula based on TD learning is as follows: 𝑉𝑉(𝑆𝑆𝑡𝑡)←𝑉𝑉(𝑆𝑆𝑡𝑡)+𝛼𝛼(𝐺𝐺𝑡𝑡𝑡𝑡𝑡𝑡𝑡−𝑉𝑉(𝑆𝑆𝑡𝑡)) Here, the target return, 𝐺𝐺𝑡𝑡𝑡𝑡𝑡𝑡𝑡≝𝑅𝑅𝑡𝑡𝑡𝑡+𝛾𝛾𝛾𝛾(𝑆𝑆𝑡𝑡𝑡𝑡)=𝑟𝑟+𝛾𝛾𝛾𝛾(𝑆𝑆𝑡𝑡𝑡𝑡) , is using the observed reward, R t+1, and the estimated value of the next immediate step. Notice the difference between MC and TD. In MC, Gt:T is not available until the end of the episode, so we should execute as many steps as needed to get there. On the contrary, in TD, we only need to go one step ahead to get the target return. This is also known as TD(0). Furthermore, the TD(0) algorithm can be generalized to the so-called n-step TD algorithm, which in- corporates more future steps—more precisely, the weighted sum of n future steps. If we define n = 1, then the n-step TD procedure is identical to TD(0), which was described in the previous paragraph. If 𝑛𝑛𝑛𝑛 , however, the n-step TD algorithm will be the same as the MC algorithm. The update rule for n-step TD is as follows: 𝑉𝑉(𝑆𝑆𝑡𝑡)←𝑉𝑉(𝑆𝑆𝑡𝑡)+𝛼𝛼(𝐺𝐺𝑡𝑡𝑡𝑡𝑡𝑡𝑡𝑡−𝑉𝑉(𝑆𝑆𝑡𝑡)) And G t:t+n is defined as: 𝐺𝐺𝑡𝑡𝑡𝑡𝑡𝑡𝑡𝑡 ≝{𝑅𝑅𝑡𝑡𝑡𝑡+ 𝛾𝛾𝑅𝑅 𝑡𝑡𝑡𝑡+⋯+𝛾𝛾𝑡𝑡𝑛𝑡𝑅𝑅𝑡𝑡𝑡𝑡𝑡+𝛾𝛾𝑡𝑡𝑉𝑉(𝑆𝑆𝑡𝑡𝑡𝑡𝑡)if 𝑡𝑡+𝑡𝑡𝑡𝑡𝑡 𝐺𝐺𝑡𝑡𝑡𝑡𝑡 otherwise Now that we have covered the prediction task using the TD algorithm, we can move on to the control task. We will cover two algorithms for TD control: an on-policy control and an off-policy control. In both cases, we use", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 621, "start_word": 198720, "end_word": 199120, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000622": {"text": "paragraph. If 𝑛𝑛𝑛𝑛 , however, the n-step TD algorithm will be the same as the MC algorithm. The update rule for n-step TD is as follows: 𝑉𝑉(𝑆𝑆𝑡𝑡)←𝑉𝑉(𝑆𝑆𝑡𝑡)+𝛼𝛼(𝐺𝐺𝑡𝑡𝑡𝑡𝑡𝑡𝑡𝑡−𝑉𝑉(𝑆𝑆𝑡𝑡)) And G t:t+n is defined as: 𝐺𝐺𝑡𝑡𝑡𝑡𝑡𝑡𝑡𝑡 ≝{𝑅𝑅𝑡𝑡𝑡𝑡+ 𝛾𝛾𝑅𝑅 𝑡𝑡𝑡𝑡+⋯+𝛾𝛾𝑡𝑡𝑛𝑡𝑅𝑅𝑡𝑡𝑡𝑡𝑡+𝛾𝛾𝑡𝑡𝑉𝑉(𝑆𝑆𝑡𝑡𝑡𝑡𝑡)if 𝑡𝑡+𝑡𝑡𝑡𝑡𝑡 𝐺𝐺𝑡𝑡𝑡𝑡𝑡 otherwise Now that we have covered the prediction task using the TD algorithm, we can move on to the control task. We will cover two algorithms for TD control: an on-policy control and an off-policy control. In both cases, we use the GPI that was used in both the dynamic programming and MC algorithms. In on-policy TD control, the value function is updated based on the actions from the same policy that the agent is following; while in an off-policy algorithm, the value function is updated based on actions outside the current policy.MC versus TD: which method converges faster? While the precise answer to this question is still unknown, in practice, it is empirically shown that TD can converge faster than MC. If you are interested, you can find more de - tails on the convergences of MC and TD in the book entitled Reinforcement Learning: An Introduction, by Richard S. Sutton and Andrew G. Barto. Chapter 19 691 On-policy TD control (SARSA) For simplicity, we only consider the one-step TD algorithm, or TD(0). However, the on-policy TD control algorithm can be readily generalized to n-step TD. We will start by extending the prediction formula for defining the state-value function to describe the action-value function. To do this, we use a lookup table, that is, a tabular 2D array, Q(St, At), which represents the action-value function for each state-action pair. In this case, we will have the following: 𝑄𝑄(𝑆𝑆𝑡𝑡,𝐴𝐴𝑡𝑡)←𝑄𝑄(𝑆𝑆𝑡𝑡,𝐴𝐴𝑡𝑡)+𝛼𝛼[𝑅𝑅𝑡𝑡𝑡𝑡+𝛾𝛾𝑄𝑄(𝑆𝑆𝑡𝑡𝑡𝑡,𝐴𝐴𝑡𝑡𝑡𝑡)−𝑄𝑄(𝑆𝑆𝑡𝑡,𝐴𝐴𝑡𝑡)] This algorithm is often called SARSA, referring to the quintuple (S t, At, Rt+1, St+1, At+1) that is used in the update formula. As we saw in the previous sections describing the dynamic programming and MC algorithms, we can use the GPI framework, and starting from the random policy, we can repeatedly estimate the action-value function for the current policy and then optimize the policy using the 𝜖𝜖 -greedy policy based on the current action-value function. Off-policy TD control (Q-learning) We saw when using the previous on-policy TD control algorithm that how we estimate the action-value function is based on the policy that is used in the simulated episode. After updating the action-value function, a separate step for policy improvement is performed", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 622, "start_word": 199040, "end_word": 199440, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000623": {"text": "framework, and starting from the random policy, we can repeatedly estimate the action-value function for the current policy and then optimize the policy using the 𝜖𝜖 -greedy policy based on the current action-value function. Off-policy TD control (Q-learning) We saw when using the previous on-policy TD control algorithm that how we estimate the action-value function is based on the policy that is used in the simulated episode. After updating the action-value function, a separate step for policy improvement is performed by taking the action that has the higher value. An alternative (and better) approach is to combine these two steps. In other words, imagine the agent is following policy 𝜋𝜋 , generating an episode with the current transition quintuple (S t, At, Rt+1, St+1, At+1). Instead of updating the action-value function using the action value of A t+1 that is taken by the agent, we can find the best action even if it is not actually chosen by the agent following the current policy. (That’s why this is considered an off-policy algorithm.) To do this, we can modify the update rule to consider the maximum Q-value by varying different actions in the next immediate state. The modified equation for updating the Q-values is as follows: 𝑄𝑄(𝑆𝑆𝑡𝑡,𝐴𝐴𝑡𝑡)←𝑄𝑄(𝑆𝑆𝑡𝑡,𝐴𝐴𝑡𝑡)+𝛼𝛼[𝑅𝑅𝑡𝑡𝑡𝑡+𝛾𝛾𝛾𝛾𝛾 𝑎𝑎𝑄𝑄(𝑆𝑆𝑡𝑡𝑡𝑡,𝑎𝑎)−𝑄𝑄(𝑆𝑆𝑡𝑡,𝐴𝐴𝑡𝑡)] We encourage you to compare the update rule here with that of the SARSA algorithm. As you can see, we find the best action in the next state, S t+1, and use that in the correction term to update our estimate of Q(S t, A t). To put these materials into perspective, in the next section, we will see how to implement the Q-learn- ing algorithm for solving a grid world problem. Implementing our first RL algorithm In this section, we will cover the implementation of the Q-learning algorithm to solve a grid world problem (a grid world is a two-dimensional, cell-based environment where the agent moves in four directions to collect as much reward as possible). To do this, we use the OpenAI Gym toolkit. Reinforcement Learning for Decision Making in Complex Environments 692 Introducing the OpenAI Gym toolkit OpenAI Gym is a specialized toolkit for facilitating the development of RL models. OpenAI Gym comes with several predefined environments. Some basic examples are CartPole and MountainCar, where the tasks are to balance a pole and to move a car up a hill, respectively, as the names suggest. There are also many advanced", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 623, "start_word": 199360, "end_word": 199760, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000624": {"text": "much reward as possible). To do this, we use the OpenAI Gym toolkit. Reinforcement Learning for Decision Making in Complex Environments 692 Introducing the OpenAI Gym toolkit OpenAI Gym is a specialized toolkit for facilitating the development of RL models. OpenAI Gym comes with several predefined environments. Some basic examples are CartPole and MountainCar, where the tasks are to balance a pole and to move a car up a hill, respectively, as the names suggest. There are also many advanced robotics environments for training a robot to fetch, push, and reach for items on a bench or training a robotic hand to orient blocks, balls, or pens. Moreover, OpenAI Gym provides a convenient, unified framework for developing new environments. More information can be found on its official website: https://gym.openai.com/ . To follow the OpenAI Gym code examples in the next sections, you need to install the gym library (at the time of writing, version 0.20.0 was used), which can be easily done using pip: pip install gym==0.20 If you need additional help with the installation, please refer to the official installation guide at https:// gym.openai.com/docs/#installation . Working with the existing environments in OpenAI Gym For practice with the Gym environments, let’s create an environment from CartPole-v1 , which already exists in OpenAI Gym. In this example environment, there is a pole attached to a cart that can move horizontally, as shown in Figure 19.6: Figure 19.6: The CartPole example in Gym The movements of the pole are governed by the laws of physics, and the goal for RL agents is to learn how to move the cart to stabilize the pole and prevent it from tipping over to either side. Now, let’s look at some properties of the CartPole environment in the context of RL, such as its state (or observation) space, action space, and how to execute an action: >>> import gym >>> env = gym.make( 'CartPole-v1' ) >>> env.observation_space Box(-3.4028234663852886e+38, 3.4028234663852886e+38, (4,), float32) >>> env.action_space Discrete(2) Chapter 19 693 In the preceding code, we created an environment for the CartPole problem. The observation space for this environment is Box(4,) (with float values from -inf to inf), which represents a four-dimensional space corresponding to four real-valued numbers: the position of the cart, the cart’s velocity, the angle of the pole, and the velocity of the tip of the pole. The action space is a discrete space, Discrete(2) , with", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 624, "start_word": 199680, "end_word": 200080, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000625": {"text": "env.observation_space Box(-3.4028234663852886e+38, 3.4028234663852886e+38, (4,), float32) >>> env.action_space Discrete(2) Chapter 19 693 In the preceding code, we created an environment for the CartPole problem. The observation space for this environment is Box(4,) (with float values from -inf to inf), which represents a four-dimensional space corresponding to four real-valued numbers: the position of the cart, the cart’s velocity, the angle of the pole, and the velocity of the tip of the pole. The action space is a discrete space, Discrete(2) , with two choices: pushing the cart either to the left or to the right. The environment object, env, that we previously created by calling gym.make('CartPole-v1') has a reset() method that we can use to reinitialize an environment prior to each episode. Calling the reset() method will basically set the pole’s starting state (S 0): >>> env.reset() array([-0.03908273, -0.00837535, 0.03277162, -0.0207195 ]) The values in the array returned by the env.reset() method call mean that the initial position of the cart is –0.039, with a velocity –0.008, and the angle of the pole is 0.033 radians, while the angular velocity of its tip is –0.021. Upon calling the reset() method, these values are initialized with random values with uniform distribution in the range [–0.05, 0.05]. After resetting the environment, we can interact with the environment by choosing an action and executing it by passing the action to the step() method: >>> env.step(action= 0) (array([-0.03925023, -0.20395158, 0.03235723, 0.28212046]), 1.0, False, {}) >>> env.step(action= 1) (array([-0.04332927, -0.00930575, 0.03799964, -0.00018409]), 1.0, False, {}) Via the previous two commands, env.step(action=0) and env.step(action=1) , we pushed the cart to the left ( action=0 ) and then to the right ( action=1 ), respectively. Based on the selected action, the cart and its pole can move as governed by the laws of physics. Every time we call env.step() , it returns a tuple consisting of four elements: • An array for the new state (or observations) • A reward (a scalar value of type float ) • A termination flag ( True or False ) • A Python dictionary containing auxiliary information The env object also has a render() method, which we can execute after each step (or a series of steps) to visualize the environment and the movements of the pole and cart, through time. The episode terminates when the angle of the pole becomes larger than 12 degrees (from either side) with respect to an imaginary", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 625, "start_word": 200000, "end_word": 200400, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000626": {"text": "reward (a scalar value of type float ) • A termination flag ( True or False ) • A Python dictionary containing auxiliary information The env object also has a render() method, which we can execute after each step (or a series of steps) to visualize the environment and the movements of the pole and cart, through time. The episode terminates when the angle of the pole becomes larger than 12 degrees (from either side) with respect to an imaginary vertical axis, or when the position of the cart is more than 2.4 units from the center position. The reward defined in this example is to maximize the time the cart and pole are stabilized within the valid regions—in other words, the total reward (that is, return) can be maximized by maximizing the length of the episode. Reinforcement Learning for Decision Making in Complex Environments 694 A grid world example After introducing the CartPole environment as a warm-up exercise for working with the OpenAI Gym toolkit, we will now switch to a different environment. We will work with a grid world example, which is a simplistic environment with m rows and n columns. Considering m = 5 and n = 6, we can summarize this environment as shown in Figure 19.7: Figure 19.7: An example of a grid world environment In this environment, there are 30 different possible states. Four of these states are terminal states: a pot of gold at state 16 and three traps at states 10, 15, and 22. Landing in any of these four terminal states will end the episode, but with a difference between the gold and trap states. Landing on the gold state yields a positive reward, +1, whereas moving the agent onto one of the trap states yields a negative reward, –1. All other states have a reward of 0. The agent always starts from state 0. Therefore, every time we reset the environment, the agent will go back to state 0. The action space consists of four directions: move up, down, left, and right. When the agent is at the outer boundary of the grid, selecting an action that would result in leaving the grid will not change the state. Next, we will see how to implement this environment in Python using the OpenAI Gym package. Implementing the grid world environment in OpenAI Gym For experimenting with the grid world environment via", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 626, "start_word": 200320, "end_word": 200720, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000627": {"text": "environment, the agent will go back to state 0. The action space consists of four directions: move up, down, left, and right. When the agent is at the outer boundary of the grid, selecting an action that would result in leaving the grid will not change the state. Next, we will see how to implement this environment in Python using the OpenAI Gym package. Implementing the grid world environment in OpenAI Gym For experimenting with the grid world environment via OpenAI Gym, using a script editor or IDE rather than executing the code interactively is highly recommended. First, we create a new Python script named gridworld_env.py and then proceed by importing the necessary packages and two helper functions that we define for building the visualization of the environment. To render the environments for visualization purposes, the OpenAI Gym library uses the pyglet library and provides wrapper classes and functions for our convenience. We will use these wrapper classes for visualizing the grid world environment in the following code example. More details about these wrapper classes can be found at https://github.com/openai/gym/blob/58ed658d9b15fd410c50d1 fdb25a7cad9acb7fa4/gym/envs/classic_control/rendering.py . Chapter 19 695 The following code example uses those wrapper classes: ## Script: gridworld_env.py import numpy as np from gym.envs.toy_text import discrete from collections import defaultdict import time import pickle import os from gym.envs.classic_control import rendering CELL_SIZE = 100 MARGIN = 10 def get_coords (row, col, loc= 'center' ): xc = (col+ 1.5) * CELL_SIZE yc = (row+ 1.5) * CELL_SIZE if loc == 'center' : return xc, yc elif loc == 'interior_corners' : half_size = CELL_SIZE// 2 - MARGIN xl, xr = xc - half_size, xc + half_size yt, yb = xc - half_size, xc + half_size return [(xl, yt), (xr, yt), (xr, yb), (xl, yb)] elif loc == 'interior_triangle' : x1, y1 = xc, yc + CELL_SIZE// 3 x2, y2 = xc + CELL_SIZE// 3, yc - CELL_SIZE// 3 x3, y3 = xc - CELL_SIZE// 3, yc - CELL_SIZE// 3 return [(x1, y1), (x2, y2), (x3, y3)] def draw_object (coords_list): if len(coords_list) == 1: # -> circle obj = rendering.make_circle( int(0.45*CELL_SIZE)) obj_transform = rendering.Transform() obj.add_attr(obj_transform) obj_transform.set_translation(*coords_list[ 0]) obj.set_color( 0.2, 0.2, 0.2) # -> black elif len(coords_list) == 3: # -> triangle obj = rendering.FilledPolygon(coords_list) obj.set_color( 0.9, 0.6, 0.2) # -> yellow elif len(coords_list) > 3: # -> polygon obj = rendering.FilledPolygon(coords_list) Reinforcement Learning for Decision Making in Complex Environments 696 obj.set_color( 0.4, 0.4, 0.8) # ->", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 627, "start_word": 200640, "end_word": 201040, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000628": {"text": "yc - CELL_SIZE// 3 return [(x1, y1), (x2, y2), (x3, y3)] def draw_object (coords_list): if len(coords_list) == 1: # -> circle obj = rendering.make_circle( int(0.45*CELL_SIZE)) obj_transform = rendering.Transform() obj.add_attr(obj_transform) obj_transform.set_translation(*coords_list[ 0]) obj.set_color( 0.2, 0.2, 0.2) # -> black elif len(coords_list) == 3: # -> triangle obj = rendering.FilledPolygon(coords_list) obj.set_color( 0.9, 0.6, 0.2) # -> yellow elif len(coords_list) > 3: # -> polygon obj = rendering.FilledPolygon(coords_list) Reinforcement Learning for Decision Making in Complex Environments 696 obj.set_color( 0.4, 0.4, 0.8) # -> blue return obj The first helper function, get_coords() , returns the coordinates of the geometric shapes that we will use to annotate the grid world environment, such as a triangle to display the gold or circles to display the traps. The list of coordinates is passed to draw_object() , which decides to draw a circle, a triangle, or a polygon based on the length of the input list of coordinates. Now, we can define the grid world environment. In the same file ( gridworld_env.py ), we define a class named GridWorldEnv , which inherits from OpenAI Gym’s DiscreteEnv class. The most import- ant function of this class is the constructor method, __init__() , where we define the action space, specify the role of each action, and determine the terminal states (gold as well as traps) as follows: class GridWorldEnv (discrete.DiscreteEnv): def __init__ (self, num_rows= 4, num_cols= 6, delay= 0.05): self.num_rows = num_rows self.num_cols = num_cols self.delay = delay move_up = lambda row, col: ( max(row-1, 0), col) move_down = lambda row, col: ( min(row+1, num_rows- 1), col) move_left = lambda row, col: (row, max(col-1, 0)) move_right = lambda row, col: ( row, min(col+1, num_cols- 1)) self.action_defs={ 0: move_up, 1: move_right, 2: move_down, 3: move_left} ## Number of states/actions nS = num_cols*num_rows nA = len(self.action_defs) self.grid2state_dict={(s//num_cols, s%num_cols):s for s in range (nS)} self.state2grid_dict={s:(s//num_cols, s%num_cols)Using Gym 0.22 or newer Note that gym is currently undergoing some internal restructuring. In version 0.22 and newer, you may have to update the previous code example (from gridworld_env.py) and replace the following line from gym.envs.classic_control import rendering with the following code: from gym.utils import pyglet_rendering For more details, please refer to the code repository at https://github.com/rasbt/ machine-learning-book/tree/main/ch19 Chapter 19 697 for s in range (nS)} ## Gold state gold_cell = (num_rows// 2, num_cols- 2) ## Trap states trap_cells = [((gold_cell[ 0]+1), gold_cell[ 1]), (gold_cell[ 0], gold_cell[ 1]-1), ((gold_cell[ 0]-1), gold_cell[ 1])] gold_state = self.grid2state_dict[gold_cell] trap_states =", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 628, "start_word": 200960, "end_word": 201360, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000629": {"text": "newer, you may have to update the previous code example (from gridworld_env.py) and replace the following line from gym.envs.classic_control import rendering with the following code: from gym.utils import pyglet_rendering For more details, please refer to the code repository at https://github.com/rasbt/ machine-learning-book/tree/main/ch19 Chapter 19 697 for s in range (nS)} ## Gold state gold_cell = (num_rows// 2, num_cols- 2) ## Trap states trap_cells = [((gold_cell[ 0]+1), gold_cell[ 1]), (gold_cell[ 0], gold_cell[ 1]-1), ((gold_cell[ 0]-1), gold_cell[ 1])] gold_state = self.grid2state_dict[gold_cell] trap_states = [self.grid2state_dict[(r, c)] for (r, c) in trap_cells] self.terminal_states = [gold_state] + trap_states print(self.terminal_states) ## Build the transition probability P = defaultdict( dict) for s in range (nS): row, col = self.state2grid_dict[s] P[s] = defaultdict( list) for a in range (nA): action = self.action_defs[a] next_s = self.grid2state_dict[action(row, col)] ## Terminal state if self.is_terminal(next_s): r = ( 1.0 if next_s == self.terminal_states[ 0] else -1.0) else: r = 0.0 if self.is_terminal(s): done = True next_s = s else: done = False P[s][a] = [( 1.0, next_s, r, done)] ## Initial state distribution isd = np.zeros(nS) isd[ 0] = 1.0 super().__init__(nS, nA, P, isd) self.viewer = None self._build_display(gold_cell, trap_cells) Reinforcement Learning for Decision Making in Complex Environments 698 def is_terminal (self, state): return state in self.terminal_states def _build_display (self, gold_cell, trap_cells): screen_width = (self.num_cols+ 2) * CELL_SIZE screen_height = (self.num_rows+ 2) * CELL_SIZE self.viewer = rendering.Viewer(screen_width, screen_height) all_objects = [] ## List of border points' coordinates bp_list = [ (CELL_SIZE-MARGIN, CELL_SIZE-MARGIN), (screen_width-CELL_SIZE+MARGIN, CELL_SIZE-MARGIN), (screen_width-CELL_SIZE+MARGIN, screen_height-CELL_SIZE+MARGIN), (CELL_SIZE-MARGIN, screen_height-CELL_SIZE+MARGIN) ] border = rendering.PolyLine(bp_list, True) border.set_linewidth( 5) all_objects.append(border) ## Vertical lines for col in range (self.num_cols+ 1): x1, y1 = (col+ 1)*CELL_SIZE, CELL_SIZE x2, y2 = (col+ 1)*CELL_SIZE,\\ (self.num_rows+ 1)*CELL_SIZE line = rendering.PolyLine([(x1, y1), (x2, y2)], False) all_objects.append(line) ## Horizontal lines for row in range (self.num_rows+ 1): x1, y1 = CELL_SIZE, (row+ 1)*CELL_SIZE x2, y2 = (self.num_cols+ 1)*CELL_SIZE,\\ (row+ 1)*CELL_SIZE line=rendering.PolyLine([(x1, y1), (x2, y2)], False) all_objects.append(line) ## Traps: --> circles for cell in trap_cells: trap_coords = get_coords(*cell, loc= 'center' ) all_objects.append(draw_object([trap_coords])) Chapter 19 699 ## Gold: --> triangle gold_coords = get_coords(*gold_cell, loc= 'interior_triangle' ) all_objects.append(draw_object(gold_coords)) ## Agent --> square or robot if (os.path.exists( 'robot-coordinates.pkl' ) and CELL_SIZE== 100): agent_coords = pickle.load( open('robot-coordinates.pkl' , 'rb')) starting_coords = get_coords( 0, 0, loc= 'center' ) agent_coords += np.array(starting_coords) else: agent_coords = get_coords( 0, 0, loc= 'interior_corners' ) agent = draw_object(agent_coords) self.agent_trans = rendering.Transform() agent.add_attr(self.agent_trans) all_objects.append(agent) for obj in all_objects: self.viewer.add_geom(obj) def render(self, mode= 'human', done=False): if done: sleep_time =", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 629, "start_word": 201280, "end_word": 201680, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000630": {"text": "get_coords(*cell, loc= 'center' ) all_objects.append(draw_object([trap_coords])) Chapter 19 699 ## Gold: --> triangle gold_coords = get_coords(*gold_cell, loc= 'interior_triangle' ) all_objects.append(draw_object(gold_coords)) ## Agent --> square or robot if (os.path.exists( 'robot-coordinates.pkl' ) and CELL_SIZE== 100): agent_coords = pickle.load( open('robot-coordinates.pkl' , 'rb')) starting_coords = get_coords( 0, 0, loc= 'center' ) agent_coords += np.array(starting_coords) else: agent_coords = get_coords( 0, 0, loc= 'interior_corners' ) agent = draw_object(agent_coords) self.agent_trans = rendering.Transform() agent.add_attr(self.agent_trans) all_objects.append(agent) for obj in all_objects: self.viewer.add_geom(obj) def render(self, mode= 'human', done=False): if done: sleep_time = 1 else: sleep_time = self.delay x_coord = self.s % self.num_cols y_coord = self.s // self.num_cols x_coord = (x_coord+ 0) * CELL_SIZE y_coord = (y_coord+ 0) * CELL_SIZE self.agent_trans.set_translation(x_coord, y_coord) rend = self.viewer.render( return_rgb_array=(mode== 'rgb_array' )) time.sleep(sleep_time) return rend def close(self): if self.viewer: self.viewer.close() self.viewer = None Reinforcement Learning for Decision Making in Complex Environments 700 This code implements the grid world environment, from which we can create instances of this envi- ronment. We can then interact with it in a manner similar to that in the CartPole example. The im- plemented class, GridWorldEnv , inherits methods such as reset() for resetting the state and step() for executing an action. The details of the implementation are as follows: • We defined the four different actions using lambda functions: move_up() , move_down() , move_ left() , and move_right() . • The NumPy array isd holds the probabilities of the starting states so that a random state will be selected based on this distribution when the reset() method (from the parent class) is called. Since we always start from state 0 (the lower-left corner of the grid world), we set the probability of state 0 to 1.0 and the probabilities of all other 29 states to 0.0. • The transition probabilities, defined in the Python dictionary P determine the probabilities of moving from one state to another state when an action is selected. This allows us to have a probabilistic environment where taking an action could have different outcomes based on the stochasticity of the environment. For simplicity, we just use a single outcome, which is to change the state in the direction of the selected action. Finally, these transition probabilities will be used by the env.step() function to determine the next state. • Furthermore, the _build_display() function will set up the initial visualization of the envi- ronment, and the render() function will show the movements of the agent. Now, we can test", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 630, "start_word": 201600, "end_word": 202000, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000631": {"text": "an action could have different outcomes based on the stochasticity of the environment. For simplicity, we just use a single outcome, which is to change the state in the direction of the selected action. Finally, these transition probabilities will be used by the env.step() function to determine the next state. • Furthermore, the _build_display() function will set up the initial visualization of the envi- ronment, and the render() function will show the movements of the agent. Now, we can test this implementation by creating a new environment and visualizing a random epi- sode by taking random actions at each state. Include the following code at the end of the same Python script (gridworld_env.py ) and then execute the script: if __name__ == '__main__' : env = GridWorldEnv( 5, 6) for i in range (1): s = env.reset() env.render(mode= 'human', done=False) while True: action = np.random.choice(env.nA) res = env.step(action) print('Action ' , env.s, action, ' -> ', res) env.render(mode= 'human', done=res[ 2]) if res[2]: break env.close()Note that during the learning process, we do not know about the transition probabilities, and the goal is to learn by interacting with the environment. Therefore, we do not have access to P outside the class definition. Chapter 19 701 After executing the script, you should see a visualization of the grid world environment as depicted in Figure 19.8: Figure 19.8: A visualization of our grid world environment Solving the grid world problem with Q-learning After focusing on the theory and the development process of RL algorithms, as well as setting up the environment via the OpenAI Gym toolkit, we will now implement the currently most popular RL algorithm, Q-learning. For this, we will use the grid world example that we already implemented in the script gridworld_env.py . Reinforcement Learning for Decision Making in Complex Environments 702 Now, we create a new script and name it agent.py . In this agent.py script, we define an agent for interacting with the environment as follows: ## Script: agent.py from collections import defaultdict import numpy as np class Agent: def __init__ ( self, env, learning_rate= 0.01, discount_factor= 0.9, epsilon_greedy= 0.9, epsilon_min= 0.1, epsilon_decay= 0.95): self.env = env self.lr = learning_rate self.gamma = discount_factor self.epsilon = epsilon_greedy self.epsilon_min = epsilon_min self.epsilon_decay = epsilon_decay ## Define the q_table self.q_table = defaultdict( lambda: np.zeros(self.env.nA)) def choose_action (self, state): if np.random.uniform() < self.epsilon: action = np.random.choice(self.env.nA) else: q_vals = self.q_table[state] perm_actions = np.random.permutation(self.env.nA)", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 631, "start_word": 201920, "end_word": 202320, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000632": {"text": "for interacting with the environment as follows: ## Script: agent.py from collections import defaultdict import numpy as np class Agent: def __init__ ( self, env, learning_rate= 0.01, discount_factor= 0.9, epsilon_greedy= 0.9, epsilon_min= 0.1, epsilon_decay= 0.95): self.env = env self.lr = learning_rate self.gamma = discount_factor self.epsilon = epsilon_greedy self.epsilon_min = epsilon_min self.epsilon_decay = epsilon_decay ## Define the q_table self.q_table = defaultdict( lambda: np.zeros(self.env.nA)) def choose_action (self, state): if np.random.uniform() < self.epsilon: action = np.random.choice(self.env.nA) else: q_vals = self.q_table[state] perm_actions = np.random.permutation(self.env.nA) q_vals = [q_vals[a] for a in perm_actions] perm_q_argmax = np.argmax(q_vals) action = perm_actions[perm_q_argmax] return action def _learn(self, transition): s, a, r, next_s, done = transition q_val = self.q_table[s][a] if done: q_target = r Chapter 19 703 else: q_target = r + self.gamma*np. max(self.q_table[next_s]) ## Update the q_table self.q_table[s][a] += self.lr * (q_target - q_val) ## Adjust the epsilon self._adjust_epsilon() def _adjust_epsilon (self): if self.epsilon > self.epsilon_min: self.epsilon *= self.epsilon_decay The __init__() constructor sets up various hyperparameters, such as the learning rate, discount factor (𝛾𝛾 ), and the parameters for the 𝜖𝜖 -greedy policy. Initially, we start with a high value of 𝜖𝜖 , but the _adjust_epsilon() method reduces it until it reaches the minimum value, 𝜖𝜖min . The choose_action() method chooses an action based on the 𝜖𝜖 -greedy policy as follows. A random uniform number is selected to determine whether the action should be selected randomly or otherwise, based on the action-value function. The _learn() method implements the update rule for the Q-learning algo - rithm. It receives a tuple for each transition, which consists of the current state (s), selected action (a), observed reward (r), next state (s′), as well as a flag to determine whether the end of the episode has been reached. The target value is equal to the observed reward (r) if this is flagged as end-of-episode; otherwise, the target is 𝑟𝑟𝑟𝑟𝑟𝑟𝑟𝑟 𝑎𝑎𝑄𝑄(𝑠𝑠′,𝑎𝑎) . Finally, for our next step, we create a new script, qlearning.py , to put everything together and train the agent using the Q-learning algorithm. In the following code, we define a function, run_qlearning() , that implements the Q-learning algo - rithm, simulating an episode by calling the _choose_action() method of the agent and executing the environment. Then, the transition tuple is passed to the _learn() method of the agent to update the action-value function. In addition, for monitoring the learning process, we also store the final reward of each episode (which could", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 632, "start_word": 202240, "end_word": 202640, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000633": {"text": "to put everything together and train the agent using the Q-learning algorithm. In the following code, we define a function, run_qlearning() , that implements the Q-learning algo - rithm, simulating an episode by calling the _choose_action() method of the agent and executing the environment. Then, the transition tuple is passed to the _learn() method of the agent to update the action-value function. In addition, for monitoring the learning process, we also store the final reward of each episode (which could be –1 or +1), as well as the length of episodes (the number of moves taken by the agent from the start of the episode until the end). The list of rewards and the number of moves is then plotted using the plot_learning_history() function: ## Script: qlearning.py from gridworld_env import GridWorldEnv from agent import Agent from collections import namedtuple import matplotlib.pyplot as plt import numpy as np np.random.seed( 1) Reinforcement Learning for Decision Making in Complex Environments 704 Transition = namedtuple( 'Transition' , ('state', 'action' , 'reward' , 'next_state' , 'done' )) def run_qlearning (agent, env, num_episodes= 50): history = [] for episode in range (num_episodes): state = env.reset() env.render(mode= 'human') final_reward, n_moves = 0.0, 0 while True: action = agent.choose_action(state) next_s, reward, done, _ = env.step(action) agent._learn(Transition(state, action, reward, next_s, done)) env.render(mode= 'human', done=done) state = next_s n_moves += 1 if done: break final_reward = reward history.append((n_moves, final_reward)) print(f'Episode {episode} : Reward {final_reward: .2} ' f'#Moves {n_moves} ') return history def plot_learning_history (history): fig = plt.figure( 1, figsize=( 14, 10)) ax = fig.add_subplot( 2, 1, 1) episodes = np.arange( len(history)) moves = np.array([h[ 0] for h in history]) plt.plot(episodes, moves, lw= 4, marker= 'o', markersize= 10) ax.tick_params(axis= 'both', which= 'major', labelsize= 15) plt.xlabel( 'Episodes' , size=20) plt.ylabel( '# moves' , size=20) ax = fig.add_subplot( 2, 1, 2) rewards = np.array([h[ 1] for h in history]) Chapter 19 705 plt.step(episodes, rewards, lw= 4) ax.tick_params(axis= 'both', which= 'major', labelsize= 15) plt.xlabel( 'Episodes' , size=20) plt.ylabel( 'Final rewards' , size=20) plt.savefig( 'q-learning-history.png' , dpi=300) plt.show() if __name__ == '__main__' : env = GridWorldEnv(num_rows= 5, num_cols= 6) agent = Agent(env) history = run_qlearning(agent, env) env.close() plot_learning_history(history) Executing this script will run the Q-learning program for 50 episodes. The behavior of the agent will be visualized, and you can see that at the beginning of the learning process, the agent mostly ends up in the trap states. But over time, it learns from its", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 633, "start_word": 202560, "end_word": 202960, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000634": {"text": "'Episodes' , size=20) plt.ylabel( 'Final rewards' , size=20) plt.savefig( 'q-learning-history.png' , dpi=300) plt.show() if __name__ == '__main__' : env = GridWorldEnv(num_rows= 5, num_cols= 6) agent = Agent(env) history = run_qlearning(agent, env) env.close() plot_learning_history(history) Executing this script will run the Q-learning program for 50 episodes. The behavior of the agent will be visualized, and you can see that at the beginning of the learning process, the agent mostly ends up in the trap states. But over time, it learns from its failures and eventually finds the gold state (for instance, the first time in episode 7). Figure 19.9 shows the agent’s number of moves and rewards: Figure 19.9: The agent’s number of moves and rewards Reinforcement Learning for Decision Making in Complex Environments 706 The plotted learning history shown in the previous figure indicates that the agent, after 30 episodes, learns a short path to get to the gold state. As a result, the lengths of the episodes after the 30th episode are more or less the same, with minor deviations due to the 𝜖𝜖 -greedy policy. A glance at deep Q-learning In the previous code, we saw an implementation of the popular Q-learning algorithm for the grid world example. This example consisted of a discrete state space of size 30, where it was sufficient to store the Q-values in a Python dictionary. However, we should note that sometimes the number of states can get very large, possibly almost in- finitely large. Also, we may be dealing with a continuous state space instead of working with discrete states. Moreover, some states may not be visited at all during training, which can be problematic when generalizing the agent to deal with such unseen states later. To address these problems, instead of representing the value function in a tabular format like V(S t), or Q(S t, At), for the action-value function, we use a function approximation approach. Here, we define a parametric function, v w(xs), that can learn to approximate the true value function, that is, 𝑣𝑣𝑤𝑤(𝑥𝑥𝑠𝑠)≈𝑣𝑣𝜋𝜋(𝑠𝑠) , where x s is a set of input features (or “featurized” states). When the approximator function, q w(xs, a), is a deep neural network (DNN ), the resulting model is called a deep Q-network ( DQN ). For training a DQN model, the weights are updated according to the Q-learning algorithm. An example of a DQN model is shown in Figure 19.10, where the states", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 634, "start_word": 202880, "end_word": 203280, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000635": {"text": "v w(xs), that can learn to approximate the true value function, that is, 𝑣𝑣𝑤𝑤(𝑥𝑥𝑠𝑠)≈𝑣𝑣𝜋𝜋(𝑠𝑠) , where x s is a set of input features (or “featurized” states). When the approximator function, q w(xs, a), is a deep neural network (DNN ), the resulting model is called a deep Q-network ( DQN ). For training a DQN model, the weights are updated according to the Q-learning algorithm. An example of a DQN model is shown in Figure 19.10, where the states are represented as features passed to the first layer: Figure 19.10: An example of a DQN Now, let’s see how we can train a DQN using the deep Q-learning algorithm. Overall, the main approach is very similar to the tabular Q-learning method. The main difference is that we now have a multilayer NN that computes the action values. Training a DQN model according to the Q-learning algorithm In this section, we describe the procedure for training a DQN model using the Q-learning algorithm. The deep Q-learning approach requires us to make some modifications to our previously implemented standard Q-learning approach. Chapter 19 707 One such modification is in the agent’s choose_action() method, which, in the code of the previous section for Q-learning, was simply accessing the action values stored in a dictionary. Now, this func- tion should be changed to perform a forward pass of the NN model for computing the action values. The other modifications needed for the deep Q-learning algorithm are described in the following two subsections. Replay memory Using the previous tabular method for Q-learning, we could update the values for specific state-action pairs without affecting the values of others. However, now that we approximate q(s, a) with an NN model, updating the weights for a state-action pair will likely affect the output of other states as well. When training NNs using stochastic gradient descent for a supervised task (for example, a classification task), we use multiple epochs to iterate through the training data multiple times until it converges. This is not feasible in Q-learning, since the episodes will change during the training and, as a result, some states that were visited in the early stages of training will become less likely to be visited later. Furthermore, another problem is that when we train an NN, we assume that the training examples are IID (independent and identically distributed). However, the samples taken from an episode of the", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 635, "start_word": 203200, "end_word": 203600, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000636": {"text": "epochs to iterate through the training data multiple times until it converges. This is not feasible in Q-learning, since the episodes will change during the training and, as a result, some states that were visited in the early stages of training will become less likely to be visited later. Furthermore, another problem is that when we train an NN, we assume that the training examples are IID (independent and identically distributed). However, the samples taken from an episode of the agent are not IID, as they form a sequence of transitions. To solve these issues, as the agent interacts with the environment and generates a transition quintu- ple qw(xs, a), we store a large (but finite) number of such transitions in a memory buffer, often called replay memory. After each new interaction (that is, the agent selects an action and executes it in the environment), the resulting new transition quintuple is appended to the memory. To keep the size of the memory bounded, the oldest transition will be removed from the memory (for example, if it is a Python list, we can use the pop(0) method to remove the first element of the list). Then, a mini-batch of examples is randomly selected from the memory buffer, which will be used for computing the loss and updating the network parameters. Figure 19.11 illustrates the process: Figure 19.11: The replay memory process Reinforcement Learning for Decision Making in Complex Environments 708 Determining the target values for computing the loss Another required change from the tabular Q-learning method is how to adapt the update rule for training the DQN model parameters. Recall that a transition quintuple, T, stored in the batch of ex - amples, contains (𝑥𝑥𝑠𝑠,𝑎𝑎,𝑎𝑎,𝑥𝑥𝑠𝑠′,done) . As shown in Figure 19.12, we perform two forward passes of the DQN model. The first forward pass uses the features of the current state (x s). Then, the second forward pass uses the features of the next state (𝑥𝑥𝑠𝑠′ ). As a result, we will obtain the estimated action values, 𝑞𝑞𝑤𝑤(𝑥𝑥𝑠𝑠,:) and 𝑞𝑞𝑤𝑤(𝑥𝑥𝑠𝑠′,:) , from the first and second forward pass, respectively. (Here, this 𝑞𝑞𝑤𝑤(𝑥𝑥𝑠𝑠,:) notation means a vector of Q-values for all actions in 𝐴𝐴̂ .) From the transition quintuple, we know that action a is selected by the agent. Therefore, according to the Q-learning algorithm, we need to update the action value corresponding to the state-action pair (x s, a) with the", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 636, "start_word": 203520, "end_word": 203920, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000637": {"text": "of the next state (𝑥𝑥𝑠𝑠′ ). As a result, we will obtain the estimated action values, 𝑞𝑞𝑤𝑤(𝑥𝑥𝑠𝑠,:) and 𝑞𝑞𝑤𝑤(𝑥𝑥𝑠𝑠′,:) , from the first and second forward pass, respectively. (Here, this 𝑞𝑞𝑤𝑤(𝑥𝑥𝑠𝑠,:) notation means a vector of Q-values for all actions in 𝐴𝐴̂ .) From the transition quintuple, we know that action a is selected by the agent. Therefore, according to the Q-learning algorithm, we need to update the action value corresponding to the state-action pair (x s, a) with the scalar target value 𝑟𝑟𝑟𝑟𝑟𝑟𝑟𝑟 𝑎𝑎′∈𝐴𝐴̂𝑞𝑞𝑤𝑤(𝑥𝑥𝑠𝑠′,𝑎𝑎′) . Instead of forming a scalar target value, we will create a target action-value vector that retains the action values for other actions, 𝑎𝑎′≠𝑎𝑎 , as shown in Figure 19.12:Implementing the replay memory The replay memory can be implemented using a Python list, where every time we add a new element to the list, we need to check the size of the list and call pop(0) if needed. Alternatively, we can use the deque data structure from the Python collections library, which allows us to specify an optional argument, max_len . By specifying the max_len argument, we will have a bounded deque. Therefore, when the object is full, appending a new element results in automatically removing an element from it. Note that this is more efficient than using a Python list, since removing the first ele - ment of a list using pop(0) has O(n) complexity, while the deque’s runtime complexi - ty is O(1). You can learn more about the deque implementation from the official docu - mentation that is available at https://docs.python.org/3.9/library/collections. html#collections.deque . Chapter 19 709 Figure 19.12: Determining the target value using the DQN We treat this as a regression problem, using the following three quantities: • The currently predicted values, 𝑞𝑞𝑤𝑤(𝑥𝑥𝑠𝑠,:) • The target value vector as described • The standard mean squared error (MSE ) loss function As a result, the losses will be zero for every action except for a. Finally, the computed loss will be backpropagated to update the network parameters. Reinforcement Learning for Decision Making in Complex Environments 710 Implementing a deep Q-learning algorithm Finally, we will use all these techniques to implement a deep Q-learning algorithm. This time, we use the CartPole environment from the OpenAI Gym environment that we introduced earlier. Recall that the CartPole environment has a continuous state space of size 4. In the following code, we define a class, DQNAgent ,", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 637, "start_word": 203840, "end_word": 204240, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000638": {"text": "for a. Finally, the computed loss will be backpropagated to update the network parameters. Reinforcement Learning for Decision Making in Complex Environments 710 Implementing a deep Q-learning algorithm Finally, we will use all these techniques to implement a deep Q-learning algorithm. This time, we use the CartPole environment from the OpenAI Gym environment that we introduced earlier. Recall that the CartPole environment has a continuous state space of size 4. In the following code, we define a class, DQNAgent , that builds the model and specifies various hyperparameters. This class has two additional methods compared to the previous agent that was based on tabular Q-learning. The remember() method will append a new transition quintuple to the memory buffer, and the replay() method will create a mini-batch of example transitions and pass that to the _learn() method for updating the network’s weight parameters: import gym import numpy as np import torch import torch.nn as nn import random import matplotlib.pyplot as plt from collections import namedtuple from collections import deque np.random.seed( 1) torch.manual_seed( 1) Transition = namedtuple( 'Transition' , ('state', 'action' , 'reward' , 'next_state' , 'done' )) class DQNAgent : def __init__ ( self, env, discount_factor= 0.95, epsilon_greedy= 1.0, epsilon_min= 0.01, epsilon_decay= 0.995, learning_rate= 1e-3, max_memory_size= 2000): self.env = env self.state_size = env.observation_space.shape[ 0] self.action_size = env.action_space.n self.memory = deque(maxlen=max_memory_size) self.gamma = discount_factor self.epsilon = epsilon_greedy self.epsilon_min = epsilon_min self.epsilon_decay = epsilon_decay self.lr = learning_rate Chapter 19 711 self._build_nn_model() def _build_nn_model (self): self.model = nn.Sequential(nn.Linear(self.state_size, 256), nn.ReLU(), nn.Linear( 256, 128), nn.ReLU(), nn.Linear( 128, 64), nn.ReLU(), nn.Linear( 64, self.action_size)) self.loss_fn = nn.MSELoss() self.optimizer = torch.optim.Adam( self.model.parameters(), self.lr) def remember (self, transition): self.memory.append(transition) def choose_action (self, state): if np.random.rand() <= self.epsilon: return np.random.choice(self.action_size) with torch.no_grad(): q_values = self.model(torch.tensor(state, dtype=torch.float32))[ 0] return torch.argmax(q_values).item() # returns action def _learn(self, batch_samples): batch_states, batch_targets = [], [] for transition in batch_samples: s, a, r, next_s, done = transition with torch.no_grad(): if done: target = r else: pred = self.model(torch.tensor(next_s, dtype=torch.float32))[ 0] target = r + self.gamma * pred. max() target_all = self.model(torch.tensor(s, dtype=torch.float32))[ 0] target_all[a] = target Reinforcement Learning for Decision Making in Complex Environments 712 batch_states.append(s.flatten()) batch_targets.append(target_all) self._adjust_epsilon() self.optimizer.zero_grad() pred = self.model(torch.tensor(batch_states, dtype=torch.float32)) loss = self.loss_fn(pred, torch.stack(batch_targets)) loss.backward() self.optimizer.step() return loss.item() def _adjust_epsilon (self): if self.epsilon > self.epsilon_min: self.epsilon *= self.epsilon_decay def replay(self, batch_size): samples = random.sample(self.memory, batch_size) return self._learn(samples) Finally, with the following code, we train the model for 200 episodes, and at the end", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 638, "start_word": 204160, "end_word": 204560, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000639": {"text": "= self.model(torch.tensor(next_s, dtype=torch.float32))[ 0] target = r + self.gamma * pred. max() target_all = self.model(torch.tensor(s, dtype=torch.float32))[ 0] target_all[a] = target Reinforcement Learning for Decision Making in Complex Environments 712 batch_states.append(s.flatten()) batch_targets.append(target_all) self._adjust_epsilon() self.optimizer.zero_grad() pred = self.model(torch.tensor(batch_states, dtype=torch.float32)) loss = self.loss_fn(pred, torch.stack(batch_targets)) loss.backward() self.optimizer.step() return loss.item() def _adjust_epsilon (self): if self.epsilon > self.epsilon_min: self.epsilon *= self.epsilon_decay def replay(self, batch_size): samples = random.sample(self.memory, batch_size) return self._learn(samples) Finally, with the following code, we train the model for 200 episodes, and at the end visualize the learning history using the plot_learning_history() function: def plot_learning_history (history): fig = plt.figure( 1, figsize=( 14, 5)) ax = fig.add_subplot( 1, 1, 1) episodes = np.arange( len(history))+ 1 plt.plot(episodes, history, lw= 4, marker= 'o', markersize= 10) ax.tick_params(axis= 'both', which= 'major', labelsize= 15) plt.xlabel( 'Episodes' , size=20) plt.ylabel( 'Total rewards' , size=20) plt.show() ## General settings EPISODES = 200 batch_size = 32 init_replay_memory_size = 500 if __name__ == '__main__' : env = gym.make( 'CartPole-v1' ) agent = DQNAgent(env) Chapter 19 713 state = env.reset() state = np.reshape(state, [ 1, agent.state_size]) ## Filling up the replay-memory for i in range (init_replay_memory_size): action = agent.choose_action(state) next_state, reward, done, _ = env.step(action) next_state = np.reshape(next_state, [ 1, agent.state_size]) agent.remember(Transition(state, action, reward, next_state, done)) if done: state = env.reset() state = np.reshape(state, [ 1, agent.state_size]) else: state = next_state total_rewards, losses = [], [] for e in range (EPISODES): state = env.reset() if e % 10 == 0: env.render() state = np.reshape(state, [ 1, agent.state_size]) for i in range (500): action = agent.choose_action(state) next_state, reward, done, _ = env.step(action) next_state = np.reshape(next_state, [ 1, agent.state_size]) agent.remember(Transition(state, action, reward, next_state, done)) state = next_state if e % 10 == 0: env.render() if done: total_rewards.append(i) print(f'Episode: {e}/{EPISODES} , Total reward: {i}') break loss = agent.replay(batch_size) losses.append(loss) plot_learning_history(total_rewards) Reinforcement Learning for Decision Making in Complex Environments 714 After training the agent for 200 episodes, we see that the agent indeed learned to increase the total rewards over time , as shown in Figure 19.13: Figure 19.13: The agent’s rewards increased over time Note that the total rewards obtained in an episode are equal to the amount of time that the agent is able to balance the pole. The learning history plotted in this figure shows that after about 30 episodes, the agent learns how to balance the pole and hold it for more than 200 time steps. Chapter and book summary In this chapter, we covered the", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 639, "start_word": 204480, "end_word": 204880, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000640": {"text": "time , as shown in Figure 19.13: Figure 19.13: The agent’s rewards increased over time Note that the total rewards obtained in an episode are equal to the amount of time that the agent is able to balance the pole. The learning history plotted in this figure shows that after about 30 episodes, the agent learns how to balance the pole and hold it for more than 200 time steps. Chapter and book summary In this chapter, we covered the essential concepts in RL, starting from the very foundations, and how RL can support decision making in complex environments. We learned about agent-environment interactions and Markov decision processes (MDPs ), and we considered three main approaches for solving RL problems: dynamic programming, MC learning, and TD learning. We discussed the fact that the dynamic programming algorithm assumes that the full knowledge of environment dynamics is available, an assumption that is not typically true for most real-world problems. Then, we saw how the MC- and TD-based algorithms learn by allowing an agent to interact with the environment and generate a simulated experience. After discussing the underlying theory, we im - plemented the Q-learning algorithm as an off-policy subcategory of the TD algorithm for solving the grid world example. Finally, we covered the concept of function approximation and deep Q-learning in particular, which can be used for problems with large or continuous state spaces. We hope you enjoyed this last chapter of Python Machine Learning and our exciting tour of machine learning and deep learning. Throughout the journey of this book, we’ve covered the essential topics that this field has to offer, and you should now be well equipped to put those techniques into action to solve real-world problems. We started our journey in Chapter 1, Giving Computers the Ability to Learn from Data, with a brief overview of the different types of learning tasks: supervised learning, reinforcement learning, and unsupervised learning. Chapter 19 715 We then discussed several different learning algorithms that you can use for classification, starting with simple single-layer NNs in Chapter 2, Training Simple Machine Learning Algorithms for Classification. We continued to discuss advanced classification algorithms in Chapter 3, A Tour of Machine Learning Classifiers Using Scikit-Learn, and we learned about the most important aspects of a machine learning pipeline in Chapter 4, Building Good Training Datasets – Data Preprocessing, and Chapter 5, Compressing Data via Dimensionality Reduction.", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 640, "start_word": 204800, "end_word": 205200, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000641": {"text": "Chapter 19 715 We then discussed several different learning algorithms that you can use for classification, starting with simple single-layer NNs in Chapter 2, Training Simple Machine Learning Algorithms for Classification. We continued to discuss advanced classification algorithms in Chapter 3, A Tour of Machine Learning Classifiers Using Scikit-Learn, and we learned about the most important aspects of a machine learning pipeline in Chapter 4, Building Good Training Datasets – Data Preprocessing, and Chapter 5, Compressing Data via Dimensionality Reduction. Remember that even the most advanced algorithm is limited by the information in the training data that it gets to learn from. So, in Chapter 6 , Learning Best Practices for Model Evaluation and Hyperparameter Tuning, we learned about the best practices to build and evaluate predictive models, which is another important aspect in machine learning applications. If one single learning algorithm does not achieve the performance we desire, it can sometimes be helpful to create an ensemble of experts to make a prediction. We explored this in Chapter 7, Combining Different Models for Ensemble Learning. Then, in Chapter 8, Applying Machine Learning to Sentiment Analysis, we applied machine learning to analyze one of the most popular and interesting forms of data in the modern age, which is dominated by social media platforms on the internet—text documents. For the most part, our focus was on algorithms for classification, which is probably the most popular application of machine learning. However, this is not where our journey ended! In Chapter 9, Predict- ing Continuous Target Variables with Regression Analysis, we explored several algorithms for regression analysis to predict continuous target variables. Another exciting subfield of machine learning is clustering analysis, which can help us find hidden structures in the data, even if our training data does not come with the right answers to learn from. We worked with this in Chapter 10, Working with Unlabeled Data – Clustering Analysis. We then shifted our attention to one of the most exciting algorithms in the whole machine learning field—artificial neural networks. We started by implementing a multilayer perceptron from scratch with NumPy in Chapter 11, Implementing a Multilayer Artificial Neural Network from Scratch. The benefits of PyTorch for deep learning became obvious in Chapter 12, Parallelizing Neural Network Training with PyTorch, where we used PyTorch to facilitate the process of building NN models, worked with PyTorch Dataset objects, and learned how to apply preprocessing", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 641, "start_word": 205120, "end_word": 205520, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000642": {"text": "our attention to one of the most exciting algorithms in the whole machine learning field—artificial neural networks. We started by implementing a multilayer perceptron from scratch with NumPy in Chapter 11, Implementing a Multilayer Artificial Neural Network from Scratch. The benefits of PyTorch for deep learning became obvious in Chapter 12, Parallelizing Neural Network Training with PyTorch, where we used PyTorch to facilitate the process of building NN models, worked with PyTorch Dataset objects, and learned how to apply preprocessing steps to a dataset. We delved deeper into the mechanics of PyTorch in Chapter 13, Going Deeper – The Mechanics of PyTorch, and discussed the different aspects and mechanics of PyTorch, including tensor objects, computing gradients of a computation, as well as the neural network module, torch.nn . In Chapter 14, Classifying Images with Deep Convolutional Neural Networks, we dived into convolutional neural networks, which are widely used in computer vision at the moment, due to their great perfor - mance in image classification tasks. In Chapter 15, Modeling Sequential Data Using Recurrent Neural Networks, we learned about sequence modeling using RNNs. In Chapter 16, Transformers – Improving Natural Language Processing with Attention Mechanisms, we introduced the attention mechanism to address one of the weaknesses of RNNs, that is, remembering previous input elements when dealing with long sequences. We then explored various kinds of trans- former architectures, which are deep learning architectures that are centered around the self-attention mechanism and constitute the state of the art for creating large-scale language models. Reinforcement Learning for Decision Making in Complex Environments 716 In Chapter 17, Generative Adversarial Networks for Synthesizing New Data, we saw how to generate new images using GANs and, along the way, we also learned about autoencoders, batch normalization, transposed convolution, and Wasserstein GANs. Previous chapters were centered around tabular datasets as well as text and image data. In Chapter 18, Graph Neural Networks for Capturing Dependencies in Graph Structured Data, we focused on deep learning for graph-structured data, which is commonly used data representation for social networks and molecules (chemical compounds). Moreover, we learned about so-called graph neural networks, which are deep neural networks that are compatible with such data. Finally, in this chapter, we covered a separate category of machine learning tasks and saw how to develop algorithms that learn by interacting with their environment through a reward process. While a comprehensive study of deep learning is", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 642, "start_word": 205440, "end_word": 205840, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000643": {"text": "Structured Data, we focused on deep learning for graph-structured data, which is commonly used data representation for social networks and molecules (chemical compounds). Moreover, we learned about so-called graph neural networks, which are deep neural networks that are compatible with such data. Finally, in this chapter, we covered a separate category of machine learning tasks and saw how to develop algorithms that learn by interacting with their environment through a reward process. While a comprehensive study of deep learning is well beyond the scope of this book, we hope that we’ve kindled your interest enough to follow the most recent advancements in this field of deep learning. If you’re considering a career in machine learning, or you just want to keep up to date with the current advancements in this field, we can recommend that you keep an eye on the recent literature published in this field. The following are some resources that we find particularly useful: • A subreddit and community dedicated to learning machine learning: https://www.reddit. com/r/learnmachinelearning/ • A daily updated list of the latest machine learning manuscripts uploaded to the arXiv preprint server: https://arxiv.org/list/cs.LG/recent • A paper recommendation engine built on top of arXiv: http://www.arxiv-sanity.com Lastly, you can find out what we, the authors, are up to at these sites: • Sebastian Raschka: https://sebastianraschka.com • Hayden Liu: https://www.mlexample.com/ • Vahid Mirjalili: http://vahidmirjalili.com You’re always welcome to contact us if you have any questions about this book or if you need some general tips on machine learning. Join our book’s Discord space Join the book’s Discord workspace for a monthly Ask me Anything session with the authors: https://packt.link/MLwPyTorch packt.com Subscribe to our online digital library for full access to over 7,000 books and videos, as well as in - dustry leading tools to help you plan your personal development and advance your career. For more information, please visit our website. Why subscribe? • Spend less time learning and more time coding with practical eBooks and Videos from over 4,000 industry professionals • Improve your learning with Skill Plans built especially for you • Get a free eBook or video every month • Fully searchable for easy access to vital information • Copy and paste, print, and bookmark content At www.packt.com , you can also read a collection of free technical articles, sign up for a range of free newsletters, and receive exclusive discounts and offers on Packt books", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 643, "start_word": 205760, "end_word": 206160, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000644": {"text": "more time coding with practical eBooks and Videos from over 4,000 industry professionals • Improve your learning with Skill Plans built especially for you • Get a free eBook or video every month • Fully searchable for easy access to vital information • Copy and paste, print, and bookmark content At www.packt.com , you can also read a collection of free technical articles, sign up for a range of free newsletters, and receive exclusive discounts and offers on Packt books and eBooks. Other Books You May Enjoy If you enjoyed this book, you may be interested in these other books by Packt: Python Machine Learning, Third Edition Sebastian Raschka Vahid Mirjalili ISBN: 9781789955750 • Master the frameworks, models, and techniques that enable machines to ‘learn’ from data • Use scikit-learn for machine learning and TensorFlow for deep learning • Apply machine learning to image classification, sentiment analysis, intelligent web applica - tions, and more • Build and train neural networks, GANs, and other models • Discover best practices for evaluating and tuning models • Predict continuous target outcomes using regression analysis • Dig deeper into textual and social media data using sentiment analysis Other Books You May Enjoy 720 Transformers for Natural Language Processing Denis Rothman ISBN: 9781800565791 • Use the latest pretrained transformer models • Grasp the workings of the original Transformer, GPT-2, BERT, T5, and other transformer models • Create language understanding Python programs using concepts that outperform classical deep learning models • Use a variety of NLP platforms, including Hugging Face, Trax, and AllenNLP • Apply Python, TensorFlow, and Keras programs to sentiment analysis, text summarization, speech recognition, machine translations, and more • Measure the productivity of key transformers to define their scope, potential, and limits in production Other Books You May Enjoy 721 Graph Machine Learning Claudio Stamile Aldo Marzullo Enrico Deusebio ISBN: 9781800204492 • Write Python scripts to extract features from graphs • Distinguish between the main graph representation learning techniques • Become well-versed with extracting data from social networks, financial transaction systems, and more • Implement the main unsupervised and supervised graph embedding techniques • Get to grips with shallow embedding methods, graph neural networks, graph regularization methods, and more • Deploy and scale out your application seamlessly Other Books You May Enjoy 722 Packt is searching for authors like you If you’re interested in becoming an author for Packt, please visit authors.packtpub.com and", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 644, "start_word": 206080, "end_word": 206480, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000645": {"text": "the main graph representation learning techniques • Become well-versed with extracting data from social networks, financial transaction systems, and more • Implement the main unsupervised and supervised graph embedding techniques • Get to grips with shallow embedding methods, graph neural networks, graph regularization methods, and more • Deploy and scale out your application seamlessly Other Books You May Enjoy 722 Packt is searching for authors like you If you’re interested in becoming an author for Packt, please visit authors.packtpub.com and apply today. We have worked with thousands of developers and tech professionals, just like you, to help them share their insight with the global tech community. You can make a general application, apply for a specific hot topic that we are recruiting an author for, or submit your own idea. Share your thoughts Now you’ve finished Machine Learning with PyTorch and Scikit-Learn, we’d love to hear your thoughts! If you purchased the book from Amazon, please click here to go straight to the Amazon review page for this book and share your feedback or leave a review on the site that you purchased it from. Your review is important to us and the tech community and will help us make sure we’re delivering excellent quality content. Index Symbols 5×2 cross-validation 192 7-Zip URL 248 A accuracy versus classification error 57 action-value function 682 estimation, with Monte Carlo 688 greedy policy, computing from 689 activation function, for multilayer neural network selecting 400 activation functions, torch.nn module reference link 406 activations computing, in RNNs 504, 505 AdaBoost applying, with scikit-learn 233-236 comparing, with gradient boosting 237 AdaBoost recognition 229 Adam optimizer 479 adaptive boosting weak learners, leveraging 229 working 229-233Adaptive Linear Neuron (Adaline) 35-37, 278 algorithm 337 implementation, converting into algorithm for logistic regression 66-68 implementing, in Python 39-43 advanced graph neural network literature pointers 669, 670 agent 6, 674, 675 agglomerative clustering applying, via scikit-learn 327, 328 AI winters reference link 336 Ames Housing dataset 272 loading, into data frame 272-274 nonlinear relationships, modeling 297-299 Anaconda 15 reference link 15 Anaconda Python distribution using 15, 16 artificial intelligence (AI) 1, 19, 336, 452 artificial neural networks training 360 used, for modeling complex functions 335, 336 artificial neuron 20 attention mechanism for RNNs 540, 542 attention weights computing 544 Index 724 autoencoders 590, 591 automatic differentiation 363, 416 autoregression 534 average-pooling 463 B backpropagation 350, 362, 363 neural networks, training via 363-367", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 645, "start_word": 206400, "end_word": 206800, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000646": {"text": "336 Ames Housing dataset 272 loading, into data frame 272-274 nonlinear relationships, modeling 297-299 Anaconda 15 reference link 15 Anaconda Python distribution using 15, 16 artificial intelligence (AI) 1, 19, 336, 452 artificial neural networks training 360 used, for modeling complex functions 335, 336 artificial neuron 20 attention mechanism for RNNs 540, 542 attention weights computing 544 Index 724 autoencoders 590, 591 automatic differentiation 363, 416 autoregression 534 average-pooling 463 B backpropagation 350, 362, 363 neural networks, training via 363-367 resources 343 bagging 95, 223, 224 applying, to classify examples in Wine dataset 225-228 for model ensembles 225 bag-of-words model 250 basic graph convolution implementing 644-647 Basic Linear Algebra Subprograms (BLAS) 29 batch gradient descent 39 BatchNorm 614-616 Bellman equation 676 dynamic programming 684 bias unit 21 bias-variance tradeoff 73 Bidirectional and Auto-Regressive Transformer (BART) 561, 572-574 Bidirectional Encoder Representations from Transformers (BERT) 561, 569 bidirectional pre-training 569-571 model, fine-tuning in PyTorch 574 bidirectional RNN 524, 525 inputs, processing 543 bigger data working with 261, 262 binary cross-entropy 471 binomial coefficient 207 boosting 95 border point 328Breast Cancer Wisconsin dataset loading 172, 173 obtaining 172 Broyden-Fletcher-Goldfarb-Shanno (BFGS) 71 C candidate value 512 car’s fuel efficiency prediction project DNN regression model, training 435, 436 feature columns, working with 431-434 Catalyst URL 439 CatBoost URL 244 categorical cross-entropy 471 categorical data encoding, with pandas 111 handling 111 CelebA dataset alternative ways, to download 483 loading 483 cell state 511 central processing units (CPUs) 370 centroid 306 channels 464 character-level language modeling, PyTorch 525, 526 dataset, processing 526-531 text passages, generating 533-537 character-level RNN model building 531, 532 classification class labels, predicting 4, 5 classification algorithm selecting 53 classification error 88 versus accuracy 57 Index 725 classification model precision, optimizing 195-197 recall, optimizing 195-197 classification task 4 classifiers combining, via majority vote 209 class imbalance managing 201-203 class labels encoding 112, 113 class membership probabilities from decision trees 214 class probabilities estimating, in multiclass classification via softmax function 402 modeling, via logistic regression 59 cluster cohesion 314 cluster inertia 308 clustering 305 used, for finding subgroups 8 clusters grouping 320, 321 organizing, as hierarchical tree 319 cluster separation 314 CNN layers configuring, in PyTorch 476 CNN smile classifier training 490-497 collinearity 159 color channels 464 common architectures implementations custom layers, writing in PyTorch 426-430 loss function, selecting 418, 419 model building, making flexible with nn.Module 424-426 nn.Sequential based model, implementing 417, 418 simplifying,", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 646, "start_word": 206720, "end_word": 207120, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000647": {"text": "multiclass classification via softmax function 402 modeling, via logistic regression 59 cluster cohesion 314 cluster inertia 308 clustering 305 used, for finding subgroups 8 clusters grouping 320, 321 organizing, as hierarchical tree 319 cluster separation 314 CNN layers configuring, in PyTorch 476 CNN smile classifier training 490-497 collinearity 159 color channels 464 common architectures implementations custom layers, writing in PyTorch 426-430 loss function, selecting 418, 419 model building, making flexible with nn.Module 424-426 nn.Sequential based model, implementing 417, 418 simplifying, via torch.nn module 417XOR classification problem, solving 419-423 complete linkage 320 complex functions modeling, with artificial neural networks 335, 336 complex NNs applications 336 computation graphs, PyTorch 410 computer processors performance challenge 369, 370 conda-forge URL 16 conditional GAN (cGAN) 635 conditional inference 593 conditional probabilities 60-63 confusion matrix reading 193-195 context embeddings encoding, via multi-head attention 554-558 context vectors outputs, generating from 543, 544 continuing task 680 convergence of learning 36 convex optimization algorithms 71 convolutional GANs architecture design considerations 618 used, for improving synthesized images quality 612 convolutional neural networks (CNNs) 451, 452 constructing, in PyTorch 477-481 graphs, reference link 666 implementing 464 implementing, with torch.nn module 476 smile classification, from face images 482 convolution output size, determining 458, 459 Index 726 core point 328 correlation matrix using 276-278 cross-correlation 456 cuML reference link 102 curse of dimensionality 102, 132, 517 custom layers writing, in PyTorch 424-430 D data preprocessing 13 synthesizing, with generative models 592, 593 data augmentation 482-484, 488 data frame Ames Housing dataset, loading into 272-274 DataLoader preparing 655-658 data science packages 16, 17 dataset partitioning, into separate training and test datasets 117, 118 data visualization via t-distributed stochastic neighbor embedding 165-168 DBSCAN regions of high density, locating 328-333 DCGAN model training, to implement WGAN-GP 629-632 decision regions 57 decision tree 86, 87, 119 building 92-95 class membership probabilities 214 decision tree regression 300 decoder 558decoder network 590 deconvolution 613 deconvolution function 613 deep CNN implementing, with PyTorch 473 deep convolutional GAN (DCGAN) 612 DeeperGCN reference link 669 deep learning 339 deep NN 339 deep Q-learning 706 algorithm, implementing 710, 714 deep Q-network (DQN) 706 dendrograms 319 attaching, to heat map 326, 327 density-based clustering 305 DiffPool 668 dimensionality reduction 128, 591 for data compression 8 directed acyclic graph (DAG) 410 directed graphs 639 discount factor 680 discrete convolutions in 2D 459-461 in one dimension 454-456 performing 454 discriminator 594 discriminator networks implementing 616-624 distance", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 647, "start_word": 207040, "end_word": 207440, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000648": {"text": "implementing, with PyTorch 473 deep convolutional GAN (DCGAN) 612 DeeperGCN reference link 669 deep learning 339 deep NN 339 deep Q-learning 706 algorithm, implementing 710, 714 deep Q-network (DQN) 706 dendrograms 319 attaching, to heat map 326, 327 density-based clustering 305 DiffPool 668 dimensionality reduction 128, 591 for data compression 8 directed acyclic graph (DAG) 410 directed graphs 639 discount factor 680 discrete convolutions in 2D 459-461 in one dimension 454-456 performing 454 discriminator 594 discriminator networks implementing 616-624 distance matrix hierarchical clustering, performing on 321-324 DistilBERT model 575 distribution dissimilarity measures 624-626 DNN regression model training 435 Index 727 document classification logistic regression model, training for 258-260 documents processing, into tokens 256, 257 dot product 21 DQN model training, according to Q-learning algorithm 706 dropout NN, regularizing 469, 470 dynamic programming 677, 685 value function, predicting 686 with Bellman equation 684 E eigendecomposition 141, 144 eigenvalues 141 reference link 141 eigenvectors 141 reference link 141 elastic net 292 elbow method 306 using, to find optimal number of clusters 313, 314 element-wise product 511 element-wise summation 511 ELMo (Embeddings from Language Models) 562 embedding advantages, over one-hot encoding 518 EM distance advantages 626 using, for GANs 627 encoder block 554 encoder network 590 encoding schemes for nominal data 116 ensemble 95 building, with stacking 223training, based on loss gradients 237 ensemble classifier evaluating 217-223 tuning 217-223 ensemble methods 205-208 entropy 88 environment 675 episode 674, 680 episodic task 679 epsilon 167 error function 12 estimated value function policy, improving 686 estimators 110 expectation-maximization (EM) reference link 266 explained variance 146 exploding gradient 510 exploitation 676 exploration 676 exploratory data analysis (EDA) 274 F F1 score 193 Facebooks AI Research lab (FAIR) 371 false negative (FN) 194 false positive (FP) 194 false positive rate (FPR) 195 fastai URL 439 feature 12 feature columns working with 431-434 feature contributions assessing 152-154 feature extraction 128, 139 Index 728 feature hierarchy 452 feature importance assessing, with random forests 134-136 feature maps 453 feature normalization 74 features 10 eliminating, with missing values 107, 108 selecting 122 feature scaling 119, 120 gradient descent, improving 43-45 feature selection 128 feature selection algorithms in scikit-learn 134 feature space examples 161 feature subspace linear discriminants, selecting for 158-160 feature transformation 146-148 feature vectors words, transforming into 250, 251 feedforward 342 few-shot learning 565, 566 filter 454 Fisher’s LDA 155 floor operation 458 forget gate 511 forward propagation neural network,", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 648, "start_word": 207360, "end_word": 207760, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000649": {"text": "assessing, with random forests 134-136 feature maps 453 feature normalization 74 features 10 eliminating, with missing values 107, 108 selecting 122 feature scaling 119, 120 gradient descent, improving 43-45 feature selection 128 feature selection algorithms in scikit-learn 134 feature space examples 161 feature subspace linear discriminants, selecting for 158-160 feature transformation 146-148 feature vectors words, transforming into 250, 251 feedforward 342 few-shot learning 565, 566 filter 454 Fisher’s LDA 155 floor operation 458 forget gate 511 forward propagation neural network, activating via 340, 341 fractionally strided convolution 613 full batch gradient descent 39 fully connected layers 452 fuzziness coefficient 312 fuzzy clustering 311 fuzzy C-means (FCM) algorithm 311 fuzzy k-means 311G GAN applications 635 gated recurrent unit (GRU) 512 gates 511 Gaussian kernel 83 generalization error 14 generalization performance estimating 180 generalized policy iteration (GPI) 687 generative adversarial networks (GANs) 589, 590 discriminator networks, implementing 600-603 discriminator networks, loss function 594, 595 EM distance, using 627 generator networks, implementing 600-603 generator networks, loss function 594, 595 implementing 596 model, training 605-612 model training, on Google Colab 596-599 training dataset, defining 604, 605 used, for generating samples 593 generative model 593 for synthesizing data 592, 593 Generative Pre-trained Transformer (GPT) 561 unlabeled data, leveraging 563-565 generator 593 generator networks implementing 616-624 Gini impurity 88 global interpreter lock (GIL) 370 global pooling layer adding, to deal with varying graph sizes 652-654 Google Colab reference link 597 GPT-1 564, 565 Index 729 GPT-2 565 references 568 using, to generate text 566-568 GPT-3 565, 566 gradient boosting 237 AdaBoost, comparing with 237 for classification 241-243 for regression 238 gradient boosting algorithm 237 for classification 239, 240 gradient clipping 510 gradient descent (GD) 56, 278 improving, through feature scaling 43-45 loss functions, minimizing 37-39 regression, solving for regression parameters 279-283 gradient descent optimization algorithm 119 gradient penalty (GP) 628 gradients adversarial examples 416 computing, via automatic differentiation 415 gradients of loss, computing 415, 416 graph creating, in PyTorch 411, 412 graph convolutions 641, 642 basic graph convolution, implementing 644-647 reasons, for using 642, 643 graphical processing units (GPUs) 410 graphics processing units (GPUs) 368-370, 596 graph Laplacian 665 graph neural network (GNN) implementing, in PyTorch 648 implementing, with PyTorch Geometric library 659-665 layers 665 recent developments 665GraphNorm 669 reference link 668 graph normalization technique 668, 669 graphs 638 directed graphs 639 labeled graphs 640 molecules, representing as 640 undirected graph 638, 639 greedy algorithms 129", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 649, "start_word": 207680, "end_word": 208080, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000650": {"text": "creating, in PyTorch 411, 412 graph convolutions 641, 642 basic graph convolution, implementing 644-647 reasons, for using 642, 643 graphical processing units (GPUs) 410 graphics processing units (GPUs) 368-370, 596 graph Laplacian 665 graph neural network (GNN) implementing, in PyTorch 648 implementing, with PyTorch Geometric library 659-665 layers 665 recent developments 665GraphNorm 669 reference link 668 graph normalization technique 668, 669 graphs 638 directed graphs 639 labeled graphs 640 molecules, representing as 640 undirected graph 638, 639 greedy algorithms 129 greedy policy computing, from action-value function 689 grid search hyperparameters, tuning 186 machine learning models, fine-tuning 185 grid world environment implementing, in OpenAI Gym 694-701 grid world problem solving, with Q-learning 701-706 H handwritten digits, classifying 343 MNIST dataset, obtaining 343-346 MNIST dataset, preparing 343-346 multilayer perceptron (MLP), implementing 347-351 neural network performance, evaluating 357-360 neural network training loop, coding 352-356 hard clustering 311 heat map 325 dendrograms, attaching to 326, 327 hidden recurrence versus output recurrence 506-508 hidden structures discovering, with unsupervised learning 7 hierarchical clustering 306, 319 agglomerative 320 Index 730 divisive 320 performing, on distance matrix 321-324 Hierarchical Graph Representation Learning with Differentiable Pooling reference link 668 hierarchical tree clusters, organizing as 319 high variance 122 HistGradientBoostingClassifier URL 244 holdout method 175, 176 human visual cortex 452 hyperbolic tangent (tanh) 403 used, for broadening output spectrum 403, 404 hyperopt reference link 191 hyperopt-sklearn reference link 191 hyperparameter configurations exploring, with randomized search 187, 188 hyperparameters 42, 175 tuning, via grid search 186 I IID (independent and identically distributed) 707 image transformations 486-489 IMDb movie review data preparing, for text processing 247, 248 IMDb movie review dataset loading 575, 576 tokenizing 577, 578 immediate reward 680 impurity 88 independent and identically distributed (IID) 500information gain (IG) 87, 300 maximizing 88-92 initial cluster centroids placing, with k-means++ 310, 311 inliers 285 input gate 512 input pipelines building, in PyTorch 378 inputs padding, to control size of output feature maps 457 processing, with bidirectional RNN 543 intelligent machines building, to transform data into knowledge 1, 2 internal covariance shift 616 Iris dataset 54 loading 31 perceptron model, training on 29-35 reference link 9 J Jensen-Shannon (JS) 625 Jupyter Notebook 597 Jupyter Notebook GUI reference link 597 K Kantorovich-Rubinstein duality 627 kernel 454 kernel function 83 kernel methods 81 kernel SVM 80 used, for solving nonlinear problems 80 kernel trick 83 using, to find separating hyperplanes in high-dimensional space 82-86 Index", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 650, "start_word": 208000, "end_word": 208400, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000651": {"text": "457 processing, with bidirectional RNN 543 intelligent machines building, to transform data into knowledge 1, 2 internal covariance shift 616 Iris dataset 54 loading 31 perceptron model, training on 29-35 reference link 9 J Jensen-Shannon (JS) 625 Jupyter Notebook 597 Jupyter Notebook GUI reference link 597 K Kantorovich-Rubinstein duality 627 kernel 454 kernel function 83 kernel methods 81 kernel SVM 80 used, for solving nonlinear problems 80 kernel trick 83 using, to find separating hyperplanes in high-dimensional space 82-86 Index 731 k-fold cross-validation 176-179 K-Lipschitz continuous 627 k-means objects, grouping by similarity 305 k-means++ initial cluster centroids, placing 310, 311 k-means clustering with scikit-learn 305-310 k-nearest neighbors (KNN) 98-102, 119 Kullback-Leibler (KL) 625 L L1 regularization 123 sparse solutions 125-128 sparsity 125 L2 regularization 74, 122 geometric interpretation 123, 124 NN, regularizing 467 versus weight decay 469 labeled graph 640 language model 558 language modeling 525 language translation 561 large-scale language models building, by leveraging unlabeled data 561 large-scale machine learning 45 Latent Dirichlet Allocation text documents, decomposing 264 topic modeling 264 with scikit-learn 265-268 latent vector 590 layer normalization mechanism 560 lazy learner 98 leaky ReLU 601 learning curves 180 bias and variance problems, diagnosing 180-183learning rate 23, 337 least absolute shrinkage and selection operator (LASSO) 292, 293 leave-one-out cross-validation (LOOCV) method 178 LightGBM URL 244 Linear Algebra Package (LAPACK) 29 linear discriminant analysis (LDA) 591 supervised data compression 154 versus principal component analysis 154, 155 via scikit-learn 162, 163 workings 156 linear discriminants selecting, for feature subspace 158-160 linear least squares 278 linearly inseparable data kernel methods 80, 81 linear regression 5, 269 linear regression model performance, evaluating 288-292 turning, into curve 294 linkage matrix 322 linkages 320 Lipschitz continuity 627 loadings 152 local receptive field 453 logistic function 400, 402 logistic loss function model weights, learning via 63-65 logistic regression 60-63 Adaline implementation, converting into algorithm 66-68 class probabilities, modeling via 59 for multiple classes 60 resource 76 versus support vector machine (SVMs) 79 Index 732 logistic regression model training, for document classification 258-260 training, with scikit-learn 70-72 logistic sigmoid function 61 log-likelihood function 63 long-range interactions challenges 509, 510 long short-term memory cells 511, 512 loss function 12 computing 360-362 for classification 471-473 minimizing, with gradient descent 37-39 low-level features 452 M machine learning 11 implementations, with GPU support 102 models, fine-tuning via grid search 185 packages 16, 17 Python, using for 14 reinforcement learning 2", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 651, "start_word": 208320, "end_word": 208720, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000652": {"text": "76 versus support vector machine (SVMs) 79 Index 732 logistic regression model training, for document classification 258-260 training, with scikit-learn 70-72 logistic sigmoid function 61 log-likelihood function 63 long-range interactions challenges 509, 510 long short-term memory cells 511, 512 loss function 12 computing 360-362 for classification 471-473 minimizing, with gradient descent 37-39 low-level features 452 M machine learning 11 implementations, with GPU support 102 models, fine-tuning via grid search 185 packages 16, 17 Python, using for 14 reinforcement learning 2 supervised learning 2 systems, workflow 12 unsupervised learning 2 majority vote 95 classifiers, combining via 209 majority vote classifier implementing 209-213 majority voting principle 205 using, to make predictions 214-217 Markov decision processes (MDPs) 676, 677, 685 mathematical formulation 677, 678 Markov process visualization 679 masked attention 558 masked language model (MLM) 570 matrix multiplication 41matrix transpose 21 Matthews correlation coefficient (MCC) 193 maximum margin classification with support vector machines (SVM) 76 maximum margin intuition 77 max-pooling 463 MC control used, for finding optimal policy 688 McCulloch-Pitts (MCP) neuron 19 McCulloch-Pitts neuron model 336 mean absolute error (MAE) 291 mean imputation 108 mean of squared errors (MSE) 337 mean-pooling 463 mean squared error derivative 38 mean squared error (MSE) 37, 279, 290-392 median absolute deviation 286 medoid 306 memory-based approaches advantages 100 disadvantages 100 memory cell 511 message-passing framework 647 mini-batch discrimination 634 mini-batch gradient descent 47 Miniconda 15 reference link 15 Miniforge 15 reference link 15 min-max normalization 121 min-max scaling 120 mirrored projections 147 missing data managing 105 missing values features, eliminating 107, 108 Index 733 identifying, in tabular data 106 imputing 108, 109 training examples, eliminating 107, 108 MNIST dataset loading 474, 475 MNIST handwritten digits classification project 436-439 mode collapse 633, 634 model-based RL 678 model ensembles with bagging 225 model-free RL 678 model parameters storing, PyTorch tensor objects used 412-414 updating, PyTorch tensor objects used 412-414 models evaluating 14 model selection 175 model weights learning, via logistic loss function 63-65 molecules representing, as graphs 640 Monte Carlo (MC) 678, 684 action-value function estimation 688 state-value function estimation 688 movie dataset preprocessing 248, 249 movie review dataset obtaining 248 MsgNorm 669 multiclass classification 5 multi-head attention context embeddings, encoding 554-558 multi-head self-attention 554 multilayer CNN architecture 473, 474 multilayer neural network activation function, selecting 400multilayer neural network architecture 338-340 multilayer perceptron (MLP) 338, 370, 452, 501 hidden layers, adding 339 layers 339 multinomial logistic regression 60", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 652, "start_word": 208640, "end_word": 209040, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000653": {"text": "via logistic loss function 63-65 molecules representing, as graphs 640 Monte Carlo (MC) 678, 684 action-value function estimation 688 state-value function estimation 688 movie dataset preprocessing 248, 249 movie review dataset obtaining 248 MsgNorm 669 multiclass classification 5 multi-head attention context embeddings, encoding 554-558 multi-head self-attention 554 multilayer CNN architecture 473, 474 multilayer neural network activation function, selecting 400multilayer neural network architecture 338-340 multilayer perceptron (MLP) 338, 370, 452, 501 hidden layers, adding 339 layers 339 multinomial logistic regression 60 multiple decision trees combining, via random forests 95-98 multiple input channels 465 multiple linear regression 271 multiprocessing via n_jobs parameter 259 MurmurHash URL 262 N naïve Bayes classifier 260 Natural Language Toolkit (NL TK) URL 256 nested cross-validation 191 algorithm selection 192, 193 NetworkX installing 644 URL 644 Neural Message Passing for Quantum Chemistry reference link 647 neural networks (NNs) 589 activating, via forward propagation 340-342 convergence 367, 368 implementation 368 training, via backpropagation 363, 364 next-word prediction 561 n-gram models 252 nn.Embedding reference link 434 NN model building, in PyTorch 389 Index 734 nn.Module 424 model building, making flexible with 424-426 nn.Sequential reference link 417 NodeNetwork graph convolution layer, coding 650, 651 using, to make predictions 658, 659 NodeNetwork model defining 649 nodes 638 no free lunch theorem 53 noise points 328 nominal features 111 one-hot encoding, performing on 113-115 NoneType error 263 nonlinear dimensionality reduction 164, 165 nonlinear problems solving, with kernel SVM 80 nonlinear relationships managing, with random forests 299 modeling, in Ames Housing dataset 297-299 non-overlapping pooling versus overlapping pooling 464 non-parametric models versus parametric models 99 normalization 120 NumPy array indexing 28 O objective function 37 object-oriented perceptron API 25-29 objects grouping, by similarity 305 off-policy Q-learning 685 off-policy TD control (Q-learning) 691 offsets 270one-hot encoding performing, on nominal features 113-115 one-hot vector representation 340 one-versus-all (OvA) technique 340 for multi-class classification 30 one-versus-rest (OvR) 56, 126 one-vs.-all (OvA) classification 200 online learning 46 on-policy SARSA (state-action-reward-state- action) 685 on-policy TD control (SARSA) 691 OpenAI Gym 692 environments 692, 693 grid world environment, implementing 694-701 grid world example 694 toolkit 692 URL 692 opinion mining 247 optimal policy finding, with MC control 688 ordinal features 111 encoding 116 mapping 111, 112 ordinary least squares linear regression model implementing 278 ordinary least squares (OLS) 278 out-of-core learning 261 output gate 512 output recurrence versus hidden recurrence 506-508 outputs generating, from context vectors 543, 544 output spectrum", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 653, "start_word": 208960, "end_word": 209360, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000654": {"text": "SARSA (state-action-reward-state- action) 685 on-policy TD control (SARSA) 691 OpenAI Gym 692 environments 692, 693 grid world environment, implementing 694-701 grid world example 694 toolkit 692 URL 692 opinion mining 247 optimal policy finding, with MC control 688 ordinal features 111 encoding 116 mapping 111, 112 ordinary least squares linear regression model implementing 278 ordinary least squares (OLS) 278 out-of-core learning 261 output gate 512 output recurrence versus hidden recurrence 506-508 outputs generating, from context vectors 543, 544 output spectrum broadening, with hyperbolic tangent (tanh) 403-405 overcomplete autoencoder 591 Index 735 overfitting 57, 122 tackling, via regularization 73-76 overlapping pooling versus non-overlapping pooling 464 P package manager using 15, 16 padding 455 modes 457 pandas categorical data, encoding 111 pandas DataFrame data handling 107 parametric models versus non-parametric models 99 parser module reference link 255 Pearson product-moment correlation coefficient 276 perceptron settings 59 perceptron convergence 35 perceptron learning algorithm implementing, in Python 25 perceptron learning rule 22-24 perceptron model training, on Iris dataset 29-35 performance evaluation metrics 193 permutation invariance 642 pipelines transformers and estimators, combining 173, 174 workflows, streamlining 171 plurality voting 205, 209 policy 682 improving, with estimated value function 686policy evaluation 686 policy improvement 689 policy iteration 687 polynomial regression 294 polynomial terms adding, with scikit-learn 294-296 pooling advantage 463 pooling layers 453, 667, 668 pooling size 463 Porter stemmer algorithm 256 Porter stemming algorithm 257 positional encodings 559, 560 precision-recall curves 198 predicted class label 23 predictions making, about future with supervised learning 3, 4 making, with majority voting principle 214-217 predictive model selecting 13, 14 training 13 pre-trained BERT model fine-tuning 579-582 loading 578, 579 principal component analysis (PCA) 173, 591 in scikit-learn 149-152 unsupervised dimensionality reduction 139-141 versus linear discriminant analysis 154, 155 principal components extracting 142, 143 projects car’s fuel efficiency prediction project 431 MNIST handwritten digits classification 436-439 prototype-based clustering 305 Index 736 prune 87 Python Adaline, implementing in 39-43 installing, from Python Package Index 14 URL 14 using, for machine learning 14 Python Progress Indicator (PyPrind) reference link 248 PyTorch 369, 371 BERT model, tuning 574 character-level language modeling 525 CNN, constructing 477-481 CNN layers, configuring 476 computation graphs 410 custom layers, writing 426-430 features 410 graph, creating 411, 412 graph neural network (GNN), implementing 648 installing 372, 373 learning 372 reference link 377 RNNs, implementing for sequence modeling 513 tensor objects 412 tensors, creating 373 training performance 369 URL 368", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 654, "start_word": 209280, "end_word": 209680, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000655": {"text": "Python Package Index 14 URL 14 using, for machine learning 14 Python Progress Indicator (PyPrind) reference link 248 PyTorch 369, 371 BERT model, tuning 574 character-level language modeling 525 CNN, constructing 477-481 CNN layers, configuring 476 computation graphs 410 custom layers, writing 426-430 features 410 graph, creating 411, 412 graph neural network (GNN), implementing 648 installing 372, 373 learning 372 reference link 377 RNNs, implementing for sequence modeling 513 tensor objects 412 tensors, creating 373 training performance 369 URL 368 used, for implementing deep CNN 473 PyTorch Geometric library for drug discovery 665 installation link 659 installing 659 used, for implementing GNN 659-665 PyTorch-Ignite URL 439 PyTorch, input pipelines batch data loader, creating 380-382 building 378dataset, creating from file on local storage disk 382-385 dataset, fetching from torchvision.datasets library 386-389 PyTorch DataLoader, creating from tensor 378 repeat data loader, creating 380-382 shuffle data loader, creating 380-382 tensor, combining into joint dataset 379, 380 PyTorch Lightning data loaders, setting up 443, 444 installing 440 model, setting up 440, 442 URL 439 PyTorch Lightning Trainer class model, training 444, 445 PyTorch neural network module (torch.nn) 390 PyTorch, NN model linear regression model, building 390-394 model training, via torch.nn module 394, 395 model training, via torch.optim module 394, 395 multilayer perceptron, building for Iris flower dataset 395-398 trained model, evaluating on test dataset 398 trained model, reloading 399 trained model, saving 399 Q Q-learning grid world problem, solving 701-706 QM9 dataset 661 reference link 661 R radial basis function (RBF) kernel 83 radial basis function (RBF) kernel SVM 186 random forest regression 301-304 random forests 95, 119 feature importance, assessing 134-136 Index 737 multiple decision trees, combining via 95-98 nonlinear relationships, managing 299 randomized search hyperparameter configurations, exploring 187, 188 RANdom SAmple Consensus (RANSAC) robust regression model, fitting 285-288 random sampling without replacement 96 with replacement 96 raw term frequencies 251 receiver operating characteristic area under the curve (ROC AUC) 212 receiver operating characteristic (ROC) plotting 198, 200 rectified linear unit (ReLU) 405 recurrent edge 503 recurrent neural networks (RNNs) activations, computing 504, 505 attention mechanism 540, 542 dataflow 502-504 for sequence modeling 502 regression 4, 5 continuous outcomes, predicting 5, 6 regression analysis 5 regression line 270 regular expressions 255 regularization 74 regularization parameter 74 regularized methods using, for regression 292 reinforcement learning 2, 6, 674, 675 algorithms 684 example 6 used, for solving interactive problems 6, 7 with Monte Carlo 687", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 655, "start_word": 209600, "end_word": 210000, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000656": {"text": "characteristic (ROC) plotting 198, 200 rectified linear unit (ReLU) 405 recurrent edge 503 recurrent neural networks (RNNs) activations, computing 504, 505 attention mechanism 540, 542 dataflow 502-504 for sequence modeling 502 regression 4, 5 continuous outcomes, predicting 5, 6 regression analysis 5 regression line 270 regular expressions 255 regularization 74 regularization parameter 74 regularized methods using, for regression 292 reinforcement learning 2, 6, 674, 675 algorithms 684 example 6 used, for solving interactive problems 6, 7 with Monte Carlo 687 re module reference link 255replay memory 707, 708 residuals 270 resource-efficient hyperparameter search with successive halving 189, 190 return 680-683 reward 683 reward signal 6, 675 ridge regression 293 RL algorithm implementing 691 RNN model building, for sentiment analysis task 521-523 RNNs, for sequence modeling in PyTorch 513 ROC area under the curve (ROC AUC) 198 S saturation 595 scaled dot-product attention 549 scatter matrices computing 156-158 scatterplot matrix 274, 275 scientific computing packages 16, 17 scientific computing stack, Python references 26 scikit-fuzzy package reference link 313 scikit-learn agglomerative clustering, applying via 327, 328 alternative implementations 79 coefficient, estimating of regression model 283 k-means clustering 305-310 LDA 162, 163 perceptron, training 54-59 polynomial terms, adding 294-296 principal component analysis 149-151 Index 738 used, for applying AdaBoost 233-236 used, for training logistic regression model 70-72 scikit-learn estimator API 109, 110 scikit-learn imputation documentation reference link 109 scikit-learn transfromer API 109 scoring metrics for multiclass classification 200 self-attention mechanism 544 basic form 545-549 parameterizing 549-552 self-supervised learning 561 semi-supervised classification, with graph convolutional networks reference link 666 sentiment analysis task RNN model, building for 521-523 sentiment classification 574 sentiment of IMDb movie reviews prediction 513 layers, embedding for sentence encoding 517-519 movie review data, preparing 513-516 RNN model, building 520, 521 sepal width 87 seq2seq task 540 sequence modeling 501 with RNNs 502 sequence modeling tasks many-to-many 502 many-to-one 502 one-to-many 502 sequences representing 500 sequential backward selection (SBS) 129-132, 139sequential data 499 modeling 500 versus time series data 500 sequential feature selection algorithms 129 sigmoid function 61 signal 454 silhouette analysis 314 silhouette coefficient 314 silhouette plots 306 quality of clustering, quantifying 314-319 similarity function 83 simple linear regression 270 single instruction, multiple data (SIMD) 29 single-layer network 338 single-layer neural network 337, 338 single linkage 320 sklearn.tree.plot_tree reference link 94 slack variables used, for dealing with nonlinearly separable case 77-79 soft clustering 311 soft k-means 311 soft-margin classification 77 softmax", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 656, "start_word": 209920, "end_word": 210320, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000657": {"text": "499 modeling 500 versus time series data 500 sequential feature selection algorithms 129 sigmoid function 61 signal 454 silhouette analysis 314 silhouette coefficient 314 silhouette plots 306 quality of clustering, quantifying 314-319 similarity function 83 simple linear regression 270 single instruction, multiple data (SIMD) 29 single-layer network 338 single-layer neural network 337, 338 single linkage 320 sklearn.tree.plot_tree reference link 94 slack variables used, for dealing with nonlinearly separable case 77-79 soft clustering 311 soft k-means 311 soft-margin classification 77 softmax function used, for estimating class probabilities in multi- class classification 402 softmax regression 60 sparse attention 566 spectral graph convolutions 665, 666 spectral networks and locally connected networks on graphs reference link 666 squared Euclidean distance 307 stack 652 Index 739 stacking references 223 used, for building ensembles 223 standardization 44, 120, 121 state-transition probability 679 state-value function 682 state-value function estimation with Monte Carlo 688 stochastic gradient descent (SGD) 46, 47, 71, 261, 279, 338, 469 stop-word removal 257 stop-words 257 stride 456 subgroups finding, with clustering 8 subsampling 463 subsequent rewards 680 sum of squared errors (SSE) 308 supervised data compression via linear discriminant analysis 154 supervised learning 2, 674 used, for making predictions about future 3, 4 support vector machine (SVM) 181 logistic regression 79 maximum margin classification 76 support vectors 76 symmetric normalized graph Laplacian 666 synthesized images quality, improving with convolutional 612 quality, improving with Wasserstein GAN 612 Synthetic Minority Over-sampling Technique (SMOTE) 203 T tabular data missing values, identifying in 106target 12 target values determining, for computing loss 708, 709 t-distributed stochastic neighbor embedding (t-SNE) 163 data visualization 165-168 TD learning 689 TD prediction 689, 690 temporal difference (TD) 678, 684 TensorBoard installing 445 model, evaluating 445-449 tensor objects, PyTorch model parameters, storing with 412-414 model parameters, updating with 412 tensor processing units (TPUs) 597 tensors concatenating 376, 377 creating, in PyTorch 373 data type, manipulating 374 mathematical operations, applying to 375, 376 shape, manipulating 374 splitting 376, 377 stacking 376, 377 term frequency-inverse document frequency word relevancy, assessing 252-254 text generating, with GPT-2 566-568 text classification with recurrent neural networks 261 text data cleaning 254-256 text documents decomposing, with LDA 264 text processing IMDb movie review data, preparing for 247, 248 time series data 500 versus sequential data 500 Index 740 tokenizers package reference link 577 tokens documents, processing into 256, 257 topic modeling 264 with LDA 264 top-k pooling 668 torch.bucketize function", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 657, "start_word": 210240, "end_word": 210640, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000658": {"text": "manipulating 374 splitting 376, 377 stacking 376, 377 term frequency-inverse document frequency word relevancy, assessing 252-254 text generating, with GPT-2 566-568 text classification with recurrent neural networks 261 text data cleaning 254-256 text documents decomposing, with LDA 264 text processing IMDb movie review data, preparing for 247, 248 time series data 500 versus sequential data 500 Index 740 tokenizers package reference link 577 tokens documents, processing into 256, 257 topic modeling 264 with LDA 264 top-k pooling 668 torch.bucketize function reference link 433 TorchDrug library 665 reference link 665 torch.nn module used, for implementing CNN 476 total variance 145 Towards Sparse Hierarchical Graph Classifiers reference link 668 traditional RNN encoder-decoder architecture for seq2seq modeling task 540 training 11 training example 11 eliminating, with missing values 107, 108 transformer fine-tuning, with Trainer API 582-586 transformer architecture 539, 552 transformer models fine-tuning 561, 562 pre-training 561, 562 transformers 539, 545 transformers package reference link 579 transformers version 4.9.1 installing 567 transposed convolution 612, 613 Tree of Parzen Estimators (TPE) method 191 true class label 23 true negative (TN) 194true positive rate (TPR) 195 true positive (TP) 194 Truncated backpropagation through time (TBPTT) 510 U undercomplete autoencoder 591 underfitting 73 undirected graph 638, 639 uniform manifold approximation and projection (UMAP) 168 reference link 168 unigram model 252 unit step function 20 unlabeled data leveraging, for building large-scale language models 561 leveraging, with GPT 563-565 unseen data instances predicting 14 unsupervised classification 8 unsupervised dimensionality reduction via principal component analysis 139 unsupervised learning 2, 674 used, for discovering hidden structures 7 unsupervised pre-training 561 V validation curves 180, 183 overfitting, addressing 185 underfitting, addressing 185 validation dataset 132 value function 594, 682, 683 predicting, with dynamic programming 686 value iteration 687 vanishing gradient 510 Index 741 variance explained ratios 144 variance reduction 300 variational autoencoder (VAE) 592 venv reference link 17 vertices 638 VotingClassifier reference link 214 W Wasserstein GAN used, for improving synthesized images quality 612 Wasserstein GAN (WGAN) 612 weak learners leveraging, via adaptive boosting 229 weight decay versus L2 regularization 469 WGAN with gradient penalty (WGAN-GP) 628 implementing, to train DCGAN model 629-632 Widrow-Hoff rule 36 Wine dataset 117 obtaining 117, 142, 226 within-node variance 300 word2vec model 264 word capitalization managing 255 word relevancy assessing, via term frequency-inverse document frequency (tf-idf) 252-254 words transforming, into feature vectors 250, 251 word stemming 256 workflows streamlining, with pipelines 171X XGBoost URL 244", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 658, "start_word": 210560, "end_word": 210960, "chunk_words": 400}}, "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir::c000659": {"text": "images quality 612 Wasserstein GAN (WGAN) 612 weak learners leveraging, via adaptive boosting 229 weight decay versus L2 regularization 469 WGAN with gradient penalty (WGAN-GP) 628 implementing, to train DCGAN model 629-632 Widrow-Hoff rule 36 Wine dataset 117 obtaining 117, 142, 226 within-node variance 300 word2vec model 264 word capitalization managing 255 word relevancy assessing, via term frequency-inverse document frequency (tf-idf) 252-254 words transforming, into feature vectors 250, 251 word stemming 256 workflows streamlining, with pipelines 171X XGBoost URL 244 using 243-245 XOR classification problem 419 solving 419-423 Z zero-padding 455 zero-shot tasks 565, 566", "metadata": {"source_type": "pdf", "source_path": "C:\\Users\\scoti\\PycharmProjects\\ML_RAG\\data\\raw\\Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "filename": "Machine.Learning.with.PyTorch.and.Scikit-Learn.Sebastian.Raschka.Packt.9781801819312.EBooksWorld.ir.pdf", "num_pages_total": 771, "num_pages_read": 771, "chunk_index": 659, "start_word": 210880, "end_word": 210975, "chunk_words": 95}}}